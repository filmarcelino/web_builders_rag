[
  {
    "source_name": "supabase_test",
    "category": "backend_service",
    "url": "https://supabase.com/docs/guides/getting-started",
    "title": "Getting Started | Supabase Docs",
    "content": "Getting StartedGetting StartedFeaturesA non-exhaustive list of features that Supabase provides for every project.ArchitectureAn overview of Supabase's architecture and product principles.Local DevelopmentUse the Supabase CLI to develop locally and collaborate between teams.\nUse cases#\nAI, Vectors, and embeddingsBuild AI-enabled applications using our Vector toolkit.Subscription Payments (SaaS)Clone, deploy, and fully customize a SaaS subscription application with Next.js.Partner GalleryPostgres full-text search, image storage, and more.\nFramework quickstarts#\nReactLearn how to create a Supabase project, add some sample data to your database, and query the data from a React app.Next.jsLearn how to create a Supabase project, add some sample data to your database, and query the data from a Next.js app.NuxtLearn how to create a Supabase project, add some sample data to your database, and query the data from a Nuxt app.HonoLearn how to create a Supabase project, add some sample data to your database, secure it with auth, and query the data from a Hono app.RedwoodJSLearn how to create a Supabase project, add some sample data to your database using Prisma migration and seeds, and query the data from a RedwoodJS app.FlutterLearn how to create a Supabase project, add some sample data to your database, and query the data from a Flutter app.iOS SwiftUILearn how to create a Supabase project, add some sample data to your database, and query the data from an iOS app.Android KotlinLearn how to create a Supabase project, add some sample data to your database, and query the data from an Android Kotlin app.SvelteKitLearn how to create a Supabase project, add some sample data to your database, and query the data from a SvelteKit app.SolidJSLearn how to create a Supabase project, add some sample data to your database, and query the data from a SolidJS app.VueLearn how to create a Supabase project, add some sample data to your database, and query the data from a Vue app.refineLearn how to create a Supabase project, add some sample data to your database, and query the data from a refine app.\nWeb app demos#\nNext.jsLearn how to build a user management app with Next.js and Supabase Database, Auth, and Storage functionality.ReactLearn how to build a user management app with React and Supabase Database, Auth, and Storage functionality.Vue 3Learn how to build a user management app with Vue 3 and Supabase Database, Auth, and Storage functionality.Nuxt 3Learn how to build a user management app with Nuxt 3 and Supabase Database, Auth, and Storage functionality.AngularLearn how to build a user management app with Angular and Supabase Database, Auth, and Storage functionality.RedwoodJSLearn how to build a user management app with RedwoodJS and Supabase Database, Auth, and Storage functionality.SvelteLearn how to build a user management app with Svelte and Supabase Database, Auth, and Storage functionality.SvelteKitLearn how to build a user management app with SvelteKit and Supabase Database, Auth, and Storage functionality.refineLearn how to build a user management app with refine and Supabase Database, Auth, and Storage functionality.\nMobile tutorials#\nFlutterLearn how to build a user management app with Flutter and Supabase Database, Auth, and Storage functionality.Expo React NativeLearn how to build a user management app with Expo React Native and Supabase Database, Auth, and Storage functionality.Android KotlinLearn how to build a product management app with Android and Supabase Database, Auth, and Storage functionality.iOS SwiftLearn how to build a user management app with iOS and Supabase Database, Auth, and Storage functionality.Ionic ReactLearn how to build a user management app with Ionic React and Supabase Database, Auth, and Storage functionality.Ionic VueLearn how to build a user management app with Ionic Vue and Supabase Database, Auth, and Storage functionality.Ionic AngularLearn how to build a user management app with Ionic Angular and Supabase Database, Auth, and Storage functionality.",
    "code_blocks": [],
    "headings": [
      "Getting Started",
      "Use cases#",
      "Framework quickstarts#",
      "Web app demos#",
      "Mobile tutorials#"
    ],
    "token_count": 875,
    "collected_at": "2025-09-03T01:38:49.528605",
    "priority": "high"
  },
  {
    "source_name": "supabase_test",
    "category": "backend_service",
    "url": "https://supabase.com/docs/guides/database",
    "title": "Database | Supabase Docs",
    "content": "DatabaseDatabaseEvery Supabase project comes with a full Postgres database, a free and open source database which is considered one of the world's most stable and advanced databases.\nFeatures#\nTable view#\nYou don't have to be a database expert to start using Supabase. Our table view makes Postgres as easy to use as a spreadsheet.\n\nRelationships#\nDig into the relationships within your data.\n\nClone tables#\nYou can duplicate your tables, just like you would inside a spreadsheet.\n\nThe SQL editor#\nSupabase comes with a SQL Editor. You can also save your favorite queries to run later!\n\nAdditional features#\n\nSupabase extends Postgres with realtime functionality using our Realtime Server.\nEvery project is a full Postgres database, with postgres level access.\nSupabase manages your database backups.\nImport data directly from a CSV or excel spreadsheet.\n\nDatabase backups do not include objects stored via the Storage API, as the database only includes metadata about these objects. Restoring an old backup does not restore objects that have been deleted since then.\nExtensions#\nTo expand the functionality of your Postgres database, you can use extensions.\nYou can enable Postgres extensions with the click of a button within the Supabase dashboard.\n\nLearn more about all the extensions provided on Supabase.\nTerminology#\n\nPostgres or PostgreSQL?#\n\nPostgreSQL the database was derived from the POSTGRES Project, a package written at the University of California at Berkeley in 1986. This package included a query language called \"PostQUEL\".\nIn 1994, Postgres95 was built on top of POSTGRES code, adding an SQL language interpreter as a replacement for PostQUEL.\n\nEventually, Postgres95 was renamed to PostgreSQL to reflect the SQL query capability.\nAfter this, many people referred to it as Postgres since it's less prone to confusion. Supabase is all about simplicity, so we also refer to it as Postgres.\nTips#\nRead about resetting your database password here and changing the timezone of your server here.\nNext steps#\n\nRead more about Postgres\nSign in: supabase.com/dashboard\nIs this helpful? No  Yes",
    "code_blocks": [
      "postgres"
    ],
    "headings": [
      "Database",
      "Features#",
      "Table view#",
      "Relationships#",
      "Clone tables#",
      "The SQL editor#",
      "Additional features#",
      "Extensions#",
      "Terminology#",
      "Postgres or PostgreSQL?#",
      "Tips#",
      "Next steps#",
      "Is this helpful?"
    ],
    "token_count": 433,
    "collected_at": "2025-09-03T01:38:51.146169",
    "priority": "high"
  },
  {
    "source_name": "supabase_test",
    "category": "backend_service",
    "url": "https://supabase.com/docs/reference/javascript/introduction",
    "title": "JavaScript API Reference | Supabase Docs",
    "content": "Javascript Reference v2.0JavaScript Client Library@supabase/supabase-jsView on GitHubThis reference documents every object and method available in Supabase's isomorphic JavaScript library, supabase-js. You can use supabase-js to interact with your Postgres database, listen to database changes, invoke Deno Edge Functions, build login and user management functionality, and manage large files.\nTo convert SQL queries to supabase-js calls, use the SQL to REST API translator.InstallingInstall as package#\nYou can install @supabase/supabase-js via the terminal.npmYarnpnpm1npm install @supabase/supabase-js\nInstall via CDN#\nYou can install @supabase/supabase-js via CDN links.123<script src=\"https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2\"></script>//or<script src=\"https://unpkg.com/@supabase/supabase-js@2\"></script>\nUse at runtime in Deno#\nYou can use supabase-js in the Deno runtime via JSR:1import { createClient } from 'npm:@supabase/supabase-js@2'InitializingCreate a new client for use in the browser.\nYou can initialize a new Supabase client using the createClient() method.\nThe Supabase client is your entrypoint to the rest of the Supabase functionality and is the easiest way to interact with everything we offer within the Supabase ecosystem.ParameterssupabaseUrlRequiredstringThe unique Supabase URL which is supplied when you create a new project in your project dashboard.supabaseKeyRequiredstringThe unique Supabase Key which is supplied when you create a new project in your project dashboard.optionsOptionalSupabaseClientOptionsDetailsCreating a clientWith a custom domainWith additional parametersWith custom schemasCustom fetch implementationReact Native options with AsyncStorageReact Native options with Expo SecureStore1234import { createClient } from '@supabase/supabase-js'// Create a single supabase client for interacting with your databaseconst supabase = createClient('https://xyzcompany.supabase.co', 'publishable-or-anon-key')TypeScript supportsupabase-js has TypeScript support for type inference, autocompletion, type-safe queries, and more.\nWith TypeScript, supabase-js detects things like not null constraints and generated columns. Nullable columns are typed as T | null when you select the column. Generated columns will show a type error when you insert to it.\nsupabase-js also detects relationships between tables. A referenced table with one-to-many relationship is typed as T[]. Likewise, a referenced table with many-to-one relationship is typed as T | null.\nGenerating TypeScript Types#\nYou can use the Supabase CLI to generate the types. You can also generate the types from the dashboard.1supabase gen types typescript --project-id abcdefghijklmnopqrst > database.types.ts\nThese types are generated from your database schema. Given a table public.movies, the generated types will look like:12345create table public.movies (  id bigint generated always as identity primary key,  name text not null,  data jsonb null);12345678910111213141516171819202122232425export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]export interface Database {  public: {    Tables: {      movies: {        Row: {               // the data expected from .select()          id: number          name: string          data: Json | null        }        Insert: {            // the data to be passed to .insert()          id?: never         // generated columns must not be supplied          name: string       // `not null` columns with no default must be supplied          data?: Json | null // nullable columns can be omitted        }        Update: {            // the data to be passed to .update()          id?: never          name?: string      // `not null` columns are optional on .update()          data?: Json | null        }      }    }  }}\nUsing TypeScript type definitions#\nYou can supply the type definitions to supabase-js like so:1234567import { createClient } from '@supabase/supabase-js'import { Database } from './database.types'const supabase = createClient<Database>(  process.env.SUPABASE_URL,  process.env.SUPABASE_ANON_KEY)\nHelper types for Tables and Joins#\nYou can use the following helper types to make the generated TypeScript types easier to use.\nSometimes the generated types are not what you expect. For example, a view's column may show up as nullable when you expect it to be not null. Using type-fest, you can override the types like so:12345export type Json = // ...export interface Database {  // ...}1234567891011121314151617181920import { MergeDeep } from 'type-fest'import { Database as DatabaseGenerated } from './database-generated.types'export { Json } from './database-generated.types'// Override the type for a specific column in a view:export type Database = MergeDeep<  DatabaseGenerated,  {    public: {      Views: {        movies_view: {          Row: {            // id is a primary key in public.movies, so it must be `not null`            id: number          }        }      }    }  }>\nYou can also override the type of an individual successful response if needed:123456789// Partial type override allows you to only override some of the properties in your resultsconst { data } = await supabase.from('countries').select().overrideTypes<Array<{ id: string }>>()// For a full replacement of the original return type use the `{ merge: false }` property as second argumentconst { data } = await supabase  .from('countries')  .select()  .overrideTypes<Array<{ id: string }>, { merge: false }>()// Use it with `maybeSingle` or `single`const { data } = await supabase.from('countries').select().single().overrideTypes<{ id: string }>()\nThe generated types provide shorthands for accessing tables and enums.1234567import { Database, Tables, Enums } from \"./database.types.ts\";// Before 😕let movie: Database['public']['Tables']['movies']['Row'] = // ...// After 😍let movie: Tables<'movies'>\nResponse types for complex queries#\nsupabase-js always returns a data object (for success), and an error object (for unsuccessful requests).These helper types provide the result types from any query, including nested types for database joins.Given the following schema with a relation between cities and countries, we can get the nested CountriesWithCities type:12345678910create table countries (  \"id\" serial primary key,  \"name\" text);create table cities (  \"id\" serial primary key,  \"name\" text,  \"country_id\" int references \"countries\");1234567891011121314151617import { QueryResult, QueryData, QueryError } from '@supabase/supabase-js'const countriesWithCitiesQuery = supabase  .from(\"countries\")  .select(`    id,    name,    cities (      id,      name    )  `);type CountriesWithCities = QueryData<typeof countriesWithCitiesQuery>;const { data, error } = await countriesWithCitiesQuery;if (error) throw error;const countriesWithCities: CountriesWithCities = data;Fetch dataPerform a SELECT query on the table or view.\n\nBy default, Supabase projects return a maximum of 1,000 rows. This setting can be changed in your project's API settings. It's recommended that you keep it low to limit the payload size of accidental or malicious requests. You can use range() queries to paginate through your data.\nselect() can be combined with Filters\nselect() can be combined with Modifiers\napikey is a reserved keyword if you're using the Supabase Platform and should be avoided as a column name.\nParameterscolumnsOptionalQueryThe columns to retrieve, separated by commas. Columns can be renamed when returned with customName:columnNameoptionsRequiredobjectNamed parametersDetailsGetting your dataSelecting specific columnsQuery referenced tablesQuery referenced tables with spaces in their namesQuery referenced tables through a join tableQuery the same referenced table multiple timesQuery nested foreign tables through a join tableFiltering through referenced tablesQuerying referenced table with countQuerying with count optionQuerying JSON dataQuerying referenced table with inner joinSwitching schemas per query123const { data, error } = await supabase  .from('characters')  .select()Data sourceResponseInsert dataPerform an INSERT into the table or view.ParametersvaluesRequiredOne of the following optionsThe values to insert. Pass an object to insert a single row or an array to insert multiple rows.DetailsOption 1RowOption 2Array<Row>optionsOptionalobjectNamed parametersDetailsCreate a recordCreate a record and return itBulk create123const { error } = await supabase  .from('countries')  .insert({ id: 1, name: 'Mordor' })Data sourceResponseUpdate dataPerform an UPDATE on the table or view.\n\nupdate() should always be combined with Filters to target the item(s) you wish to update.\nParametersvaluesRequiredRowThe values to update withoptionsRequiredobjectNamed parametersDetailsUpdating your dataUpdate a record and return itUpdating JSON data1234const { error } = await supabase  .from('instruments')  .update({ name: 'piano' })  .eq('id', 1)Data sourceResponseUpsert dataPerform an UPSERT on the table or view. Depending on the column(s) passed to onConflict, .upsert() allows you to perform the equivalent of .insert() if a row with the corresponding onConflict columns doesn't exist, or if it does exist, perform an alternative action depending on ignoreDuplicates.\n\nPrimary keys must be included in values to use upsert.\nParametersvaluesRequiredOne of the following optionsThe values to upsert with. Pass an object to upsert a single row or an array to upsert multiple rows.DetailsOption 1RowOption 2Array<Row>optionsOptionalobjectNamed parametersDetailsUpsert your dataBulk Upsert your dataUpserting into tables with constraints1234const { data, error } = await supabase  .from('instruments')  .upsert({ id: 1, name: 'piano' })  .select()Data sourceResponseDelete dataPerform a DELETE on the table or view.\n\ndelete() should always be combined with filters to target the item(s) you wish to delete.\nIf you use delete() with filters and you have RLS enabled, only rows visible through SELECT policies are deleted. Note that by default no rows are visible, so you need at least one SELECT/ALL policy that makes the rows visible.\nWhen using delete().in(), specify an array of values to target multiple rows with a single query. This is particularly useful for batch deleting entries that share common criteria, such as deleting users by their IDs. Ensure that the array you provide accurately represents all records you intend to delete to avoid unintended data removal.\nParametersoptionsRequiredobjectNamed parametersDetailsDelete a single recordDelete a record and return itDelete multiple records1234const response = await supabase  .from('countries')  .delete()  .eq('id', 1)Data sourceResponseCall a Postgres functionPerform a function call.\nYou can call Postgres functions as Remote Procedure Calls, logic in your database that you can execute from anywhere. Functions are useful when the logic rarely changes—like for password resets and updates.\n123create or replace function hello_world() returns text as $$  select 'Hello world';$$ language sql;\nTo call Postgres functions on Read Replicas, use the get: true option.ParametersfnRequiredFnNameThe function name to callargsRequiredFn['Args']The arguments to pass to the function calloptionsRequiredobjectNamed parametersDetailsCall a Postgres function without argumentsCall a Postgres function with argumentsBulk processingCall a Postgres function with filtersCall a read-only Postgres function1const { data, error } = await supabase.rpc('hello_world')Data sourceResponseUsing filtersFilters allow you to only return rows that match certain conditions.\nFilters can be used on select(), update(), upsert(), and delete() queries.\nIf a Postgres function returns a table response, you can also apply filters.Applying FiltersChainingConditional ChainingFilter by values within a JSON columnFilter referenced tables123456789const { data, error } = await supabase  .from('instruments')  .select('name, section_id')  .eq('name', 'violin')    // Correctconst { data, error } = await supabase  .from('instruments')  .eq('name', 'violin')    // Incorrect  .select('name, section_id')NotesColumn is equal to a valueMatch only rows where column is equal to value.ParameterscolumnRequiredColumnNameThe column to filter onvalueRequiredThe value to filter withWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .eq('name', 'Leia')Data sourceResponseColumn is not equal to a valueMatch only rows where column is not equal to value.ParameterscolumnRequiredColumnNameThe column to filter onvalueRequiredThe value to filter withWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .neq('name', 'Leia')Data sourceResponseColumn is greater than a valueMatch only rows where column is greater than value.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe value to filter withDetailsOption 1Row['ColumnName']Option 2unknownWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .gt('id', 2)Data sourceResponseNotesColumn is greater than or equal to a valueMatch only rows where column is greater than or equal to value.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe value to filter withDetailsOption 1Row['ColumnName']Option 2unknownWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .gte('id', 2)Data sourceResponseColumn is less than a valueMatch only rows where column is less than value.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe value to filter withDetailsOption 1Row['ColumnName']Option 2unknownWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .lt('id', 2)Data sourceResponseColumn is less than or equal to a valueMatch only rows where column is less than or equal to value.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe value to filter withDetailsOption 1Row['ColumnName']Option 2unknownWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .lte('id', 2)Data sourceResponseColumn matches a patternMatch only rows where column matches pattern case-sensitively.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringpatternRequiredstringThe pattern to match withWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .like('name', '%Lu%')Data sourceResponseColumn matches a case-insensitive patternMatch only rows where column matches pattern case-insensitively.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringpatternRequiredstringThe pattern to match withWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .ilike('name', '%lu%')Data sourceResponseColumn is a valueMatch only rows where column IS value.ParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe value to filter withDetailsOption 1nullOption 2booleanChecking for nullness, true or false1234const { data, error } = await supabase  .from('countries')  .select()  .is('name', null)Data sourceResponseNotesColumn is in an arrayMatch only rows where column is included in the values array.ParameterscolumnRequiredColumnNameThe column to filter onvaluesRequiredArrayThe values array to filter withWith `select()`1234const { data, error } = await supabase  .from('characters')  .select()  .in('name', ['Leia', 'Han'])Data sourceResponseColumn contains every element in a valueOnly relevant for jsonb, array, and range columns. Match only rows where column contains every element appearing in value.ParameterscolumnRequiredOne of the following optionsThe jsonb, array, or range column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe jsonb, array, or range value to filter withDetailsOption 1stringOption 2Record<string, unknown>Option 3Array<Row['ColumnName']>Option 4Array<unknown>On array columnsOn range columnsOn `jsonb` columns1234const { data, error } = await supabase  .from('issues')  .select()  .contains('tags', ['is:open', 'priority:low'])Data sourceResponseContained by valueOnly relevant for jsonb, array, and range columns. Match only rows where every element appearing in column is contained by value.ParameterscolumnRequiredOne of the following optionsThe jsonb, array, or range column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe jsonb, array, or range value to filter withDetailsOption 1stringOption 2Record<string, unknown>Option 3Array<Row['ColumnName']>Option 4Array<unknown>On array columnsOn range columnsOn `jsonb` columns1234const { data, error } = await supabase  .from('classes')  .select('name')  .containedBy('days', ['monday', 'tuesday', 'wednesday', 'friday'])Data sourceResponseGreater than a rangeOnly relevant for range columns. Match only rows where every element in column is greater than any element in range.ParameterscolumnRequiredOne of the following optionsThe range column to filter onDetailsOption 1ColumnNameOption 2stringrangeRequiredstringThe range to filter withWith `select()`1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeGt('during', '[2000-01-02 08:00, 2000-01-02 09:00)')Data sourceResponseNotesGreater than or equal to a rangeOnly relevant for range columns. Match only rows where every element in column is either contained in range or greater than any element in range.ParameterscolumnRequiredOne of the following optionsThe range column to filter onDetailsOption 1ColumnNameOption 2stringrangeRequiredstringThe range to filter withWith `select()`1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeGte('during', '[2000-01-02 08:30, 2000-01-02 09:30)')Data sourceResponseNotesLess than a rangeOnly relevant for range columns. Match only rows where every element in column is less than any element in range.ParameterscolumnRequiredOne of the following optionsThe range column to filter onDetailsOption 1ColumnNameOption 2stringrangeRequiredstringThe range to filter withWith `select()`1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeLt('during', '[2000-01-01 15:00, 2000-01-01 16:00)')Data sourceResponseNotesLess than or equal to a rangeOnly relevant for range columns. Match only rows where every element in column is either contained in range or less than any element in range.ParameterscolumnRequiredOne of the following optionsThe range column to filter onDetailsOption 1ColumnNameOption 2stringrangeRequiredstringThe range to filter withWith `select()`1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeLte('during', '[2000-01-01 14:00, 2000-01-01 16:00)')Data sourceResponseNotesMutually exclusive to a rangeOnly relevant for range columns. Match only rows where column is mutually exclusive to range and there can be no element between the two ranges.ParameterscolumnRequiredOne of the following optionsThe range column to filter onDetailsOption 1ColumnNameOption 2stringrangeRequiredstringThe range to filter withWith `select()`1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeAdjacent('during', '[2000-01-01 12:00, 2000-01-01 13:00)')Data sourceResponseNotesWith a common elementOnly relevant for array and range columns. Match only rows where column and value have an element in common.ParameterscolumnRequiredOne of the following optionsThe array or range column to filter onDetailsOption 1ColumnNameOption 2stringvalueRequiredOne of the following optionsThe array or range value to filter withDetailsOption 1stringOption 2Array<Row['ColumnName']>Option 3Array<unknown>On array columnsOn range columns1234const { data, error } = await supabase  .from('issues')  .select('title')  .overlaps('tags', ['is:closed', 'severity:high'])Data sourceResponseMatch a stringOnly relevant for text and tsvector columns. Match only rows where column matches the query string in query.\n\nFor more information, see Postgres full text search.\nParameterscolumnRequiredOne of the following optionsThe text or tsvector column to filter onDetailsOption 1ColumnNameOption 2stringqueryRequiredstringThe query text to match withoptionsOptionalobjectNamed parametersDetailsText searchBasic normalizationFull normalizationWebsearch123456const result = await supabase  .from(\"texts\")  .select(\"content\")  .textSearch(\"content\", `'eggs' & 'ham'`, {    config: \"english\",  });Data sourceResponseMatch an associated valueMatch only rows where each column in query keys is equal to its associated value. Shorthand for multiple .eq()s.ParametersqueryRequiredOne of the following optionsThe object to filter with, with column names as keys mapped to their filter valuesDetailsOption 1Record<ColumnName, Row['ColumnName']>Option 2Record<string, unknown>With `select()`1234const { data, error } = await supabase  .from('characters')  .select('name')  .match({ id: 2, name: 'Leia' })Data sourceResponseDon't match the filterMatch only rows which doesn't satisfy the filter.\nnot() expects you to use the raw PostgREST syntax for the filter values.\n12.not('id', 'in', '(5,6,7)')  // Use `()` for `in` filter.not('arraycol', 'cs', '{\"a\",\"b\"}')  // Use `cs` for `contains()`, `{}` for array valuesParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringoperatorRequiredOne of the following optionsThe operator to be negated to filter with, following PostgREST syntaxDetailsOption 1FilterOperatorOption 2stringvalueRequiredOne of the following optionsThe value to filter with, following PostgREST syntaxDetailsOption 1Row['ColumnName']Option 2unknownWith `select()`1234const { data, error } = await supabase  .from('countries')  .select()  .not('name', 'is', null)Data sourceResponseMatch at least one filterMatch only rows which satisfy at least one of the filters.\nor() expects you to use the raw PostgREST syntax for the filter names and values.\n12.or('id.in.(5,6,7), arraycol.cs.{\"a\",\"b\"}')  // Use `()` for `in` filter, `{}` for array values and `cs` for `contains()`..or('id.in.(5,6,7), arraycol.cd.{\"a\",\"b\"}')  // Use `cd` for `containedBy()`ParametersfiltersRequiredstringThe filters to use, following PostgREST syntaxoptionsRequiredobjectNamed parametersDetailsWith `select()`Use `or` with `and`Use `or` on referenced tables1234const { data, error } = await supabase  .from('characters')  .select('name')  .or('id.eq.2,name.eq.Han')Data sourceResponseMatch the filterMatch only rows which satisfy the filter. This is an escape hatch - you should use the specific filter methods wherever possible.\nfilter() expects you to use the raw PostgREST syntax for the filter values.\n12.filter('id', 'in', '(5,6,7)')  // Use `()` for `in` filter.filter('arraycol', 'cs', '{\"a\",\"b\"}')  // Use `cs` for `contains()`, `{}` for array valuesParameterscolumnRequiredOne of the following optionsThe column to filter onDetailsOption 1ColumnNameOption 2stringoperatorRequiredOne of the following optionsThe operator to filter with, following PostgREST syntaxDetailsOption 1FilterOperatorOption 2\"not.eq\"Option 3\"not.neq\"Option 4\"not.gt\"Option 5\"not.gte\"Option 6\"not.lt\"Option 7\"not.lte\"Option 8\"not.like\"Option 9\"not.ilike\"Option 10\"not.is\"Option 11\"not.in\"Option 12\"not.cs\"Option 13\"not.cd\"Option 14\"not.sl\"Option 15\"not.sr\"Option 16\"not.nxl\"Option 17\"not.nxr\"Option 18\"not.adj\"Option 19\"not.ov\"Option 20\"not.fts\"Option 21\"not.plfts\"Option 22\"not.phfts\"Option 23\"not.wfts\"Option 24stringvalueRequiredunknownThe value to filter with, following PostgREST syntaxWith `select()`On a referenced table1234const { data, error } = await supabase  .from('characters')  .select()  .filter('name', 'in', '(\"Han\",\"Yoda\")')Data sourceResponseUsing modifiersFilters work on the row level—they allow you to return rows that only match certain conditions without changing the shape of the rows. Modifiers are everything that don't fit that definition—allowing you to change the format of the response (e.g., returning a CSV string).\nModifiers must be specified after filters. Some modifiers only apply for queries that return rows (e.g., select() or rpc() on a function that returns a table response).Return data after insertingPerform a SELECT on the query result.ParameterscolumnsOptionalQueryThe columns to retrieve, separated by commasWith `upsert()`1234const { data, error } = await supabase  .from('characters')  .upsert({ id: 1, name: 'Han Solo' })  .select()Data sourceResponseOrder the resultsOrder the query result by column.ParameterscolumnRequiredOne of the following optionsThe column to order byDetailsOption 1ColumnNameOption 2stringoptionsOptionalobjectNamed parametersDetailsWith `select()`On a referenced tableOrder parent table by a referenced table1234const { data, error } = await supabase  .from('characters')  .select('id, name')  .order('id', { ascending: false })Data sourceResponseLimit the number of rows returnedLimit the query result by count.ParameterscountRequirednumberThe maximum number of rows to returnoptionsRequiredobjectNamed parametersDetailsWith `select()`On a referenced table1234const { data, error } = await supabase  .from('characters')  .select('name')  .limit(1)Data sourceResponseLimit the query to a rangeLimit the query result by starting at an offset from and ending at the offset to. Only records within this range are returned. This respects the query order and if there is no order clause the range could behave unexpectedly. The from and to values are 0-based and inclusive: range(1, 3) will include the second, third and fourth rows of the query.ParametersfromRequirednumberThe starting index from which to limit the resulttoRequirednumberThe last index to which to limit the resultoptionsRequiredobjectNamed parametersDetailsWith `select()`1234const { data, error } = await supabase  .from('countries')  .select('name')  .range(0, 1)Data sourceResponseSet an abort signalSet the AbortSignal for the fetch request.\nYou can use this to set a timeout for the request.ParameterssignalRequiredAbortSignalThe AbortSignal to use for the fetch requestAborting requests in-flightSet a timeout123456const ac = new AbortController()ac.abort()const { data, error } = await supabase  .from('very_big_table')  .select()  .abortSignal(ac.signal)ResponseNotesRetrieve one row of dataReturn data as a single object instead of an array of objects.With `select()`12345const { data, error } = await supabase  .from('characters')  .select('name')  .limit(1)  .single()Data sourceResponseRetrieve zero or one row of dataReturn data as a single object instead of an array of objects.With `select()`12345const { data, error } = await supabase  .from('characters')  .select()  .eq('name', 'Katniss')  .maybeSingle()Data sourceResponseRetrieve as a CSVReturn data as a string in CSV format.Return data as CSV1234const { data, error } = await supabase  .from('characters')  .select()  .csv()Data sourceResponseNotesOverride type of successful responseOverride the type of the returned data.\n\nDeprecated: use overrideTypes method instead\nOverride type of successful responseOverride type of object response1234const { data } = await supabase  .from('countries')  .select()  .returns<Array<MyType>>()ResponsePartially override or replace type of successful responseOverride the type of the returned data field in the response.Complete Override type of successful responseComplete Override type of object responsePartial Override type of successful responsePartial Override type of object response1234const { data } = await supabase  .from('countries')  .select()  .overrideTypes<Array<MyType>, { merge: false }>()ResponseUsing explainReturn data as the EXPLAIN plan for the query.\nFor debugging slow queries, you can get the Postgres EXPLAIN execution plan of a query using the explain() method. This works on any query, even for rpc() or writes.\nExplain is not enabled by default as it can reveal sensitive information about your database. It's best to only enable this for testing environments but if you wish to enable it for production you can provide additional protection by using a pre-request function.\nFollow the Performance Debugging Guide to enable the functionality on your project.ParametersoptionsRequiredobjectNamed parametersDetailsReturn TypeOne of the following optionsDetailsOption 1ClientOptionsOption 2ClientOptionsGet the execution planGet the execution plan with analyze and verbose1234const { data, error } = await supabase  .from('characters')  .select()  .explain()Data sourceResponseNotesOverview\n\nThe auth methods can be accessed via the supabase.auth namespace.\n\n\nBy default, the supabase client sets persistSession to true and attempts to store the session in local storage. When using the supabase client in an environment that doesn't support local storage, you might notice the following warning message being logged:\n\nNo storage option exists to persist the session, which may result in unexpected behavior when using auth. If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.\n\nThis warning message can be safely ignored if you're not using auth on the server-side. If you are using auth and you want to set persistSession to true, you will need to provide a custom storage implementation that follows this interface.\n\n\nAny email links and one-time passwords (OTPs) sent have a default expiry of 24 hours. We have the following rate limits in place to guard against brute force attacks.\n\n\nThe expiry of an access token can be set in the \"JWT expiry limit\" field in your project's auth settings. A refresh token never expires and can only be used once.\n\nCreate auth clientCreate auth client (server-side)123import { createClient } from '@supabase/supabase-js'const supabase = createClient(supabase_url, anon_key)Create a new userCreates a new user.\n\nBy default, the user needs to verify their email address before logging in. To turn this off, disable Confirm email in your project.\nConfirm email determines if users need to confirm their email address after signing up.\n\nIf Confirm email is enabled, a user is returned but session is null.\nIf Confirm email is disabled, both a user and a session are returned.\n\n\nWhen the user confirms their email address, they are redirected to the SITE_URL by default. You can modify your SITE_URL or add additional redirect URLs in your project.\nIf signUp() is called for an existing confirmed user:\n\nWhen both Confirm email and Confirm phone (even when phone provider is disabled) are enabled in your project, an obfuscated/fake user object is returned.\nWhen either Confirm email or Confirm phone (even when phone provider is disabled) is disabled, the error message, User already registered is returned.\n\n\nTo fetch the currently logged-in user, refer to getUser().\nParameterscredentialsRequiredOne of the following optionsDetailsOption 1objectDetailsOption 2objectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSign up with an email and passwordSign up with a phone number and password (SMS)Sign up with a phone number and password (whatsapp)Sign up with additional user metadataSign up with a redirect URL1234const { data, error } = await supabase.auth.signUp({  email: 'example@email.com',  password: 'example-password',})ResponseListen to auth eventsReceive a notification every time an auth event happens.\n\nSubscribes to important events occurring on the user's session.\nUse on the frontend/client. It is less useful on the server.\nEvents are emitted across tabs to keep your application's UI up-to-date. Some events can fire very frequently, based on the number of tabs open. Use a quick and efficient callback function, and defer or debounce as many operations as you can to be performed outside of the callback.\nImportant: A callback can be an async function and it runs synchronously during the processing of the changes causing the event. You can easily create a dead-lock by using await on a call to another method of the Supabase library.\n\nAvoid using async functions as callbacks.\nLimit the number of await calls in async callbacks.\nDo not use other Supabase functions in the callback function. If you must, dispatch the functions once the callback has finished executing. Use this as a quick way to achieve this:\n123456supabase.auth.onAuthStateChange((event, session) => {  setTimeout(async () => {    // await on other Supabase function here    // this runs right after the callback has finished  }, 0)})\n\n\n\nEmitted events:\n\nINITIAL_SESSION\n\nEmitted right after the Supabase client is constructed and the initial session from storage is loaded.\n\n\nSIGNED_IN\n\nEmitted each time a user session is confirmed or re-established, including on user sign in and when refocusing a tab.\nAvoid making assumptions as to when this event is fired, this may occur even when the user is already signed in. Instead, check the user object attached to the event to see if a new user has signed in and update your application's UI.\nThis event can fire very frequently depending on the number of tabs open in your application.\n\n\nSIGNED_OUT\n\nEmitted when the user signs out. This can be after:\n\nA call to supabase.auth.signOut().\nAfter the user's session has expired for any reason:\n\nUser has signed out on another device.\nThe session has reached its timebox limit or inactivity timeout.\nUser has signed in on another device with single session per user enabled.\nCheck the User Sessions docs for more information.\n\n\n\n\nUse this to clean up any local storage your application has associated with the user.\n\n\nTOKEN_REFRESHED\n\nEmitted each time a new access and refresh token are fetched for the signed in user.\nIt's best practice and highly recommended to extract the access token (JWT) and store it in memory for further use in your application.\n\nAvoid frequent calls to supabase.auth.getSession() for the same purpose.\n\n\nThere is a background process that keeps track of when the session should be refreshed so you will always receive valid tokens by listening to this event.\nThe frequency of this event is related to the JWT expiry limit configured on your project.\n\n\nUSER_UPDATED\n\nEmitted each time the supabase.auth.updateUser() method finishes successfully. Listen to it to update your application's UI based on new profile information.\n\n\nPASSWORD_RECOVERY\n\nEmitted instead of the SIGNED_IN event when the user lands on a page that includes a password recovery link in the URL.\nUse it to show a UI to the user where they can reset their password.\n\n\n\n\nParameterscallbackRequiredfunctionA callback function to be invoked when an auth event happens.DetailsReturn TypeobjectDetailsListen to auth changesListen to sign outStore OAuth provider tokens on sign inUse React Context for the User's sessionListen to password recovery eventsListen to sign inListen to token refreshListen to user updates1234567891011121314151617181920const { data } = supabase.auth.onAuthStateChange((event, session) => {  console.log(event, session)  if (event === 'INITIAL_SESSION') {    // handle initial session  } else if (event === 'SIGNED_IN') {    // handle sign in event  } else if (event === 'SIGNED_OUT') {    // handle sign out event  } else if (event === 'PASSWORD_RECOVERY') {    // handle password recovery event  } else if (event === 'TOKEN_REFRESHED') {    // handle token refreshed event  } else if (event === 'USER_UPDATED') {    // handle user updated event  }})// call unsubscribe to remove the callbackdata.subscription.unsubscribe()Create an anonymous userCreates a new anonymous user.\n\nReturns an anonymous user\nIt is recommended to set up captcha for anonymous sign-ins to prevent abuse. You can pass in the captcha token in the options param.\nParameterscredentialsOptionalSignInAnonymouslyCredentialsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate an anonymous userCreate an anonymous user with custom user metadata12345const { data, error } = await supabase.auth.signInAnonymously({  options: {    captchaToken  }});ResponseSign in a userLog in an existing user with an email and password or phone and password.\n\nRequires either an email and password or a phone number and password.\nParameterscredentialsRequiredOne of the following optionsDetailsOption 1objectDetailsOption 2objectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSign in with email and passwordSign in with phone and password1234const { data, error } = await supabase.auth.signInWithPassword({  email: 'example@email.com',  password: 'example-password',})ResponseSign in with ID TokenAllows signing in with an OIDC ID token. The authentication provider used should be enabled and configured.ParameterscredentialsRequiredSignInWithIdTokenCredentialsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSign In using ID Token1234const { data, error } = await supabase.auth.signInWithIdToken({  provider: 'google',  token: 'your-id-token'})ResponseSign in a user through OTPLog in a user using magiclink or a one-time password (OTP).\n\nRequires either an email or phone number.\nThis method is used for passwordless sign-ins where a OTP is sent to the user's email or phone number.\nIf the user doesn't exist, signInWithOtp() will signup the user instead. To restrict this behavior, you can set shouldCreateUser in SignInWithPasswordlessCredentials.options to false.\nIf you're using an email, you can configure whether you want the user to receive a magiclink or a OTP.\nIf you're using phone, you can configure whether you want the user to receive a OTP.\nThe magic link's destination URL is determined by the SITE_URL.\nSee redirect URLs and wildcards to add additional redirect URLs to your project.\nMagic links and OTPs share the same implementation. To send users a one-time code instead of a magic link, modify the magic link email template to include {{ .Token }} instead of {{ .ConfirmationURL }}.\nSee our Twilio Phone Auth Guide for details about configuring WhatsApp sign in.\nParameterscredentialsRequiredOne of the following optionsDetailsOption 1objectDetailsOption 2objectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSign in with emailSign in with SMS OTPSign in with WhatsApp OTP123456const { data, error } = await supabase.auth.signInWithOtp({  email: 'example@email.com',  options: {    emailRedirectTo: 'https://example.com/welcome'  }})ResponseNotesSign in a user through OAuthLog in an existing user via a third-party provider. This method supports the PKCE flow.\n\nThis method is used for signing in using a third-party provider.\nSupabase supports many different third-party providers.\nParameterscredentialsRequiredSignInWithOAuthCredentialsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSign in using a third-party providerSign in using a third-party provider with redirectSign in with scopes and access provider tokens123const { data, error } = await supabase.auth.signInWithOAuth({  provider: 'github'})ResponseSign in a user through SSOAttempts a single-sign on using an enterprise Identity Provider. A successful SSO attempt will redirect the current page to the identity provider authorization page. The redirect URL is implementation and SSO protocol specific.\n\nBefore you can call this method you need to establish a connection to an identity provider. Use the CLI commands to do this.\nIf you've associated an email domain to the identity provider, you can use the domain property to start a sign-in flow.\nIn case you need to use a different way to start the authentication flow with an identity provider, you can use the providerId property. For example:\n\nMapping specific user email addresses with an identity provider.\nUsing different hints to identity the identity provider to be used by the user, like a company-specific page, IP address or other tracking information.\n\n\nParametersparamsRequiredOne of the following optionsDetailsOption 1objectDetailsOption 2objectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSign in with email domainSign in with provider UUID1234567891011// You can extract the user's email domain and use it to trigger the  // authentication flow with the correct identity provider.  const { data, error } = await supabase.auth.signInWithSSO({    domain: 'company.com'  })  if (data?.url) {    // redirect the user to the identity provider's authentication flow    window.location.href = data.url  }Get user claims from verified JWTExtracts the JWT claims present in the access token by first verifying the JWT against the server's JSON Web Key Set endpoint /.well-known/jwks.json which is often cached, resulting in significantly faster responses. Prefer this method over {@link #getUser} which always sends a request to the Auth server for each JWT.ParametersjwtOptionalstringAn optional specific JWT you wish to verify, not the one you can obtain from {@link #getSession}.optionsRequiredobjectVarious additional options that allow you to customize the behavior of this method.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsOption 3objectDetailsGet user object1const { data, error } = await supabase.auth.getClaims()ResponseSign out a userInside a browser context, signOut() will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n\nIn order to use the signOut() method, the user needs to be signed in first.\nBy default, signOut() uses the global scope, which signs out all other sessions that the user is logged into as well.\nSince Supabase Auth uses JWTs for authentication, the access token JWT will be valid until it's expired. When the user signs out, Supabase revokes the refresh token and deletes the JWT from the client-side. This does not revoke the JWT and it will still be valid until it expires.\nParametersoptionsRequiredSignOutDetailsReturn TypePromise<object>DetailsSign out1const { error } = await supabase.auth.signOut()Send a password reset requestSends a password reset request to an email address. This method supports the PKCE flow.\n\nThe password reset flow consist of 2 broad steps: (i) Allow the user to login via the password reset link; (ii) Update the user's password.\nThe resetPasswordForEmail() only sends a password reset link to the user's email. To update the user's password, see updateUser().\nA PASSWORD_RECOVERY event will be emitted when the password recovery link is clicked. You can use onAuthStateChange() to listen and invoke a callback function on these events.\nWhen the user clicks the reset link in the email they are redirected back to your application. You can configure the URL that the user is redirected to with the redirectTo parameter. See redirect URLs and wildcards to add additional redirect URLs to your project.\nAfter the user has been redirected successfully, prompt them for a new password and call updateUser():\n\n123const { data, error } = await supabase.auth.updateUser({  password: new_password})ParametersemailRequiredstringThe email address of the user.optionsRequiredobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsReset passwordReset password (React)123const { data, error } = await supabase.auth.resetPasswordForEmail(email, {  redirectTo: 'https://example.com/update-password',})ResponseVerify and log in through OTPLog in a user given a User supplied OTP or TokenHash received through mobile or email.\n\nThe verifyOtp method takes in different verification types.\nIf a phone number is used, the type can either be:\n\nsms – Used when verifying a one-time password (OTP) sent via SMS during sign-up or sign-in.\nphone_change – Used when verifying an OTP sent to a new phone number during a phone number update process.\n\n\nIf an email address is used, the type can be one of the following (note: signup and magiclink types are deprecated):\n\nemail – Used when verifying an OTP sent to the user's email during sign-up or sign-in.\nrecovery – Used when verifying an OTP sent for account recovery, typically after a password reset request.\ninvite – Used when verifying an OTP sent as part of an invitation to join a project or organization.\nemail_change – Used when verifying an OTP sent to a new email address during an email update process.\n\n\nThe verification type used should be determined based on the corresponding auth method called before verifyOtp to sign up / sign-in a user.\nThe TokenHash is contained in the email templates and can be used to sign in. You may wish to use the hash with Magic Links for the PKCE flow for Server Side Auth. See this guide for more details.\nParametersparamsRequiredOne of the following optionsDetailsOption 1VerifyMobileOtpParamsDetailsOption 2VerifyEmailOtpParamsDetailsOption 3VerifyTokenHashParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsVerify Signup One-Time Password (OTP)Verify Sms One-Time Password (OTP)Verify Email Auth (Token Hash)1const { data, error } = await supabase.auth.verifyOtp({ email, token, type: 'email'})ResponseRetrieve a sessionReturns the session, refreshing it if necessary.\n\nThis method retrieves the current local session (i.e local storage).\nThe session contains a signed JWT and unencoded session data.\nSince the unencoded session data is retrieved from the local storage medium, do not rely on it as a source of trusted data on the server. It could be tampered with by the sender. If you need verified, trustworthy user data, call getUser instead.\nIf the session has an expired access token, this method will use the refresh token to get a new session.\nReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsOption 3objectDetailsGet the session data1const { data, error } = await supabase.auth.getSession()ResponseRetrieve a new sessionReturns a new session, regardless of expiry status. Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession(). If the current session's refresh token is invalid, an error will be thrown.\n\nThis method will refresh and return a new session whether the current one is expired or not.\nParameterscurrentSessionOptionalobjectThe current session. If passed in, it must contain a refresh token.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsRefresh session using the current sessionRefresh session using a refresh token12const { data, error } = await supabase.auth.refreshSession()const { session, user } = dataResponseRetrieve a userGets the current user details if there is an existing session. This method performs a network request to the Supabase Auth server, so the returned value is authentic and can be used to base authorization rules on.\n\nThis method fetches the user object from the database instead of local session.\nThis method is useful for checking if the user is authorized because it validates the user's access token JWT on the server.\nShould always be used when checking for user authorization on the server. On the client, you can instead use getSession().session.user for faster results. getSession is insecure on the server.\nParametersjwtOptionalstringTakes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsGet the logged in user with the current existing sessionGet the logged in user with a custom access token jwt1const { data: { user } } = await supabase.auth.getUser()ResponseUpdate a userUpdates user data for a logged in user.\n\nIn order to use the updateUser() method, the user needs to be signed in first.\nBy default, email updates sends a confirmation link to both the user's current and new email. To only send a confirmation link to the user's new email, disable Secure email change in your project's email auth provider settings.\nParametersattributesRequiredUserAttributesDetailsoptionsRequiredobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUpdate the email for an authenticated userUpdate the phone number for an authenticated userUpdate the password for an authenticated userUpdate the user's metadataUpdate the user's password with a nonce123const { data, error } = await supabase.auth.updateUser({  email: 'new@email.com'})ResponseNotesRetrieve identities linked to a userGets all the identities linked to a user.\n\nThe user needs to be signed in to call getUserIdentities().\nReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsReturns a list of identities linked to the user1const { data, error } = await supabase.auth.getUserIdentities()ResponseLink an identity to a userLinks an oauth identity to an existing user. This method supports the PKCE flow.\n\nThe Enable Manual Linking option must be enabled from your project's authentication settings.\nThe user needs to be signed in to call linkIdentity().\nIf the candidate identity is already linked to the existing user or another user, linkIdentity() will fail.\nIf linkIdentity is run in the browser, the user is automatically redirected to the returned URL. On the server, you should handle the redirect.\nParameterscredentialsRequiredSignInWithOAuthCredentialsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsLink an identity to a user123const { data, error } = await supabase.auth.linkIdentity({  provider: 'github'})ResponseUnlink an identity from a userUnlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n\nThe Enable Manual Linking option must be enabled from your project's authentication settings.\nThe user needs to be signed in to call unlinkIdentity().\nThe user must have at least 2 identities in order to unlink an identity.\nThe identity to be unlinked must belong to the user.\nParametersidentityRequiredUserIdentityDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUnlink an identity12345678910// retrieve all identites linked to a userconst identities = await supabase.auth.getUserIdentities()// find the google identityconst googleIdentity = identities.find(  identity => identity.provider === 'google')// unlink the google identityconst { error } = await supabase.auth.unlinkIdentity(googleIdentity)Send a password reauthentication nonceSends a reauthentication OTP to the user's email or phone number. Requires the user to be signed-in.\n\nThis method is used together with updateUser() when a user's password needs to be updated.\nIf you require your user to reauthenticate before updating their password, you need to enable the Secure password change option in your project's email provider settings.\nA user is only require to reauthenticate before updating their password if Secure password change is enabled and the user hasn't recently signed in. A user is deemed recently signed in if the session was created in the last 24 hours.\nThis method will send a nonce to the user's email. If the user doesn't have a confirmed email address, the method will send the nonce to the user's confirmed phone number instead.\nAfter receiving the OTP, include it as the nonce in your updateUser() call to finalize the password change.\nReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSend reauthentication nonce1const { error } = await supabase.auth.reauthenticate()NotesResend an OTPResends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n\nResends a signup confirmation, email change or phone change email to the user.\nPasswordless sign-ins can be resent by calling the signInWithOtp() method again.\nPassword recovery emails can be resent by calling the resetPasswordForEmail() method again.\nThis method will only resend an email or phone OTP to the user if there was an initial signup, email change or phone change request being made(note: For existing users signing in with OTP, you should use signInWithOtp() again to resend the OTP).\nYou can specify a redirect url when you resend an email link using the emailRedirectTo option.\nParameterscredentialsRequiredOne of the following optionsDetailsOption 1objectDetailsOption 2objectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsResend an email signup confirmationResend a phone signup confirmationResend email change emailResend phone change OTP1234567const { error } = await supabase.auth.resend({  type: 'signup',  email: 'email@example.com',  options: {    emailRedirectTo: 'https://example.com/welcome'  }})NotesSet the session dataSets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session. If the refresh token or access token in the current session is invalid, an error will be thrown.\n\nThis method sets the session using an access_token and refresh_token.\nIf successful, a SIGNED_IN event is emitted.\nParameterscurrentSessionRequiredobjectThe current session that minimally contains an access token and refresh token.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsSet the session1234const { data, error } = await supabase.auth.setSession({    access_token,    refresh_token  })ResponseNotesExchange an auth code for a sessionLog in an existing user by exchanging an Auth Code issued during the PKCE flow.\n\nUsed when flowType is set to pkce in client options.\nParametersauthCodeRequiredstringReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsExchange Auth Code1supabase.auth.exchangeCodeForSession('34e770dd-9ff9-416c-87fa-43b31d7ef225')ResponseStart auto-refresh session (non-browser)Starts an auto-refresh process in the background. The session is checked every few seconds. Close to the time of expiration a process is started to refresh the session. If refreshing fails it will be retried for as long as necessary.\n\nOnly useful in non-browser environments such as React Native or Electron.\nThe Supabase Auth library automatically starts and stops proactively refreshing the session when a tab is focused or not.\nOn non-browser platforms, such as mobile or desktop apps built with web technologies, the library is not able to effectively determine whether the application is focused or not.\nTo give this hint to the application, you should be calling this method when the app is in focus and calling supabase.auth.stopAutoRefresh() when it's out of focus.\nReturn TypePromise<void>Start and stop auto refresh in React Native12345678910import { AppState } from 'react-native'// make sure you register this only once!AppState.addEventListener('change', (state) => {  if (state === 'active') {    supabase.auth.startAutoRefresh()  } else {    supabase.auth.stopAutoRefresh()  }})Stop auto-refresh session (non-browser)Stops an active auto refresh process running in the background (if any).\n\nOnly useful in non-browser environments such as React Native or Electron.\nThe Supabase Auth library automatically starts and stops proactively refreshing the session when a tab is focused or not.\nOn non-browser platforms, such as mobile or desktop apps built with web technologies, the library is not able to effectively determine whether the application is focused or not.\nWhen your application goes in the background or out of focus, call this method to stop the proactive refreshing of the session.\nReturn TypePromise<void>Start and stop auto refresh in React Native12345678910import { AppState } from 'react-native'// make sure you register this only once!AppState.addEventListener('change', (state) => {  if (state === 'active') {    supabase.auth.startAutoRefresh()  } else {    supabase.auth.stopAutoRefresh()  }})Auth MFAThis section contains methods commonly used for Multi-Factor Authentication (MFA) and are invoked behind the supabase.auth.mfa namespace.\nCurrently, there is support for time-based one-time password (TOTP) and phone verification code as the 2nd factor. Recovery codes are not supported but users can enroll multiple factors, with an upper limit of 10.\nHaving a 2nd factor for recovery frees the user of the burden of having to store their recovery codes somewhere. It also reduces the attack surface since multiple recovery codes are usually generated compared to just having 1 backup factor.\nLearn more about implementing MFA in your application in the MFA guide.Enroll a factorStarts the enrollment process for a new Multi-Factor Authentication (MFA) factor. This method creates a new unverified factor. To verify a factor, present the QR code or secret to the user and ask them to add it to their authenticator app. The user has to enter the code from their authenticator app to verify it.\n\nUse totp or phone as the factorType and use the returned id to create a challenge.\nTo create a challenge, see mfa.challenge().\nTo verify a challenge, see mfa.verify().\nTo create and verify a TOTP challenge in a single step, see mfa.challengeAndVerify().\nTo generate a QR code for the totp secret in Next.js, you can do the following:\n\n1<Image src={data.totp.qr_code} alt={data.totp.uri} layout=\"fill\"></Image>\n\nThe challenge and verify steps are separated when using Phone factors as the user will need time to receive and input the code obtained from the SMS in challenge.\nParametersparamsRequiredOne of the following optionsDetailsOption 1MFAEnrollTOTPParamsDetailsOption 2MFAEnrollPhoneParamsDetailsOption 3objectDetailsOption 4objectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsEnroll a time-based, one-time password (TOTP) factorEnroll a Phone Factor12345678910const { data, error } = await supabase.auth.mfa.enroll({  factorType: 'totp',  friendlyName: 'your_friendly_name'})// Use the id to create a challenge.// The challenge can be verified by entering the code generated from the authenticator app.// The code will be generated upon scanning the qr_code or entering the secret into the authenticator app.const { id, type, totp: { qr_code, secret, uri }, friendly_name } = dataconst challenge = await supabase.auth.mfa.challenge({ factorId: id });ResponseCreate a challengePrepares a challenge used to verify that a user has access to a MFA factor.\n\nAn enrolled factor is required before creating a challenge.\nTo verify a challenge, see mfa.verify().\nA phone factor sends a code to the user upon challenge. The channel defaults to sms unless otherwise specified.\nParametersparamsRequiredMFAChallengeParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate a challenge for a factorCreate a challenge for a phone factorCreate a challenge for a phone factor (WhatsApp)123const { data, error } = await supabase.auth.mfa.challenge({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225'})ResponseVerify a challengeVerifies a code against a challenge. The verification code is provided by the user by entering a code seen in their authenticator app.\n\nTo verify a challenge, please create a challenge first.\nParametersparamsRequiredMFAVerifyParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsVerify a challenge for a factor12345const { data, error } = await supabase.auth.mfa.verify({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  challengeId: '4034ae6f-a8ce-4fb5-8ee5-69a5863a7c15',  code: '123456'})ResponseCreate and verify a challengeHelper method which creates a challenge and immediately uses the given code to verify against it thereafter. The verification code is provided by the user by entering a code seen in their authenticator app.\n\nIntended for use with only TOTP factors.\nAn enrolled factor is required before invoking challengeAndVerify().\nExecutes mfa.challenge() and mfa.verify() in a single step.\nParametersparamsRequiredMFAChallengeAndVerifyParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate and verify a challenge for a factor1234const { data, error } = await supabase.auth.mfa.challengeAndVerify({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  code: '123456'})ResponseUnenroll a factorUnenroll removes a MFA factor. A user has to have an aal2 authenticator level in order to unenroll a verified factor.ParametersparamsRequiredMFAUnenrollParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUnenroll a factor123const { data, error } = await supabase.auth.mfa.unenroll({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',})ResponseGet Authenticator Assurance LevelReturns the Authenticator Assurance Level (AAL) for the active session.\n\nAuthenticator Assurance Level (AAL) is the measure of the strength of an authentication mechanism.\nIn Supabase, having an AAL of aal1 refers to having the 1st factor of authentication such as an email and password or OAuth sign-in while aal2 refers to the 2nd factor of authentication such as a time-based, one-time-password (TOTP) or Phone factor.\nIf the user has a verified factor, the nextLevel field will return aal2, else, it will return aal1.\nReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsGet the AAL details of a session12const { data, error } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()const { currentLevel, nextLevel, currentAuthenticationMethods } = dataResponseAuth Admin\nAny method under the supabase.auth.admin namespace requires a service_role key.\nThese methods are considered admin methods and should be called on a trusted server. Never expose your service_role key in the browser.\nCreate server-side auth client1234567891011import { createClient } from '@supabase/supabase-js'const supabase = createClient(supabase_url, service_role_key, {  auth: {    autoRefreshToken: false,    persistSession: false  }})// Access auth admin apiconst adminAuthClient = supabase.auth.adminRetrieve a userGet user by id.\n\nFetches the user object from the database based on the user's id.\nThe getUserById() method requires the user's id which maps to the auth.users.id column.\nParametersuidRequiredstringThe user's unique identifier\nThis function should only be called on a server. Never expose your service_role key in the browser.Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsFetch the user object using the access_token jwt1const { data, error } = await supabase.auth.admin.getUserById(1)ResponseList all usersGet a list of users.\n\nDefaults to return 50 users per page.\nParametersparamsOptionalPageParamsAn object which supports page and perPage as numbers, to alter the paginated results.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsGet a page of usersPaginated list of users1const { data: { users }, error } = await supabase.auth.admin.listUsers()Create a userCreates a new user. This function should only be called on a server. Never expose your service_role key in the browser.\n\nTo confirm the user's email address or phone number, set email_confirm or phone_confirm to true. Both arguments default to false.\ncreateUser() will not send a confirmation email to the user. You can use inviteUserByEmail() if you want to send them an email invite instead.\nIf you are sure that the created user's email or phone number is legitimate and verified, you can set the email_confirm or phone_confirm param to true.\nParametersattributesRequiredAdminUserAttributesDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsWith custom user metadataAuto-confirm the user's emailAuto-confirm the user's phone number12345const { data, error } = await supabase.auth.admin.createUser({  email: 'user@email.com',  password: 'password',  user_metadata: { name: 'Yoda' }})ResponseDelete a userDelete a user. Requires a service_role key.\n\nThe deleteUser() method requires the user's ID, which maps to the auth.users.id column.\nParametersidRequiredstringThe user id you want to remove.shouldSoftDeleteRequiredbooleanIf true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible. Defaults to false for backward compatibility.\nThis function should only be called on a server. Never expose your service_role key in the browser.Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsRemoves a user123const { data, error } = await supabase.auth.admin.deleteUser(  '715ed5db-f090-4b8c-a067-640ecee36aa0')ResponseSend an email invite linkSends an invite link to an email address.\n\nSends an invite link to the user's email address.\nThe inviteUserByEmail() method is typically used by administrators to invite users to join the application.\nNote that PKCE is not supported when using inviteUserByEmail. This is because the browser initiating the invite is often different from the browser accepting the invite which makes it difficult to provide the security guarantees required of the PKCE flow.\nParametersemailRequiredstringThe email address of the user.optionsRequiredobjectAdditional options to be included when inviting.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsInvite a user1const { data, error } = await supabase.auth.admin.inviteUserByEmail('email@example.com')ResponseGenerate an email linkGenerates email links and OTPs to be sent via a custom email provider.\n\nThe following types can be passed into generateLink(): signup, magiclink, invite, recovery, email_change_current, email_change_new, phone_change.\ngenerateLink() only generates the email link for email_change_email if the Secure email change is enabled in your project's email auth provider settings.\ngenerateLink() handles the creation of the user for signup, invite and magiclink.\nParametersparamsRequiredGenerateLinkParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsGenerate a signup linkGenerate an invite linkGenerate a magic linkGenerate a recovery linkGenerate links to change current email address12345const { data, error } = await supabase.auth.admin.generateLink({  type: 'signup',  email: 'email@example.com',  password: 'secret'})ResponseUpdate a userUpdates the user data.ParametersuidRequiredstringattributesRequiredAdminUserAttributesThe data you want to update.\nThis function should only be called on a server. Never expose your service_role key in the browser.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUpdates a user's emailUpdates a user's passwordUpdates a user's metadataUpdates a user's app_metadataConfirms a user's email addressConfirms a user's phone number1234const { data: user, error } = await supabase.auth.admin.updateUserById(  '11111111-1111-1111-1111-111111111111',  { email: 'new@email.com' })ResponseDelete a factor for a userDeletes a factor on a user. This will log the user out of all active sessions if the deleted factor was verified.ParametersparamsRequiredAuthMFAAdminDeleteFactorParamsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsDelete a factor for a user1234const { data, error } = await supabase.auth.admin.mfa.deleteFactor({  id: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  userId: 'a89baba7-b1b7-440f-b4bb-91026967f66b',})ResponseInvokes a Supabase Edge Function.Invokes a function\nInvoke a Supabase Edge Function.\n\nRequires an Authorization header.\nInvoke params generally match the Fetch API spec.\nWhen you pass in a body to your function, we automatically attach the Content-Type header for Blob, ArrayBuffer, File, FormData and String. If it doesn't match any of these types we assume the payload is json, serialize it and attach the Content-Type header as application/json. You can override this behavior by passing in a Content-Type header of your own.\nResponses are automatically parsed as json, blob and form-data depending on the Content-Type header sent by your function. Responses are parsed as text by default.\nParametersfunctionNameRequiredstringThe name of the Function to invoke.optionsRequiredFunctionInvokeOptionsOptions for invoking the Function.DetailsReturn TypePromise<One of the following options>Basic invocationError handlingPassing custom headersCalling with DELETE HTTP verbInvoking a Function in the UsEast1 regionCalling with GET HTTP verb123const { data, error } = await supabase.functions.invoke('hello', {  body: { foo: 'bar' }})Subscribe to channelCreates an event handler that listens to changes.\n\nBy default, Broadcast and Presence are enabled for all projects.\nBy default, listening to database changes is disabled for new projects due to database performance and security concerns. You can turn it on by managing Realtime's replication.\nYou can receive the \"previous\" data for updates and deletes by setting the table's REPLICA IDENTITY to FULL (e.g., ALTER TABLE your_table REPLICA IDENTITY FULL;).\nRow level security is not applied to delete statements. When RLS is enabled and replica identity is set to full, only the primary key is sent to clients.\nParameterstypeRequiredOne of the following optionsDetailsOption 1\"presence\"Option 2\"postgres_changes\"Option 3\"broadcast\"Option 4\"system\"filterRequiredOne of the following optionsDetailsOption 1objectDetailsOption 2objectDetailsOption 3objectDetailsOption 4RealtimePostgresChangesFilterDetailsOption 5objectDetailscallbackRequiredfunctionDetailsListen to broadcast messagesListen to presence syncListen to presence joinListen to presence leaveListen to all database changesListen to a specific tableListen to insertsListen to updatesListen to deletesListen to multiple eventsListen to row level changes12345678910111213const channel = supabase.channel(\"room1\")channel.on(\"broadcast\", { event: \"cursor-pos\" }, (payload) => {  console.log(\"Cursor position received!\", payload);}).subscribe((status) => {  if (status === \"SUBSCRIBED\") {    channel.send({      type: \"broadcast\",      event: \"cursor-pos\",      payload: { x: Math.random(), y: Math.random() },    });  }});Unsubscribe from a channelUnsubscribes and removes Realtime channel from Realtime client.\n\nRemoving a channel is a great way to maintain the performance of your project's Realtime service as well as your database if you're listening to Postgres changes. Supabase will automatically handle cleanup 30 seconds after a client is disconnected, but unused channels may cause degradation as more clients are simultaneously subscribed.\nParameterschannelRequired@supabase/realtime-js.RealtimeChannelThe name of the Realtime channel.Return TypePromise<One of the following options>DetailsOption 1\"error\"Option 2\"ok\"Option 3\"timed out\"Removes a channel1supabase.removeChannel(myChannel)Unsubscribe from all channelsUnsubscribes and removes all Realtime channels from Realtime client.\n\nRemoving channels is a great way to maintain the performance of your project's Realtime service as well as your database if you're listening to Postgres changes. Supabase will automatically handle cleanup 30 seconds after a client is disconnected, but unused channels may cause degradation as more clients are simultaneously subscribed.\nReturn TypePromise<Array<One of the following options>>DetailsRemove all channels1supabase.removeAllChannels()Retrieve all channelsReturns all Realtime channels.Return TypeArray<@supabase/realtime-js.RealtimeChannel>Get all channels1const channels = supabase.getChannels()Broadcast a messageSends a message into the channel.\nBroadcast a message to all connected clients to a channel.\n\nWhen using REST you don't need to subscribe to the channel\nREST calls are only available from 2.37.0 onwards\nParametersargsRequiredobjectArguments to send to channelDetailsoptsRequired{ [key: string]: any }Options to be used during the send processReturn TypePromise<One of the following options>DetailsOption 1\"ok\"Option 2\"timed out\"Option 3\"error\"Send a message via websocketSend a message via REST1234567891011supabase  .channel('room1')  .subscribe((status) => {    if (status === 'SUBSCRIBED') {      channel.send({        type: 'broadcast',        event: 'cursor-pos',        payload: { x: Math.random(), y: Math.random() },      })    }  })ResponseCreate a bucketCreates a new Storage bucket\n\nRLS policy permissions required:\n\nbuckets table permissions: insert\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nParametersidRequiredstringA unique identifier for the bucket you are creating.optionsRequiredobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate bucket1234567const { data, error } = await supabase  .storage  .createBucket('avatars', {    public: false,    allowedMimeTypes: ['image/png'],    fileSizeLimit: 1024  })ResponseRetrieve a bucketRetrieves the details of an existing Storage bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: select\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nParametersidRequiredstringThe unique identifier of the bucket you would like to retrieve.Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsGet bucket123const { data, error } = await supabase  .storage  .getBucket('avatars')ResponseList all bucketsRetrieves the details of all Storage buckets within an existing project.\n\nRLS policy permissions required:\n\nbuckets table permissions: select\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsList buckets123const { data, error } = await supabase  .storage  .listBuckets()ResponseUpdate a bucketUpdates a Storage bucket\n\nRLS policy permissions required:\n\nbuckets table permissions: select and update\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nParametersidRequiredstringA unique identifier for the bucket you are updating.optionsRequiredobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUpdate bucket1234567const { data, error } = await supabase  .storage  .updateBucket('avatars', {    public: false,    allowedMimeTypes: ['image/png'],    fileSizeLimit: 1024  })ResponseDelete a bucketDeletes an existing bucket. A bucket can't be deleted with existing objects inside it. You must first empty() the bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: select and delete\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nParametersidRequiredstringThe unique identifier of the bucket you would like to delete.Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsDelete bucket123const { data, error } = await supabase  .storage  .deleteBucket('avatars')ResponseEmpty a bucketRemoves all objects inside a single bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: select\nobjects table permissions: select and delete\n\n\nRefer to the Storage guide on how access control works\nParametersidRequiredstringThe unique identifier of the bucket you would like to empty.Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsEmpty bucket123const { data, error } = await supabase  .storage  .emptyBucket('avatars')ResponseUpload a fileUploads a file to an existing bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: only insert when you are uploading new files and select, insert and update when you are upserting files\n\n\nRefer to the Storage guide on how access control works\nFor React Native, using either Blob, File or FormData does not work as intended. Upload file using ArrayBuffer from base64 file data instead, see example below.\nParameterspathRequiredstringThe file path, including the file name. Should be of the format folder/subfolder/filename.png. The bucket must already exist before attempting to upload.fileBodyRequiredFileBodyThe body of the file to be stored in the bucket.fileOptionsOptionalFileOptionsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUpload fileUpload file using `ArrayBuffer` from base64 file data12345678const avatarFile = event.target.files[0]const { data, error } = await supabase  .storage  .from('avatars')  .upload('public/avatar1.png', avatarFile, {    cacheControl: '3600',    upsert: false  })ResponseDownload a fileDownloads a file from a private bucket. For public buckets, make a request to the URL returned from getPublicUrl instead.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: select\n\n\nRefer to the Storage guide on how access control works\nParameterspathRequiredstringThe full path and file name of the file to be downloaded. For example folder/image.png.optionsOptionalobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsDownload fileDownload file with transformations1234const { data, error } = await supabase  .storage  .from('avatars')  .download('folder/avatar1.png')ResponseList all files in a bucketLists all the files within a bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: select\n\n\nRefer to the Storage guide on how access control works\nParameterspathOptionalstringThe folder path.optionsOptionalSearchOptionsSearch options including limit (defaults to 100), offset, sortBy, and searchDetailsparametersOptionalFetchParametersDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsList files in a bucketSearch files in a bucket12345678const { data, error } = await supabase  .storage  .from('avatars')  .list('folder', {    limit: 100,    offset: 0,    sortBy: { column: 'name', order: 'asc' },  })ResponseReplace an existing fileReplaces an existing file at the specified path with a new one.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: update and select\n\n\nRefer to the Storage guide on how access control works\nFor React Native, using either Blob, File or FormData does not work as intended. Update file using ArrayBuffer from base64 file data instead, see example below.\nParameterspathRequiredstringThe relative file path. Should be of the format folder/subfolder/filename.png. The bucket must already exist before attempting to update.fileBodyRequiredOne of the following optionsThe body of the file to be stored in the bucket.DetailsOption 1stringOption 2ArrayBufferOption 3ArrayBufferViewOption 4BlobOption 5@types/node.BufferOption 6FileOption 7FormDataOption 8@types/node.NodeJS.ReadableStreamOption 9ReadableStreamOption 10URLSearchParamsfileOptionsOptionalFileOptionsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUpdate fileUpdate file using `ArrayBuffer` from base64 file data12345678const avatarFile = event.target.files[0]const { data, error } = await supabase  .storage  .from('avatars')  .update('public/avatar1.png', avatarFile, {    cacheControl: '3600',    upsert: true  })ResponseMove an existing fileMoves an existing file to a new path in the same bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: update and select\n\n\nRefer to the Storage guide on how access control works\nParametersfromPathRequiredstringThe original file path, including the current file name. For example folder/image.png.toPathRequiredstringThe new file path, including the new file name. For example folder/image-new.png.optionsOptionalDestinationOptionsThe destination options.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsMove file1234const { data, error } = await supabase  .storage  .from('avatars')  .move('public/avatar1.png', 'private/avatar2.png')ResponseCopy an existing fileCopies an existing file to a new path in the same bucket.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: insert and select\n\n\nRefer to the Storage guide on how access control works\nParametersfromPathRequiredstringThe original file path, including the current file name. For example folder/image.png.toPathRequiredstringThe new file path, including the new file name. For example folder/image-copy.png.optionsOptionalDestinationOptionsThe destination options.DetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCopy file1234const { data, error } = await supabase  .storage  .from('avatars')  .copy('public/avatar1.png', 'private/avatar2.png')ResponseDelete files in a bucketDeletes files within the same bucket\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: delete and select\n\n\nRefer to the Storage guide on how access control works\nParameterspathsRequiredArray<string>An array of files to delete, including the path and file name. For example ['folder/image.png'].Return TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsDelete file1234const { data, error } = await supabase  .storage  .from('avatars')  .remove(['folder/avatar1.png'])ResponseCreate a signed URLCreates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: select\n\n\nRefer to the Storage guide on how access control works\nParameterspathRequiredstringThe file path, including the current file name. For example folder/image.png.expiresInRequirednumberThe number of seconds until the signed URL expires. For example, 60 for a URL which is valid for one minute.optionsOptionalobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate Signed URLCreate a signed URL for an asset with transformationsCreate a signed URL which triggers the download of the asset1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUrl('folder/avatar1.png', 60)ResponseCreate signed URLsCreates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: select\n\n\nRefer to the Storage guide on how access control works\nParameterspathsRequiredArray<string>The file paths to be downloaded, including the current file names. For example ['folder/image.png', 'folder2/image2.png'].expiresInRequirednumberThe number of seconds until the signed URLs expire. For example, 60 for URLs which are valid for one minute.optionsOptionalobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate Signed URLs1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)ResponseCreate signed upload URLCreates a signed upload URL. Signed upload URLs can be used to upload files to the bucket without further authentication. They are valid for 2 hours.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: insert\n\n\nRefer to the Storage guide on how access control works\nParameterspathRequiredstringThe file path, including the current file name. For example folder/image.png.optionsOptionalobjectDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsCreate Signed Upload URL1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUploadUrl('folder/cat.jpg')ResponseUpload to a signed URLUpload a file with a token generated from createSignedUploadUrl.\n\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nParameterspathRequiredstringThe file path, including the file name. Should be of the format folder/subfolder/filename.png. The bucket must already exist before attempting to upload.tokenRequiredstringThe token generated from createSignedUploadUrlfileBodyRequiredFileBodyThe body of the file to be stored in the bucket.fileOptionsOptionalFileOptionsDetailsReturn TypePromise<One of the following options>DetailsOption 1objectDetailsOption 2objectDetailsUpload to a signed URL1234const { data, error } = await supabase  .storage  .from('avatars')  .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)ResponseRetrieve public URLA simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset. This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\nThe bucket needs to be set to public, either via updateBucket() or by going to Storage on supabase.com/dashboard, clicking the overflow menu on a bucket and choosing \"Make public\"\nRLS policy permissions required:\n\nbuckets table permissions: none\nobjects table permissions: none\n\n\nRefer to the Storage guide on how access control works\nParameterspathRequiredstringThe path and name of the file to generate the public URL for. For example folder/image.png.optionsOptionalobjectDetailsReturn TypeobjectDetailsReturns the URL for an asset in a public bucketReturns the URL for an asset in a public bucket with transformationsReturns the URL which triggers the download of an asset in a public bucket1234const { data } = supabase  .storage  .from('public-bucket')  .getPublicUrl('folder/avatar1.png')Response",
    "code_blocks": [
      "supabase-js",
      "supabase-js",
      "supabase-js",
      "1npm install @supabase/supabase-js",
      "1npm install @supabase/supabase-js",
      "123<script src=\"https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2\"></script>//or<script src=\"https://unpkg.com/@supabase/supabase-js@2\"></script>",
      "123<script src=\"https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2\"></script>//or<script src=\"https://unpkg.com/@supabase/supabase-js@2\"></script>",
      "1import { createClient } from 'npm:@supabase/supabase-js@2'",
      "1import { createClient } from 'npm:@supabase/supabase-js@2'",
      "createClient()",
      "1234import { createClient } from '@supabase/supabase-js'// Create a single supabase client for interacting with your databaseconst supabase = createClient('https://xyzcompany.supabase.co', 'publishable-or-anon-key')",
      "1234import { createClient } from '@supabase/supabase-js'// Create a single supabase client for interacting with your databaseconst supabase = createClient('https://xyzcompany.supabase.co', 'publishable-or-anon-key')",
      "supabase-js",
      "supabase-js",
      "not null",
      "T | null",
      "supabase-js",
      "T[]",
      "T | null",
      "1supabase gen types typescript --project-id abcdefghijklmnopqrst > database.types.ts",
      "1supabase gen types typescript --project-id abcdefghijklmnopqrst > database.types.ts",
      "public.movies",
      "12345create table public.movies (  id bigint generated always as identity primary key,  name text not null,  data jsonb null);",
      "12345create table public.movies (  id bigint generated always as identity primary key,  name text not null,  data jsonb null);",
      "12345678910111213141516171819202122232425export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]export interface Database {  public: {    Tables: {      movies: {        Row: {               // the data expected from .select()          id: number          name: string          data: Json | null        }        Insert: {            // the data to be passed to .insert()          id?: never         // generated columns must not be supplied          name: string       // `not null` columns with no default must be supplied          data?: Json | null // nullable columns can be omitted        }        Update: {            // the data to be passed to .update()          id?: never          name?: string      // `not null` columns are optional on .update()          data?: Json | null        }      }    }  }}",
      "12345678910111213141516171819202122232425export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]export interface Database {  public: {    Tables: {      movies: {        Row: {               // the data expected from .select()          id: number          name: string          data: Json | null        }        Insert: {            // the data to be passed to .insert()          id?: never         // generated columns must not be supplied          name: string       // `not null` columns with no default must be supplied          data?: Json | null // nullable columns can be omitted        }        Update: {            // the data to be passed to .update()          id?: never          name?: string      // `not null` columns are optional on .update()          data?: Json | null        }      }    }  }}",
      "supabase-js",
      "1234567import { createClient } from '@supabase/supabase-js'import { Database } from './database.types'const supabase = createClient<Database>(  process.env.SUPABASE_URL,  process.env.SUPABASE_ANON_KEY)",
      "1234567import { createClient } from '@supabase/supabase-js'import { Database } from './database.types'const supabase = createClient<Database>(  process.env.SUPABASE_URL,  process.env.SUPABASE_ANON_KEY)",
      "not null",
      "12345export type Json = // ...export interface Database {  // ...}",
      "12345export type Json = // ...export interface Database {  // ...}",
      "1234567891011121314151617181920import { MergeDeep } from 'type-fest'import { Database as DatabaseGenerated } from './database-generated.types'export { Json } from './database-generated.types'// Override the type for a specific column in a view:export type Database = MergeDeep<  DatabaseGenerated,  {    public: {      Views: {        movies_view: {          Row: {            // id is a primary key in public.movies, so it must be `not null`            id: number          }        }      }    }  }>",
      "1234567891011121314151617181920import { MergeDeep } from 'type-fest'import { Database as DatabaseGenerated } from './database-generated.types'export { Json } from './database-generated.types'// Override the type for a specific column in a view:export type Database = MergeDeep<  DatabaseGenerated,  {    public: {      Views: {        movies_view: {          Row: {            // id is a primary key in public.movies, so it must be `not null`            id: number          }        }      }    }  }>",
      "123456789// Partial type override allows you to only override some of the properties in your resultsconst { data } = await supabase.from('countries').select().overrideTypes<Array<{ id: string }>>()// For a full replacement of the original return type use the `{ merge: false }` property as second argumentconst { data } = await supabase  .from('countries')  .select()  .overrideTypes<Array<{ id: string }>, { merge: false }>()// Use it with `maybeSingle` or `single`const { data } = await supabase.from('countries').select().single().overrideTypes<{ id: string }>()",
      "123456789// Partial type override allows you to only override some of the properties in your resultsconst { data } = await supabase.from('countries').select().overrideTypes<Array<{ id: string }>>()// For a full replacement of the original return type use the `{ merge: false }` property as second argumentconst { data } = await supabase  .from('countries')  .select()  .overrideTypes<Array<{ id: string }>, { merge: false }>()// Use it with `maybeSingle` or `single`const { data } = await supabase.from('countries').select().single().overrideTypes<{ id: string }>()",
      "1234567import { Database, Tables, Enums } from \"./database.types.ts\";// Before 😕let movie: Database['public']['Tables']['movies']['Row'] = // ...// After 😍let movie: Tables<'movies'>",
      "1234567import { Database, Tables, Enums } from \"./database.types.ts\";// Before 😕let movie: Database['public']['Tables']['movies']['Row'] = // ...// After 😍let movie: Tables<'movies'>",
      "supabase-js",
      "data",
      "error",
      "CountriesWithCities",
      "12345678910create table countries (  \"id\" serial primary key,  \"name\" text);create table cities (  \"id\" serial primary key,  \"name\" text,  \"country_id\" int references \"countries\");",
      "12345678910create table countries (  \"id\" serial primary key,  \"name\" text);create table cities (  \"id\" serial primary key,  \"name\" text,  \"country_id\" int references \"countries\");",
      "1234567891011121314151617import { QueryResult, QueryData, QueryError } from '@supabase/supabase-js'const countriesWithCitiesQuery = supabase  .from(\"countries\")  .select(`    id,    name,    cities (      id,      name    )  `);type CountriesWithCities = QueryData<typeof countriesWithCitiesQuery>;const { data, error } = await countriesWithCitiesQuery;if (error) throw error;const countriesWithCities: CountriesWithCities = data;",
      "1234567891011121314151617import { QueryResult, QueryData, QueryError } from '@supabase/supabase-js'const countriesWithCitiesQuery = supabase  .from(\"countries\")  .select(`    id,    name,    cities (      id,      name    )  `);type CountriesWithCities = QueryData<typeof countriesWithCitiesQuery>;const { data, error } = await countriesWithCitiesQuery;if (error) throw error;const countriesWithCities: CountriesWithCities = data;",
      "range()",
      "select()",
      "select()",
      "apikey",
      "customName:columnName",
      "123const { data, error } = await supabase  .from('characters')  .select()",
      "123const { data, error } = await supabase  .from('characters')  .select()",
      "123const { error } = await supabase  .from('countries')  .insert({ id: 1, name: 'Mordor' })",
      "123const { error } = await supabase  .from('countries')  .insert({ id: 1, name: 'Mordor' })",
      "update()",
      "1234const { error } = await supabase  .from('instruments')  .update({ name: 'piano' })  .eq('id', 1)",
      "1234const { error } = await supabase  .from('instruments')  .update({ name: 'piano' })  .eq('id', 1)",
      "onConflict",
      ".upsert()",
      ".insert()",
      "onConflict",
      "ignoreDuplicates",
      "values",
      "1234const { data, error } = await supabase  .from('instruments')  .upsert({ id: 1, name: 'piano' })  .select()",
      "1234const { data, error } = await supabase  .from('instruments')  .upsert({ id: 1, name: 'piano' })  .select()",
      "delete()",
      "delete()",
      "SELECT",
      "SELECT",
      "ALL",
      "delete().in()",
      "1234const response = await supabase  .from('countries')  .delete()  .eq('id', 1)",
      "1234const response = await supabase  .from('countries')  .delete()  .eq('id', 1)",
      "123create or replace function hello_world() returns text as $$  select 'Hello world';$$ language sql;",
      "123create or replace function hello_world() returns text as $$  select 'Hello world';$$ language sql;",
      "get: true",
      "1const { data, error } = await supabase.rpc('hello_world')",
      "1const { data, error } = await supabase.rpc('hello_world')",
      "select()",
      "update()",
      "upsert()",
      "delete()",
      "123456789const { data, error } = await supabase  .from('instruments')  .select('name, section_id')  .eq('name', 'violin')    // Correctconst { data, error } = await supabase  .from('instruments')  .eq('name', 'violin')    // Incorrect  .select('name, section_id')",
      "123456789const { data, error } = await supabase  .from('instruments')  .select('name, section_id')  .eq('name', 'violin')    // Correctconst { data, error } = await supabase  .from('instruments')  .eq('name', 'violin')    // Incorrect  .select('name, section_id')",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .eq('name', 'Leia')",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .eq('name', 'Leia')",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .neq('name', 'Leia')",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .neq('name', 'Leia')",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .gt('id', 2)",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .gt('id', 2)",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .gte('id', 2)",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .gte('id', 2)",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .lt('id', 2)",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .lt('id', 2)",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .lte('id', 2)",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .lte('id', 2)",
      "column",
      "pattern",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .like('name', '%Lu%')",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .like('name', '%Lu%')",
      "column",
      "pattern",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .ilike('name', '%lu%')",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .ilike('name', '%lu%')",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('countries')  .select()  .is('name', null)",
      "1234const { data, error } = await supabase  .from('countries')  .select()  .is('name', null)",
      "column",
      "values",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .in('name', ['Leia', 'Han'])",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .in('name', ['Leia', 'Han'])",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('issues')  .select()  .contains('tags', ['is:open', 'priority:low'])",
      "1234const { data, error } = await supabase  .from('issues')  .select()  .contains('tags', ['is:open', 'priority:low'])",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('classes')  .select('name')  .containedBy('days', ['monday', 'tuesday', 'wednesday', 'friday'])",
      "1234const { data, error } = await supabase  .from('classes')  .select('name')  .containedBy('days', ['monday', 'tuesday', 'wednesday', 'friday'])",
      "column",
      "range",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeGt('during', '[2000-01-02 08:00, 2000-01-02 09:00)')",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeGt('during', '[2000-01-02 08:00, 2000-01-02 09:00)')",
      "column",
      "range",
      "range",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeGte('during', '[2000-01-02 08:30, 2000-01-02 09:30)')",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeGte('during', '[2000-01-02 08:30, 2000-01-02 09:30)')",
      "column",
      "range",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeLt('during', '[2000-01-01 15:00, 2000-01-01 16:00)')",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeLt('during', '[2000-01-01 15:00, 2000-01-01 16:00)')",
      "column",
      "range",
      "range",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeLte('during', '[2000-01-01 14:00, 2000-01-01 16:00)')",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeLte('during', '[2000-01-01 14:00, 2000-01-01 16:00)')",
      "column",
      "range",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeAdjacent('during', '[2000-01-01 12:00, 2000-01-01 13:00)')",
      "1234const { data, error } = await supabase  .from('reservations')  .select()  .rangeAdjacent('during', '[2000-01-01 12:00, 2000-01-01 13:00)')",
      "column",
      "value",
      "1234const { data, error } = await supabase  .from('issues')  .select('title')  .overlaps('tags', ['is:closed', 'severity:high'])",
      "1234const { data, error } = await supabase  .from('issues')  .select('title')  .overlaps('tags', ['is:closed', 'severity:high'])",
      "column",
      "query",
      "123456const result = await supabase  .from(\"texts\")  .select(\"content\")  .textSearch(\"content\", `'eggs' & 'ham'`, {    config: \"english\",  });",
      "123456const result = await supabase  .from(\"texts\")  .select(\"content\")  .textSearch(\"content\", `'eggs' & 'ham'`, {    config: \"english\",  });",
      "query",
      ".eq()",
      "1234const { data, error } = await supabase  .from('characters')  .select('name')  .match({ id: 2, name: 'Leia' })",
      "1234const { data, error } = await supabase  .from('characters')  .select('name')  .match({ id: 2, name: 'Leia' })",
      "12.not('id', 'in', '(5,6,7)')  // Use `()` for `in` filter.not('arraycol', 'cs', '{\"a\",\"b\"}')  // Use `cs` for `contains()`, `{}` for array values",
      "12.not('id', 'in', '(5,6,7)')  // Use `()` for `in` filter.not('arraycol', 'cs', '{\"a\",\"b\"}')  // Use `cs` for `contains()`, `{}` for array values",
      "1234const { data, error } = await supabase  .from('countries')  .select()  .not('name', 'is', null)",
      "1234const { data, error } = await supabase  .from('countries')  .select()  .not('name', 'is', null)",
      "12.or('id.in.(5,6,7), arraycol.cs.{\"a\",\"b\"}')  // Use `()` for `in` filter, `{}` for array values and `cs` for `contains()`..or('id.in.(5,6,7), arraycol.cd.{\"a\",\"b\"}')  // Use `cd` for `containedBy()`",
      "12.or('id.in.(5,6,7), arraycol.cs.{\"a\",\"b\"}')  // Use `()` for `in` filter, `{}` for array values and `cs` for `contains()`..or('id.in.(5,6,7), arraycol.cd.{\"a\",\"b\"}')  // Use `cd` for `containedBy()`",
      "1234const { data, error } = await supabase  .from('characters')  .select('name')  .or('id.eq.2,name.eq.Han')",
      "1234const { data, error } = await supabase  .from('characters')  .select('name')  .or('id.eq.2,name.eq.Han')",
      "12.filter('id', 'in', '(5,6,7)')  // Use `()` for `in` filter.filter('arraycol', 'cs', '{\"a\",\"b\"}')  // Use `cs` for `contains()`, `{}` for array values",
      "12.filter('id', 'in', '(5,6,7)')  // Use `()` for `in` filter.filter('arraycol', 'cs', '{\"a\",\"b\"}')  // Use `cs` for `contains()`, `{}` for array values",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .filter('name', 'in', '(\"Han\",\"Yoda\")')",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .filter('name', 'in', '(\"Han\",\"Yoda\")')",
      "select()",
      "rpc()",
      "1234const { data, error } = await supabase  .from('characters')  .upsert({ id: 1, name: 'Han Solo' })  .select()",
      "1234const { data, error } = await supabase  .from('characters')  .upsert({ id: 1, name: 'Han Solo' })  .select()",
      "column",
      "1234const { data, error } = await supabase  .from('characters')  .select('id, name')  .order('id', { ascending: false })",
      "1234const { data, error } = await supabase  .from('characters')  .select('id, name')  .order('id', { ascending: false })",
      "count",
      "1234const { data, error } = await supabase  .from('characters')  .select('name')  .limit(1)",
      "1234const { data, error } = await supabase  .from('characters')  .select('name')  .limit(1)",
      "from",
      "to",
      "from",
      "to",
      "range(1, 3)",
      "1234const { data, error } = await supabase  .from('countries')  .select('name')  .range(0, 1)",
      "1234const { data, error } = await supabase  .from('countries')  .select('name')  .range(0, 1)",
      "123456const ac = new AbortController()ac.abort()const { data, error } = await supabase  .from('very_big_table')  .select()  .abortSignal(ac.signal)",
      "123456const ac = new AbortController()ac.abort()const { data, error } = await supabase  .from('very_big_table')  .select()  .abortSignal(ac.signal)",
      "data",
      "12345const { data, error } = await supabase  .from('characters')  .select('name')  .limit(1)  .single()",
      "12345const { data, error } = await supabase  .from('characters')  .select('name')  .limit(1)  .single()",
      "data",
      "12345const { data, error } = await supabase  .from('characters')  .select()  .eq('name', 'Katniss')  .maybeSingle()",
      "12345const { data, error } = await supabase  .from('characters')  .select()  .eq('name', 'Katniss')  .maybeSingle()",
      "data",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .csv()",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .csv()",
      "data",
      "1234const { data } = await supabase  .from('countries')  .select()  .returns<Array<MyType>>()",
      "1234const { data } = await supabase  .from('countries')  .select()  .returns<Array<MyType>>()",
      "data",
      "1234const { data } = await supabase  .from('countries')  .select()  .overrideTypes<Array<MyType>, { merge: false }>()",
      "1234const { data } = await supabase  .from('countries')  .select()  .overrideTypes<Array<MyType>, { merge: false }>()",
      "data",
      "EXPLAIN",
      "explain()",
      "rpc()",
      "pre-request",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .explain()",
      "1234const { data, error } = await supabase  .from('characters')  .select()  .explain()",
      "supabase.auth",
      "persistSession",
      "persistSession",
      "persistSession",
      "persistSession",
      "123import { createClient } from '@supabase/supabase-js'const supabase = createClient(supabase_url, anon_key)",
      "123import { createClient } from '@supabase/supabase-js'const supabase = createClient(supabase_url, anon_key)",
      "user",
      "session",
      "user",
      "session",
      "SITE_URL",
      "SITE_URL",
      "User already registered",
      "getUser()",
      "1234const { data, error } = await supabase.auth.signUp({  email: 'example@email.com',  password: 'example-password',})",
      "1234const { data, error } = await supabase.auth.signUp({  email: 'example@email.com',  password: 'example-password',})",
      "async",
      "await",
      "async",
      "await",
      "async",
      "123456supabase.auth.onAuthStateChange((event, session) => {  setTimeout(async () => {    // await on other Supabase function here    // this runs right after the callback has finished  }, 0)})",
      "123456supabase.auth.onAuthStateChange((event, session) => {  setTimeout(async () => {    // await on other Supabase function here    // this runs right after the callback has finished  }, 0)})",
      "INITIAL_SESSION",
      "SIGNED_IN",
      "SIGNED_OUT",
      "supabase.auth.signOut()",
      "TOKEN_REFRESHED",
      "supabase.auth.getSession()",
      "USER_UPDATED",
      "supabase.auth.updateUser()",
      "PASSWORD_RECOVERY",
      "SIGNED_IN",
      "1234567891011121314151617181920const { data } = supabase.auth.onAuthStateChange((event, session) => {  console.log(event, session)  if (event === 'INITIAL_SESSION') {    // handle initial session  } else if (event === 'SIGNED_IN') {    // handle sign in event  } else if (event === 'SIGNED_OUT') {    // handle sign out event  } else if (event === 'PASSWORD_RECOVERY') {    // handle password recovery event  } else if (event === 'TOKEN_REFRESHED') {    // handle token refreshed event  } else if (event === 'USER_UPDATED') {    // handle user updated event  }})// call unsubscribe to remove the callbackdata.subscription.unsubscribe()",
      "1234567891011121314151617181920const { data } = supabase.auth.onAuthStateChange((event, session) => {  console.log(event, session)  if (event === 'INITIAL_SESSION') {    // handle initial session  } else if (event === 'SIGNED_IN') {    // handle sign in event  } else if (event === 'SIGNED_OUT') {    // handle sign out event  } else if (event === 'PASSWORD_RECOVERY') {    // handle password recovery event  } else if (event === 'TOKEN_REFRESHED') {    // handle token refreshed event  } else if (event === 'USER_UPDATED') {    // handle user updated event  }})// call unsubscribe to remove the callbackdata.subscription.unsubscribe()",
      "options",
      "12345const { data, error } = await supabase.auth.signInAnonymously({  options: {    captchaToken  }});",
      "12345const { data, error } = await supabase.auth.signInAnonymously({  options: {    captchaToken  }});",
      "1234const { data, error } = await supabase.auth.signInWithPassword({  email: 'example@email.com',  password: 'example-password',})",
      "1234const { data, error } = await supabase.auth.signInWithPassword({  email: 'example@email.com',  password: 'example-password',})",
      "1234const { data, error } = await supabase.auth.signInWithIdToken({  provider: 'google',  token: 'your-id-token'})",
      "1234const { data, error } = await supabase.auth.signInWithIdToken({  provider: 'google',  token: 'your-id-token'})",
      "signInWithOtp()",
      "shouldCreateUser",
      "SignInWithPasswordlessCredentials.options",
      "false",
      "SITE_URL",
      "{{ .Token }}",
      "{{ .ConfirmationURL }}",
      "123456const { data, error } = await supabase.auth.signInWithOtp({  email: 'example@email.com',  options: {    emailRedirectTo: 'https://example.com/welcome'  }})",
      "123456const { data, error } = await supabase.auth.signInWithOtp({  email: 'example@email.com',  options: {    emailRedirectTo: 'https://example.com/welcome'  }})",
      "123const { data, error } = await supabase.auth.signInWithOAuth({  provider: 'github'})",
      "123const { data, error } = await supabase.auth.signInWithOAuth({  provider: 'github'})",
      "domain",
      "providerId",
      "1234567891011// You can extract the user's email domain and use it to trigger the  // authentication flow with the correct identity provider.  const { data, error } = await supabase.auth.signInWithSSO({    domain: 'company.com'  })  if (data?.url) {    // redirect the user to the identity provider's authentication flow    window.location.href = data.url  }",
      "1234567891011// You can extract the user's email domain and use it to trigger the  // authentication flow with the correct identity provider.  const { data, error } = await supabase.auth.signInWithSSO({    domain: 'company.com'  })  if (data?.url) {    // redirect the user to the identity provider's authentication flow    window.location.href = data.url  }",
      "/.well-known/jwks.json",
      "1const { data, error } = await supabase.auth.getClaims()",
      "1const { data, error } = await supabase.auth.getClaims()",
      "signOut()",
      "\"SIGNED_OUT\"",
      "signOut()",
      "signOut()",
      "1const { error } = await supabase.auth.signOut()",
      "1const { error } = await supabase.auth.signOut()",
      "resetPasswordForEmail()",
      "updateUser()",
      "PASSWORD_RECOVERY",
      "onAuthStateChange()",
      "redirectTo",
      "updateUser()",
      "123const { data, error } = await supabase.auth.updateUser({  password: new_password})",
      "123const { data, error } = await supabase.auth.updateUser({  password: new_password})",
      "123const { data, error } = await supabase.auth.resetPasswordForEmail(email, {  redirectTo: 'https://example.com/update-password',})",
      "123const { data, error } = await supabase.auth.resetPasswordForEmail(email, {  redirectTo: 'https://example.com/update-password',})",
      "verifyOtp",
      "sms",
      "phone_change",
      "signup",
      "magiclink",
      "email",
      "recovery",
      "invite",
      "email_change",
      "verifyOtp",
      "TokenHash",
      "1const { data, error } = await supabase.auth.verifyOtp({ email, token, type: 'email'})",
      "1const { data, error } = await supabase.auth.verifyOtp({ email, token, type: 'email'})",
      "getUser",
      "1const { data, error } = await supabase.auth.getSession()",
      "1const { data, error } = await supabase.auth.getSession()",
      "12const { data, error } = await supabase.auth.refreshSession()const { session, user } = data",
      "12const { data, error } = await supabase.auth.refreshSession()const { session, user } = data",
      "getSession().session.user",
      "getSession",
      "1const { data: { user } } = await supabase.auth.getUser()",
      "1const { data: { user } } = await supabase.auth.getUser()",
      "updateUser()",
      "123const { data, error } = await supabase.auth.updateUser({  email: 'new@email.com'})",
      "123const { data, error } = await supabase.auth.updateUser({  email: 'new@email.com'})",
      "getUserIdentities()",
      "1const { data, error } = await supabase.auth.getUserIdentities()",
      "1const { data, error } = await supabase.auth.getUserIdentities()",
      "linkIdentity()",
      "linkIdentity()",
      "linkIdentity",
      "123const { data, error } = await supabase.auth.linkIdentity({  provider: 'github'})",
      "123const { data, error } = await supabase.auth.linkIdentity({  provider: 'github'})",
      "unlinkIdentity()",
      "12345678910// retrieve all identites linked to a userconst identities = await supabase.auth.getUserIdentities()// find the google identityconst googleIdentity = identities.find(  identity => identity.provider === 'google')// unlink the google identityconst { error } = await supabase.auth.unlinkIdentity(googleIdentity)",
      "12345678910// retrieve all identites linked to a userconst identities = await supabase.auth.getUserIdentities()// find the google identityconst googleIdentity = identities.find(  identity => identity.provider === 'google')// unlink the google identityconst { error } = await supabase.auth.unlinkIdentity(googleIdentity)",
      "updateUser()",
      "nonce",
      "updateUser()",
      "1const { error } = await supabase.auth.reauthenticate()",
      "1const { error } = await supabase.auth.reauthenticate()",
      "signInWithOtp()",
      "resetPasswordForEmail()",
      "signInWithOtp()",
      "emailRedirectTo",
      "1234567const { error } = await supabase.auth.resend({  type: 'signup',  email: 'email@example.com',  options: {    emailRedirectTo: 'https://example.com/welcome'  }})",
      "1234567const { error } = await supabase.auth.resend({  type: 'signup',  email: 'email@example.com',  options: {    emailRedirectTo: 'https://example.com/welcome'  }})",
      "access_token",
      "refresh_token",
      "SIGNED_IN",
      "1234const { data, error } = await supabase.auth.setSession({    access_token,    refresh_token  })",
      "1234const { data, error } = await supabase.auth.setSession({    access_token,    refresh_token  })",
      "flowType",
      "pkce",
      "1supabase.auth.exchangeCodeForSession('34e770dd-9ff9-416c-87fa-43b31d7ef225')",
      "1supabase.auth.exchangeCodeForSession('34e770dd-9ff9-416c-87fa-43b31d7ef225')",
      "supabase.auth.stopAutoRefresh()",
      "12345678910import { AppState } from 'react-native'// make sure you register this only once!AppState.addEventListener('change', (state) => {  if (state === 'active') {    supabase.auth.startAutoRefresh()  } else {    supabase.auth.stopAutoRefresh()  }})",
      "12345678910import { AppState } from 'react-native'// make sure you register this only once!AppState.addEventListener('change', (state) => {  if (state === 'active') {    supabase.auth.startAutoRefresh()  } else {    supabase.auth.stopAutoRefresh()  }})",
      "12345678910import { AppState } from 'react-native'// make sure you register this only once!AppState.addEventListener('change', (state) => {  if (state === 'active') {    supabase.auth.startAutoRefresh()  } else {    supabase.auth.stopAutoRefresh()  }})",
      "12345678910import { AppState } from 'react-native'// make sure you register this only once!AppState.addEventListener('change', (state) => {  if (state === 'active') {    supabase.auth.startAutoRefresh()  } else {    supabase.auth.stopAutoRefresh()  }})",
      "supabase.auth.mfa",
      "unverified",
      "totp",
      "phone",
      "factorType",
      "id",
      "mfa.challenge()",
      "mfa.verify()",
      "mfa.challengeAndVerify()",
      "totp",
      "1<Image src={data.totp.qr_code} alt={data.totp.uri} layout=\"fill\"></Image>",
      "1<Image src={data.totp.qr_code} alt={data.totp.uri} layout=\"fill\"></Image>",
      "challenge",
      "verify",
      "12345678910const { data, error } = await supabase.auth.mfa.enroll({  factorType: 'totp',  friendlyName: 'your_friendly_name'})// Use the id to create a challenge.// The challenge can be verified by entering the code generated from the authenticator app.// The code will be generated upon scanning the qr_code or entering the secret into the authenticator app.const { id, type, totp: { qr_code, secret, uri }, friendly_name } = dataconst challenge = await supabase.auth.mfa.challenge({ factorId: id });",
      "12345678910const { data, error } = await supabase.auth.mfa.enroll({  factorType: 'totp',  friendlyName: 'your_friendly_name'})// Use the id to create a challenge.// The challenge can be verified by entering the code generated from the authenticator app.// The code will be generated upon scanning the qr_code or entering the secret into the authenticator app.const { id, type, totp: { qr_code, secret, uri }, friendly_name } = dataconst challenge = await supabase.auth.mfa.challenge({ factorId: id });",
      "mfa.verify()",
      "sms",
      "123const { data, error } = await supabase.auth.mfa.challenge({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225'})",
      "123const { data, error } = await supabase.auth.mfa.challenge({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225'})",
      "12345const { data, error } = await supabase.auth.mfa.verify({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  challengeId: '4034ae6f-a8ce-4fb5-8ee5-69a5863a7c15',  code: '123456'})",
      "12345const { data, error } = await supabase.auth.mfa.verify({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  challengeId: '4034ae6f-a8ce-4fb5-8ee5-69a5863a7c15',  code: '123456'})",
      "challengeAndVerify()",
      "mfa.challenge()",
      "mfa.verify()",
      "1234const { data, error } = await supabase.auth.mfa.challengeAndVerify({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  code: '123456'})",
      "1234const { data, error } = await supabase.auth.mfa.challengeAndVerify({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  code: '123456'})",
      "aal2",
      "verified",
      "123const { data, error } = await supabase.auth.mfa.unenroll({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',})",
      "123const { data, error } = await supabase.auth.mfa.unenroll({  factorId: '34e770dd-9ff9-416c-87fa-43b31d7ef225',})",
      "aal1",
      "aal2",
      "nextLevel",
      "aal2",
      "aal1",
      "12const { data, error } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()const { currentLevel, nextLevel, currentAuthenticationMethods } = data",
      "12const { data, error } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()const { currentLevel, nextLevel, currentAuthenticationMethods } = data",
      "supabase.auth.admin",
      "service_role",
      "service_role",
      "1234567891011import { createClient } from '@supabase/supabase-js'const supabase = createClient(supabase_url, service_role_key, {  auth: {    autoRefreshToken: false,    persistSession: false  }})// Access auth admin apiconst adminAuthClient = supabase.auth.admin",
      "1234567891011import { createClient } from '@supabase/supabase-js'const supabase = createClient(supabase_url, service_role_key, {  auth: {    autoRefreshToken: false,    persistSession: false  }})// Access auth admin apiconst adminAuthClient = supabase.auth.admin",
      "getUserById()",
      "auth.users.id",
      "service_role",
      "1const { data, error } = await supabase.auth.admin.getUserById(1)",
      "1const { data, error } = await supabase.auth.admin.getUserById(1)",
      "page",
      "perPage",
      "1const { data: { users }, error } = await supabase.auth.admin.listUsers()",
      "1const { data: { users }, error } = await supabase.auth.admin.listUsers()",
      "service_role",
      "email_confirm",
      "phone_confirm",
      "createUser()",
      "inviteUserByEmail()",
      "email_confirm",
      "phone_confirm",
      "true",
      "12345const { data, error } = await supabase.auth.admin.createUser({  email: 'user@email.com',  password: 'password',  user_metadata: { name: 'Yoda' }})",
      "12345const { data, error } = await supabase.auth.admin.createUser({  email: 'user@email.com',  password: 'password',  user_metadata: { name: 'Yoda' }})",
      "service_role",
      "deleteUser()",
      "auth.users.id",
      "service_role",
      "123const { data, error } = await supabase.auth.admin.deleteUser(  '715ed5db-f090-4b8c-a067-640ecee36aa0')",
      "123const { data, error } = await supabase.auth.admin.deleteUser(  '715ed5db-f090-4b8c-a067-640ecee36aa0')",
      "inviteUserByEmail()",
      "inviteUserByEmail",
      "1const { data, error } = await supabase.auth.admin.inviteUserByEmail('email@example.com')",
      "1const { data, error } = await supabase.auth.admin.inviteUserByEmail('email@example.com')",
      "generateLink()",
      "signup",
      "magiclink",
      "invite",
      "recovery",
      "email_change_current",
      "email_change_new",
      "phone_change",
      "generateLink()",
      "email_change_email",
      "generateLink()",
      "signup",
      "invite",
      "magiclink",
      "12345const { data, error } = await supabase.auth.admin.generateLink({  type: 'signup',  email: 'email@example.com',  password: 'secret'})",
      "12345const { data, error } = await supabase.auth.admin.generateLink({  type: 'signup',  email: 'email@example.com',  password: 'secret'})",
      "service_role",
      "1234const { data: user, error } = await supabase.auth.admin.updateUserById(  '11111111-1111-1111-1111-111111111111',  { email: 'new@email.com' })",
      "1234const { data: user, error } = await supabase.auth.admin.updateUserById(  '11111111-1111-1111-1111-111111111111',  { email: 'new@email.com' })",
      "1234const { data, error } = await supabase.auth.admin.mfa.deleteFactor({  id: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  userId: 'a89baba7-b1b7-440f-b4bb-91026967f66b',})",
      "1234const { data, error } = await supabase.auth.admin.mfa.deleteFactor({  id: '34e770dd-9ff9-416c-87fa-43b31d7ef225',  userId: 'a89baba7-b1b7-440f-b4bb-91026967f66b',})",
      "Blob",
      "ArrayBuffer",
      "File",
      "FormData",
      "String",
      "json",
      "Content-Type",
      "application/json",
      "Content-Type",
      "json",
      "blob",
      "form-data",
      "Content-Type",
      "text",
      "123const { data, error } = await supabase.functions.invoke('hello', {  body: { foo: 'bar' }})",
      "123const { data, error } = await supabase.functions.invoke('hello', {  body: { foo: 'bar' }})",
      "REPLICA IDENTITY",
      "FULL",
      "ALTER TABLE your_table REPLICA IDENTITY FULL;",
      "12345678910111213const channel = supabase.channel(\"room1\")channel.on(\"broadcast\", { event: \"cursor-pos\" }, (payload) => {  console.log(\"Cursor position received!\", payload);}).subscribe((status) => {  if (status === \"SUBSCRIBED\") {    channel.send({      type: \"broadcast\",      event: \"cursor-pos\",      payload: { x: Math.random(), y: Math.random() },    });  }});",
      "12345678910111213const channel = supabase.channel(\"room1\")channel.on(\"broadcast\", { event: \"cursor-pos\" }, (payload) => {  console.log(\"Cursor position received!\", payload);}).subscribe((status) => {  if (status === \"SUBSCRIBED\") {    channel.send({      type: \"broadcast\",      event: \"cursor-pos\",      payload: { x: Math.random(), y: Math.random() },    });  }});",
      "1supabase.removeChannel(myChannel)",
      "1supabase.removeChannel(myChannel)",
      "1supabase.removeAllChannels()",
      "1supabase.removeAllChannels()",
      "1const channels = supabase.getChannels()",
      "1const channels = supabase.getChannels()",
      "1234567891011supabase  .channel('room1')  .subscribe((status) => {    if (status === 'SUBSCRIBED') {      channel.send({        type: 'broadcast',        event: 'cursor-pos',        payload: { x: Math.random(), y: Math.random() },      })    }  })",
      "1234567891011supabase  .channel('room1')  .subscribe((status) => {    if (status === 'SUBSCRIBED') {      channel.send({        type: 'broadcast',        event: 'cursor-pos',        payload: { x: Math.random(), y: Math.random() },      })    }  })",
      "buckets",
      "insert",
      "objects",
      "1234567const { data, error } = await supabase  .storage  .createBucket('avatars', {    public: false,    allowedMimeTypes: ['image/png'],    fileSizeLimit: 1024  })",
      "1234567const { data, error } = await supabase  .storage  .createBucket('avatars', {    public: false,    allowedMimeTypes: ['image/png'],    fileSizeLimit: 1024  })",
      "buckets",
      "select",
      "objects",
      "123const { data, error } = await supabase  .storage  .getBucket('avatars')",
      "123const { data, error } = await supabase  .storage  .getBucket('avatars')",
      "buckets",
      "select",
      "objects",
      "123const { data, error } = await supabase  .storage  .listBuckets()",
      "123const { data, error } = await supabase  .storage  .listBuckets()",
      "buckets",
      "select",
      "update",
      "objects",
      "1234567const { data, error } = await supabase  .storage  .updateBucket('avatars', {    public: false,    allowedMimeTypes: ['image/png'],    fileSizeLimit: 1024  })",
      "1234567const { data, error } = await supabase  .storage  .updateBucket('avatars', {    public: false,    allowedMimeTypes: ['image/png'],    fileSizeLimit: 1024  })",
      "empty()",
      "buckets",
      "select",
      "delete",
      "objects",
      "123const { data, error } = await supabase  .storage  .deleteBucket('avatars')",
      "123const { data, error } = await supabase  .storage  .deleteBucket('avatars')",
      "buckets",
      "select",
      "objects",
      "select",
      "delete",
      "123const { data, error } = await supabase  .storage  .emptyBucket('avatars')",
      "123const { data, error } = await supabase  .storage  .emptyBucket('avatars')",
      "buckets",
      "objects",
      "insert",
      "select",
      "insert",
      "update",
      "Blob",
      "File",
      "FormData",
      "ArrayBuffer",
      "folder/subfolder/filename.png",
      "12345678const avatarFile = event.target.files[0]const { data, error } = await supabase  .storage  .from('avatars')  .upload('public/avatar1.png', avatarFile, {    cacheControl: '3600',    upsert: false  })",
      "12345678const avatarFile = event.target.files[0]const { data, error } = await supabase  .storage  .from('avatars')  .upload('public/avatar1.png', avatarFile, {    cacheControl: '3600',    upsert: false  })",
      "getPublicUrl",
      "buckets",
      "objects",
      "select",
      "folder/image.png",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .download('folder/avatar1.png')",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .download('folder/avatar1.png')",
      "buckets",
      "objects",
      "select",
      "12345678const { data, error } = await supabase  .storage  .from('avatars')  .list('folder', {    limit: 100,    offset: 0,    sortBy: { column: 'name', order: 'asc' },  })",
      "12345678const { data, error } = await supabase  .storage  .from('avatars')  .list('folder', {    limit: 100,    offset: 0,    sortBy: { column: 'name', order: 'asc' },  })",
      "buckets",
      "objects",
      "update",
      "select",
      "Blob",
      "File",
      "FormData",
      "ArrayBuffer",
      "folder/subfolder/filename.png",
      "12345678const avatarFile = event.target.files[0]const { data, error } = await supabase  .storage  .from('avatars')  .update('public/avatar1.png', avatarFile, {    cacheControl: '3600',    upsert: true  })",
      "12345678const avatarFile = event.target.files[0]const { data, error } = await supabase  .storage  .from('avatars')  .update('public/avatar1.png', avatarFile, {    cacheControl: '3600',    upsert: true  })",
      "buckets",
      "objects",
      "update",
      "select",
      "folder/image.png",
      "folder/image-new.png",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .move('public/avatar1.png', 'private/avatar2.png')",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .move('public/avatar1.png', 'private/avatar2.png')",
      "buckets",
      "objects",
      "insert",
      "select",
      "folder/image.png",
      "folder/image-copy.png",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .copy('public/avatar1.png', 'private/avatar2.png')",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .copy('public/avatar1.png', 'private/avatar2.png')",
      "buckets",
      "objects",
      "delete",
      "select",
      "'folder/image.png'",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .remove(['folder/avatar1.png'])",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .remove(['folder/avatar1.png'])",
      "buckets",
      "objects",
      "select",
      "folder/image.png",
      "60",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUrl('folder/avatar1.png', 60)",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUrl('folder/avatar1.png', 60)",
      "buckets",
      "objects",
      "select",
      "['folder/image.png', 'folder2/image2.png']",
      "60",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)",
      "buckets",
      "objects",
      "insert",
      "folder/image.png",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUploadUrl('folder/cat.jpg')",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .createSignedUploadUrl('folder/cat.jpg')",
      "createSignedUploadUrl",
      "buckets",
      "objects",
      "folder/subfolder/filename.png",
      "createSignedUploadUrl",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)",
      "1234const { data, error } = await supabase  .storage  .from('avatars')  .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)",
      "buckets",
      "objects",
      "folder/image.png",
      "1234const { data } = supabase  .storage  .from('public-bucket')  .getPublicUrl('folder/avatar1.png')",
      "1234const { data } = supabase  .storage  .from('public-bucket')  .getPublicUrl('folder/avatar1.png')"
    ],
    "headings": [
      "JavaScript Client Library",
      "Installing",
      "Install as package#",
      "Install via CDN#",
      "Use at runtime in Deno#",
      "Initializing",
      "Parameters",
      "TypeScript support",
      "Generating TypeScript Types#",
      "Using TypeScript type definitions#",
      "Helper types for Tables and Joins#",
      "Response types for complex queries#",
      "Fetch data",
      "Parameters",
      "Insert data",
      "Parameters",
      "Update data",
      "Parameters",
      "Upsert data",
      "Parameters",
      "Delete data",
      "Parameters",
      "Call a Postgres function",
      "Parameters",
      "Using filters",
      "Column is equal to a value",
      "Parameters",
      "Column is not equal to a value",
      "Parameters",
      "Column is greater than a value",
      "Parameters",
      "Column is greater than or equal to a value",
      "Parameters",
      "Column is less than a value",
      "Parameters",
      "Column is less than or equal to a value",
      "Parameters",
      "Column matches a pattern",
      "Parameters",
      "Column matches a case-insensitive pattern",
      "Parameters",
      "Column is a value",
      "Parameters",
      "Column is in an array",
      "Parameters",
      "Column contains every element in a value",
      "Parameters",
      "Contained by value",
      "Parameters",
      "Greater than a range",
      "Parameters",
      "Greater than or equal to a range",
      "Parameters",
      "Less than a range",
      "Parameters",
      "Less than or equal to a range",
      "Parameters",
      "Mutually exclusive to a range",
      "Parameters",
      "With a common element",
      "Parameters",
      "Match a string",
      "Parameters",
      "Match an associated value",
      "Parameters",
      "Don't match the filter",
      "Parameters",
      "Match at least one filter",
      "Parameters",
      "Match the filter",
      "Parameters",
      "Using modifiers",
      "Return data after inserting",
      "Parameters",
      "Order the results",
      "Parameters",
      "Limit the number of rows returned",
      "Parameters",
      "Limit the query to a range",
      "Parameters",
      "Set an abort signal",
      "Parameters",
      "Retrieve one row of data",
      "Retrieve zero or one row of data",
      "Retrieve as a CSV",
      "Override type of successful response",
      "Partially override or replace type of successful response",
      "Using explain",
      "Parameters",
      "Return Type",
      "Overview",
      "Create a new user",
      "Parameters",
      "Return Type",
      "Listen to auth events",
      "Parameters",
      "Return Type",
      "Create an anonymous user",
      "Parameters",
      "Return Type",
      "Sign in a user",
      "Parameters",
      "Return Type",
      "Sign in with ID Token",
      "Parameters",
      "Return Type",
      "Sign in a user through OTP",
      "Parameters",
      "Return Type",
      "Sign in a user through OAuth",
      "Parameters",
      "Return Type",
      "Sign in a user through SSO",
      "Parameters",
      "Return Type",
      "Get user claims from verified JWT",
      "Parameters",
      "Return Type",
      "Sign out a user",
      "Parameters",
      "Return Type",
      "Send a password reset request",
      "Parameters",
      "Return Type",
      "Verify and log in through OTP",
      "Parameters",
      "Return Type",
      "Retrieve a session",
      "Return Type",
      "Retrieve a new session",
      "Parameters",
      "Return Type",
      "Retrieve a user",
      "Parameters",
      "Return Type",
      "Update a user",
      "Parameters",
      "Return Type",
      "Retrieve identities linked to a user",
      "Return Type",
      "Link an identity to a user",
      "Parameters",
      "Return Type",
      "Unlink an identity from a user",
      "Parameters",
      "Return Type",
      "Send a password reauthentication nonce",
      "Return Type",
      "Resend an OTP",
      "Parameters",
      "Return Type",
      "Set the session data",
      "Parameters",
      "Return Type",
      "Exchange an auth code for a session",
      "Parameters",
      "Return Type",
      "Start auto-refresh session (non-browser)",
      "Return Type",
      "Stop auto-refresh session (non-browser)",
      "Return Type",
      "Auth MFA",
      "Enroll a factor",
      "Parameters",
      "Return Type",
      "Create a challenge",
      "Parameters",
      "Return Type",
      "Verify a challenge",
      "Parameters",
      "Return Type",
      "Create and verify a challenge",
      "Parameters",
      "Return Type",
      "Unenroll a factor",
      "Parameters",
      "Return Type",
      "Get Authenticator Assurance Level",
      "Return Type",
      "Auth Admin",
      "Retrieve a user",
      "Parameters",
      "Return Type",
      "List all users",
      "Parameters",
      "Return Type",
      "Create a user",
      "Parameters",
      "Return Type",
      "Delete a user",
      "Parameters",
      "Return Type",
      "Send an email invite link",
      "Parameters",
      "Return Type",
      "Generate an email link",
      "Parameters",
      "Return Type",
      "Update a user",
      "Parameters",
      "Return Type",
      "Delete a factor for a user",
      "Parameters",
      "Return Type",
      "Invokes a Supabase Edge Function.",
      "Parameters",
      "Return Type",
      "Subscribe to channel",
      "Parameters",
      "Unsubscribe from a channel",
      "Parameters",
      "Return Type",
      "Unsubscribe from all channels",
      "Return Type",
      "Retrieve all channels",
      "Return Type",
      "Broadcast a message",
      "Parameters",
      "Return Type",
      "Create a bucket",
      "Parameters",
      "Return Type",
      "Retrieve a bucket",
      "Parameters",
      "Return Type",
      "List all buckets",
      "Return Type",
      "Update a bucket",
      "Parameters",
      "Return Type",
      "Delete a bucket",
      "Parameters",
      "Return Type",
      "Empty a bucket",
      "Parameters",
      "Return Type",
      "Upload a file",
      "Parameters",
      "Return Type",
      "Download a file",
      "Parameters",
      "Return Type",
      "List all files in a bucket",
      "Parameters",
      "Return Type",
      "Replace an existing file",
      "Parameters",
      "Return Type",
      "Move an existing file",
      "Parameters",
      "Return Type",
      "Copy an existing file",
      "Parameters",
      "Return Type",
      "Delete files in a bucket",
      "Parameters",
      "Return Type",
      "Create a signed URL",
      "Parameters",
      "Return Type",
      "Create signed URLs",
      "Parameters",
      "Return Type",
      "Create signed upload URL",
      "Parameters",
      "Return Type",
      "Upload to a signed URL",
      "Parameters",
      "Return Type",
      "Retrieve public URL",
      "Parameters",
      "Return Type"
    ],
    "token_count": 19291,
    "collected_at": "2025-09-03T01:38:53.744507",
    "priority": "high"
  },
  {
    "source_name": "supabase_test",
    "category": "backend_service",
    "url": "https://supabase.com/docs/guides/auth",
    "title": "Auth | Supabase Docs",
    "content": "AuthAuthUse Supabase to authenticate and authorize your users.Supabase Auth makes it easy to implement authentication and authorization in your app. We provide client SDKs and API endpoints to help you create and manage users.\nYour users can use many popular Auth methods, including password, magic link, one-time password (OTP), social login, and single sign-on (SSO).\nAbout authentication and authorization#\nAuthentication and authorization are the core responsibilities of any Auth system.\n\nAuthentication means checking that a user is who they say they are.\nAuthorization means checking what resources a user is allowed to access.\n\nSupabase Auth uses JSON Web Tokens (JWTs) for authentication. For a complete reference of all JWT fields, see the JWT Fields Reference. Auth integrates with Supabase's database features, making it easy to use Row Level Security (RLS) for authorization.\nThe Supabase ecosystem#\nYou can use Supabase Auth as a standalone product, but it's also built to integrate with the Supabase ecosystem.\nAuth uses your project's Postgres database under the hood, storing user data and other Auth information in a special schema. You can connect this data to your own tables using triggers and foreign key references.\nAuth also enables access control to your database's automatically generated REST API. When using Supabase SDKs, your data requests are automatically sent with the user's Auth Token. The Auth Token scopes database access on a row-by-row level when used along with RLS policies.\nProviders#\nSupabase Auth works with many popular Auth methods, including Social and Phone Auth using third-party providers. See the following sections for a list of supported third-party providers.\nSocial Auth#\nAppleAzure (Microsoft)BitbucketDiscordFacebookFigmaGitHubGitLabGoogleKakaoKeycloakLinkedInNotionSlackSpotifyTwitterTwitchWorkOSZoom\nPhone Auth#\nMessageBirdTwilioVonage\nPricing#\nCharges apply to Monthly Active Users (MAU), Monthly Active Third-Party Users (Third-Party MAU), and Monthly Active SSO Users (SSO MAU) and Advanced MFA Add-ons. For a detailed breakdown of how these charges are calculated, refer to the following pages:\n\nPricing MAU\nPricing Third-Party MAU\nPricing SSO MAU\nAdvanced MFA - Phone\nWatch video guideIs this helpful? No  Yes",
    "code_blocks": [],
    "headings": [
      "Auth",
      "Use Supabase to authenticate and authorize your users.",
      "About authentication and authorization#",
      "The Supabase ecosystem#",
      "Providers#",
      "Social Auth#",
      "Phone Auth#",
      "Pricing#",
      "Is this helpful?"
    ],
    "token_count": 484,
    "collected_at": "2025-09-03T01:38:55.129198",
    "priority": "high"
  }
]