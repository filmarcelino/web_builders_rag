[
  {
    "id": "0a8049d14505465aed3f835f56428980",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "建立銀行應用程式第三部分：獲取及使用數據的方法\n課前測驗\n課前測驗\n簡介\n每個網頁應用程式的核心都是數據。數據可以有多種形式，但其主要目的是向用戶展示信息。隨著網頁應用程式越來越互動化和複雜，用戶如何訪問和操作信息已成為網頁開發的重要部分。\n在本課中，我們將學習如何從伺服器異步獲取數據，並使用這些數據在不重新加載 HTML 的情況下在網頁上顯示信息。\n先決條件\n您需要完成本課程的登錄和註冊表單部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便獲取帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAX 和數據獲取\n傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。\n隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。\n在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。\n雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。\n任務\n在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數：\njs\nasync function login() {\nconst loginForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1060,
    "chunk_index": 3,
    "total_chunks": 83
  },
  {
    "id": "c2de86f2e06e1869c8121ae3ff1c46c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "js 並在本地運行伺服器 API，以便獲取帳戶數據。 您可以通過在終端執行以下命令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAX 和數據獲取 傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。 隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm')\nconst user = loginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 785,
    "chunk_index": 4,
    "total_chunks": 83
  },
  {
    "id": "356dca487259f37647897e763036bfd2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAX 和數據獲取 傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。 隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 719,
    "chunk_index": 5,
    "total_chunks": 83
  },
  {
    "id": "c943b00fbd8a1d2657c812b9dc99d560",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAX 和數據獲取 傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。 隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue;\n}\n首先，我們使用 getElementById() 獲取表單元素，然後使用 loginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 6,
    "total_chunks": 83
  },
  {
    "id": "c0dfa31c32dcddd3b62e043cdbb8be8e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "return \"Bank API v1 00\" as a result ``` AJAX 和數據獲取 傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。 隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 首先，我們使用 getElementById() 獲取表單元素，然後使用 loginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 7,
    "total_chunks": 83
  },
  {
    "id": "387b31c5bd7afa705744e7c92d0fdd63",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "return \"Bank API v1 00\" as a result ``` AJAX 和數據獲取 傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。 隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 首先，我們使用 getElementById() 獲取表單元素，然後使用 loginFormuservalue 從輸入中獲取用戶名。每個表單控件都可以通過其名稱（在 HTML 中使用 name 屬性設置）作為表單的屬性來訪問。\n與我們在註冊中所做的類似，我們將創建另一個函數來執行伺服器請求，但這次是用於獲取帳戶數據：\njs\nasync function getAccount(user) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 909,
    "chunk_index": 8,
    "total_chunks": 83
  },
  {
    "id": "bf259b0982755474131558a341ffe65c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 首先，我們使用 getElementById() 獲取表單元素，然後使用 loginFormuservalue 從輸入中獲取用戶名。每個表單控件都可以通過其名稱（在 HTML 中使用 name 屬性設置）作為表單的屬性來訪問。 與我們在註冊中所做的類似，我們將創建另一個函數來執行伺服器請求，但這次是用於獲取帳戶數據： js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson();\n} catch (error) {\nreturn { error: error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 641,
    "chunk_index": 9,
    "total_chunks": 83
  },
  {
    "id": "123d61571ac760dc37716c8f2078b6dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。 在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。 雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。 任務 在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 appjs 文件並添加一個新的 login 函數： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 首先，我們使用 getElementById() 獲取表單元素，然後使用 loginFormuservalue 從輸入中獲取用戶名。每個表單控件都可以通過其名稱（在 HTML 中使用 name 屬性設置）作為表單的屬性來訪問。 與我們在註冊中所做的類似，我們將創建另一個函數來執行伺服器請求，但這次是用於獲取帳戶數據： js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' };\n}\n}\n我們使用 fetch API 從伺服器異步請求數據，但這次除了要調用的 URL 外，我們不需要任何額外的參數，因為我們只是查詢數據。默認情況下，fetch 創建一個 GET HTTP 請求，這正是我們需要的。\n✅ encodeURIComponent() 是一個用於對 URL 中的特殊字符進行編碼的函數。如果我們不調用此函數而直接在 URL 中使用 user 值，可能會出現什麼問題？\n現在讓我們更新 login 函數以使用 getAccount：\n```js\nasync function login() {\nconst loginForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 774,
    "chunk_index": 10,
    "total_chunks": 83
  },
  {
    "id": "133f4e026e5e738ce1fc1364e452367e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "= loginFormuservalue; } 首先，我們使用 getElementById() 獲取表單元素，然後使用 loginFormuservalue 從輸入中獲取用戶名。每個表單控件都可以通過其名稱（在 HTML 中使用 name 屬性設置）作為表單的屬性來訪問。 與我們在註冊中所做的類似，我們將創建另一個函數來執行伺服器請求，但這次是用於獲取帳戶數據： js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } 我們使用 fetch API 從伺服器異步請求數據，但這次除了要調用的 URL 外，我們不需要任何額外的參數，因為我們只是查詢數據。默認情況下，fetch 創建一個 GET HTTP 請求，這正是我們需要的。 ✅ encodeURIComponent() 是一個用於對 URL 中的特殊字符進行編碼的函數。如果我們不調用此函數而直接在 URL 中使用 user 值，可能會出現什麼問題？ 現在讓我們更新 login 函數以使用 getAccount： ```js async function login() { const loginForm = documentgetElementById('loginForm')\nconst user = loginForm user value;\nconst data = await getAccount(user);\nif (data error) {\nreturn console log('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 11,
    "total_chunks": 83
  },
  {
    "id": "12d5f05a02dc55d08e42eca7593ae30c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "{ const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } 我們使用 fetch API 從伺服器異步請求數據，但這次除了要調用的 URL 外，我們不需要任何額外的參數，因為我們只是查詢數據。默認情況下，fetch 創建一個 GET HTTP 請求，這正是我們需要的。 ✅ encodeURIComponent() 是一個用於對 URL 中的特殊字符進行編碼的函數。如果我們不調用此函數而直接在 URL 中使用 user 值，可能會出現什麼問題？ 現在讓我們更新 login 函數以使用 getAccount： ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror);\n}\naccount = data;\nnavigate('/dashboard');\n}\n```\n首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。\n然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數：\njs\nlet account = null;\n在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。\n最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML：\n```html\n```\n通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。\n在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數：\n```js\naccount = result;\nnavigate('/dashboard');\n```\n✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 874,
    "chunk_index": 12,
    "total_chunks": 83
  },
  {
    "id": "c46c77bd14db267a041ad5a43ad1c29a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "函數以使用 getAccount： ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 638,
    "chunk_index": 13,
    "total_chunks": 83
  },
  {
    "id": "ee146d0ac39f635b8b7ea6d0c5767477",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "函數以使用 getAccount： ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。\n> 了解更多有關 API 的知識，請參加這個[課程](https://docs",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 14,
    "total_chunks": 83
  },
  {
    "id": "21567dcd8e2865b9c0de6aced2859e64",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 726,
    "chunk_index": 15,
    "total_chunks": 83
  },
  {
    "id": "d924965973d60836c52dfccc2ec3bde5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 16,
    "total_chunks": 83
  },
  {
    "id": "f653cbfec90f176466f43c88429ddbe3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WT",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 740,
    "chunk_index": 17,
    "total_chunks": 83
  },
  {
    "id": "2507a74b135874e6d1bf03805af2ed5d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。\n## 更新 HTML 以顯示數據\n現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 816,
    "chunk_index": 18,
    "total_chunks": 83
  },
  {
    "id": "8cd86f5a724b84fa49154080d8363216",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API：\n- 使用 [`textContent`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 852,
    "chunk_index": 19,
    "total_chunks": 83
  },
  {
    "id": "13946e1376445f6b9c01d1b34f3a8ce3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 845,
    "chunk_index": 20,
    "total_chunks": 83
  },
  {
    "id": "2d727aa907cc470dc2d433f347a0d81e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。\n- 使用 [`document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 946,
    "chunk_index": 21,
    "total_chunks": 83
  },
  {
    "id": "faa43d3ff971f648124ab3f0de425977",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 942,
    "chunk_index": 22,
    "total_chunks": 83
  },
  {
    "id": "b904b0279724b2c5555952586e3a06e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 944,
    "chunk_index": 23,
    "total_chunks": 83
  },
  {
    "id": "f81069f59041e0eaeb768c5c6e366dc9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 961,
    "chunk_index": 24,
    "total_chunks": 83
  },
  {
    "id": "d3eac544d0b48b90172ada233caa1359",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 961,
    "chunk_index": 25,
    "total_chunks": 83
  },
  {
    "id": "76bc50968594af3aad7abf97dcb31568",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。\n✅ 使用元素的 [`innerHTML`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1008,
    "chunk_index": 26,
    "total_chunks": 83
  },
  {
    "id": "4a82c173dcc558001f1b6a7918f7bf52",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "= data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1000,
    "chunk_index": 27,
    "total_chunks": 83
  },
  {
    "id": "976eba0adcd15aed738c6ae8a2cf9730",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "= data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1061,
    "chunk_index": 28,
    "total_chunks": 83
  },
  {
    "id": "8b5a30468996bdd3075309b2c38743ff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "} ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1056,
    "chunk_index": 29,
    "total_chunks": 83
  },
  {
    "id": "4abaa22c222efe216144aa81eea1471c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "} ``` 首先，由於 getAccount 是一個異步函數，我們需要使用 await 關鍵字來等待伺服器結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前，我們只添加了一條日誌消息來顯示錯誤，稍後再回來處理。 然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。\n### 任務\n在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。\n讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面：\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1243,
    "chunk_index": 30,
    "total_chunks": 83
  },
  {
    "id": "abf2d6ad96ac02fb00c292e8d85095a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1121,
    "chunk_index": 31,
    "total_chunks": 83
  },
  {
    "id": "d460ba61572a5722dc224d23d2e25e88",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "然後，我們需要將數據存儲在某個地方，以便稍後用於顯示儀表板信息。由於 account 變數尚不存在，我們將在文件的頂部創建一個全局變數： js let account = null; 在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin```\n這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。\n回到 `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1215,
    "chunk_index": 32,
    "total_chunks": 83
  },
  {
    "id": "ed965ceddf0deccba63306bb89965abf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "在用戶數據保存到變數後，我們可以使用已經存在的 navigate() 函數從登錄頁面導航到儀表板。 最後，我們需要在提交登錄表單時調用 login 函數，通過修改 HTML： ```html ``` 通過註冊新帳戶並嘗試使用相同帳戶登錄，測試一切是否正常運行。 在進入下一部分之前，我們還可以通過在函數底部添加以下內容來完成 `register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`：\n```js\nfunction updateElement(id, text) {\nconst element = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1172,
    "chunk_index": 33,
    "total_chunks": 83
  },
  {
    "id": "870dd3c643365e61730ac83062e0d15b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "`register` 函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id);\nelement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1008,
    "chunk_index": 34,
    "total_chunks": 83
  },
  {
    "id": "159750bf3aa5a5455a8d0e8b368e8e1c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "函數： ```js account = result; navigate('/dashboard'); ``` ✅ 您知道嗎？默認情況下，您只能從與您正在查看的網頁相同的*域名和端口*調用伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常工作？通過使用一種名為[跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)的技術，如果伺服器在響應中添加特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text;\n}\n```\n這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息：\n```js\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1107,
    "chunk_index": 35,
    "total_chunks": 83
  },
  {
    "id": "3f3c1ac72f67addc4022903b2fa499d9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "了解更多有關 API 的知識，請參加這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)。 ## 更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) {\nreturn updateElement('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 856,
    "chunk_index": 36,
    "total_chunks": 83
  },
  {
    "id": "d39e7987566d44bb46bf8df7d6a7c50f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "更新 HTML 以顯示數據 現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror);\n}\n```\n現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 37,
    "total_chunks": 83
  },
  {
    "id": "8262a2b7801ee92e0f27e7f616d1192c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 848,
    "chunk_index": 38,
    "total_chunks": 83
  },
  {
    "id": "49ffe10bbc95af70d52089c6263d39e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 849,
    "chunk_index": 39,
    "total_chunks": 83
  },
  {
    "id": "1c4dc23fbd28c5bd61544414544e5d4e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 849,
    "chunk_index": 40,
    "total_chunks": 83
  },
  {
    "id": "ceb568270e29fe5b402bc1a8b49663b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 849,
    "chunk_index": 41,
    "total_chunks": 83
  },
  {
    "id": "1b9a442df81c3a11880cd056e02543d0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](////7-bank-project/3-data/images/login-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 859,
    "chunk_index": 42,
    "total_chunks": 83
  },
  {
    "id": "50e1235e1bf15313e320204447dc02a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "現在我們有了用戶數據，我們需要更新現有的 HTML 以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](////7-bank-project/3-data/images/login-errorpng)\n現在我們有了視覺上顯示的錯誤文本，但如果您使用屏幕閱讀器嘗試，您會注意到什麼都沒有被宣告。為了讓動態添加到頁面的文本被屏幕閱讀器宣告，我們需要使用一種名為[Live Region](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 976,
    "chunk_index": 43,
    "total_chunks": 83
  },
  {
    "id": "bb7602a99c469bc9cdbfc73d7fe75ec5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](////7-bank-project/3-data/images/login-errorpng) 現在我們有了視覺上顯示的錯誤文本，但如果您使用屏幕閱讀器嘗試，您會注意到什麼都沒有被宣告。為了讓動態添加到頁面的文本被屏幕閱讀器宣告，我們需要使用一種名為[Live Region](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 951,
    "chunk_index": 44,
    "total_chunks": 83
  },
  {
    "id": "ac1699b1f3fd32439b5d24b6e6a700c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "以顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或添加子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文本。請注意，更改此值會移除元素的所有子元素（如果有的話），並用提供的文本替換。因此，通過分配空字符串 `''`，它也是移除給定元素所有子元素的一種高效方法。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 和 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法，您可以創建並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到[跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻擊。 ### 任務 在進入*儀表板*屏幕之前，我們需要在*登錄*頁面上做一件事。目前，如果您嘗試使用不存在的用戶名登錄，控制台中會顯示一條消息，但普通用戶不會看到任何變化，也不知道發生了什麼。 讓我們在登錄表單中添加一個佔位元素，以便在需要時顯示錯誤消息。一個不錯的位置是登錄 `` 的前面： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們添加內容之前，屏幕上不會顯示任何內容。我們還為它設置了一個 `id`，以便可以通過 JavaScript 輕鬆檢索。 回到 `appjs` 文件並創建一個新的輔助函數 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函數非常簡單：給定一個元素的 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文本內容。讓我們在 `login` 函數中使用此方法來替代之前的錯誤消息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果您嘗試使用無效帳戶登錄，您應該會看到類似以下的內容：[顯示登錄錯誤消息的截圖](////7-bank-project/3-data/images/login-errorpng) 現在我們有了視覺上顯示的錯誤文本，但如果您使用屏幕閱讀器嘗試，您會注意到什麼都沒有被宣告。為了讓動態添加到頁面的文本被屏幕閱讀器宣告，我們需要使用一種名為[Live Region](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)的技術。這裡我們將使用一種特定類型的 Live Region，稱為警告（alert）：\n```html\n```\n為 `register` 函數的錯誤實現相同的行為（別忘了更新 HTML）。\n## 在儀表板上顯示信息\n使用我們剛剛看到的相同技術，我們還將處理在儀表板頁面上顯示帳戶信息。\n以下是從伺服器接收到的帳戶對象的樣子：\n```json\n{\n\"user\": \"test\",\n\"currency\": \"$\",\n\"description\": \"Test account\",\n\"balance\": 75,\n\"transactions\": [\n{ \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 },\n{ \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 },\n{ \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 }\n],\n}\n```\n> 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。\n### 任務\n首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素：\n```html\nBalance:\n```\n我們還將在下面添加一個新部分以顯示帳戶描述：\n```html\n```\n✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1455,
    "chunk_index": 45,
    "total_chunks": 83
  },
  {
    "id": "83cbc4c452cf8b42f3ee6f09bda7973f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "Live Region，稱為警告（alert）： ```html ``` 為 `register` 函數的錯誤實現相同的行為（別忘了更新 HTML）。 ## 在儀表板上顯示信息 使用我們剛剛看到的相同技術，我們還將處理在儀表板頁面上顯示帳戶信息。 以下是從伺服器接收到的帳戶對象的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensa",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 46,
    "total_chunks": 83
  },
  {
    "id": "6c6f4a786faea019de9644c870f88a29",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "Live Region，稱為警告（alert）： ```html ``` 為 `register` 函數的錯誤實現相同的行為（別忘了更新 HTML）。 ## 在儀表板上顯示信息 使用我們剛剛看到的相同技術，我們還將處理在儀表板頁面上顯示帳戶信息。 以下是從伺服器接收到的帳戶對象的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。\n接下來，我們將在 `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 536,
    "chunk_index": 47,
    "total_chunks": 83
  },
  {
    "id": "d91f034382199b47117e064c9483f622",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "```html ``` 為 `register` 函數的錯誤實現相同的行為（別忘了更新 HTML）。 ## 在儀表板上顯示信息 使用我們剛剛看到的相同技術，我們還將處理在儀表板頁面上顯示帳戶信息。 以下是從伺服器接收到的帳戶對象的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素：\n```js\nfunction updateDashboard() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 557,
    "chunk_index": 48,
    "total_chunks": 83
  },
  {
    "id": "785b3e4acaa47b7111087d0763515649",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "在儀表板上顯示信息 使用我們剛剛看到的相同技術，我們還將處理在儀表板頁面上顯示帳戶信息。 以下是從伺服器接收到的帳戶對象的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) {\nreturn navigate('/login');\n}\nupdateElement('description', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 532,
    "chunk_index": 49,
    "total_chunks": 83
  },
  {
    "id": "26e468d0525df333490b86ad95d80203",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "\"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription);\nupdateElement('balance', account balance toFixed(2));\nupdateElement('currency', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 463,
    "chunk_index": 50,
    "total_chunks": 83
  },
  {
    "id": "a1aa390545b09b0b16f56db53eca876f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "\"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency);\n}\n```\n首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。\n> 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 546,
    "chunk_index": 51,
    "total_chunks": 83
  },
  {
    "id": "f1bc21eb15c35094ca12a71474193f1b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "\"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 52,
    "total_chunks": 83
  },
  {
    "id": "77819647f15a8152a3589498c6fc709d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "\"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。\n現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 600,
    "chunk_index": 53,
    "total_chunks": 83
  },
  {
    "id": "07cf3252b452037ae709be1e7542e037",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 596,
    "chunk_index": 54,
    "total_chunks": 83
  },
  {
    "id": "a6ca97a46794cfa90162a5211ebf6d5b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。\n將此代碼添加到 `updateRoute()` 函數的末尾：\n```js\nif (typeof route",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 55,
    "total_chunks": 83
  },
  {
    "id": "535a0761a9443e7d495c773669e76b0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "\"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。 將此代碼添加到 `updateRoute()` 函數的末尾： ```js if (typeof routeinit === 'function') {\nroute",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 640,
    "chunk_index": 56,
    "total_chunks": 83
  },
  {
    "id": "d5c6843284d226b76a95a93d13aa94d3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "}, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓您的操作更簡單，您可以使用已經填充了數據的預設 `test` 帳戶。 ### 任務 首先，我們將替換 HTML 中的“餘額”部分，添加佔位元素： ```html Balance: ``` 我們還將在下面添加一個新部分以顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。 將此代碼添加到 `updateRoute()` 函數的末尾： ```js if (typeof routeinit === 'function') { routeinit();\n}\n```\n並使用以下代碼更新路由定義：\n```js\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: updateDashboard }\n};\n```\n通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。\n## 使用 HTML 模板動態創建表格行\n在[第一課](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 778,
    "chunk_index": 57,
    "total_chunks": 83
  },
  {
    "id": "8cec995d312e1d4eab71519965929790",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。 將此代碼添加到 `updateRoute()` 函數的末尾： ```js if (typeof routeinit === 'function') { routeinit(); } ``` 並使用以下代碼更新路由定義： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/README",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 620,
    "chunk_index": 58,
    "total_chunks": 83
  },
  {
    "id": "5b1903b8f43cd9eb05ec5dccb68c0a6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "由於帳戶描述作為下面內容的標題，它在語義上被標記為標題。了解更多有關[標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)對可訪問性的重要性，並仔細檢查頁面以確定還有什麼可以作為標題。 接下來，我們將在 `appjs` 中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。 將此代碼添加到 `updateRoute()` 函數的末尾： ```js if (typeof routeinit === 'function') { routeinit(); } ``` 並使用以下代碼更新路由定義： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/READMEmd)中，我們使用 HTML 模板和 [`appendChild()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 642,
    "chunk_index": 59,
    "total_chunks": 83
  },
  {
    "id": "35352d34556e2c17886590643afdcb06",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。 將此代碼添加到 `updateRoute()` 函數的末尾： ```js if (typeof routeinit === 'function') { routeinit(); } ``` 並使用以下代碼更新路由定義： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/READMEmd)中，我們使用 HTML 模板和 [`appendChild()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 60,
    "total_chunks": 83
  },
  {
    "id": "6abe1244f214288df759411f2c06dc2f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "中創建一個新函數來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶數據，然後再進一步操作。然後，我們使用之前創建的 `updateElement()` 函數來更新 HTML。 > 為了讓餘額顯示更美觀，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後兩位。 現在，我們需要在每次加載儀表板時調用 `updateDashboard()` 函數。如果您已完成[第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則您可以使用以下實現。 將此代碼添加到 `updateRoute()` 函數的末尾： ```js if (typeof routeinit === 'function') { routeinit(); } ``` 並使用以下代碼更新路由定義： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/READMEmd)中，我們使用 HTML 模板和 [`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中的重複部分。\n我們將使用類似的方法在 HTML 表格中顯示交易列表。\n### 任務\n在 HTML `` 中添加一個新模板：\n```html\n```\n此模板表示單個表格行，包含我們希望填充的三列：交易的*日期*、*對象*和*金額*。\n然後，將此 `id` 屬性添加到儀表板模板中的表格 `` 元素，以便使用 JavaScript 更容易找到：\n```html\n```\n我們的 HTML 已準備好，接下來切換到 JavaScript 代碼並創建一個新函數 `createTransactionRow`：\n```js\nfunction createTransactionRow(transaction) {\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 756,
    "chunk_index": 61,
    "total_chunks": 83
  },
  {
    "id": "9d8256ea07e188ae8ab83ec07c01966e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "if (typeof routeinit === 'function') { routeinit(); } ``` 並使用以下代碼更新路由定義： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/READMEmd)中，我們使用 HTML 模板和 [`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中的重複部分。 我們將使用類似的方法在 HTML 表格中顯示交易列表。 ### 任務 在 HTML `` 中添加一個新模板： ```html ``` 此模板表示單個表格行，包含我們希望填充的三列：交易的*日期*、*對象*和*金額*。 然後，將此 `id` 屬性添加到儀表板模板中的表格 `` 元素，以便使用 JavaScript 更容易找到： ```html ``` 我們的 HTML 已準備好，接下來切換到 JavaScript 代碼並創建一個新函數 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction');\nconst transactionRow = template content cloneNode(true);\nconst tr = transactionRow querySelector('tr');\ntr children[0] textContent = transaction date;\ntr children[1] textContent = transaction object;\ntr children[2] textContent = transaction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 504,
    "chunk_index": 62,
    "total_chunks": 83
  },
  {
    "id": "f697c286ad0ac21fcb6f389471751771",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/READMEmd)中，我們使用 HTML 模板和 [`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中的重複部分。 我們將使用類似的方法在 HTML 表格中顯示交易列表。 ### 任務 在 HTML `` 中添加一個新模板： ```html ``` 此模板表示單個表格行，包含我們希望填充的三列：交易的*日期*、*對象*和*金額*。 然後，將此 `id` 屬性添加到儀表板模板中的表格 `` 元素，以便使用 JavaScript 更容易找到： ```html ``` 我們的 HTML 已準備好，接下來切換到 JavaScript 代碼並創建一個新函數 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transactionamount",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 63,
    "total_chunks": 83
  },
  {
    "id": "5916a389a91965c98b4b8e3738f5b265",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "``` 通過此更改，每次顯示儀表板頁面時，都會調用 `updateDashboard()` 函數。登錄後，您應該能夠看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態創建表格行 在[第一課](/1-template-route/READMEmd)中，我們使用 HTML 模板和 [`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中的重複部分。 我們將使用類似的方法在 HTML 表格中顯示交易列表。 ### 任務 在 HTML `` 中添加一個新模板： ```html ``` 此模板表示單個表格行，包含我們希望填充的三列：交易的*日期*、*對象*和*金額*。 然後，將此 `id` 屬性添加到儀表板模板中的表格 `` 元素，以便使用 JavaScript 更容易找到： ```html ``` 我們的 HTML 已準備好，接下來切換到 JavaScript 代碼並創建一個新函數 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transactionamounttoFixed(2);\nreturn transactionRow;\n}\n```\n此函數正如其名稱所示：使用我們之前創建的模板，它創建一個新的表格行並使用交易數據填充其內容。我們將在 `updateDashboard()` 函數中使用此函數來填充表格：\n```js\nconst transactionsRows = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 548,
    "chunk_index": 64,
    "total_chunks": 83
  },
  {
    "id": "cb80623ee72a0c3d2303e1dcb382f870",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中的重複部分。 我們將使用類似的方法在 HTML 表格中顯示交易列表。 ### 任務 在 HTML `` 中添加一個新模板： ```html ``` 此模板表示單個表格行，包含我們希望填充的三列：交易的*日期*、*對象*和*金額*。 然後，將此 `id` 屬性添加到儀表板模板中的表格 `` 元素，以便使用 JavaScript 更容易找到： ```html ``` 我們的 HTML 已準備好，接下來切換到 JavaScript 代碼並創建一個新函數 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transactionamounttoFixed(2); return transactionRow; } ``` 此函數正如其名稱所示：使用我們之前創建的模板，它創建一個新的表格行並使用交易數據填充其內容。我們將在 `updateDashboard()` 函數中使用此函數來填充表格： ```js const transactionsRows = documentcreateDocumentFragment();\nfor (const transaction of account transactions) {\nconst transactionRow = createTransactionRow(transaction);\ntransactionsRows appendChild(transactionRow);\n}\nupdateElement('transactions', transactionsRows);\n```\n這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 65,
    "total_chunks": 83
  },
  {
    "id": "ef935be060866638fe770a4d2e4a8331",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "``` 我們的 HTML 已準備好，接下來切換到 JavaScript 代碼並創建一個新函數 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transactionamounttoFixed(2); return transactionRow; } ``` 此函數正如其名稱所示：使用我們之前創建的模板，它創建一個新的表格行並使用交易數據填充其內容。我們將在 `updateDashboard()` 函數中使用此函數來填充表格： ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。\n在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼：\n```js\nfunction updateElement(id, textOrNode) {\nconst element = document getElementById(id);\nelement textContent = ''; // Removes all children\nelement append(textOrNode);\n}\n```\n我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 66,
    "total_chunks": 83
  },
  {
    "id": "9ffc19c53adaf681e681751e1c2cd8b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "object; tr children[2] textContent = transactionamounttoFixed(2); return transactionRow; } ``` 此函數正如其名稱所示：使用我們之前創建的模板，它創建一個新的表格行並使用交易數據填充其內容。我們將在 `updateDashboard()` 函數中使用此函數來填充表格： ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。\n如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。\n---\n## 🚀 挑戰\n一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 559,
    "chunk_index": 67,
    "total_chunks": 83
  },
  {
    "id": "2a85dd90a716fb65c43616af47583bbc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "`updateDashboard()` 函數中使用此函數來填充表格： ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 68,
    "total_chunks": 83
  },
  {
    "id": "29b58014ab4b7a338882b092c783fba0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "`updateDashboard()` 函數中使用此函數來填充表格： ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 69,
    "total_chunks": 83
  },
  {
    "id": "5d9107086fbaaa7c91d8ae75a1ae9ec7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 70,
    "total_chunks": 83
  },
  {
    "id": "db0050a9f5e59b46c69a79cdc7a03355",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。\n以下是一個設計過的儀表板頁面的範例：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 553,
    "chunk_index": 71,
    "total_chunks": 83
  },
  {
    "id": "6a28f3ca0d2b67b0390ed3445ed8ed60",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 72,
    "total_chunks": 83
  },
  {
    "id": "bdcfcf9a5ffd720e356e63b852f9f33f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 73,
    "total_chunks": 83
  },
  {
    "id": "705063d2effaa75baa73d513eccea22b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 74,
    "total_chunks": 83
  },
  {
    "id": "d03586c71c105bd763f4bfd11fd22a63",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 75,
    "total_chunks": 83
  },
  {
    "id": "cf4a8d09841da67cc3c0bda47ba1be32",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 583,
    "chunk_index": 76,
    "total_chunks": 83
  },
  {
    "id": "ea7adedf9834850d2b6f10c8c027a953",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2png)\n## 課後測驗\n[課後測驗](https://ashy-river-0debb7803",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 616,
    "chunk_index": 77,
    "total_chunks": 83
  },
  {
    "id": "a05ffb8d1c694d98f71632966cdaa92f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 611,
    "chunk_index": 78,
    "total_chunks": 83
  },
  {
    "id": "87e7b062413ee1a0902df15e15715720",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 614,
    "chunk_index": 79,
    "total_chunks": 83
  },
  {
    "id": "01f52738bde13b53edeecef298db59ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/46)\n## 作業\n[重構並為你的程式碼添加註解](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 648,
    "chunk_index": 80,
    "total_chunks": 83
  },
  {
    "id": "eea213503e589df945490bf499a3d670",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/46) ## 作業 [重構並為你的程式碼添加註解](assignmentmd)\n**免責聲明**：\n本文件使用人工智能翻譯服務 [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 675,
    "chunk_index": 81,
    "total_chunks": 83
  },
  {
    "id": "9493c4e7bc218f7b34d239519d90a4f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "{ const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 這裡我們使用方法 [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment)，它創建了一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此代碼能正常工作之前，我們還需要做一件事，因為我們的 `updateElement()` 函數目前僅支持文本內容。讓我們稍微修改一下它的代碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) 方法，因為它允許將文本或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用場景。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易列表了 🎉。 --- ## 🚀 挑戰 一起合作，讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和移動設備上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板設計完成後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/46) ## 作業 [重構並為你的程式碼添加註解](assignmentmd) **免責聲明**： 本文件使用人工智能翻譯服務 [Co-op Translator](https://githubcom/Azure/co-op-translator) 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 829,
    "chunk_index": 82,
    "total_chunks": 83
  },
  {
    "id": "bf1063d0e663ce7b0cc700851b69f1c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\assignment.md",
    "source_type": "git_repo",
    "title": "建立一個計分遊戲",
    "content": "建立一個計分遊戲\n指引\n創建一個遊戲，以創意的方式顯示生命值和分數。一個建議是將生命值顯示為心形，並將分數顯示為螢幕底部中央的大數字。可以參考這裡的免費遊戲資源。\n評分標準\n| 評分標準 | 優秀                     | 合格                        | 需要改進                   |\n| -------- | ------------------------ | --------------------------- | -------------------------- |\n|          | 完整遊戲已呈現           | 部分遊戲已呈現              | 部分遊戲包含錯誤           |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要信息，建議使用專業的人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1325,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 400,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "db0acecd02c33fae07698c8e9fa9d2bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 0,
    "total_chunks": 41
  },
  {
    "id": "edaa22098bcfcc31dd05ffd211c96c36",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 502,
    "chunk_index": 1,
    "total_chunks": 41
  },
  {
    "id": "f38c400af79490ac88bc68588fa92e1d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 505,
    "chunk_index": 2,
    "total_chunks": 41
  },
  {
    "id": "6bfb4ba0204d362a1618f1f49db74274",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 3,
    "total_chunks": 41
  },
  {
    "id": "71c05ea7f32da66a81dc3753de547db7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 515,
    "chunk_index": 4,
    "total_chunks": 41
  },
  {
    "id": "d72f02f9938ae3a298d37feacd1635cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 5,
    "total_chunks": 41
  },
  {
    "id": "dff70ccd631773a3ac1042e77f52bb82",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 6,
    "total_chunks": 41
  },
  {
    "id": "8eeaf581c24403c0f63452fd8b5b42b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, heroy);\n✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。\n處理鍵盤事件\n你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。\n要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。\n以下是一個範例：\njavascript\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 789,
    "chunk_index": 7,
    "total_chunks": 41
  },
  {
    "id": "bf4ab4064204c25d10439a4be0ea9f9e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, heroy);\n✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。\n處理鍵盤事件\n你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。\n要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。\n以下是一個範例：\njavascript\nwindowaddEventListener('keyup', (evt) => {\n// `evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 801,
    "chunk_index": 8,
    "total_chunks": 41
  },
  {
    "id": "0f0aab8fb9ecc1caf69cc2fae8f6ff0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "建立太空遊戲第三部分：加入移動功能\n課前測驗\n課前測驗\n遊戲中如果沒有外星人在螢幕上移動，會顯得很無趣！在這個遊戲中，我們將使用兩種類型的移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。\n遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。\n那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常，你需要以下步驟來實現螢幕上的移動：\n設定物件的新位置：這是讓物件看起來已經移動的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。\n在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。\n以下是程式碼的範例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, heroy);\n✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。\n處理鍵盤事件\n你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。\n要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。\n以下是一個範例：\njavascript\nwindowaddEventListener('keyup', (evt) => {\n// `evtkey` = string representation of the key\nif (evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 813,
    "chunk_index": 9,
    "total_chunks": 41
  },
  {
    "id": "4f0dedb3c9c7d662bd216b93a16fe9ae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與遊戲互動時，移動螢幕上的物件。 遊戲驅動的移動：當遊戲以一定的時間間隔自動移動物件。 那麼，我們如何在螢幕上移動物件呢？這一切都與笛卡兒座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。 通常，你需要以下步驟來實現螢幕上的移動： 設定物件的新位置：這是讓物件看起來已經移動的必要步驟。 清除螢幕：在每次繪製之間需要清除螢幕。我們可以透過繪製一個填滿背景顏色的矩形來清除螢幕。 在新位置重新繪製物件：這樣我們就能實現將物件從一個位置移動到另一個位置。 以下是程式碼的範例： javascript //set the hero's location hero x += 5; // clear the rectangle that hosts the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。 處理鍵盤事件 你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。 以下是一個範例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') {\n// do something\n}\n})\n對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵：\nkey：這是一個字串，表示按下的鍵，例如 ArrowUp。\nkeyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。\n✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？\n特殊鍵：注意事項\n有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼：\n```javascript\nlet onKeyDown = function (e) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1015,
    "chunk_index": 10,
    "total_chunks": 41
  },
  {
    "id": "0054cfb16747a9e5d2407aef7fb561be",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。 處理鍵盤事件 你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。 以下是一個範例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 641,
    "chunk_index": 11,
    "total_chunks": 41
  },
  {
    "id": "8f947595ac4311b8e79e3104cf595e10",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。 處理鍵盤事件 你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。 以下是一個範例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode);\nswitch (e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 12,
    "total_chunks": 41
  },
  {
    "id": "f38595cdb40d157766020b8e3450b343",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "canvas width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。 處理鍵盤事件 你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。 以下是一個範例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) {\ncase 37:\ncase 39:\ncase 38:\ncase 40: // Arrow keys\ncase 32:\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 666,
    "chunk_index": 13,
    "total_chunks": 41
  },
  {
    "id": "8b516a3f4a4b878a0cb34adf6e66e5d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ 你能想到為什麼每秒多次重繪你的英雄可能會導致效能問題嗎？閱讀有關此模式的替代方案。 處理鍵盤事件 你可以透過將特定事件附加到程式碼來處理事件。鍵盤事件會在整個視窗上觸發，而滑鼠事件（例如 click）則可以連結到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用視窗的 addEventListener() 方法，並提供兩個輸入參數。第一個參數是事件的名稱，例如 keyup。第二個參數是事件發生時應該執行的函式。 以下是一個範例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault();\nbreak; // Space\ndefault:\nbreak; // do not block other keys\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 659,
    "chunk_index": 14,
    "total_chunks": 41
  },
  {
    "id": "b826ee7d0a5c9dbfbe9acd659611110f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "keyup。第二個參數是事件發生時應該執行的函式。 以下是一個範例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown);\n```\n上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 471,
    "chunk_index": 15,
    "total_chunks": 41
  },
  {
    "id": "d4c572f0f301190e2ba636d52ca985dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "(evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。\n遊戲驅動的移動\n我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例：\njavascript\nlet id = setInterval(() => {\n//move the enemy on the y axis\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 531,
    "chunk_index": 16,
    "total_chunks": 41
  },
  {
    "id": "24407f1fa06e4ccc12740be826eef1e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "key：這是一個字串，表示按下的鍵，例如 ArrowUp。 keyCode：這是一個數字表示，例如 37，對應於 ArrowLeft。 ✅ 鍵盤事件的操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響視窗。這意味著如果你正在監聽 keyup 事件，並使用這些特殊鍵來移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10;\n})\n遊戲迴圈\n遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。\n以下是遊戲迴圈的典型程式碼表達方式：\njavascript\nlet gameLoopId = setInterval(() =>\nfunction gameLoop() {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 744,
    "chunk_index": 17,
    "total_chunks": 41
  },
  {
    "id": "6e6aa288ee6063077b9dee8db897a889",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "(e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 512,
    "chunk_index": 18,
    "total_chunks": 41
  },
  {
    "id": "ccb63170eedff0df32b859a0fb4e7d43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 512,
    "chunk_index": 19,
    "total_chunks": 41
  },
  {
    "id": "4e8a6e9ab22d98654de140584dce0d57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight);\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 510,
    "chunk_index": 20,
    "total_chunks": 41
  },
  {
    "id": "63df175ef847840ddaa856bd606d0968",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "(ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 515,
    "chunk_index": 21,
    "total_chunks": 41
  },
  {
    "id": "c865f8f83c39cd20aefee4236d45c847",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 518,
    "chunk_index": 22,
    "total_chunks": 41
  },
  {
    "id": "74837c183ebbdd61fa204ee4edca2169",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 517,
    "chunk_index": 23,
    "total_chunks": 41
  },
  {
    "id": "ae6cdd99e8b2791d602219986aea5a7c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight);\ndrawHero();\ndrawEnemies();\ndrawStaticObjects();\n}, 200);\n上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。\n繼續太空遊戲\n你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。\n移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。\n移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 775,
    "chunk_index": 24,
    "total_chunks": 41
  },
  {
    "id": "84f791695d05eee0183819f0830a3cbf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "}; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 25,
    "total_chunks": 41
  },
  {
    "id": "a8b57666d7d88367c57b8ab1dfe463b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 747,
    "chunk_index": 26,
    "total_chunks": 41
  },
  {
    "id": "7f7cadd535dbf4a96eec6e23240e7d05",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。當我們呼叫 epreventDefault() 時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 747,
    "chunk_index": 27,
    "total_chunks": 41
  },
  {
    "id": "18307af9409825d93da237e3424e86fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "時，就實現了關閉機制。 遊戲驅動的移動 我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 697,
    "chunk_index": 28,
    "total_chunks": 41
  },
  {
    "id": "6cacd51414c00bbd5f3b65e77958e83d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "我們可以使用計時器（例如 setTimeout() 或 setInterval() 函式）讓物件自行移動，這些函式會在每個時間間隔更新物件的位置。以下是範例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲迴圈 遊戲迴圈是一個概念，本質上是一個以固定間隔調用的函式。它被稱為遊戲迴圈，因為所有應該顯示給使用者的內容都會在這個迴圈中繪製。遊戲迴圈會使用遊戲中的所有物件，並繪製它們，除非某些物件不再屬於遊戲的一部分。例如，如果一個物件是被雷射擊中的敵人並爆炸，那麼它就不再屬於當前的遊戲迴圈（你會在後續課程中學到更多）。 以下是遊戲迴圈的典型程式碼表達方式： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson\n你可以透過輸入以下指令啟動專案的 your_work 資料夾：\nbash\ncd your-work\nnpm start\n上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！\n新增程式碼\n新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。\n提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。\n提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上：\n```javascript\nclass GameObject {\nconstructor(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 965,
    "chunk_index": 29,
    "total_chunks": 41
  },
  {
    "id": "610eecfea4103543aa5aee19c51857a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以透過輸入以下指令啟動專案的 your_work 資料夾： bash cd your-work npm start 上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！ 新增程式碼 新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。 提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。 提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 582,
    "chunk_index": 30,
    "total_chunks": 41
  },
  {
    "id": "c648269b7138ce2b34331e6ffab19ef2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "drawEnemies(); drawStaticObjects(); }, 200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以透過輸入以下指令啟動專案的 your_work 資料夾： bash cd your-work npm start 上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！ 新增程式碼 新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。 提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。 提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 578,
    "chunk_index": 31,
    "total_chunks": 41
  },
  {
    "id": "cd1971268c345f9eded51123780c85f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "200); 上述迴圈每 200 毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以透過輸入以下指令啟動專案的 your_work 資料夾： bash cd your-work npm start 上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！ 新增程式碼 新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。 提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。 提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 574,
    "chunk_index": 32,
    "total_chunks": 41
  },
  {
    "id": "dc9de2aecd18cd3e2e0b212fc6e78613",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "毫秒調用一次以重新繪製畫布。你可以選擇最適合你遊戲的間隔。 繼續太空遊戲 你將使用現有的程式碼並進行擴展。可以從你在第一部分完成的程式碼開始，或者使用 第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以透過輸入以下指令啟動專案的 your_work 資料夾： bash cd your-work npm start 上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！ 新增程式碼 新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。 提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。 提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\";\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 567,
    "chunk_index": 33,
    "total_chunks": 41
  },
  {
    "id": "0484cfb279030488235c6eec954ee71a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "第二部分的起始程式碼。 移動英雄：你將新增程式碼，確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要新增程式碼，確保敵人以一定的速度從上到下移動。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以透過輸入以下指令啟動專案的 your_work 資料夾： bash cd your-work npm start 上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！ 新增程式碼 新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。 提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。 提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0;\nthis height = 0;\nthis img = undefined;\n}\ndraw(ctx) {\nctx drawImage(this img, this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 34,
    "total_chunks": 41
  },
  {
    "id": "5e946697119942e377ec05566fe9f661",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "appjs -| packagejson 你可以透過輸入以下指令啟動專案的 your_work 資料夾： bash cd your-work npm start 上述指令將在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該會顯示英雄和所有敵人；但它們還不會移動！ 新增程式碼 新增專用物件：為 hero、enemy 和 game object 新增專用物件，它們應該具有 x 和 y 屬性。（記得參考 繼承或組合 的部分）。 提示：game object 應該是具有 x 和 y 屬性並能夠將自己繪製到畫布上的物件。 提示：從新增一個 GameObject 類別開始，並按照以下方式定義其建構函式，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; this height = 0; this img = undefined; } draw(ctx) { ctx drawImage(this img, thisx, this y, this width, this height);\n}\n}\n```\n現在，擴展這個 GameObject 來建立 Hero 和 Enemy。\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) { it needs an x, y, type, and speed\n}\n}\n```\n```javascript\nclass Enemy extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 98), (this height = 50);\nthis type = \"Enemy\";\nlet id = setInterval(() => {\nif (this y < canvas height - this height) {\nthis y += 5;\n} else {\nconsole log('Stopped at', this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 35,
    "total_chunks": 41
  },
  {
    "id": "578ec9a11f79c14fb6a1e7ca57f3956b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "現在，擴展這個 GameObject 來建立 Hero 和 Enemy。 ```javascript class Hero extends GameObject { constructor(x, y) { it needs an x, y, type, and speed } } ``` ```javascript class Enemy extends GameObject { constructor(x, y) { super(x, y); (this width = 98), (this height = 50); this type = \"Enemy\"; let id = setInterval(() => { if (this y < canvas height - this height) { this y += 5; } else { console log('Stopped at', thisy)\nclearInterval(id);\n}\n}, 300)\n}\n}\n```\n新增鍵盤事件處理程式：處理鍵盤導航（移動英雄上下左右）。\n記住：這是一個笛卡兒系統，左上角是 0,0。還要記得新增程式碼來停止預設行為。\n提示：建立你的 onKeyDown 函式並將其附加到視窗：\n```javascript\nlet onKeyDown = function (e) {\nconsole log(e keyCode); add the code from the lesson above to stop default behavior\n}\n};\nwindow addEventListener(\"keydown\", onKeyDown);\n```\n此時檢查你的瀏覽器主控台，觀察按鍵記錄。\n實現 Pub sub 模式，這將使你的程式碼在後續部分保持清晰。\n要完成這部分，你可以：\n在視窗上新增事件監聽器：\njavascript\nwindow addEventListener(\"keyup\", (evt) => {\nif (evt key === \"ArrowUp\") {\neventEmitter emit(Messages KEY_EVENT_UP);\n} else if (evt key === \"ArrowDown\") {\neventEmitter emit(Messages KEY_EVENT_DOWN);\n} else if (evt key === \"ArrowLeft\") {\neventEmitter emit(Messages KEY_EVENT_LEFT);\n} else if (evt key === \"ArrowRight\") {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 465,
    "chunk_index": 36,
    "total_chunks": 41
  },
  {
    "id": "7a8c84b56836d05e77c412cab9a8391d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "(e) { console log(e keyCode); add the code from the lesson above to stop default behavior } }; window addEventListener(\"keydown\", onKeyDown); ``` 此時檢查你的瀏覽器主控台，觀察按鍵記錄。 實現 Pub sub 模式，這將使你的程式碼在後續部分保持清晰。 要完成這部分，你可以： 在視窗上新增事件監聽器： javascript window addEventListener(\"keyup\", (evt) => { if (evt key === \"ArrowUp\") { eventEmitter emit(Messages KEY_EVENT_UP); } else if (evt key === \"ArrowDown\") { eventEmitter emit(Messages KEY_EVENT_DOWN); } else if (evt key === \"ArrowLeft\") { eventEmitter emit(Messages KEY_EVENT_LEFT); } else if (evt key === \"ArrowRight\") { eventEmitter emit(MessagesKEY_EVENT_RIGHT);\n}\n});\n建立一個 EventEmitter 類別，用於發布和訂閱訊息：\n```javascript\nclass EventEmitter {\nconstructor() {\nthis listeners = {};\n}\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message] forEach((l) => l(message, payload));\n}\n}\n}\n```\n新增常數並設置 EventEmitter：\n```javascript\nconst Messages = {\nKEY_EVENT_UP: \"KEY_EVENT_UP\",\nKEY_EVENT_DOWN: \"KEY_EVENT_DOWN\",\nKEY_EVENT_LEFT: \"KEY_EVENT_LEFT\",\nKEY_EVENT_RIGHT: \"KEY_EVENT_RIGHT\",\n};\nlet heroImg,\nenemyImg,\nlaserImg,\ncanvas, ctx,\ngameObjects = [],\nhero,\neventEmitter = new EventEmitter();\n```\n初始化遊戲\n```javascript\nfunction initGame() {\ngameObjects = [];\ncreateEnemies();\ncreateHero();\neventEmitter on(Messages KEY_EVENT_UP, () => {\nhero y -=5 ;\n})\neventEmitter on(Messages KEY_EVENT_DOWN, () => {\nhero y += 5;\n});\neventEmitter on(Messages KEY_EVENT_LEFT, () => {\nhero x -= 5;\n});\neventEmitter on(Messages KEY_EVENT_RIGHT, () => {\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 37,
    "total_chunks": 41
  },
  {
    "id": "60e6fa6e364e97fb2131441b81f6597d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "= { KEY_EVENT_UP: \"KEY_EVENT_UP\", KEY_EVENT_DOWN: \"KEY_EVENT_DOWN\", KEY_EVENT_LEFT: \"KEY_EVENT_LEFT\", KEY_EVENT_RIGHT: \"KEY_EVENT_RIGHT\", }; let heroImg, enemyImg, laserImg, canvas, ctx, gameObjects = [], hero, eventEmitter = new EventEmitter(); ``` 初始化遊戲 ```javascript function initGame() { gameObjects = []; createEnemies(); createHero(); eventEmitter on(Messages KEY_EVENT_UP, () => { hero y -=5 ; }) eventEmitter on(Messages KEY_EVENT_DOWN, () => { hero y += 5; }); eventEmitter on(Messages KEY_EVENT_LEFT, () => { hero x -= 5; }); eventEmitter on(Messages KEY_EVENT_RIGHT, () => { herox += 5;\n});\n}\n```\n設置遊戲迴圈\n重構 window onload 函式以初始化遊戲並在適當的間隔設置遊戲迴圈。你還將新增一個雷射光束：\n```javascript\nwindow onload = async () => {\ncanvas = document getElementById(\"canvas\");\nctx = canvas getContext(\"2d\");\nheroImg = await loadTexture(\"assets/player png\");\nenemyImg = await loadTexture(\"assets/enemyShip png\");\nlaserImg = await loadTexture(\"assets/laserRed png\");\ninitGame();\nlet gameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\ndrawGameObjects(ctx);\n}, 100)\n};\n```\n新增程式碼：以一定的間隔移動敵人。\n重構 createEnemies() 函式以建立敵人並將它們推入新的 gameObjects 類別：\n```javascript\nfunction createEnemies() {\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 38,
    "total_chunks": 41
  },
  {
    "id": "899455350e7511b0ff7505f9b47fba51",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "= document getElementById(\"canvas\"); ctx = canvas getContext(\"2d\"); heroImg = await loadTexture(\"assets/player png\"); enemyImg = await loadTexture(\"assets/enemyShip png\"); laserImg = await loadTexture(\"assets/laserRed png\"); initGame(); let gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvas height); drawGameObjects(ctx); }, 100) }; ``` 新增程式碼：以一定的間隔移動敵人。 重構 createEnemies() 函式以建立敵人並將它們推入新的 gameObjects 類別： ```javascript function createEnemies() { const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nconst enemy = new Enemy(x, y);\nenemy img = enemyImg;\ngameObjects push(enemy);\n}\n}\n}\n```\n並新增一個 createHero() 函式，對英雄執行類似的過程。\njavascript\nfunction createHero() {\nhero = new Hero(\ncanvas width / 2 - 45,\ncanvas height - canvas height / 4\n);\nhero img = heroImg;\ngameObjects push(hero);\n}\n最後，新增一個 drawGameObjects() 函式以開始繪製：\njavascript\nfunction drawGameObjects(ctx) {\ngameObjects forEach(go => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 400,
    "chunk_index": 39,
    "total_chunks": 41
  },
  {
    "id": "eac9bd4de2f2b900feae7feb3573477c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入移動功能",
    "content": "+= 98) { for (let y = 0; y < 50 * 5; y += 50) { const enemy = new Enemy(x, y); enemy img = enemyImg; gameObjects push(enemy); } } } ``` 並新增一個 createHero() 函式，對英雄執行類似的過程。 javascript function createHero() { hero = new Hero( canvas width / 2 - 45, canvas height - canvas height / 4 ); hero img = heroImg; gameObjects push(hero); } 最後，新增一個 drawGameObjects() 函式以開始繪製： javascript function drawGameObjects(ctx) { gameObjects forEach(go => godraw(ctx));\n}\n你的敵人應該開始向你的英雄太空船進攻了！\n🚀 挑戰\n如你所見，當你開始新增函式、變數和類別時，程式碼可能會變成「意大利麵條式程式碼」。你如何更好地組織程式碼，使其更具可讀性？即使程式碼仍然位於一個檔案中，也試著設計一個系統來組織它。\n課後測驗\n課後測驗\n複習與自學\n雖然我們在不使用框架的情況下編寫遊戲，但有許多基於 JavaScript 的畫布框架可用於遊戲開發。花些時間閱讀有關這些框架的資訊：閱讀更多。\n作業\n為你的程式碼新增註解\n免責聲明：\n本文件已使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13725,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 635,
    "chunk_index": 40,
    "total_chunks": 41
  },
  {
    "id": "091c8cbe89e3a536d946e86a4389ba10",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\assignment.md",
    "source_type": "git_repo",
    "title": "建立一個簡單遊戲",
    "content": "建立一個簡單遊戲\n指引\n嘗試建立一個小型遊戲，練習不同的結局條件。可以設計不同的目標，例如獲得一定的分數、英雄失去所有生命值或擊敗所有怪物。建立一些簡單的遊戲，例如基於控制台的冒險遊戲。以下的遊戲流程可作為靈感：\nHero> Strikes with broadsword - orc takes 3p damage\nOrc> Hits with club - hero takes 2p damage\nHero> Kicks - orc takes 1p damage\nGame> Orc is defeated - Hero collects 2 coins\nGame> ****No more monsters, you have conquered the evil fortress****\n評分標準\n| 評分標準 | 優秀表現              | 合格表現                    | 需要改進                  |\n| -------- | ---------------------- | --------------------------- | -------------------------- |\n|          | 完整遊戲已呈現        | 部分遊戲已呈現              | 部分遊戲存在錯誤          |\n免責聲明：\n本文件已使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1595,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "94a058cca4da09e790b42d453436c03f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 667,
    "chunk_index": 0,
    "total_chunks": 52
  },
  {
    "id": "884c422bf48f7a79d500ce7667ed8f22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 1,
    "total_chunks": 52
  },
  {
    "id": "802feff8ecf7a4cad60f3ad8c7c25830",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 2,
    "total_chunks": 52
  },
  {
    "id": "de17189d07585083c4ba60828c5da0b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 680,
    "chunk_index": 3,
    "total_chunks": 52
  },
  {
    "id": "c8cec0f72b41f4640e0c08223834f2e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 685,
    "chunk_index": 4,
    "total_chunks": 52
  },
  {
    "id": "4d1ada278e10a08f333267283bf7264d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 5,
    "total_chunks": 52
  },
  {
    "id": "00eae9192f47c24f6524ced197f89798",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 6,
    "total_chunks": 52
  },
  {
    "id": "07ac012a18f9c157e2d18655b1840f19",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 7,
    "total_chunks": 52
  },
  {
    "id": "0a4fd256831c6eac18fd301dc3e5eb61",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 737,
    "chunk_index": 8,
    "total_chunks": 52
  },
  {
    "id": "43e1a911e7a91861440fb051c09cdc28",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 741,
    "chunk_index": 9,
    "total_chunks": 52
  },
  {
    "id": "ffbbeef6ddb8daf84bee9a6406d64b75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 745,
    "chunk_index": 10,
    "total_chunks": 52
  },
  {
    "id": "bc211ec1a026de814b56a213ada4e328",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 749,
    "chunk_index": 11,
    "total_chunks": 52
  },
  {
    "id": "ce617ea83c4d0ed9b6844eb11c452643",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 753,
    "chunk_index": 12,
    "total_chunks": 52
  },
  {
    "id": "ebd40337b505c40a5ad7dd02b37b7cac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 757,
    "chunk_index": 13,
    "total_chunks": 52
  },
  {
    "id": "5bb584b82f70d6b1d0cf1c628b927eaf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 761,
    "chunk_index": 14,
    "total_chunks": 52
  },
  {
    "id": "acab207d5145bc92f5c5202c18f5d482",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1top);\n}\n我們如何銷毀物件\n在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示：\njavascript\n// collision happened\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 883,
    "chunk_index": 15,
    "total_chunks": 52
  },
  {
    "id": "f5c940e10aacf4375ffd860cbfdca253",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞\n課前測驗\n課前測驗\n在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能：\n雷射：從英雄的飛船發射，垂直向上移動\n碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞偵測\n我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容：\n一種方法來獲取遊戲物件的矩形表示，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以像這樣：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1top);\n}\n我們如何銷毀物件\n在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示：\njavascript\n// collision happened\nenemydead = true\n然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示：\njavascript\ngameObjects = gameObject",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 934,
    "chunk_index": 16,
    "total_chunks": 52
  },
  {
    "id": "9d720e00ca41fdc5c8157be4abc8a0bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "課前測驗 在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能： 雷射：從英雄的飛船發射，垂直向上移動 碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。 ✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？ 讓我們一起成為英雄吧！ 碰撞偵測 我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容： 一種方法來獲取遊戲物件的矩形表示，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 896,
    "chunk_index": 17,
    "total_chunks": 52
  },
  {
    "id": "6743794fc910a89bc8779f4073850032",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能： 雷射：從英雄的飛船發射，垂直向上移動 碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。 ✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？ 讓我們一起成為英雄吧！ 碰撞偵測 我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容： 一種方法來獲取遊戲物件的矩形表示，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 890,
    "chunk_index": 18,
    "total_chunks": 52
  },
  {
    "id": "18a42e87ff17e2a2dce83a46f8a7f762",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "在這一課中，你將學習如何用 JavaScript 發射雷射！我們將為遊戲新增以下兩個功能： 雷射：從英雄的飛船發射，垂直向上移動 碰撞偵測：作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。 ✅ 做一些研究，了解第一款電腦遊戲的功能是什麼？ 讓我們一起成為英雄吧！ 碰撞偵測 我們該如何進行碰撞偵測？我們需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、width 和 height。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容： 一種方法來獲取遊戲物件的矩形表示，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead);\n我們如何發射雷射\n發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟：\n創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。\n綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。\n當按下按鍵時，創建一個看起來像雷射的遊戲物件。\n雷射的冷卻時間\n雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現：\n```javascript\nclass Cooldown {\nconstructor(time) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1255,
    "chunk_index": 19,
    "total_chunks": 52
  },
  {
    "id": "0f5dcfef43116ffb9d84a3b348e281ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "x、y、width 和 height。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼，取決於遊戲規則。要實現碰撞偵測，你需要以下內容： 一種方法來獲取遊戲物件的矩形表示，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false;\nsetTimeout(() => {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 777,
    "chunk_index": 20,
    "total_chunks": 52
  },
  {
    "id": "1df77939ba70da4bdddda52ba7c725d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true;\n}, time)\n}\n}\nclass Weapon {\nconstructor {\n}\nfire() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 676,
    "chunk_index": 21,
    "total_chunks": 52
  },
  {
    "id": "4575919eea03a913bfd51991fc502c69",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "} } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 645,
    "chunk_index": 22,
    "total_chunks": 52
  },
  {
    "id": "0d53c2273f26b307e65e7da0fa4d51db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "} } 一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 648,
    "chunk_index": 23,
    "total_chunks": 52
  },
  {
    "id": "74fd153ab197374d5ed237bdc786523d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldown",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 24,
    "total_chunks": 52
  },
  {
    "id": "e5ece317c3a919ac791ea6990dfac81f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "一個比較函數，該函數可以像這樣： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) {\n// produce a laser\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 655,
    "chunk_index": 25,
    "total_chunks": 52
  },
  {
    "id": "c0e4f89a360bae254385375493e3ee0c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500);\n} else {\n// do nothing - it hasn't cooled down yet",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 638,
    "chunk_index": 26,
    "total_chunks": 52
  },
  {
    "id": "400e79ba73ab36d03c2b8022c3a56ab4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "} 我們如何銷毀物件 在遊戲中銷毀物件需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前，將死亡的物件過濾掉，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部發射，創建後開始向螢幕頂部移動。 綁定按鍵事件的程式碼：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 當按下按鍵時，創建一個看起來像雷射的遊戲物件。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內產生過多的雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，一個計時器，確保雷射只能在一定時間間隔內發射一次。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet}\n}\n}\n```\n✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。\n要構建的內容\n你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。\n提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。\n新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則：\n雷射擊中敵人：敵人被雷射擊中後會死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀\n推薦步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1034,
    "chunk_index": 27,
    "total_chunks": 52
  },
  {
    "id": "6b39a2ceecbece895fa9045975cb1888",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "{ thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 502,
    "chunk_index": 28,
    "total_chunks": 52
  },
  {
    "id": "4a04585a941d0a08fd182e9bf82e059c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "= false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 504,
    "chunk_index": 29,
    "total_chunks": 52
  },
  {
    "id": "02adf27a28d7fe52ae118def5f44fe9f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 505,
    "chunk_index": 30,
    "total_chunks": 52
  },
  {
    "id": "a8e7f3f739fe58f7d8e110f098855c89",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "{ thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 31,
    "total_chunks": 52
  },
  {
    "id": "993d4def8c7181b538ea7b8fd20cb941",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "= true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 32,
    "total_chunks": 52
  },
  {
    "id": "57b88860997b3987d546fb89569bf859",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "}, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson\n在 your_work 資料夾中輸入以下指令來啟動專案：\nbash\ncd your-work\nnpm start\n上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。\n新增程式碼\n為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它：\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 711,
    "chunk_index": 33,
    "total_chunks": 52
  },
  {
    "id": "7e0429e1c73735038efaa08d22bba379",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "{ // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy,\nleft: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 34,
    "total_chunks": 52
  },
  {
    "id": "4d99c92c41f23bcc03550760f135eeb3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 675,
    "chunk_index": 35,
    "total_chunks": 52
  },
  {
    "id": "914387824c9a58b9fcb3b6d47a249ed3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "- it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 676,
    "chunk_index": 36,
    "total_chunks": 52
  },
  {
    "id": "5578a515136be25447f08c41bfec9763",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight,\nright: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 680,
    "chunk_index": 37,
    "total_chunks": 52
  },
  {
    "id": "28df88cadc4a9c12728ef9d6186ad159",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "down yet} } } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 679,
    "chunk_index": 38,
    "total_chunks": 52
  },
  {
    "id": "7820ecd3b7c4abf06c2906f5c89c1a09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "} } ``` ✅ 回顧太空遊戲系列的第 1 課，重新了解冷卻時間的概念。 要構建的內容 你將使用上一課的現有程式碼（應該已經清理和重構過），並進行擴展。可以從第 II 部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth,\n};\n}\n新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交：\njavascript\nfunction intersectRect(r1, r2) {\nreturn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 741,
    "chunk_index": 39,
    "total_chunks": 52
  },
  {
    "id": "94af0be9d940ebec648fbe67c517bd62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "部分的程式碼開始，或者使用 第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return(\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 639,
    "chunk_index": 40,
    "total_chunks": 52
  },
  {
    "id": "d182896f242bd02bda6911671198a70f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "第 III 部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 630,
    "chunk_index": 41,
    "total_chunks": 52
  },
  {
    "id": "2f20feec605f9a86e8ce05add678283f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "部分的起始程式碼。 提示：你將使用的雷射已經在資產資料夾中，並且已在程式碼中引用。 新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 630,
    "chunk_index": 42,
    "total_chunks": 52
  },
  {
    "id": "d3a11984df00dc2c71be013d6aa4b90d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "新增碰撞偵測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後會死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 582,
    "chunk_index": 43,
    "total_chunks": 52
  },
  {
    "id": "7672e0a5d0b668c4288f4be599b4026f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "雷射擊中螢幕頂部：雷射擊中螢幕頂部後會被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都會被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 512,
    "chunk_index": 44,
    "total_chunks": 52
  },
  {
    "id": "953f35548436b500eb83f6d5e9a60726",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都會被銷毀 推薦步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1 bottom ||\nr2 bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 445,
    "chunk_index": 45,
    "total_chunks": 52
  },
  {
    "id": "fdb77fca62ed0e7c7b92363f4277656b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "-| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中輸入以下指令來啟動專案： bash cd your-work npm start 上述指令會在位址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1 bottom || r2 bottom < r1top\n);\n}\n新增雷射發射功能\n新增按鍵事件訊息。空格鍵應該在英雄飛船上方創建一個雷射。在 Messages 物件中新增三個常數：\njavascript\nKEY_EVENT_SPACE: \"KEY_EVENT_SPACE\",\nCOLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\",\nCOLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\",\n處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵：\njavascript\n} else if(evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 501,
    "chunk_index": 46,
    "total_chunks": 52
  },
  {
    "id": "1104812b24b0393d1fd0b9e22568c732",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "HTTP 伺服器。打開瀏覽器並輸入該位址，目前應該只會顯示英雄和所有敵人，暫時還沒有任何移動。 新增程式碼 為遊戲物件設置矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類別以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1 bottom || r2 bottom < r1top ); } 新增雷射發射功能 新增按鍵事件訊息。空格鍵應該在英雄飛船上方創建一個雷射。在 Messages 物件中新增三個常數： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", 處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵： javascript } else if(evtkeyCode === 32) {\neventEmitter emit(Messages KEY_EVENT_SPACE);\n}\n新增監聽器。編輯 initGame() 函數，確保當按下空格鍵時英雄可以發射雷射：\njavascript\neventEmitter on(Messages KEY_EVENT_SPACE, () => {\nif (hero canFire()) {\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 47,
    "total_chunks": 52
  },
  {
    "id": "b2f9a3205672fed83cc001b83b4c0bd3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "right: thisx + thiswidth, }; } 新增檢查碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1 bottom || r2 bottom < r1top ); } 新增雷射發射功能 新增按鍵事件訊息。空格鍵應該在英雄飛船上方創建一個雷射。在 Messages 物件中新增三個常數： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", 處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵： javascript } else if(evtkeyCode === 32) { eventEmitter emit(Messages KEY_EVENT_SPACE); } 新增監聽器。編輯 initGame() 函數，確保當按下空格鍵時英雄可以發射雷射： javascript eventEmitter on(Messages KEY_EVENT_SPACE, () => { if (hero canFire()) { herofire();\n}\n並新增一個新的 eventEmitter on() 函數，以確保當敵人與雷射碰撞時的行為：\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\n})\n```\n移動物件，確保雷射逐漸移動到螢幕頂部。你將創建一個新的 Laser 類別，繼承自 GameObject，如之前所做：\njavascript\nclass Laser extends GameObject {\nconstructor(x, y) {\nsuper(x,y);\n(this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 48,
    "total_chunks": 52
  },
  {
    "id": "08008131fc1ba5777e25a068b5f22428",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "\"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", 處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵： javascript } else if(evtkeyCode === 32) { eventEmitter emit(Messages KEY_EVENT_SPACE); } 新增監聽器。編輯 initGame() 函數，確保當按下空格鍵時英雄可以發射雷射： javascript eventEmitter on(Messages KEY_EVENT_SPACE, () => { if (hero canFire()) { herofire(); } 並新增一個新的 eventEmitter on() 函數，以確保當敵人與雷射碰撞時的行為： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; }) ``` 移動物件，確保雷射逐漸移動到螢幕頂部。你將創建一個新的 Laser 類別，繼承自 GameObject，如之前所做： javascript class Laser extends GameObject { constructor(x, y) { super(x,y); (thiswidth = 9), (this height = 33);\nthis type = 'Laser';\nthis img = laserImg;\nlet id = setInterval(() => {\nif (this y > 0) {\nthis y -= 15;\n} else {\nthis dead = true;\nclearInterval(id);\n}\n}, 100)\n}\n}\n處理碰撞，為雷射實現碰撞規則。新增一個 updateGameObjects() 函數，用於測試碰撞物件是否命中：\n```javascript\nfunction updateGameObjects() {\nconst enemies = gameObjects filter(go => go type === 'Enemy');\nconst lasers = gameObjects filter((go) => go type === \"Laser\");\n// laser hit something\nlasers forEach((l) => {\nenemies forEach((m) => {\nif (intersectRect(l rectFromGameObject(), m",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 49,
    "total_chunks": 52
  },
  {
    "id": "e14ec2c917eac1a6d74ea1006c1c9fae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "this img = laserImg; let id = setInterval(() => { if (this y > 0) { this y -= 15; } else { this dead = true; clearInterval(id); } }, 100) } } 處理碰撞，為雷射實現碰撞規則。新增一個 updateGameObjects() 函數，用於測試碰撞物件是否命中： ```javascript function updateGameObjects() { const enemies = gameObjects filter(go => go type === 'Enemy'); const lasers = gameObjects filter((go) => go type === \"Laser\"); // laser hit something lasers forEach((l) => { enemies forEach((m) => { if (intersectRect(l rectFromGameObject(), mrectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_LASER, {\nfirst: l,\nsecond: m,\n});\n}\n});\n});\ngameObjects = gameObjects filter(go => go dead);\n}\n```\n確保將 updateGameObjects() 新增到 window onload 的遊戲迴圈中。\n實現雷射的冷卻時間，確保雷射只能在一定時間間隔內發射。\n最後，編輯 Hero 類別以實現冷卻功能：\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 99), (this height = 75);\nthis type = \"Hero\";\nthis speed = { x: 0, y: 0 };\nthis cooldown = 0;\n}\nfire() {\ngameObjects push(new Laser(this x + 45, this y - 10));\nthis cooldown = 500;\nlet id = setInterval(() => {\nif (this cooldown > 0) {\nthis cooldown -= 100;\n} else {\nclearInterval(id);\n}\n}, 200);\n}\ncanFire() {\nreturn this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 427,
    "chunk_index": 50,
    "total_chunks": 52
  },
  {
    "id": "ba57eb56371e84a044f18e7adcd7583a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 4 部分：新增雷射及偵測碰撞",
    "content": "{ constructor(x, y) { super(x, y); (this width = 99), (this height = 75); this type = \"Hero\"; this speed = { x: 0, y: 0 }; this cooldown = 0; } fire() { gameObjects push(new Laser(this x + 45, this y - 10)); this cooldown = 500; let id = setInterval(() => { if (this cooldown > 0) { this cooldown -= 100; } else { clearInterval(id); } }, 200); } canFire() { return thiscooldown === 0;\n}\n}\n```\n到這一步，你的遊戲已經具備了一些功能！你可以用方向鍵移動，用空格鍵發射雷射，並且當敵人被擊中時會消失。做得好！\n🚀 挑戰\n新增爆炸效果！查看 Space Art 資源庫 中的遊戲資產，嘗試在雷射擊中外星人時新增爆炸效果。\n課後測驗\n課後測驗\n回顧與自學\n嘗試調整遊戲中的時間間隔，觀察會發生什麼變化？閱讀更多關於 JavaScript 計時事件 的內容。\n作業\n探索碰撞\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10761,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 51,
    "total_chunks": 52
  },
  {
    "id": "0b73b7ae5a4c119cb2d81ca6ae2ef93c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 690,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 194,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b018c83d6c8666b9acff13901ec0a28a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 204,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "2120999905543c60a1bc0a97de9afc94",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 704,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 195,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "d1bf5be390e05f7e5ee58269ac1a3fa6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 703,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 194,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "84f96a13e8a21e19407dee85e9e9913c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 707,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 196,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c52f8a055e501c20430fe1f69411d3f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 712,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 194,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "6f5919c645cd0a827c941c8249da4308",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 242,
    "chunk_index": 0,
    "total_chunks": 22
  },
  {
    "id": "34f9c76e295e304af9f5df96973a7666",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 679,
    "chunk_index": 1,
    "total_chunks": 22
  },
  {
    "id": "6ad064685d25299ab7a8638aab9387c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 685,
    "chunk_index": 2,
    "total_chunks": 22
  },
  {
    "id": "10f32b2ba2e02a6d4b16b8d2a299c0b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 691,
    "chunk_index": 3,
    "total_chunks": 22
  },
  {
    "id": "4fecbb52863a6ec928a99ac9442a756f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 696,
    "chunk_index": 4,
    "total_chunks": 22
  },
  {
    "id": "5bc39f89cf2de250478375557fc1a691",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 701,
    "chunk_index": 5,
    "total_chunks": 22
  },
  {
    "id": "93686fa0091fde8fc9f7ec53973caafc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 706,
    "chunk_index": 6,
    "total_chunks": 22
  },
  {
    "id": "9360f4522a5e476847029600128ac23a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建立太空遊戲第五部分：分數與生命\n課前測驗\n課前測驗\n在這一課中，你將學習如何在遊戲中加入分數計算以及生命值。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。\n要建立什麼\n讓我們在你的遊戲中加入以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。\n生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\n你可以通過輸入以下指令啟動你的專案：\nbash\ncd your-work\nnpm start\n上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。\n添加程式碼\n複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 888,
    "chunk_index": 7,
    "total_chunks": 22
  },
  {
    "id": "46b316122869309bdecd8602e61d0523",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用什麼字體、文字的顏色，甚至文字的對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。 javascript ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。 要建立什麼 讓我們在你的遊戲中加入以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 756,
    "chunk_index": 8,
    "total_chunks": 22
  },
  {
    "id": "18bb0813bf9ecb627ad3483b079b5f86",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "javascript ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。 要建立什麼 讓我們在你的遊戲中加入以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中：\njavascript\nlifeImg = await loadTexture(\"assets/life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 694,
    "chunk_index": 9,
    "total_chunks": 22
  },
  {
    "id": "1ffa9acc9fed183e31917e7ecd7bad3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。 要建立什麼 讓我們在你的遊戲中加入以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\");\n將 lifeImg 添加到資產列表中：\njavascript\nlet heroImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 706,
    "chunk_index": 10,
    "total_chunks": 22
  },
  {
    "id": "a36baf11a36d185848a6f93190c262a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "= \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。 要建立什麼 讓我們在你的遊戲中加入以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 699,
    "chunk_index": 11,
    "total_chunks": 22
  },
  {
    "id": "5f6a9109406e1dafd3b95072653a16ca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "= \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。 要建立什麼 讓我們在你的遊戲中加入以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter();\n添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。\n擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞：\njavascript\nenemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 802,
    "chunk_index": 12,
    "total_chunks": 22
  },
  {
    "id": "13b8bebb07bb4a9860f0ff67e70a6fb4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "canvas 上添加文字的內容，並隨意讓你的文字看起來更有趣！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的背景下，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一減少。如果能用圖形化的方式顯示生命值，例如小型飛船或心形圖案，而不是僅僅顯示數字，會更好。 要建立什麼 讓我們在你的遊戲中加入以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => {\nconst heroRect = hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 773,
    "chunk_index": 13,
    "total_chunks": 22
  },
  {
    "id": "9b767ed26987e64f8d9819b1dbc95f33",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "遊戲分數：每摧毀一艘敵方飛船，英雄應獲得一些分數，我們建議每艘飛船獲得 100 分。遊戲分數應顯示在左下角。 生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject();\nif (intersectRect(heroRect, enemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 586,
    "chunk_index": 14,
    "total_chunks": 22
  },
  {
    "id": "f59cb84f4022f4b2029500cd5a2736da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "生命值：你的飛船有三條生命。每當敵方飛船與你碰撞時，你會失去一條生命。生命值應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) {\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 514,
    "chunk_index": 15,
    "total_chunks": 22
  },
  {
    "id": "65b4deb76f40f007de660a1c25d80032",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "建議步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(Messages COLLISION_ENEMY_HERO, { enemy });\n}\n})\n添加生命值和分數。\n初始化變數。在 Hero 類別中的 this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 16,
    "total_chunks": 22
  },
  {
    "id": "5fa60263e857c3057cd50002b01f2a55",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "-| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) 添加生命值和分數。 初始化變數。在 Hero 類別中的 thiscooldown = 0 下，設置生命值和分數：\n```javascript\nthis life = 3;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 448,
    "chunk_index": 17,
    "total_chunks": 22
  },
  {
    "id": "6965d22af8f7b07513dfaf4a4feab55d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右箭頭時，英雄會移動並能擊落敵人。 添加程式碼 複製所需資產 從 solution/assets/ 資料夾複製到 your-work 資料夾；你需要添加一個 lifepng 資產。將 lifeImg 添加到 windowonload 函數中： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) 添加生命值和分數。 初始化變數。在 Hero 類別中的 thiscooldown = 0 下，設置生命值和分數： ```javascript this life = 3; thispoints = 0;\n```\n在螢幕上繪製變數。將這些值繪製到螢幕上：\n```javascript\nfunction drawLife() {\n// TODO, 35, 27\nconst START_POS = canvas width - 180;\nfor(let i=0; i < hero life; i++ ) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 18,
    "total_chunks": 22
  },
  {
    "id": "19300d106ae98e43a7b653d1fa151aba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "lifeImg 添加到資產列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加代表你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) 添加生命值和分數。 初始化變數。在 Hero 類別中的 thiscooldown = 0 下，設置生命值和分數： ```javascript this life = 3; thispoints = 0; ``` 在螢幕上繪製變數。將這些值繪製到螢幕上： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvas width - 180; for(let i=0; i < hero life; i++ ) { ctxdrawImage(\nlifeImg,\nSTART_POS + (45 * (i+1) ),\ncanvas height - 37);\n}\n}\nfunction drawPoints() {\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"left\";\ndrawText(\"Points: \" + hero points, 10, canvas height-20);\n}\nfunction drawText(message, x, y) {\nctx fillText(message, x, y);\n}\n```\n將方法添加到遊戲循環中。確保你在 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 412,
    "chunk_index": 19,
    "total_chunks": 22
  },
  {
    "id": "9b9a79a26ca8519b7994e2ee6f9a5155",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvas width - 180; for(let i=0; i < hero life; i++ ) { ctxdrawImage( lifeImg, START_POS + (45 * (i+1) ), canvas height - 37); } } function drawPoints() { ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"left\"; drawText(\"Points: \" + hero points, 10, canvas height-20); } function drawText(message, x, y) { ctx fillText(message, x, y); } ``` 將方法添加到遊戲循環中。確保你在 windowonload 函數中 updateGameObjects() 下添加這些函數：\n```javascript\ndrawPoints();\ndrawLife();\n```\n實現遊戲規則。實現以下遊戲規則：\n每次英雄與敵人碰撞，扣除一條生命。\n擴展 Hero 類別以執行此扣除：\n```javascript\ndecrementLife() {\nthis life--;\nif (this life === 0) {\nthis dead = true;\n}\n}\n```\n每次雷射擊中敵人，遊戲分數增加 100 分。\n擴展 Hero 類別以執行此增量：\n```javascript\nincrementPoints() {\nthis points += 100;\n}\n```\n將這些函數添加到你的碰撞事件發射器中：\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\n})\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 433,
    "chunk_index": 20,
    "total_chunks": 22
  },
  {
    "id": "8b7a97c9ad83bc9ec648a465f44407b8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第五部分：分數與生命",
    "content": "``` 實現遊戲規則。實現以下遊戲規則： 每次英雄與敵人碰撞，扣除一條生命。 擴展 Hero 類別以執行此扣除： ```javascript decrementLife() { this life--; if (this life === 0) { this dead = true; } } ``` 每次雷射擊中敵人，遊戲分數增加 100 分。 擴展 Hero 類別以執行此增量： ```javascript incrementPoints() { this points += 100; } ``` 將這些函數添加到你的碰撞事件發射器中： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); }) eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; herodecrementLife();\n});\n```\n✅ 做一些研究，了解其他使用 JavaScript/Canvas 創建的遊戲。它們有哪些共同特點？\n完成這些工作後，你應該能在右下角看到小型的“生命”飛船，在左下角看到分數，並且當你與敵人碰撞時生命值會減少，當你擊中敵人時分數會增加。做得好！你的遊戲幾乎完成了。\n🚀 挑戰\n你的程式碼幾乎完成了。你能想像下一步該做什麼嗎？\n課後測驗\n課後測驗\n回顧與自學\n研究一些方法，了解如何增減遊戲分數和生命值。有一些有趣的遊戲引擎，例如 PlayFab。使用其中一個引擎如何能提升你的遊戲？\n作業\n建立一個計分遊戲\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7078,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 21,
    "total_chunks": 22
  },
  {
    "id": "122857fd1c73e4bde6e580d7c0a5f552",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 195,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "05c39bb88456db0484c3f10c5ebfd2fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\assignment.md",
    "source_type": "git_repo",
    "title": "重新設計你的擴展",
    "content": "重新設計你的擴展\n指引\n這個擴展的代碼庫已經包含了樣式，但你不一定要使用它們；通過編輯其 CSS 文件來重新設計，讓你的擴展更具個人特色。\n評分標準\n| 標準     | 優秀                                            | 合格                 | 需要改進          |\n| -------- | -------------------------------------------- | --------------------- | ----------------- |\n|          | 提交的代碼包含功能完善的新樣式                 | 樣式不完整           | 樣式有問題        |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1254,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 357,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "d91b999009c12bb97943200e361a590f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
    "source_type": "git_repo",
    "title": "採用 API",
    "content": "採用 API\n指引\n使用 API 可以非常有趣。這裡有一個免費 API 的列表。選擇一個 API，並建立一個解決問題的瀏覽器擴展。這個問題可以很小，例如缺乏足夠的寵物圖片（可以試試 dog CEO API），或者是更大的問題——盡情享受吧！\n評分標準\n| 評分標準 | 卓越表現                                                                  | 合格表現                                 | 需要改進               |\n| -------- | -------------------------------------------------------------------------- | ---------------------------------------- | ----------------------- |\n|          | 使用上述列表中的 API 提交了一個完整的瀏覽器擴展                             | 提交了一個部分完成的瀏覽器擴展           | 提交的作品有錯誤       |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1627,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 429,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "af60f0ac71eaeb97720e221045568079",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 812,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "df91c40a0f0910ce9382d959d770f56e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 818,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "e3f90f0d61663e66bd16fdcca2db23a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 824,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "cd4c719900900779d3504ca0b23f193d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 829,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "d84fa07a62ff3874f57aea4e445c622f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 835,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "e11733533c0be43a8b125b64fac94ae4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 840,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "9f2e5eb1872ed6a3660e0b8bada13e73",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 845,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "c8168292baf7a18cd4d7843987a288b8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| packagejson\n在 your_work 資料夾中啟動你的專案，輸入以下指令：\nbash\ncd your-work\nnpm start\n上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。\n提示：為了避免在 Visual Studio Code 中出現警告，編輯 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 983,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "1de5e9635481c2f340d9863226aa5d07",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因：\n摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。\n你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。\n重新開始\n如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。\n✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。\n要建立什麼\n你將為遊戲新增以下規則：\n贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。\n重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。\n推薦步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| packagejson\n在 your_work 資料夾中啟動你的專案，輸入以下指令：\nbash\ncd your-work\nnpm start\n上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。\n提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。\n新增程式碼\n追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數：\n```javascript\nfunction isHeroDead() {\nreturn hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1107,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "1027f48dda219c69ef1e319ecdd11a6d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "在遊戲中，有多種方式來表達結束條件。作為遊戲的創作者，由你來決定遊戲為什麼會結束。如果我們假設你正在建立的太空遊戲，以下是一些可能的原因： 摧毀了 N 艘敵方飛船：如果你將遊戲分成不同的關卡，通常需要摧毀 N 艘敵方飛船來完成一個關卡。 你的飛船被摧毀：有些遊戲中，如果你的飛船被摧毀，你就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次你的飛船被摧毀，生命值就會減少一條。一旦所有生命值都用完，遊戲就結束。 收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數由你決定，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。 完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。 重新開始 如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。 ✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。 要建立什麼 你將為遊戲新增以下規則： 贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。 重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0;\n}\nfunction isEnemiesDead() {\nconst enemies = gameObjects",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1083,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "96997894e96eac22a30ca030c703f3ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分，或者收集某個特定的物品。 重新開始 如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。 ✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。 要建立什麼 你將為遊戲新增以下規則： 贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。 重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 702,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "5c569405a1a740f8655e02622d407662",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "艘敵方飛船、收集 Y 分，或者收集某個特定的物品。 重新開始 如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。 ✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。 要建立什麼 你將為遊戲新增以下規則： 贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。 重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 678,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "59f69d1f5c5798aedaafde37056b5512",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "重新開始 如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。 ✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。 要建立什麼 你將為遊戲新增以下規則： 贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。 重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 649,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "0d50d92a87cae65ab46507e118315df0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "重新開始 如果玩家喜歡你的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，你都應該提供一個重新開始的選項。 ✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。 要建立什麼 你將為遊戲新增以下規則： 贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。 重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead);\nreturn enemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "d6a82b431668b3627939ee623ec3bb51",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "✅ 想一想，遊戲在什麼條件下結束，然後玩家是如何被提示重新開始的。 要建立什麼 你將為遊戲新增以下規則： 贏得遊戲。當所有敵方飛船被摧毀時，你贏得遊戲。此外，顯示某種勝利訊息。 重新開始。當所有生命值用完或遊戲勝利時，你應該提供一個重新開始遊戲的方法。記住！你需要重新初始化遊戲，並清除之前的遊戲狀態。 推薦步驟 找到在 your-work 子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0;\n}\n```\n新增邏輯到訊息處理器。編輯 eventEmitter 來處理這些條件：\n```javascript\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "0eb02022822b94d667eeba6d2b4d9608",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "子資料夾中為你建立的檔案。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 資料夾中啟動你的專案，輸入以下指令： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。你的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在檔案頂部獨立宣告 let gameLoopId;。 新增程式碼 追蹤結束條件。新增程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，透過新增以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0; } ``` 新增邏輯到訊息處理器。編輯 eventEmitter 來處理這些條件： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero decrementLife();\nif (isHeroDead())  {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "113bfe03215a1940384d23c4e39f3bfe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0; } ``` 新增邏輯到訊息處理器。編輯 eventEmitter 來處理這些條件： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(MessagesGAME_END_LOSS);\nreturn; // loss before victory\n}\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages GAME_END_WIN, () => {\nendGame(true);\n});\neventEmitter on(Messages GAME_END_LOSS, () => {\nendGame(false);\n});\n```\n新增新的訊息類型。將這些訊息新增到常數物件中：\njavascript\nGAME_END_LOSS: \"GAME_END_LOSS\",\nGAME_END_WIN: \"GAME_END_WIN\",\n新增重新開始的程式碼，在按下選定按鈕時重新開始遊戲。\n監聽按鍵 Enter。編輯你的視窗事件監聽器，監聽此按鍵：\njavascript\nelse if(evt key === \"Enter\") {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 372,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "f6ce2729f15aa49c1b0779dd352be7b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "(isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(MessagesGAME_END_LOSS); return; // loss before victory } if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages GAME_END_WIN, () => { endGame(true); }); eventEmitter on(Messages GAME_END_LOSS, () => { endGame(false); }); ``` 新增新的訊息類型。將這些訊息新增到常數物件中： javascript GAME_END_LOSS: \"GAME_END_LOSS\", GAME_END_WIN: \"GAME_END_WIN\", 新增重新開始的程式碼，在按下選定按鈕時重新開始遊戲。 監聽按鍵 Enter。編輯你的視窗事件監聽器，監聽此按鍵： javascript else if(evt key === \"Enter\") { eventEmitter emit(MessagesKEY_EVENT_ENTER);\n}\n新增重新開始訊息。將此訊息新增到你的 Messages 常數中：\n```javascript\nKEY_EVENT_ENTER: \"KEY_EVENT_ENTER\",\n```\n實現遊戲規則。實現以下遊戲規則：\n玩家勝利條件。當所有敵方飛船被摧毀時，顯示勝利訊息。\n首先，建立一個 displayMessage() 函數：\njavascript\nfunction displayMessage(message, color = \"red\") {\nctx font = \"30px Arial\";\nctx fillStyle = color;\nctx textAlign = \"center\";\nctx fillText(message, canvas width / 2, canvas height / 2);\n}\n建立一個 endGame() 函數：\n```javascript\nfunction endGame(win) {\nclearInterval(gameLoopId);\n// set a delay so we are sure any paints have finished\nsetTimeout(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "5308a965144ef02b50ba61f0df56a74f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "\"KEY_EVENT_ENTER\", ``` 實現遊戲規則。實現以下遊戲規則： 玩家勝利條件。當所有敵方飛船被摧毀時，顯示勝利訊息。 首先，建立一個 displayMessage() 函數： javascript function displayMessage(message, color = \"red\") { ctx font = \"30px Arial\"; ctx fillStyle = color; ctx textAlign = \"center\"; ctx fillText(message, canvas width / 2, canvas height / 2); } 建立一個 endGame() 函數： ```javascript function endGame(win) { clearInterval(gameLoopId); // set a delay so we are sure any paints have finished setTimeout(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvaswidth, canvas height);\nif (win) {\ndisplayMessage(\n\"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\",\n\"green\"\n);\n} else {\ndisplayMessage(\n\"You died Press [Enter] to start a new game Captain Pew Pew\"\n);\n}\n}, 200)\n}\n```\n重新開始邏輯。當所有生命值用完或玩家贏得遊戲時，顯示可以重新開始遊戲的提示。此外，當按下重新開始按鍵時重新開始遊戲（你可以決定哪個按鍵對應重新開始）。\n建立 resetGame() 函數：\njavascript\nfunction resetGame() {\nif (gameLoopId) {\nclearInterval(gameLoopId);\neventEmitter clear();\ninitGame();\ngameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 453,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "21c14b2c54f9425f73edcde95c885eba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "displayMessage( \"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\", \"green\" ); } else { displayMessage( \"You died Press [Enter] to start a new game Captain Pew Pew\" ); } }, 200) } ``` 重新開始邏輯。當所有生命值用完或玩家贏得遊戲時，顯示可以重新開始遊戲的提示。此外，當按下重新開始按鍵時重新開始遊戲（你可以決定哪個按鍵對應重新開始）。 建立 resetGame() 函數： javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight);\ndrawPoints();\ndrawLife();\nupdateGameObjects();\ndrawGameObjects(ctx);\n}, 100);\n}\n}\n在 initGame() 中新增一個呼叫 eventEmitter 的程式碼來重置遊戲：\njavascript\neventEmitter on(Messages KEY_EVENT_ENTER, () => {\nresetGame();\n});\n為 EventEmitter 新增一個 clear() 函數：\njavascript\nclear() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 317,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "d1372f6a1a0c7d35899b8fb48a4b2c72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "Pew Pew\" ); } }, 200) } ``` 重新開始邏輯。當所有生命值用完或玩家贏得遊戲時，顯示可以重新開始遊戲的提示。此外，當按下重新開始按鍵時重新開始遊戲（你可以決定哪個按鍵對應重新開始）。 建立 resetGame() 函數： javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight); drawPoints(); drawLife(); updateGameObjects(); drawGameObjects(ctx); }, 100); } } 在 initGame() 中新增一個呼叫 eventEmitter 的程式碼來重置遊戲： javascript eventEmitter on(Messages KEY_EVENT_ENTER, () => { resetGame(); }); 為 EventEmitter 新增一個 clear() 函數： javascript clear() { thislisteners = {};\n}\n👽 💥 🚀 恭喜你，船長！你的遊戲完成了！幹得好！🚀 💥 👽\n🚀 挑戰\n新增音效！你能為遊戲新增音效來增強遊戲體驗嗎？例如當激光擊中、英雄死亡或勝利時播放音效？看看這個 sandbox 來學習如何使用 JavaScript 播放音效。\n課後測驗\n課後測驗\n回顧與自學\n你的作業是建立一個全新的遊戲範例，因此探索一些有趣的遊戲，看看你可能會建立什麼類型的遊戲。\n作業\n建立一個遊戲範例\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8570,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 701,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "6c729791a648a9c21dfc538d5a3b0a8c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
    "source_type": "git_repo",
    "title": "分析網站效能",
    "content": "分析網站效能\n提供一份詳細的網站報告，指出效能存在問題的地方。分析網站速度緩慢的原因，以及可以採取哪些措施來加快速度。不僅僅依賴瀏覽器工具，還需要研究其他可以幫助撰寫報告的工具。\n評分標準\n| 評分標準 | 卓越                                                                                                      | 合格                        | 有待改善                     |\n| -------- | ---------------------------------------------------------------------------------------------------------- | --------------------------- | ----------------------------- |\n|          | 報告詳細，內容不僅來自瀏覽器工具，還包括第三方工具（如有）                                                  | 提供基本報告                | 僅提供簡略報告               |\n免責聲明：\n本文件已使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1578,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 410,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "57504803a162e5a788281af09c0bdce2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "瀏覽器擴展項目第一部分：關於瀏覽器的一切\nSketchnote 由 Wassim Chegham 提供\n課前測驗\n課前測驗\n簡介\n瀏覽器擴展為瀏覽器添加了額外的功能。但在你開始構建之前，應該先了解一些關於瀏覽器如何運作的知識。\n關於瀏覽器\n在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴展。在這部分，你將了解瀏覽器的工作原理，並搭建瀏覽器擴展的基本結構。\n那麼，什麼是瀏覽器？它是一種軟件應用程序，允許終端用戶從伺服器訪問內容並將其顯示在網頁上。\n✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。\n一些早期的瀏覽器，圖片來源：Karen McGrane\n當用戶使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。\n此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。\n瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。\n需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。\n一個非常有用的網站是 caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 823,
    "chunk_index": 0,
    "total_chunks": 13
  },
  {
    "id": "8375b8efef51e0981a6d3389502342d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "瀏覽器擴展項目第一部分：關於瀏覽器的一切\nSketchnote 由 Wassim Chegham 提供\n課前測驗\n課前測驗\n簡介\n瀏覽器擴展為瀏覽器添加了額外的功能。但在你開始構建之前，應該先了解一些關於瀏覽器如何運作的知識。\n關於瀏覽器\n在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴展。在這部分，你將了解瀏覽器的工作原理，並搭建瀏覽器擴展的基本結構。\n那麼，什麼是瀏覽器？它是一種軟件應用程序，允許終端用戶從伺服器訪問內容並將其顯示在網頁上。\n✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。\n一些早期的瀏覽器，圖片來源：Karen McGrane\n當用戶使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。\n此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。\n瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。\n需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。\n一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。\n✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。\n瀏覽器擴展\n為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。\n開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。\n✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？\n安裝擴展\n在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似：\n注意：請確保開啟開發者模式並允許來自其他商店的擴展。\n基本過程如下：\n使用 npm run build 構建你的擴展\n在瀏覽器中通過右上角的「設置及更多」按鈕（",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1421,
    "chunk_index": 1,
    "total_chunks": 13
  },
  {
    "id": "aee7ea54f7de30bdf624443396a324e7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "瀏覽器擴展項目第一部分：關於瀏覽器的一切\nSketchnote 由 Wassim Chegham 提供\n課前測驗\n課前測驗\n簡介\n瀏覽器擴展為瀏覽器添加了額外的功能。但在你開始構建之前，應該先了解一些關於瀏覽器如何運作的知識。\n關於瀏覽器\n在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴展。在這部分，你將了解瀏覽器的工作原理，並搭建瀏覽器擴展的基本結構。\n那麼，什麼是瀏覽器？它是一種軟件應用程序，允許終端用戶從伺服器訪問內容並將其顯示在網頁上。\n✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。\n一些早期的瀏覽器，圖片來源：Karen McGrane\n當用戶使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。\n此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。\n瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。\n需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。\n一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。\n✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。\n瀏覽器擴展\n為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。\n開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。\n✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？\n安裝擴展\n在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似：\n注意：請確保開啟開發者模式並允許來自其他商店的擴展。\n基本過程如下：\n使用 npm run build 構建你的擴展\n在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面\n如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展\n或者，如果是重新加載已安裝的擴展，點擊「重新加載」\n✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。\n開始構建\n你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。\n你需要：\n一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱\n與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」）\n起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼\nNPM - NPM 是一個包管理工具；本地安裝後，package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1862,
    "chunk_index": 2,
    "total_chunks": 13
  },
  {
    "id": "e317b94fa9f7bcd1553c669fc0d346a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "Edge 瀏覽器上運行的瀏覽器擴展。在這部分，你將了解瀏覽器的工作原理，並搭建瀏覽器擴展的基本結構。 那麼，什麼是瀏覽器？它是一種軟件應用程序，允許終端用戶從伺服器訪問內容並將其顯示在網頁上。 ✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。 一些早期的瀏覽器，圖片來源：Karen McGrane 當用戶使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。 需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。 一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。 ✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。 瀏覽器擴展 為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。 開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。 ✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？ 安裝擴展 在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：請確保開啟開發者模式並允許來自其他商店的擴展。 基本過程如下： 使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用\n✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。\n花點時間瀏覽代碼庫：\ndist\n-|manifest",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1777,
    "chunk_index": 3,
    "total_chunks": 13
  },
  {
    "id": "431e636835f66dcaf2745ab63eb8791a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "McGrane 當用戶使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。 需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。 一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。 ✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。 瀏覽器擴展 為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。 開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。 ✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？ 安裝擴展 在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：請確保開啟開發者模式並允許來自其他商店的擴展。 基本過程如下： 使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡）\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1566,
    "chunk_index": 4,
    "total_chunks": 13
  },
  {
    "id": "0adf82fc7956a7dd522d479c594052a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "當用戶使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。 需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。 一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。 ✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。 瀏覽器擴展 為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。 開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。 ✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？ 安裝擴展 在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：請確保開啟開發者模式並允許來自其他商店的擴展。 基本過程如下： 使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡）\n-|background",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1580,
    "chunk_index": 5,
    "total_chunks": 13
  },
  {
    "id": "1b13f1f24a652d2068a662f9a0f645d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。 需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。 一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。 ✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。 瀏覽器擴展 為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。 開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。 ✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？ 安裝擴展 在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：請確保開啟開發者模式並允許來自其他商店的擴展。 基本過程如下： 使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡）\n-|main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1558,
    "chunk_index": 6,
    "total_chunks": 13
  },
  {
    "id": "763c099931f1352431bfa72e04a0f45c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "此時，瀏覽器的渲染引擎會將網頁顯示在用戶的設備上，這可能是手機、桌面電腦或筆記本電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄用戶的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存用戶活動的信息）等。 需要記住的一個重要事實是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線用戶。 一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。 ✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。 瀏覽器擴展 為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。 開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。 ✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？ 安裝擴展 在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：請確保開啟開發者模式並允許來自其他商店的擴展。 基本過程如下： 使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡） -|mainjs（構建後的 JS）\nsrc\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1519,
    "chunk_index": 7,
    "total_chunks": 13
  },
  {
    "id": "56ff5412f9017c1650e5c3cd0aa9c06a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "一個非常有用的網站是 caniusecom，你應該將其加入你喜歡使用的瀏覽器的書籤中。在構建網頁時，使用 caniuse 提供的支持技術列表可以幫助你更好地支持用戶。 ✅ 如何知道哪些瀏覽器在你的網站用戶中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你哪些瀏覽器在用戶中最常用。 瀏覽器擴展 為什麼要構建瀏覽器擴展？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選擇器瀏覽器擴展。如果你記不住密碼，可以使用密碼管理瀏覽器擴展。 開發瀏覽器擴展也很有趣。它們通常只需管理少量任務，但能執行得非常出色。 ✅ 你最喜歡的瀏覽器擴展是什麼？它們執行哪些任務？ 安裝擴展 在開始構建之前，先了解一下構建和部署瀏覽器擴展的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：請確保開啟開發者模式並允許來自其他商店的擴展。 基本過程如下： 使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡） -|mainjs（構建後的 JS） src -|indexjs（你的 JS 代碼在這裡）\n✅ 一旦你有了 API 密鑰和地區代碼，將它們存儲在某個筆記中以備後用。\n為擴展構建 HTML\n這個擴展有兩個視圖。一個用於收集 API 密鑰和地區代碼：\n另一個用於顯示地區的碳使用情況：\n我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。\n在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1418,
    "chunk_index": 8,
    "total_chunks": 13
  },
  {
    "id": "86ee3d4d2f2d5a4413442d6ef1cf57d4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "使用 npm run build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡） -|mainjs（構建後的 JS） src -|indexjs（你的 JS 代碼在這裡） ✅ 一旦你有了 API 密鑰和地區代碼，將它們存儲在某個筆記中以備後用。 為擴展構建 HTML 這個擴展有兩個視圖。一個用於收集 API 密鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域：\n```HTML\nNew",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 864,
    "chunk_index": 9,
    "total_chunks": 13
  },
  {
    "id": "c9eb4d7dff24c0f38b688c38a68ecaf0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "build 構建你的擴展 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴展頁面 如果是新安裝，選擇「加載未打包的擴展」來從其構建文件夾（在我們的例子中是 /dist）上傳新的擴展 或者，如果是重新加載已安裝的擴展，點擊「重新加載」 ✅ 這些指引適用於你自己構建的擴展；如果要安裝已發布到瀏覽器擴展商店的擴展，應導航到這些 商店 並安裝你選擇的擴展。 開始構建 你將構建一個顯示你所在地區碳足跡的瀏覽器擴展，展示你所在地區的能源使用情況及能源來源。該擴展將包含一個表單，用於收集 API 密鑰，以便訪問 CO2 Signal 的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡） -|mainjs（構建後的 JS） src -|indexjs（你的 JS 代碼在這裡） ✅ 一旦你有了 API 密鑰和地區代碼，將它們存儲在某個筆記中以備後用。 為擴展構建 HTML 這個擴展有兩個視圖。一個用於收集 API 密鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域： ```HTML NewAdd your Information\nRegion Name\nYour API Key from tmrow\nSubmit\n```\n這是保存信息並將其輸入到本地存儲的表單。\n接下來，創建結果區域；在最後的表單標籤下方添加一些 div：\n```HTML\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 943,
    "chunk_index": 10,
    "total_chunks": 13
  },
  {
    "id": "34060b2a15b2a7b930191a85ff253a09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "的 API。 你需要： 一個 API 密鑰；在此頁面輸入你的電子郵件，密鑰將發送到你的郵箱 與 Electricity Map 對應的 地區代碼（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡） -|mainjs（構建後的 JS） src -|indexjs（你的 JS 代碼在這裡） ✅ 一旦你有了 API 密鑰和地區代碼，將它們存儲在某個筆記中以備後用。 為擴展構建 HTML 這個擴展有兩個視圖。一個用於收集 API 密鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域： ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` 這是保存信息並將其輸入到本地存儲的表單。 接下來，創建結果區域；在最後的表單標籤下方添加一些 div： ```HTML loadingRegion:\nCarbon Usage:\nFossil Fuel Percentage:\nChange region\n```\n此時，你可以嘗試構建。確保安裝此擴展的包依賴項：\nnpm install\n此命令將使用 npm（Node 包管理器）來安裝用於擴展構建過程的 webpack。你可以通過查看 /dist/main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 697,
    "chunk_index": 11,
    "total_chunks": 13
  },
  {
    "id": "bc1c83b263030e8916c14c70686e66e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第一部分：關於瀏覽器的一切",
    "content": "NPM 是一個包管理工具；本地安裝後，packagejson 文件中列出的包將被安裝以供網頁資產使用 ✅ 在這個 優秀的學習模組 中了解更多關於包管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson（默認設置在這裡） -|indexhtml（前端 HTML 標記在這裡） -|backgroundjs（背景 JS 在這裡） -|mainjs（構建後的 JS） src -|indexjs（你的 JS 代碼在這裡） ✅ 一旦你有了 API 密鑰和地區代碼，將它們存儲在某個筆記中以備後用。 為擴展構建 HTML 這個擴展有兩個視圖。一個用於收集 API 密鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域： ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` 這是保存信息並將其輸入到本地存儲的表單。 接下來，創建結果區域；在最後的表單標籤下方添加一些 div： ```HTML loadingRegion: Carbon Usage: Fossil Fuel Percentage: Change region ``` 此時，你可以嘗試構建。確保安裝此擴展的包依賴項： npm install 此命令將使用 npm（Node 包管理器）來安裝用於擴展構建過程的 webpack。你可以通過查看 /dist/mainjs 來查看此過程的輸出——你會看到代碼已被打包。\n目前，該擴展應該可以構建，並且如果你將其部署到 Edge 作為擴展，你會看到一個整齊顯示的表單。\n恭喜你，你已經邁出了構建瀏覽器擴展的第一步。在後續課程中，你將使其更具功能性和實用性。\n🚀 挑戰\n瀏覽一個瀏覽器擴展商店並安裝一個擴展到你的瀏覽器。你可以用有趣的方式檢查其文件。你發現了什麼？\n課後測驗\n課後測驗\n回顧與自學\n在本課中，你學習了一些關於網頁瀏覽器歷史的知識；利用這個機會，通過閱讀更多歷史資料來了解萬維網的發明者如何設想其用途。一些有用的網站包括：\nThe History of Web Browsers\nHistory of the Web\nAn interview with Tim Berners-Lee\n作業\n重新設計你的擴展\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9647,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1157,
    "chunk_index": 12,
    "total_chunks": 13
  },
  {
    "id": "ab76ca708ad50675db9708e39e278135",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\README.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴展：完成的代碼",
    "content": "Carbon Trigger 瀏覽器擴展：完成的代碼\n使用 tmrow 的 C02 Signal API 追蹤電力使用情況，建立一個瀏覽器擴展，讓您可以在瀏覽器中直接提醒所在地區的電力使用情況。即時使用此擴展可以幫助您根據這些信息對活動進行判斷。\n開始使用\n您需要先安裝 npm。將此代碼下載到電腦上的一個文件夾。\n安裝所有所需的套件：\nnpm install\n使用 webpack 建立擴展：\nnpm run build\n在 Edge 瀏覽器上安裝擴展，使用瀏覽器右上角的「三點」菜單找到擴展面板。從那裡選擇「載入未打包的擴展」，然後在提示中打開「dist」文件夾，擴展就會被載入。要使用此擴展，您需要 CO2 Signal API 的 API 密鑰（在此處通過電子郵件獲取 - 在該頁面上的框中輸入您的電子郵件）以及與 Electricity Map 對應的地區代碼（例如，在波士頓，我使用「US-NEISO」）代碼列表。\n一旦在擴展界面中輸入 API 密鑰和地區代碼，瀏覽器擴展欄中的彩色點應該會根據您所在地區的能源使用情況進行變化，並給出指引，告訴您哪些高耗能活動適合進行。這個「點」系統的概念是受加州排放的 Energy Lollipop 擴展 啟發而設計的。\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2294,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 721,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "9ef139b20a55e57a77a90750df5263db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\start\\README.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴展：入門代碼",
    "content": "Carbon Trigger 瀏覽器擴展：入門代碼\n使用 tmrow 的 C02 Signal API 來追蹤電力使用情況，建立一個瀏覽器擴展，讓你可以在瀏覽器中即時獲得有關你所在地區電力使用情況的提醒。隨時使用這個擴展可以幫助你根據這些資訊對你的活動作出判斷。\n開始使用\n你需要先安裝 npm。將這段代碼下載到你電腦上的一個資料夾中。\n安裝所有所需的套件：\nnpm install\n使用 webpack 建置擴展：\nnpm run build\n在 Edge 瀏覽器上安裝，使用瀏覽器右上角的「三點」選單找到擴展面板。從那裡選擇「載入未封裝的擴展」來載入新的擴展。在提示時打開「dist」資料夾，擴展就會被載入。要使用它，你需要一個 CO2 Signal API 的 API 金鑰（點擊這裡通過電郵獲取 - 在此頁面輸入你的電郵地址）以及對應 Electricity Map 的 地區代碼（例如，在波士頓，我使用的是「US-NEISO」）。\n一旦在擴展介面中輸入了 API 金鑰和地區代碼，瀏覽器擴展欄中的彩色圓點應該會改變，反映你所在地區的能源使用情況，並給你一些建議，告訴你哪些高耗能活動是適合進行的。這個「圓點」系統的概念來自 Energy Lollipop 擴展，該擴展用於加州的排放情況。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2336,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\start\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 762,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ca69644ea4d5950945abf1209cdd4ffc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.es.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展 Carbon Trigger：完整代碼",
    "content": "瀏覽器擴展 Carbon Trigger：完整代碼\n使用 tmrow 的 C02 信號 API 來追蹤電力使用情況，創建一個瀏覽器擴展，讓您可以直接在瀏覽器中獲得有關您所在地區電力消耗的提醒。使用這個即時的擴展可以幫助您根據這些資訊來決定您的活動。\n開始使用\n您需要安裝 npm。將此代碼的副本下載到您電腦中的一個資料夾。\n安裝所有必要的套件：\nnpm install\n使用 webpack 構建擴展：\nnpm run build\n要在 Edge 中安裝，請使用瀏覽器右上角的「三點」菜單找到擴展面板。從那裡選擇「載入未封裝的擴展」來載入新的擴展。當系統提示時，打開「dist」資料夾，擴展就會被載入。要使用此擴展，您需要一個 CO2 Signal API 的 API 金鑰（在這裡通過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件）以及對應於 電力地圖 的 地區代碼（例如，在波士頓，我使用的是「US-NEISO」）。\n一旦在擴展介面中輸入了 API 金鑰和地區代碼，瀏覽器擴展欄中的顏色點應該會改變，以反映您所在地區的能源使用情況，並為您提供有關高能耗活動是否適合的指標。這個「顏色點」系統的概念靈感來自 Energy Lollipop 擴展，該擴展用於加州的排放情況。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2423,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.es.md",
      "source_type": "git_repo"
    },
    "token_count": 782,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "962e81ddee18008808b503f1b98d13e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.fr.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展 Carbon Trigger：完成的代碼",
    "content": "瀏覽器擴展 Carbon Trigger：完成的代碼\n使用 tmrow 的 C02 Signal API 來追蹤電力消耗，創建一個瀏覽器擴展，讓您可以直接在瀏覽器中獲得有關您所在地區電力消耗的提醒。使用這個即時的擴展可以幫助您根據這些資訊對您的活動作出判斷。\n開始\n您需要安裝 npm。將此代碼的副本下載到您電腦中的一個資料夾。\n安裝所有所需的套件：\nnpm install\n使用 webpack 構建擴展\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的“三點”菜單找到擴展面板。從那裡選擇“加載未壓縮的擴展”來加載新的擴展。在提示時打開 'dist' 資料夾，擴展就會被加載。要使用此擴展，您需要一個 CO2 Signal API 的 API 密鑰（在這裡通過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件）以及對應於 電力地圖 的 地區代碼（例如，在波士頓，我使用 'US-NEISO'）。\n當您在擴展介面中輸入 API 密鑰和地區代碼後，瀏覽器擴展欄中的彩色點應該會改變，以反映您所在地區的能源消耗，並為您提供有關適合進行高耗能活動的指標。這個“點”系統的概念靈感來自 Energy Lollipop 擴展，該擴展用於加州的排放情況。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2328,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.fr.md",
      "source_type": "git_repo"
    },
    "token_count": 766,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "044f274e1e7a7110cac96adc05c5a276",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.hi.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴展：完成的代碼",
    "content": "Carbon Trigger 瀏覽器擴展：完成的代碼\n使用 tmrow 的 C02 Signal API 追蹤電力使用情況，開發一個瀏覽器擴展，提醒您所在地區的電力使用情況是否繁重。使用此擴展可以幫助您根據這些資訊來決定自己的活動。\n開始使用\n您需要安裝 npm。將此代碼的副本下載到您的電腦中的一個資料夾。\n安裝所有必要的套件：\nnpm install\n使用 Webpack 建立擴展：\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的“三點”選單找到擴展面板。從那裡選擇“載入未封裝的擴展”，然後在提示中打開“dist”資料夾，擴展就會載入。要使用此擴展，您需要 CO2 Signal 的 API 金鑰（通過電子郵件在此處獲取——在該頁面的框中輸入您的電子郵件）以及 您所在地區的代碼 電力地圖（例如，在波士頓，我使用 'US-NEISO'）。\n一旦 API 金鑰和地區代碼輸入到擴展介面中，瀏覽器擴展欄中的彩色點應該會根據您所在地區的能源使用情況進行變化，並為您提供一個指標，告訴您哪些能源密集型活動適合您的操作。這個“點”系統的概念是我從加州排放的 Energy Lollipop 擴展 中獲得的靈感。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2308,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.hi.md",
      "source_type": "git_repo"
    },
    "token_count": 726,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3d7d5c5c4129bb132b35dd20af6391c1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.it.md",
    "source_type": "git_repo",
    "title": "碳觸發瀏覽器擴展：啟動代碼",
    "content": "碳觸發瀏覽器擴展：啟動代碼\n我們將使用 tmrow 的 Signal C02 API 來監測電力使用情況，並創建一個瀏覽器擴展，讓您可以直接在瀏覽器中獲得提醒，了解所在地區的電力使用情況。使用這個專門的擴展可以幫助您根據這些信息評估自己的活動。\n開始使用\n需要先安裝 npm。將此代碼下載到電腦中的一個文件夾。\n安裝所有所需的套件：\nnpm install\n使用 webpack 創建擴展：\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的“三點”菜單找到擴展面板。如果尚未啟用，請啟用開發者模式（左下角）。選擇“載入未壓縮的擴展”以載入新的擴展。在提示中打開“dist”文件夾，擴展將被載入。要使用此擴展，您需要一個 CO2 Signal API 的 API 密鑰（您可以通過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件）以及對應於電力地圖的地區代碼（例如，在波士頓，代碼是“US-NEISO”）。\n當 API 密鑰和地區代碼輸入到擴展界面後，瀏覽器擴展欄中的彩色點應該會改變，以反映該地區的能源使用情況，並提供指導，告訴您哪些高能耗活動適合執行。這個“點”系統的概念是基於Energy Lollipop 擴展提供的加州排放數據。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2389,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.it.md",
      "source_type": "git_repo"
    },
    "token_count": 773,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e9aaa6c1934e739cbda92fc70e92a077",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "瀏覽器擴展項目第 3 部分：了解背景任務和性能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學會了如何建立一個表單以及一個用於顯示從 API 獲取數據的區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何異步獲取數據。你的瀏覽器擴展幾乎已經完成了。\n現在需要處理一些背景任務，包括刷新擴展圖標的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在構建網頁資產時，讓我們從性能的角度來思考這些瀏覽器任務。\n網頁性能基礎\n「網站性能關乎兩件事：頁面加載的速度，以及頁面上的代碼運行的速度。」-- Zack Grossbart\n如何讓你的網站在各種設備、各類用戶和各種情況下都能快速運行，這個話題自然非常廣泛。以下是一些在構建標準網頁項目或瀏覽器擴展時需要記住的要點。\n確保網站高效運行的第一步是收集其性能數據。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點擊「設置及更多」按鈕（瀏覽器右上角的三點圖標），然後導航到「更多工具 > 開發者工具」，並打開「性能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「性能」標籤包含一個分析工具。打開一個網站（例如，https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 0,
    "total_chunks": 25
  },
  {
    "id": "d704d04d0ea08c099c18edfc15365d90",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "瀏覽器擴展項目第 3 部分：了解背景任務和性能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學會了如何建立一個表單以及一個用於顯示從 API 獲取數據的區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何異步獲取數據。你的瀏覽器擴展幾乎已經完成了。\n現在需要處理一些背景任務，包括刷新擴展圖標的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在構建網頁資產時，讓我們從性能的角度來思考這些瀏覽器任務。\n網頁性能基礎\n「網站性能關乎兩件事：頁面加載的速度，以及頁面上的代碼運行的速度。」-- Zack Grossbart\n如何讓你的網站在各種設備、各類用戶和各種情況下都能快速運行，這個話題自然非常廣泛。以下是一些在構建標準網頁項目或瀏覽器擴展時需要記住的要點。\n確保網站高效運行的第一步是收集其性能數據。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點擊「設置及更多」按鈕（瀏覽器右上角的三點圖標），然後導航到「更多工具 > 開發者工具」，並打開「性能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「性能」標籤包含一個分析工具。打開一個網站（例如，https://wwwmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 690,
    "chunk_index": 1,
    "total_chunks": 25
  },
  {
    "id": "b8d83ca19782037462920a6e9da5bf63",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "瀏覽器擴展項目第 3 部分：了解背景任務和性能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學會了如何建立一個表單以及一個用於顯示從 API 獲取數據的區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何異步獲取數據。你的瀏覽器擴展幾乎已經完成了。\n現在需要處理一些背景任務，包括刷新擴展圖標的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在構建網頁資產時，讓我們從性能的角度來思考這些瀏覽器任務。\n網頁性能基礎\n「網站性能關乎兩件事：頁面加載的速度，以及頁面上的代碼運行的速度。」-- Zack Grossbart\n如何讓你的網站在各種設備、各類用戶和各種情況下都能快速運行，這個話題自然非常廣泛。以下是一些在構建標準網頁項目或瀏覽器擴展時需要記住的要點。\n確保網站高效運行的第一步是收集其性能數據。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點擊「設置及更多」按鈕（瀏覽器右上角的三點圖標），然後導航到「更多工具 > 開發者工具」，並打開「性能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「性能」標籤包含一個分析工具。打開一個網站（例如，https://wwwmicrosoftcom），點擊「記錄」按鈕，然後刷新網站。隨時停止記錄，你將能看到生成的「腳本」、「渲染」和「繪製」網站的例程：\n✅ 查看 Microsoft 文檔 中有關 Edge 中性能面板的內容。\n提示：為了獲取網站啟動時間的準確讀數，請清除瀏覽器緩存。\n選擇性能時間軸的某些元素，放大頁面加載過程中發生的事件。\n通過選擇性能時間軸的一部分並查看摘要面板，獲取頁面性能的快照：\n檢查事件日誌面板，看看是否有任何事件超過了 15 毫秒：\n✅ 熟悉你的分析工具！打開此網站的開發者工具，看看是否有任何瓶頸。加載最慢的資產是什麼？最快的是什麼？\n性能分析檢查\n通常來說，為了避免在部署到生產環境時出現意外，每個網頁開發者都應該注意一些「問題區域」。\n資產大小：過去幾年，網頁變得越來越「重」，因此也變得更慢。這部分重量與圖片的使用有關。\n✅ 瀏覽 Internet Archive 以查看頁面重量的歷史數據及更多內容。\n一個好的做法是確保圖片已經過優化，並以適合用戶的大小和分辨率進行傳遞。\nDOM 遍歷：瀏覽器需要根據你編寫的代碼構建其文檔對象模型（DOM），因此為了良好的頁面性能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某個頁面使用的樣式不需要包含在主樣式表中。\nJavaScript：每個 JavaScript 開發者都應該注意「渲染阻塞」腳本，這些腳本必須在 DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。\n✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。\n現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步：\n創建一個計算顏色的函數\n在 /src/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1614,
    "chunk_index": 2,
    "total_chunks": 25
  },
  {
    "id": "275bed1d692b2f116f4fd0b233c0f6ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "瀏覽器擴展項目第 3 部分：了解背景任務和性能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學會了如何建立一個表單以及一個用於顯示從 API 獲取數據的區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何異步獲取數據。你的瀏覽器擴展幾乎已經完成了。\n現在需要處理一些背景任務，包括刷新擴展圖標的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在構建網頁資產時，讓我們從性能的角度來思考這些瀏覽器任務。\n網頁性能基礎\n「網站性能關乎兩件事：頁面加載的速度，以及頁面上的代碼運行的速度。」-- Zack Grossbart\n如何讓你的網站在各種設備、各類用戶和各種情況下都能快速運行，這個話題自然非常廣泛。以下是一些在構建標準網頁項目或瀏覽器擴展時需要記住的要點。\n確保網站高效運行的第一步是收集其性能數據。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點擊「設置及更多」按鈕（瀏覽器右上角的三點圖標），然後導航到「更多工具 > 開發者工具」，並打開「性能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「性能」標籤包含一個分析工具。打開一個網站（例如，https://wwwmicrosoftcom），點擊「記錄」按鈕，然後刷新網站。隨時停止記錄，你將能看到生成的「腳本」、「渲染」和「繪製」網站的例程：\n✅ 查看 Microsoft 文檔 中有關 Edge 中性能面板的內容。\n提示：為了獲取網站啟動時間的準確讀數，請清除瀏覽器緩存。\n選擇性能時間軸的某些元素，放大頁面加載過程中發生的事件。\n通過選擇性能時間軸的一部分並查看摘要面板，獲取頁面性能的快照：\n檢查事件日誌面板，看看是否有任何事件超過了 15 毫秒：\n✅ 熟悉你的分析工具！打開此網站的開發者工具，看看是否有任何瓶頸。加載最慢的資產是什麼？最快的是什麼？\n性能分析檢查\n通常來說，為了避免在部署到生產環境時出現意外，每個網頁開發者都應該注意一些「問題區域」。\n資產大小：過去幾年，網頁變得越來越「重」，因此也變得更慢。這部分重量與圖片的使用有關。\n✅ 瀏覽 Internet Archive 以查看頁面重量的歷史數據及更多內容。\n一個好的做法是確保圖片已經過優化，並以適合用戶的大小和分辨率進行傳遞。\nDOM 遍歷：瀏覽器需要根據你編寫的代碼構建其文檔對象模型（DOM），因此為了良好的頁面性能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某個頁面使用的樣式不需要包含在主樣式表中。\nJavaScript：每個 JavaScript 開發者都應該注意「渲染阻塞」腳本，這些腳本必須在 DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。\n✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。\n現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步：\n創建一個計算顏色的函數\n在 /src/indexjs 中，添加一個名為 calculateColor() 的函數，放在你設置的 const 變量之後，用於訪問 DOM：\n```JavaScript\nfunction calculateColor(value) {\nlet co2Scale = [0, 150, 600, 750, 800];\nlet colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02'];\nlet closestNum = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1723,
    "chunk_index": 3,
    "total_chunks": 25
  },
  {
    "id": "c956b824a3bb9f5fd32933aeb429f093",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "I（Mac）來打開開發者工具。 「性能」標籤包含一個分析工具。打開一個網站（例如，https://wwwmicrosoftcom），點擊「記錄」按鈕，然後刷新網站。隨時停止記錄，你將能看到生成的「腳本」、「渲染」和「繪製」網站的例程： ✅ 查看 Microsoft 文檔 中有關 Edge 中性能面板的內容。 提示：為了獲取網站啟動時間的準確讀數，請清除瀏覽器緩存。 選擇性能時間軸的某些元素，放大頁面加載過程中發生的事件。 通過選擇性能時間軸的一部分並查看摘要面板，獲取頁面性能的快照： 檢查事件日誌面板，看看是否有任何事件超過了 15 毫秒： ✅ 熟悉你的分析工具！打開此網站的開發者工具，看看是否有任何瓶頸。加載最慢的資產是什麼？最快的是什麼？ 性能分析檢查 通常來說，為了避免在部署到生產環境時出現意外，每個網頁開發者都應該注意一些「問題區域」。 資產大小：過去幾年，網頁變得越來越「重」，因此也變得更慢。這部分重量與圖片的使用有關。 ✅ 瀏覽 Internet Archive 以查看頁面重量的歷史數據及更多內容。 一個好的做法是確保圖片已經過優化，並以適合用戶的大小和分辨率進行傳遞。 DOM 遍歷：瀏覽器需要根據你編寫的代碼構建其文檔對象模型（DOM），因此為了良好的頁面性能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某個頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應該注意「渲染阻塞」腳本，這些腳本必須在 DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。 現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步： 創建一個計算顏色的函數 在 /src/indexjs 中，添加一個名為 calculateColor() 的函數，放在你設置的 const 變量之後，用於訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => {\nreturn Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1100,
    "chunk_index": 4,
    "total_chunks": 25
  },
  {
    "id": "b7ccf488b7fdcb55b681bbbcfd7516bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "文檔 中有關 Edge 中性能面板的內容。 提示：為了獲取網站啟動時間的準確讀數，請清除瀏覽器緩存。 選擇性能時間軸的某些元素，放大頁面加載過程中發生的事件。 通過選擇性能時間軸的一部分並查看摘要面板，獲取頁面性能的快照： 檢查事件日誌面板，看看是否有任何事件超過了 15 毫秒： ✅ 熟悉你的分析工具！打開此網站的開發者工具，看看是否有任何瓶頸。加載最慢的資產是什麼？最快的是什麼？ 性能分析檢查 通常來說，為了避免在部署到生產環境時出現意外，每個網頁開發者都應該注意一些「問題區域」。 資產大小：過去幾年，網頁變得越來越「重」，因此也變得更慢。這部分重量與圖片的使用有關。 ✅ 瀏覽 Internet Archive 以查看頁面重量的歷史數據及更多內容。 一個好的做法是確保圖片已經過優化，並以適合用戶的大小和分辨率進行傳遞。 DOM 遍歷：瀏覽器需要根據你編寫的代碼構建其文檔對象模型（DOM），因此為了良好的頁面性能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某個頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應該注意「渲染阻塞」腳本，這些腳本必須在 DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。 現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步： 創建一個計算顏色的函數 在 /src/indexjs 中，添加一個名為 calculateColor() 的函數，放在你設置的 const 變量之後，用於訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 980,
    "chunk_index": 5,
    "total_chunks": 25
  },
  {
    "id": "dfec855cd0a811f373b0cca0a1f65283",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "提示：為了獲取網站啟動時間的準確讀數，請清除瀏覽器緩存。 選擇性能時間軸的某些元素，放大頁面加載過程中發生的事件。 通過選擇性能時間軸的一部分並查看摘要面板，獲取頁面性能的快照： 檢查事件日誌面板，看看是否有任何事件超過了 15 毫秒： ✅ 熟悉你的分析工具！打開此網站的開發者工具，看看是否有任何瓶頸。加載最慢的資產是什麼？最快的是什麼？ 性能分析檢查 通常來說，為了避免在部署到生產環境時出現意外，每個網頁開發者都應該注意一些「問題區域」。 資產大小：過去幾年，網頁變得越來越「重」，因此也變得更慢。這部分重量與圖片的使用有關。 ✅ 瀏覽 Internet Archive 以查看頁面重量的歷史數據及更多內容。 一個好的做法是確保圖片已經過優化，並以適合用戶的大小和分辨率進行傳遞。 DOM 遍歷：瀏覽器需要根據你編寫的代碼構建其文檔對象模型（DOM），因此為了良好的頁面性能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某個頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應該注意「渲染阻塞」腳本，這些腳本必須在 DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。 現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步： 創建一個計算顏色的函數 在 /src/indexjs 中，添加一個名為 calculateColor() 的函數，放在你設置的 const 變量之後，用於訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value);\n})[0];\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 970,
    "chunk_index": 6,
    "total_chunks": 25
  },
  {
    "id": "120335e2a8fd746b270d38b6cdac2714",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "15 毫秒： ✅ 熟悉你的分析工具！打開此網站的開發者工具，看看是否有任何瓶頸。加載最慢的資產是什麼？最快的是什麼？ 性能分析檢查 通常來說，為了避免在部署到生產環境時出現意外，每個網頁開發者都應該注意一些「問題區域」。 資產大小：過去幾年，網頁變得越來越「重」，因此也變得更慢。這部分重量與圖片的使用有關。 ✅ 瀏覽 Internet Archive 以查看頁面重量的歷史數據及更多內容。 一個好的做法是確保圖片已經過優化，並以適合用戶的大小和分辨率進行傳遞。 DOM 遍歷：瀏覽器需要根據你編寫的代碼構建其文檔對象模型（DOM），因此為了良好的頁面性能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某個頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應該注意「渲染阻塞」腳本，這些腳本必須在 DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。 現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步： 創建一個計算顏色的函數 在 /src/indexjs 中，添加一個名為 calculateColor() 的函數，放在你設置的 const 變量之後，用於訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum);\nlet num = (element) => element > closestNum;\nlet scaleIndex = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 852,
    "chunk_index": 7,
    "total_chunks": 25
  },
  {
    "id": "78252a0fdb8a18c2ab867a981b285457",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "DOM 遍歷和繪製到瀏覽器之前加載。考慮對內聯腳本使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於確定網站性能的常見檢查。 現在你已經了解了瀏覽器如何渲染你傳遞的資產，讓我們來看看完成擴展所需的最後幾步： 創建一個計算顏色的函數 在 /src/indexjs 中，添加一個名為 calculateColor() 的函數，放在你設置的 const 變量之後，用於訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num);\nlet closestColor = colors[scaleIndex];\nconsole log(scaleIndex, closestColor);\nchrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } });\n}\n```\n這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 8,
    "total_chunks": 25
  },
  {
    "id": "765c7e6a2329a6404e7db338784452d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "[0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它：\n「使用 chrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 290,
    "chunk_index": 9,
    "total_chunks": 25
  },
  {
    "id": "ee5a683edb6ddf06d3619dfd43da0f2d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」\n✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。\n注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。\n設置默認圖標顏色\n現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色：\nJavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 578,
    "chunk_index": 10,
    "total_chunks": 25
  },
  {
    "id": "7179c89bb1fdcd32f4267dab58881fc6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 11,
    "total_chunks": 25
  },
  {
    "id": "f4750a869dd232ae2c4fe282bcc124e8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({\naction: 'updateIcon',\nvalue: {\ncolor: 'green',\n},\n});\n調用函數並執行調用\n接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數：\nJavaScript\n//let CO2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 594,
    "chunk_index": 12,
    "total_chunks": 25
  },
  {
    "id": "dbad04f96c9773d51ca75aa54a9d6288",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2);\n最後，在 /dist/background",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 13,
    "total_chunks": 25
  },
  {
    "id": "83c807f59b6e04670bf5df2a2a6dc26e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "= colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器：\n```JavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 599,
    "chunk_index": 14,
    "total_chunks": 25
  },
  {
    "id": "5770a25f7d16f9149981ce9f44c203a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 15,
    "total_chunks": 25
  },
  {
    "id": "4c957bdf5228451b1cc14b1684cb1be8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 595,
    "chunk_index": 16,
    "total_chunks": 25
  },
  {
    "id": "b418422b2e869e0d10b465c63f4bad27",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) {\nif (msg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 609,
    "chunk_index": 17,
    "total_chunks": 25
  },
  {
    "id": "6df78100844a9f0bb854f055223efe4e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') {\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 604,
    "chunk_index": 18,
    "total_chunks": 25
  },
  {
    "id": "521a2d58e628585699ecad49110d74bc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserAction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 598,
    "chunk_index": 19,
    "total_chunks": 25
  },
  {
    "id": "5ea57cf51b358fa59215539a464311a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 20,
    "total_chunks": 25
  },
  {
    "id": "40a95a681ea2af70cd65fc66fce2e4c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "}); } ``` 這裡發生了什麼？你傳入一個值（來自上一課完成的 API 調用的碳強度），然後計算其值與顏色數組中索引的接近程度。接著，你將最接近的顏色值發送到 chrome runtime。 chromeruntime 有一個 API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) });\n}\n});\n//borrowed from energy lollipop extension, nice feature",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 618,
    "chunk_index": 21,
    "total_chunks": 25
  },
  {
    "id": "542b0a81b42d495429abb94515695b83",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "API，用於處理各種背景任務，而你的擴展正在利用它： 「使用 chromeruntime API 獲取背景頁面，返回有關清單的詳細信息，並監聽和響應應用或擴展生命週期中的事件。你還可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) {\nlet canvas = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 22,
    "total_chunks": 25
  },
  {
    "id": "657f7f6e3b3a30e61d2fbcccd9f14dd9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴展，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴展，請從擴展本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置默認圖標顏色 現在，在 init() 函數中，通過調用 chrome 的 updateIcon 操作，將圖標設置為默認的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas');\nlet context = canvas getContext('2d');\ncontext beginPath();\ncontext fillStyle = value color;\ncontext arc(100, 100, 50, 0, 2 * Math PI);\ncontext fill();\nreturn context",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 23,
    "total_chunks": 25
  },
  {
    "id": "e9af5d380a21896dd105271f9315eef7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第 3 部分：了解背景任務和性能",
    "content": "action: 'updateIcon', value: { color: 'green', }, }); 調用函數並執行調用 接下來，通過將該函數添加到 C02Signal API 返回的 promise 中來調用你剛剛創建的函數： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，為這些背景操作調用添加監聽器： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvas getContext('2d'); context beginPath(); context fillStyle = value color; context arc(100, 100, 50, 0, 2 * Math PI); context fill(); return contextgetImageData(50, 50, 100, 100);\n}\n```\n在這段代碼中，你為任何發送到後端任務管理器的消息添加了一個監聽器。如果消息名為 'updateIcon'，則運行下一段代碼，使用 Canvas API 繪製適當顏色的圖標。\n✅ 你將在 太空遊戲課程 中學到更多有關 Canvas API 的知識。\n現在，重新構建你的擴展（npm run build），刷新並啟動你的擴展，觀察顏色變化。現在是跑腿或洗碗的好時機嗎？現在你知道了！\n恭喜你，你已經構建了一個實用的瀏覽器擴展，並學到了更多有關瀏覽器如何運作以及如何分析其性能的知識。\n🚀 挑戰\n調查一些存在已久的開源網站，根據其 GitHub 歷史，看看它們是否在多年來進行了性能優化。如果有，最常見的痛點是什麼？\n課後測驗\n課後測驗\n回顧與自學\n考慮訂閱一份 性能新聞簡報\n通過瀏覽器的開發者工具中的性能標籤，調查瀏覽器如何評估網頁性能。你發現了哪些主要差異？\n作業\n分析網站性能\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9147,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 904,
    "chunk_index": 24,
    "total_chunks": 25
  },
  {
    "id": "f17a62910d89d0c8dd16b3fd2246eec2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.ja.md",
    "source_type": "git_repo",
    "title": "碳觸發瀏覽器擴展功能：完成的代碼",
    "content": "碳觸發瀏覽器擴展功能：完成的代碼\n使用 tmrow 的 C02 Signal API 來追蹤電力使用情況，並在瀏覽器上顯示您所在地區的電力使用量作為提醒。透過這個瀏覽器擴展功能，您可以根據這些資訊來判斷自己的活動。\n開始使用\n您需要先安裝 npm。將此代碼的副本下載到您電腦上的資料夾中。\n安裝所有必要的套件。\nnpm install\n使用 webpack 來構建擴展功能。\nnpm run build\n要在 Edge 中安裝，請在瀏覽器右上角的「三點」菜單中找到「擴展功能」面板。從那裡選擇「載入未打包的擴展功能」，然後載入新的擴展功能。在提示中打開「dist」資料夾，擴展功能就會被載入。要使用此功能，您需要 CO2 Signal API 的 API 金鑰 (在此處通過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件) 和 Electricity Map 對應的 您所在地區的代碼 (例如，在波士頓使用 'US-NEISO')。\n在擴展介面中輸入 API 金鑰和地區代碼後，瀏覽器擴展欄中的彩色圓點會根據您所在地區的能源使用情況進行變化，並提示您進行哪些活動是適合的。這個「圓點」系統的概念是受加州排放量的 Energy Lollipop 擴展功能 啟發而來的。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2326,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.ja.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e889a611414a8c70eb2336081f46f30b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業的人類翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 721,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 206,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "90cffaed9384a793106901ee24e8837d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.ms.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴展：完整代碼",
    "content": "Carbon Trigger 瀏覽器擴展：完整代碼\n使用 tmrow 的 C02 Signal API 來檢測電力使用情況，構建一個瀏覽器擴展，讓您可以在瀏覽器中收到有關您所在地區電力使用情況的提醒。使用這個擴展可以幫助您根據這些資訊來調整您的活動。\n開始使用\n您需要安裝 npm。將此代碼的副本下載到您電腦上的一個文件夾中。\n安裝所有所需的套件：\nnpm install\n使用 webpack 構建擴展：\nnpm run build\n要在 Edge 中安裝，請使用瀏覽器右上角的“三點”菜單找到擴展面板。從那裡選擇“加載未打包的擴展”來加載新的擴展。根據提示打開“dist”文件夾，擴展就會被加載。要使用它，您需要一個 CO2 Signal API 的 API 密鑰（在這裡通過電子郵件獲取 - 在頁面上的框中輸入您的電子郵件）以及 對應於您地區的代碼，這些代碼可以在 Electricity Map 上找到（例如，在波士頓，我使用的是“US-NEISO”）。\n當您將 API 密鑰和地區代碼輸入到擴展的界面後，瀏覽器擴展欄中的彩色點將會改變，以反映您所在地區的能源使用情況，並為您提供建議，告訴您哪些高耗能活動適合進行。這個“彩色點”系統的概念靈感來自 Energy Lollipop 瀏覽器擴展，該擴展專為加州的排放量設計。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2420,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\solution\\translation\\README.ms.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0eadc1213e5098a13efb378526cc8846",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\assignment.md",
    "source_type": "git_repo",
    "title": "建立一個新的鍵盤遊戲",
    "content": "建立一個新的鍵盤遊戲\n指示\n創建一個使用鍵盤事件來完成任務的小型遊戲。它可以是一種不同類型的打字遊戲，或者是一種藝術型遊戲，透過按鍵在螢幕上繪製像素。發揮創意！\n評分標準\n| 評分標準 | 表現卓越                  | 表現尚可                  | 需要改進         |\n| -------- | ------------------------ | ------------------------ | ----------------- |\n|          | 提供完整的遊戲            | 遊戲非常簡單              | 遊戲有錯誤       |\n|          |                          |                          |                   |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業的人類翻譯服務。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1354,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 417,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c54eaf4a94e48b5a13d6036e4ce81bdd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\assignment.md",
    "source_type": "git_repo",
    "title": "練習你的 HTML：建立部落格模型",
    "content": "練習你的 HTML：建立部落格模型\n指示\n想像你正在設計或重新設計你的個人網站。創建一個網站的圖形模型，然後寫下你會使用的 HTML 標記來構建網站的各個元素。你可以在紙上完成，然後掃描它，或者使用你選擇的軟件，只需確保手動編寫 HTML 標記。\n評分標準\n| 評分標準 | 卓越表現                                                                           | 合格表現                                                                         | 需要改進                                                                 |\n| -------- | ----------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |\n|          | 部落格佈局以視覺方式呈現，並顯示至少 10 個標記元素                                  | 部落格佈局以視覺方式呈現，並顯示約 5 個標記元素                                  | 部落格佈局以視覺方式呈現，並顯示最多 3 個標記元素                          |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1911,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "055f43f24122a39c5b56daafa4257975",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲\n課前測驗\n課前測驗\n簡介\n在本課中，你將通過提交瀏覽器擴展的表單來調用 API，並在瀏覽器擴展中顯示結果。此外，你還將學習如何將數據存儲在瀏覽器的本地存儲中，以供未來參考和使用。\n✅ 按照適當文件中的編號段落，了解應將代碼放置在哪裡。\n設置擴展中需要操作的元素：\n到目前為止，你已經為瀏覽器擴展構建了表單和結果 <div> 的 HTML。接下來，你需要在 /src/index js 文件中工作，逐步構建你的擴展。參考上一課了解如何設置項目和構建過程。\n在 index js 文件中工作，首先創建一些 const 變量來保存與各個字段相關的值：\n```JavaScript\n// form fields\nconst form = document querySelector(' form-data');\nconst region = document querySelector(' region-name');\nconst apiKey = document querySelector(' api-key');\n// results\nconst errors = document querySelector(' errors');\nconst loading = document querySelector(' loading');\nconst results = document querySelector(' result-container');\nconst usage = document querySelector(' carbon-usage');\nconst fossilfuel = document querySelector(' fossil-fuel');\nconst myregion = document querySelector(' my-region');\nconst clearBtn = document querySelector('",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 460,
    "chunk_index": 0,
    "total_chunks": 38
  },
  {
    "id": "84715e51ed7e1e0eeeea1e65b241643e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "的 HTML。接下來，你需要在 /src/index js 文件中工作，逐步構建你的擴展。參考上一課了解如何設置項目和構建過程。 在 index js 文件中工作，首先創建一些 const 變量來保存與各個字段相關的值： ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn');\n```\n所有這些字段都是通過它們的 CSS 類名引用的，這些類名是在上一課的 HTML 中設置的。\n添加事件監聽器\n接下來，為表單和重置按鈕添加事件監聽器，這樣當用戶提交表單或點擊重置按鈕時，會觸發某些操作，並在文件底部添加初始化應用的調用：\nJavaScript\nform addEventListener('submit', (e) => handleSubmit(e));\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 359,
    "chunk_index": 1,
    "total_chunks": 38
  },
  {
    "id": "01301b169fe5ac47fd0f9cbfba67af2d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn'); ``` 所有這些字段都是通過它們的 CSS 類名引用的，這些類名是在上一課的 HTML 中設置的。 添加事件監聽器 接下來，為表單和重置按鈕添加事件監聽器，這樣當用戶提交表單或點擊重置按鈕時，會觸發某些操作，並在文件底部添加初始化應用的調用： JavaScript form addEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e));\ninit();\n✅ 注意這裡使用的簡寫方式來監聽提交或點擊事件，以及事件如何被傳遞到 handleSubmit 或 reset 函數。你能否用更長的格式寫出這個簡寫的等效代碼？你更喜歡哪種方式？\n構建 init() 函數和 reset() 函數：\n現在你需要構建初始化擴展的函數，該函數名為 init()：\n```JavaScript\nfunction init() {\n//if anything is in localStorage, pick it up\nconst storedApiKey = localStorage getItem('apiKey');\nconst storedRegion = localStorage getItem('regionName');\n//set icon to be generic green\n//todo\nif (storedApiKey === null || storedRegion === null) {\n//if we don't have the keys, show the form\nform style display = 'block';\nresults style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 2,
    "total_chunks": 38
  },
  {
    "id": "68a3cbdc7f0cb292f50e850f2bd15e1b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "addEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e)); init(); ✅ 注意這裡使用的簡寫方式來監聽提交或點擊事件，以及事件如何被傳遞到 handleSubmit 或 reset 函數。你能否用更長的格式寫出這個簡寫的等效代碼？你更喜歡哪種方式？ 構建 init() 函數和 reset() 函數： 現在你需要構建初始化擴展的函數，該函數名為 init()： ```JavaScript function init() { //if anything is in localStorage, pick it up const storedApiKey = localStorage getItem('apiKey'); const storedRegion = localStorage getItem('regionName'); //set icon to be generic green //todo if (storedApiKey === null || storedRegion === null) { //if we don't have the keys, show the form form style display = 'block'; results styledisplay = 'none';\nloading style display = 'none';\nclearBtn style display = 'none';\nerrors textContent = '';\n} else {\n//if we have saved keys/regions in localStorage, show results when they load\ndisplayCarbonUsage(storedApiKey, storedRegion);\nresults style display = 'none';\nform style display = 'none';\nclearBtn style display = 'block';\n}\n};\nfunction reset(e) {\ne preventDefault();\n//clear local storage for region only\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 344,
    "chunk_index": 3,
    "total_chunks": 38
  },
  {
    "id": "b6d758d0706472f3bc113af22faf6260",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "don't have the keys, show the form form style display = 'block'; results styledisplay = 'none'; loading style display = 'none'; clearBtn style display = 'none'; errors textContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName');\ninit();\n}\n```\n在這個函數中，有一些有趣的邏輯。仔細閱讀，你能看出發生了什麼嗎？\n設置兩個 const 來檢查用戶是否在本地存儲中保存了 APIKey 和地區代碼。\n如果其中任何一個為 null，通過將表單的樣式更改為 'block' 來顯示表單。\n隱藏結果、加載和 clearBtn，並將任何錯誤文本設置為空字符串。\n如果存在密鑰和地區，啟動一個例程以：\n調用 API 獲取碳使用數據。\n隱藏結果區域。\n隱藏表單。\n顯示重置按鈕。\n在繼續之前，了解瀏覽器中一個非常重要的概念：LocalStorage。LocalStorage 是一種有用的方法，可以將字符串以 key-value 的形式存儲在瀏覽器中。這種類型的網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而 SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。\n注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。\n你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。\n✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。\n注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。\n在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。\n處理表單提交\n創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1014,
    "chunk_index": 4,
    "total_chunks": 38
  },
  {
    "id": "50f5a22978a2d8c10fe04e946a78b57a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "local storage for region only localStorageremoveItem('regionName'); init(); } ``` 在這個函數中，有一些有趣的邏輯。仔細閱讀，你能看出發生了什麼嗎？ 設置兩個 const 來檢查用戶是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載和 clearBtn，並將任何錯誤文本設置為空字符串。 如果存在密鑰和地區，啟動一個例程以： 調用 API 獲取碳使用數據。 隱藏結果區域。 隱藏表單。 顯示重置按鈕。 在繼續之前，了解瀏覽器中一個非常重要的概念：LocalStorage。LocalStorage 是一種有用的方法，可以將字符串以 key-value 的形式存儲在瀏覽器中。這種類型的網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而 SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。 注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 917,
    "chunk_index": 5,
    "total_chunks": 38
  },
  {
    "id": "5eac49d4178c21306846b2fd540d5f93",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "for region only localStorageremoveItem('regionName'); init(); } ``` 在這個函數中，有一些有趣的邏輯。仔細閱讀，你能看出發生了什麼嗎？ 設置兩個 const 來檢查用戶是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載和 clearBtn，並將任何錯誤文本設置為空字符串。 如果存在密鑰和地區，啟動一個例程以： 調用 API 獲取碳使用數據。 隱藏結果區域。 隱藏表單。 顯示重置按鈕。 在繼續之前，了解瀏覽器中一個非常重要的概念：LocalStorage。LocalStorage 是一種有用的方法，可以將字符串以 key-value 的形式存儲在瀏覽器中。這種類型的網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而 SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。 注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。\nJavaScript\nfunction handleSubmit(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 970,
    "chunk_index": 6,
    "total_chunks": 38
  },
  {
    "id": "013502234f9b537ce41105831b71630c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "} ``` 在這個函數中，有一些有趣的邏輯。仔細閱讀，你能看出發生了什麼嗎？ 設置兩個 const 來檢查用戶是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載和 clearBtn，並將任何錯誤文本設置為空字符串。 如果存在密鑰和地區，啟動一個例程以： 調用 API 獲取碳使用數據。 隱藏結果區域。 隱藏表單。 顯示重置按鈕。 在繼續之前，了解瀏覽器中一個非常重要的概念：LocalStorage。LocalStorage 是一種有用的方法，可以將字符串以 key-value 的形式存儲在瀏覽器中。這種類型的網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而 SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。 注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault();\nsetUpUser(apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 960,
    "chunk_index": 7,
    "total_chunks": 38
  },
  {
    "id": "41c6e64dc4f80f09d1caea8c4353bd75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "``` 在這個函數中，有一些有趣的邏輯。仔細閱讀，你能看出發生了什麼嗎？ 設置兩個 const 來檢查用戶是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載和 clearBtn，並將任何錯誤文本設置為空字符串。 如果存在密鑰和地區，啟動一個例程以： 調用 API 獲取碳使用數據。 隱藏結果區域。 隱藏表單。 顯示重置按鈕。 在繼續之前，了解瀏覽器中一個非常重要的概念：LocalStorage。LocalStorage 是一種有用的方法，可以將字符串以 key-value 的形式存儲在瀏覽器中。這種類型的網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而 SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。 注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 962,
    "chunk_index": 8,
    "total_chunks": 38
  },
  {
    "id": "87d14e78dd2691acd71f867e15bd9c56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "在這個函數中，有一些有趣的邏輯。仔細閱讀，你能看出發生了什麼嗎？ 設置兩個 const 來檢查用戶是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載和 clearBtn，並將任何錯誤文本設置為空字符串。 如果存在密鑰和地區，啟動一個例程以： 調用 API 獲取碳使用數據。 隱藏結果區域。 隱藏表單。 顯示重置按鈕。 在繼續之前，了解瀏覽器中一個非常重要的概念：LocalStorage。LocalStorage 是一種有用的方法，可以將字符串以 key-value 的形式存儲在瀏覽器中。這種類型的網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而 SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。 注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue);\n}\n✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。\n設置用戶\n接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數：\nJavaScript\nfunction setUpUser(apiKey, regionName) {\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1124,
    "chunk_index": 9,
    "total_chunks": 38
  },
  {
    "id": "2fedbfeb27aff1ee65675aa5cae66c22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "SessionStorage（另一種網頁存儲）會在瀏覽器關閉時清除。不同類型的存儲有其使用的優缺點。 注意 - 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey);\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 779,
    "chunk_index": 10,
    "total_chunks": 38
  },
  {
    "id": "43fdca125aa9f4ce1a1c24bb53f56445",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "- 你的瀏覽器擴展有自己的本地存儲；主瀏覽器窗口是不同的實例，行為獨立。 你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName);\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 734,
    "chunk_index": 11,
    "total_chunks": 38
  },
  {
    "id": "0624e6ba04df35b1fa4872dc13643f98",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 681,
    "chunk_index": 12,
    "total_chunks": 38
  },
  {
    "id": "f5af96f3994e57b897d13d90395781e8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "你可以將 APIKey 設置為一個字符串值，例如，你可以通過 \"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block';\nerrors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 687,
    "chunk_index": 13,
    "total_chunks": 38
  },
  {
    "id": "4fcc32a09879ee53f8a5e5f03fd1d372",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "\"檢查\" 網頁（你可以右鍵點擊瀏覽器進行檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = '';\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 668,
    "chunk_index": 14,
    "total_chunks": 38
  },
  {
    "id": "7e4dc6ee6a3dfb5238ad62f8348dc485",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 15,
    "total_chunks": 38
  },
  {
    "id": "c330afa9a5ef6b6fda6c7b5e0e0f9cc5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "標籤查看存儲來看到它在 Edge 上的設置。 ✅ 思考哪些情況下你不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！你能看出原因嗎？在我們的情況下，由於我們的應用僅用於學習，並不會部署到應用商店，因此我們將使用這種方法。 注意，你使用 Web API 操作 LocalStorage，可以使用 getItem()、setItem() 或 removeItem()。它在各瀏覽器中廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 創建一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳入參數 apiKeyvalue 和 regionvalue。通過這種方式，你使用了通過初始表單輸入的兩個值，當適當字段被填充時。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回憶一下 - 你在上一課設置的 HTML 有兩個輸入字段，其 values 是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block';\n//make initial call\ndisplayCarbonUsage(apiKey, regionName);\n}\n此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！\n顯示碳使用數據\n最後，是時候查詢 API 了！\n在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。\n✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？\n此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。\n這裡有一段關於 async 的快速視頻：\n🎥 點擊上方圖片觀看關於 async/await 的視頻。\n創建一個新函數來查詢 C02Signal API：\n```JavaScript\nimport axios from '",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1151,
    "chunk_index": 16,
    "total_chunks": 38
  },
  {
    "id": "b73effbe0eccd7e20e1590cea5351d81",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "是通過你在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止用戶輸入空值。 設置用戶 接下來是 setUpUser 函數，這裡你設置了本地存儲的 apiKey 和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios';\nasync function displayCarbonUsage(apiKey, region) {\ntry {\nawait axios",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 17,
    "total_chunks": 38
  },
  {
    "id": "7129800ea3ac3eac6fa8d428794d60d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://api",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 618,
    "chunk_index": 18,
    "total_chunks": 38
  },
  {
    "id": "f1edf5a32d9ce8487486e61b4573f842",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signal",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 19,
    "total_chunks": 38
  },
  {
    "id": "a904343c814a6e72fe1575e2d9fc017b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "和 regionName 值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', {\nparams: {\ncountryCode: region,\n},\nheaders: {\n'auth-token': apiKey,\n},\n})",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 647,
    "chunk_index": 20,
    "total_chunks": 38
  },
  {
    "id": "b5ddee0a7c372832e87ae64fa6242291",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => {\nlet CO2 = Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 21,
    "total_chunks": 38
  },
  {
    "id": "80a9c88b3cdd5c6db0099f2580fb2bdc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 594,
    "chunk_index": 22,
    "total_chunks": 38
  },
  {
    "id": "9206123792c4ea5fff9d2d7a7a8aa0b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 596,
    "chunk_index": 23,
    "total_chunks": 38
  },
  {
    "id": "a3c3cc8d7a7d1326ce28f11e90f32501",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 598,
    "chunk_index": 24,
    "total_chunks": 38
  },
  {
    "id": "a732b11315874a0bef34ae9fbe71f1af",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity);\n//calculateColor(CO2);\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 609,
    "chunk_index": 25,
    "total_chunks": 38
  },
  {
    "id": "f0bea05275a6c56cab5283d056c96e80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 26,
    "total_chunks": 38
  },
  {
    "id": "750c1cb8689fff49993f5b0186d32cd7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none';\nform",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 611,
    "chunk_index": 27,
    "total_chunks": 38
  },
  {
    "id": "784f5c279e69c20db8bee6591ed70aa1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 28,
    "total_chunks": 38
  },
  {
    "id": "eaefd541643e7481990aaed1e71eb0cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none';\nmyregion",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 613,
    "chunk_index": 29,
    "total_chunks": 38
  },
  {
    "id": "b9c55c7cdfb90e1816bfd76e22faecd0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "} 此函數設置了一條加載消息，以在調用 API 時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region;\nusage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 608,
    "chunk_index": 30,
    "total_chunks": 38
  },
  {
    "id": "8fa4f30868495b1e5a4ceacac59a4fdf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "時顯示。到此為止，你已經到達了創建此瀏覽器擴展最重要的函數！ 顯示碳使用數據 最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent =\nMath",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 585,
    "chunk_index": 31,
    "total_chunks": 38
  },
  {
    "id": "89246ea422d3413a7c049203c76b5a18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 531,
    "chunk_index": 32,
    "total_chunks": 38
  },
  {
    "id": "a48290a2d5c38e5c59e13524889d62d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 533,
    "chunk_index": 33,
    "total_chunks": 38
  },
  {
    "id": "f6afd34855b3c1862193debac1e831b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 34,
    "total_chunks": 38
  },
  {
    "id": "a8d4e7f69af8aa84c87921c41613ecf4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "最後，是時候查詢 API 了！ 在進一步之前，我們應該討論 API。API，即應用程序編程接口，是網頁開發者工具箱中的關鍵元素。它們提供了程序之間交互和接口的標準方式。例如，如果你正在構建一個需要查詢數據庫的網站，可能有人已經為你創建了一個 API 可以使用。雖然有許多類型的 API，其中一種最流行的是 REST API。 ✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)';\nfossilfuel",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 555,
    "chunk_index": 35,
    "total_chunks": 38
  },
  {
    "id": "e7575b718d105a351df9eb251719c028",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "✅ \"REST\" 的意思是 \"表現層狀態轉移\"，其特點是使用不同配置的 URL 來獲取數據。研究一下開發者可用的各種 API 類型。哪種格式最吸引你？ 此函數有一些重要的注意事項。首先，注意 async 關鍵字。將函數設計為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一段關於 async 的快速視頻： 🎥 點擊上方圖片觀看關於 async/await 的視頻。 創建一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent =\nresponse data data fossilFuelPercentage toFixed(2) +\n'% (percentage of fossil fuels used to generate electricity)';\nresults style display = 'block';\n});\n} catch (error) {\nconsole log(error);\nloading style display = 'none';\nresults style display = 'none';\nerrors textContent = 'Sorry, we have no data for the region you have requested",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 453,
    "chunk_index": 36,
    "total_chunks": 38
  },
  {
    "id": "e4447a3fb7561601ea1b92ff10695204",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴展項目第二部分：調用 API，使用本地存儲",
    "content": "Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = response data data fossilFuelPercentage toFixed(2) + '% (percentage of fossil fuels used to generate electricity)'; results style display = 'block'; }); } catch (error) { console log(error); loading style display = 'none'; results style display = 'none'; errors textContent = 'Sorry, we have no data for the region you have requested';\n}\n}\n```\n這是一個較大的函數。這裡發生了什麼？\n遵循最佳實踐，你使用 async 關鍵字使此函數異步運行。該函數包含一個 try/catch 塊，因為當 API 返回數據時，它會返回一個 Promise。由於你無法控制 API 的響應速度（它可能根本不響應！），你需要通過異步調用來處理這種不確定性。\n你正在查詢 co2signal API 以獲取地區數據，使用你的 API 密鑰。要使用該密鑰，你需要在 header 參數中使用一種身份驗證方式。\n一旦 API 響應，你將其響應數據的各個元素分配給你設置的屏幕部分以顯示這些數據。\n如果出現錯誤或沒有結果，你會顯示一條錯誤消息。\n✅ 使用異步編程模式是工具箱中的另一個非常有用的工具。閱讀各種配置此類代碼的方法。\n恭喜！如果你構建了擴展（npm run build）並在擴展面板中刷新它，你就擁有了一個可運行的擴展！唯一未完成的是圖標，你將在下一課中修復它。\n🚀 挑戰\n我們在這些課程中已經討論了幾種 API。選擇一個網絡 API，深入研究它提供的功能。例如，查看瀏覽器中可用的 API，例如 HTML 拖放 API。在你看來，什麼樣的 API 是優秀的？\n課後測驗\n課後測驗\n回顧與自學\n在本課中，你學習了 LocalStorage 和 API，這兩者對專業網頁開發者都非常有用。你能想到這兩者如何協同工作嗎？思考一下如何設計一個網站，將項目存儲起來以供 API 使用。\n作業\n採用一個 API\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11733,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1042,
    "chunk_index": 37,
    "total_chunks": 38
  },
  {
    "id": "f5b05f6962156e968c5a5eb1cfac9fb1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\assignment.md",
    "source_type": "git_repo",
    "title": "CSS 重構",
    "content": "CSS 重構\n指示\n使用 Flexbox 或 CSS Grid 重新設計植物箱的樣式，並截圖以顯示已在多個瀏覽器上進行測試。可能需要修改標記，因此請建立應用程式的新版本，並將藝術作品放置於重構中。不用擔心讓元素可拖曳；目前只需重構 HTML 和 CSS。\n評分標準\n| 標準     | 卓越表現                                                         | 合格表現                      | 需要改進                            |\n| -------- | ----------------------------------------------------------------- | ----------------------------- | ------------------------------------ |\n|          | 使用 Flexbox 或 CSS Grid 完全重新設計植物箱樣式                   | 重新設計部分元素樣式          | 未能重新設計植物箱樣式              |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1511,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 427,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "eb7c90ce10a70d194c4ed1e05158b954",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 424,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "ac7f3c9ff4363bbf9168e77bb016ac2d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 558,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "14f3ec32582263360d3cf275e22391a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 563,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "e50865b52413151ce19d549b113f88e2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 567,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "24f254d9611f414e7fa58253a5d33e7d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 570,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "e1ff2754b39dbf063b35cf9193c46817",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，https://anysite",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 610,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "ff6b2a38f398d34ebb19ce459fa79a97",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，https://anysitecom/test 可能是由一個名為 test 的資料夾結構建立，裡面包含 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 645,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "a2d4c56b8a871899c681149035c77c28",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，https://anysitecom/test 可能是由一個名為 test 的資料夾結構建立，裡面包含 indexhtml；URL 中不一定會顯示 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 658,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "dc4f2a6bfb8e2364db7426f12594d13c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium Project Part 1: HTML 簡介\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n查看影片\n簡介\nHTML，全名 HyperText Markup Language，是網頁的「骨架」。如果說 CSS 是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，https://anysitecom/test 可能是由一個名為 test 的資料夾結構建立，裡面包含 indexhtml；URL 中不一定會顯示 indexhtml。\nDocType 和 html 標籤\nHTML 檔案的第一行是它的 DocType。雖然有點令人驚訝，但你需要將這行放在檔案的最頂端，它告訴舊版瀏覽器需要以標準模式渲染頁面，遵循當前的 HTML 規範。\n提示：在 VS Code 中，你可以將滑鼠懸停在標籤上，查看 MDN 參考指南中關於其用途的資訊。\n第二行應該是 <html> 標籤的開啟標籤，接著是它的關閉標籤 </html>。這些標籤是介面的根元素。\n任務\n在你的 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 891,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "a58f80eeb6545f692da7f36fceee6d3b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "是為 HTML「穿衣服」，JavaScript 是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。 在這節課中，我們將使用 HTML 來設計虛擬玻璃花園的介面「骨架」。它將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。完成這節課後，你將能看到植物出現在欄位中，但介面可能看起來有點奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。 任務 在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到你新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案： 或者 使用以下指令在 git bash 中完成： * mkdir terrarium * cd terrarium * touch indexhtml * code indexhtml 或 nano indexhtml indexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，https://anysitecom/test 可能是由一個名為 test 的資料夾結構建立，裡面包含 indexhtml；URL 中不一定會顯示 indexhtml。 DocType 和 html 標籤 HTML 檔案的第一行是它的 DocType。雖然有點令人驚訝，但你需要將這行放在檔案的最頂端，它告訴舊版瀏覽器需要以標準模式渲染頁面，遵循當前的 HTML 規範。 提示：在 VS Code 中，你可以將滑鼠懸停在標籤上，查看 MDN 參考指南中關於其用途的資訊。 第二行應該是 <html> 標籤的開啟標籤，接著是它的關閉標籤 </html>。這些標籤是介面的根元素。 任務 在你的 indexhtml 檔案頂部添加以下內容：\n```HTML\n```\n✅ 有幾種不同的模式可以通過設置 DocType 的查詢字串來確定：Quirks Mode 和 Standards Mode。這些模式曾用於支援非常舊的瀏覽器（例如 Netscape Navigator 4 和 Internet Explorer 5），但現在通常不再使用。你可以使用標準的 DocType 聲明。\n文件的 'head'\nHTML 文件的 'head' 區域包含關於網頁的重要資訊，也稱為 metadata。在我們的例子中，我們告訴網頁伺服器以下四件事：\n網頁的標題\n網頁的 metadata，包括：\n字元集，告訴網頁使用的字元編碼\n瀏覽器資訊，包括 x-ua-compatible，表示支援 IE=edge 瀏覽器\n關於 viewport 的資訊，設定頁面載入時的行為。將 viewport 的初始縮放設為 1 可以控制頁面首次載入時的縮放級別。\n任務\n在開啟和關閉的 <html> 標籤之間添加 'head' 區塊。\nhtml\n<head>\n<title>Welcome to my Virtual Terrarium</title>\n<meta charset=\"utf-8\" />\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n</head>\n✅ 如果你像這樣設置 viewport meta 標籤：<meta name=\"viewport\" content=\"width=600\">，會發生什麼？閱讀更多關於 viewport 的資訊。\n文件的 body\nHTML 標籤\n在 HTML 中，你可以在",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1320,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "86788514d4c227a4514fcc4fb2d4d25c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "和 Standards Mode。這些模式曾用於支援非常舊的瀏覽器（例如 Netscape Navigator 4 和 Internet Explorer 5），但現在通常不再使用。你可以使用標準的 DocType 聲明。 文件的 'head' HTML 文件的 'head' 區域包含關於網頁的重要資訊，也稱為 metadata。在我們的例子中，我們告訴網頁伺服器以下四件事： 網頁的標題 網頁的 metadata，包括： 字元集，告訴網頁使用的字元編碼 瀏覽器資訊，包括 x-ua-compatible，表示支援 IE=edge 瀏覽器 關於 viewport 的資訊，設定頁面載入時的行為。將 viewport 的初始縮放設為 1 可以控制頁面首次載入時的縮放級別。 任務 在開啟和關閉的 <html> 標籤之間添加 'head' 區塊。 html <head> <title>Welcome to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ 如果你像這樣設置 viewport meta 標籤：<meta name=\"viewport\" content=\"width=600\">，會發生什麼？閱讀更多關於 viewport 的資訊。 文件的 body HTML 標籤 在 HTML 中，你可以在html 檔案中添加標籤來建立網頁的元素。每個標籤通常有一個開啟和關閉標籤，例如：<p>hello</p> 表示一段文字。通過在 <html> 標籤對內添加一組 <body> 標籤來建立介面的主體；你的標記現在看起來像這樣：\n任務\n```html\nWelcome to my Virtual Terrarium\n```\n現在，你可以開始建立你的頁面。通常，你會使用 <div> 標籤來建立頁面中的各個元素。我們將建立一系列 <div> 元素，這些元素將包含圖片。\n圖片\n一個不需要關閉標籤的 HTML 標籤是 <img>，因為它有一個 src 元素，包含頁面渲染該項目所需的所有資訊。\n在你的應用程式中建立一個名為 images 的資料夾，並將 source code folder 中的所有圖片添加到該資料夾中；（共有 14 張植物圖片）。\n任務\n在 <body></body> 標籤之間添加這些植物圖片到兩個欄位中：\n```html\n```\n注意：Spans vs",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 858,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "943221af706ec0295e46ce1c4e02cec0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ 如果你像這樣設置 viewport meta 標籤：<meta name=\"viewport\" content=\"width=600\">，會發生什麼？閱讀更多關於 viewport 的資訊。 文件的 body HTML 標籤 在 HTML 中，你可以在html 檔案中添加標籤來建立網頁的元素。每個標籤通常有一個開啟和關閉標籤，例如：<p>hello</p> 表示一段文字。通過在 <html> 標籤對內添加一組 <body> 標籤來建立介面的主體；你的標記現在看起來像這樣： 任務 ```html Welcome to my Virtual Terrarium ``` 現在，你可以開始建立你的頁面。通常，你會使用 <div> 標籤來建立頁面中的各個元素。我們將建立一系列 <div> 元素，這些元素將包含圖片。 圖片 一個不需要關閉標籤的 HTML 標籤是 <img>，因為它有一個 src 元素，包含頁面渲染該項目所需的所有資訊。 在你的應用程式中建立一個名為 images 的資料夾，並將 source code folder 中的所有圖片添加到該資料夾中；（共有 14 張植物圖片）。 任務 在 <body></body> 標籤之間添加這些植物圖片到兩個欄位中： ```html ``` 注意：Spans vsDivs。Divs 被認為是「區塊」元素，而 Spans 是「內聯」元素。如果你將這些 divs 轉換為 spans，會發生什麼？\n通過這些標記，植物現在會顯示在螢幕上。它看起來很糟糕，因為它們尚未使用 CSS 進行樣式設計，我們會在下一節課中完成這部分。\n每張圖片都有 alt 文本，即使你無法看到或渲染圖片，alt 文本也會顯示。這是一個重要的屬性，對於無障礙設計非常重要。在未來的課程中，你將學習更多關於無障礙設計的內容；目前請記住，alt 屬性為圖片提供了替代資訊，當使用者因某些原因無法查看圖片時（例如網速慢、src 屬性錯誤，或使用者使用螢幕閱讀器）。\n✅ 你是否注意到每張圖片都有相同的 alt 標籤？這是好的做法嗎？為什麼？你能改進這段程式碼嗎？\n語意化標記\n通常，撰寫 HTML 時最好使用有意義的「語意化」標記。這意味著你使用 HTML 標籤來表示它們設計用於的資料或互動類型。例如，頁面上的主要標題文字應使用 <h1> 標籤。\n在開啟的 <body> 標籤下方添加以下內容：\n```html\nMy Terrarium\n```\n使用語意化標記，例如將標題設為 <h1>，將無序列表渲染為 <ul>，有助於螢幕閱讀器導航頁面。通常，按鈕應寫為 <button>，列表應寫為 <li>。雖然可以使用特別樣式的 <span> 元素和點擊處理器來模仿按鈕，但對於使用輔助技術的使用者來說，確定頁面上的按鈕位置並與之互動會更容易。如果元素顯示為按鈕，這樣的設計更友好。因此，盡量使用語意化標記。\n✅ 查看螢幕閱讀器 如何與網頁互動。你能理解為什麼非語意化標記可能會讓使用者感到沮喪嗎？\n玻璃花園\n介面的最後部分涉及建立標記，這些標記將被樣式化以建立玻璃花園。\n任務：\n在最後的 </div> 標籤上方添加以下標記：\n```html\n```\n✅ 雖然你已將這些標記添加到螢幕上，但你完全看不到任何渲染。為什麼？\n🚀挑戰\nHTML 中有一些有趣的「舊」標籤，雖然不應在標記中使用已棄用的標籤，例如 這些標籤，但你能使用舊的 <marquee> 標籤讓 h1 標題水平滾動嗎？（如果你使用了，記得之後移除它）\n課後測驗\n課後測驗\n回顧與自學\nHTML 是「經得起考驗」的建構系統，幫助網頁發展成今天的樣子。通過研究一些舊標籤和新標籤，了解它的歷史。你能弄清楚為什麼某些標籤被棄用，而某些標籤被添加嗎？未來可能會引入哪些標籤？\n了解更多關於為網頁和行動裝置建立網站的內容，請參考 Microsoft Learn。\n作業\n練習你的 HTML：建立部落格模型\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11449,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2021,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "752d17868e6d6aa3866979f86c3a63ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
    "source_type": "git_repo",
    "title": "多了解一些 DOM",
    "content": "多了解一些 DOM\n指引\n深入研究 DOM，嘗試「採用」一個 DOM 元素。造訪 MDN 的 DOM 接口列表，選擇其中一個。然後在網頁中找到它的使用範例，並撰寫一段解釋說明它是如何被使用的。\n評分標準\n| 評分項目 | 優秀                                         | 合格                                           | 需要改進               |\n| -------- | ------------------------------------------- | ---------------------------------------------- | ---------------------- |\n|          | 提供段落式的說明，並附上範例                | 提供段落式的說明，但未附上範例                  | 未提供任何說明         |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 396,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f1a7389917dd7e56db629e1df15b0d6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1325,
    "chunk_index": 0,
    "total_chunks": 34
  },
  {
    "id": "24fa4a53ffe2d1988e8f083037c3dcde",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：indexhtml、script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1328,
    "chunk_index": 1,
    "total_chunks": 34
  },
  {
    "id": "e58624e43f44905fa455ebd87a3f7f64",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1331,
    "chunk_index": 2,
    "total_chunks": 34
  },
  {
    "id": "4c0b5e28e01ea77b299fe7b611f3d9d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。\n打開控制台或終端窗口，輸入以下命令來創建一個新文件夾：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1435,
    "chunk_index": 3,
    "total_chunks": 34
  },
  {
    "id": "3e5df5ad26206b9d663bc02255eb5e85",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。\n打開控制台或終端窗口，輸入以下命令來創建一個新文件夾：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode在 Visual Studio Code 中，為該文件夾添加以下三個文件：\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1457,
    "chunk_index": 4,
    "total_chunks": 34
  },
  {
    "id": "a7b0887b0c700fa589986b451adc6d23",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。\n打開控制台或終端窗口，輸入以下命令來創建一個新文件夾：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode在 Visual Studio Code 中，為該文件夾添加以下三個文件：\nindexhtml\nscript",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1460,
    "chunk_index": 5,
    "total_chunks": 34
  },
  {
    "id": "4244b53c2e498d8af5469a2c4f090c65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動編程\n當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！\n事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。\n我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。\n為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）：\nclick：用戶點擊某個元素，通常是按鈕或超連結\ncontextmenu：用戶點擊右鍵\nselect：用戶選取了一些文字\ninput：用戶輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到一段需要輸入的文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識吧！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。\n打開控制台或終端窗口，輸入以下命令來創建一個新文件夾：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode在 Visual Studio Code 中，為該文件夾添加以下三個文件：\nindexhtml\nscriptjs\nstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1463,
    "chunk_index": 6,
    "total_chunks": 34
  },
  {
    "id": "d9edfab4c5d0ef4b013a6553d4263a47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "課前測驗 課前測驗 事件驅動編程 當我們創建一個基於瀏覽器的應用程式時，我們會提供一個圖形用戶界面（GUI），讓用戶可以與我們構建的內容進行互動。與瀏覽器互動最常見的方式是點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是，我們不知道用戶何時會執行這些操作！ 事件驅動編程 是我們需要用來創建 GUI 的編程類型。如果我們稍微拆解這個詞語，我們會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，我們希望執行一些代碼來響應，但我們不知道它何時會發生。 我們標記希望執行的代碼部分的方法是創建一個函數。當我們考慮程序式編程時，函數是按照特定順序調用的。在事件驅動編程中也是如此，不同之處在於函數的調用方式。 為了處理事件（按鈕點擊、輸入等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並作出響應。事件監聽器可以更新用戶界面、向伺服器發送請求，或者執行其他需要響應用戶操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。 NOTE: 值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）： click：用戶點擊某個元素，通常是按鈕或超連結 contextmenu：用戶點擊右鍵 select：用戶選取了一些文字 input：用戶輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到一段需要輸入的文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識吧！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。 打開控制台或終端窗口，輸入以下命令來創建一個新文件夾： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，為該文件夾添加以下三個文件： indexhtml scriptjs stylecss\n創建用戶界面\n根據需求，我們知道我們的 HTML 頁面需要一些元素。這有點像食譜，我們需要一些材料：\n一個用於顯示用戶需要輸入的文字的區域\n一個用於顯示訊息（例如成功訊息）的區域\n一個用於輸入的文本框\n一個開始按鈕\n每個元素都需要有 ID，以便我們可以在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。\n創建一個名為 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1632,
    "chunk_index": 7,
    "total_chunks": 34
  },
  {
    "id": "c747cbdcffdc3cd361a00991e30c63b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "值得注意的是，創建事件監聽器有多種方法。你可以使用匿名函數，也可以創建命名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）： click：用戶點擊某個元素，通常是按鈕或超連結 contextmenu：用戶點擊右鍵 select：用戶選取了一些文字 input：用戶輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到一段需要輸入的文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識吧！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。 打開控制台或終端窗口，輸入以下命令來創建一個新文件夾： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，為該文件夾添加以下三個文件： indexhtml scriptjs stylecss 創建用戶界面 根據需求，我們知道我們的 HTML 頁面需要一些元素。這有點像食譜，我們需要一些材料： 一個用於顯示用戶需要輸入的文字的區域 一個用於顯示訊息（例如成功訊息）的區域 一個用於輸入的文本框 一個開始按鈕 每個元素都需要有 ID，以便我們可以在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML：\n```html\nTyping game\nTyping game",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1046,
    "chunk_index": 8,
    "total_chunks": 34
  },
  {
    "id": "4385d2eb8a634d3bfe5ce5df977ba96b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，用戶在頁面上執行的任何操作都會觸發事件，這讓你有很大的能力來確保用戶獲得理想的體驗。幸運的是，你通常只需要少數幾種事件。以下是一些常見的事件（包括我們在創建遊戲時會用到的兩個）： click：用戶點擊某個元素，通常是按鈕或超連結 contextmenu：用戶點擊右鍵 select：用戶選取了一些文字 input：用戶輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到一段需要輸入的文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識吧！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。 打開控制台或終端窗口，輸入以下命令來創建一個新文件夾： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，為該文件夾添加以下三個文件： indexhtml scriptjs stylecss 創建用戶界面 根據需求，我們知道我們的 HTML 頁面需要一些元素。這有點像食譜，我們需要一些材料： 一個用於顯示用戶需要輸入的文字的區域 一個用於顯示訊息（例如成功訊息）的區域 一個用於輸入的文本框 一個開始按鈕 每個元素都需要有 ID，以便我們可以在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock Holmes",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 905,
    "chunk_index": 9,
    "total_chunks": 34
  },
  {
    "id": "ad11eb539ca7810e6e3e028b25f86eca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "JavaScript 中的事件是如何工作的。我們的遊戲將測試玩家的打字技能，這是所有開發者應該具備的一項非常重要的技能。我們都應該多練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到一段需要輸入的文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識吧！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。 打開控制台或終端窗口，輸入以下命令來創建一個新文件夾： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，為該文件夾添加以下三個文件： indexhtml scriptjs stylecss 創建用戶界面 根據需求，我們知道我們的 HTML 頁面需要一些元素。這有點像食譜，我們需要一些材料： 一個用於顯示用戶需要輸入的文字的區域 一個用於顯示訊息（例如成功訊息）的區域 一個用於輸入的文本框 一個開始按鈕 每個元素都需要有 ID，以便我們可以在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to begin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 10,
    "total_chunks": 34
  },
  {
    "id": "28ac96e812c81afe0c2e0259d87ce008",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識吧！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續的工作更輕鬆。 打開控制台或終端窗口，輸入以下命令來創建一個新文件夾： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，為該文件夾添加以下三個文件： indexhtml scriptjs stylecss 創建用戶界面 根據需求，我們知道我們的 HTML 頁面需要一些元素。這有點像食譜，我們需要一些材料： 一個用於顯示用戶需要輸入的文字的區域 一個用於顯示訊息（例如成功訊息）的區域 一個用於輸入的文本框 一個開始按鈕 每個元素都需要有 ID，以便我們可以在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart\n```\n啟動應用程式\n開發時最好採用迭代方式，隨時查看效果。讓我們啟動應用程式。Visual Studio Code 有一個很棒的擴展工具 Live Server，它可以在本地託管你的應用程式，並在每次保存時自動刷新瀏覽器。\n按照鏈接安裝 Live Server，點擊 Install\n瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝\n如果有提示，請重新啟動 Visual Studio Code\n安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板\n輸入 Live Server: Open with Live Server\nLive Server 會開始託管你的應用程式\n打開瀏覽器，導航到 https://localhost:5500\n你現在應該能看到你創建的頁面！\n接下來，我們添加一些功能。\n添加 CSS\n在創建 HTML 後，我們需要添加 CSS 來進行核心樣式設計。我們需要高亮玩家應該輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來實現這些功能。\n創建一個名為 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 926,
    "chunk_index": 11,
    "total_chunks": 34
  },
  {
    "id": "0cb6f6188d492e7c1d7f96f7a8dde999",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` 啟動應用程式 開發時最好採用迭代方式，隨時查看效果。讓我們啟動應用程式。Visual Studio Code 有一個很棒的擴展工具 Live Server，它可以在本地託管你的應用程式，並在每次保存時自動刷新瀏覽器。 按照鏈接安裝 Live Server，點擊 Install 瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝 如果有提示，請重新啟動 Visual Studio Code 安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始託管你的應用程式 打開瀏覽器，導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 接下來，我們添加一些功能。 添加 CSS 在創建 HTML 後，我們需要添加 CSS 來進行核心樣式設計。我們需要高亮玩家應該輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來實現這些功能。 創建一個名為 stylecss 的新文件，並添加以下語法。\n```css\n/ inside style css / highlight {\nbackground-color: yellow;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 492,
    "chunk_index": 12,
    "total_chunks": 34
  },
  {
    "id": "1ebd40b1588364a3fc12d6cad36c860b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "skills with a quote from Sherlock HolmesClick **start** to beginStart ``` 啟動應用程式 開發時最好採用迭代方式，隨時查看效果。讓我們啟動應用程式。Visual Studio Code 有一個很棒的擴展工具 Live Server，它可以在本地託管你的應用程式，並在每次保存時自動刷新瀏覽器。 按照鏈接安裝 Live Server，點擊 Install 瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝 如果有提示，請重新啟動 Visual Studio Code 安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始託管你的應用程式 打開瀏覽器，導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 接下來，我們添加一些功能。 添加 CSS 在創建 HTML 後，我們需要添加 CSS 來進行核心樣式設計。我們需要高亮玩家應該輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來實現這些功能。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error {\nbackground-color: lightcoral;\nborder: red;\n}\n```\n✅ 關於 CSS，你可以按照自己的喜好設計頁面。花點時間讓頁面更吸引人：\n選擇不同的字體\n為標題添加顏色\n調整元素大小\nJavaScript\n在創建了用戶界面後，現在我們將重點放在提供邏輯的 JavaScript 上。我們將把它分成幾個步驟：\n創建常量\n為開始遊戲添加事件監聽器\n為輸入添加事件監聽器\n首先，創建一個名為 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 13,
    "total_chunks": 34
  },
  {
    "id": "3597ae6c4064c9dad137f30c74c98829",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝 如果有提示，請重新啟動 Visual Studio Code 安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始託管你的應用程式 打開瀏覽器，導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 接下來，我們添加一些功能。 添加 CSS 在創建 HTML 後，我們需要添加 CSS 來進行核心樣式設計。我們需要高亮玩家應該輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來實現這些功能。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好設計頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 在創建了用戶界面後，現在我們將重點放在提供邏輯的 JavaScript 上。我們將把它分成幾個步驟： 創建常量 為開始遊戲添加事件監聽器 為輸入添加事件監聽器 首先，創建一個名為 scriptjs 的新文件。\n創建常量\n我們需要一些項目來讓編程更輕鬆。這有點像食譜，以下是我們需要的內容：\n包含所有文字段落的數組\n用於存儲當前段落中所有單詞的空數組\n用於存儲玩家當前輸入單詞索引的空間\n玩家點擊開始時的時間\n我們還需要引用用戶界面中的元素：\n文本框（typed-value）\n顯示文字的區域（quote）\n訊息區域（message）\njavascript\n// inside script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 699,
    "chunk_index": 14,
    "total_chunks": 34
  },
  {
    "id": "d320ac244e21e82ac6750161f973c06c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始託管你的應用程式 打開瀏覽器，導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 接下來，我們添加一些功能。 添加 CSS 在創建 HTML 後，我們需要添加 CSS 來進行核心樣式設計。我們需要高亮玩家應該輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來實現這些功能。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好設計頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 在創建了用戶界面後，現在我們將重點放在提供邏輯的 JavaScript 上。我們將把它分成幾個步驟： 創建常量 為開始遊戲添加事件監聽器 為輸入添加事件監聽器 首先，創建一個名為 scriptjs 的新文件。 創建常量 我們需要一些項目來讓編程更輕鬆。這有點像食譜，以下是我們需要的內容： 包含所有文字段落的數組 用於存儲當前段落中所有單詞的空數組 用於存儲玩家當前輸入單詞索引的空間 玩家點擊開始時的時間 我們還需要引用用戶界面中的元素： 文本框（typed-value） 顯示文字的區域（quote） 訊息區域（message） javascript // inside scriptjs\n// all of our quotes\nconst quotes = [\n'When you have eliminated the impossible, whatever remains, however improbable, must be the truth",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 15,
    "total_chunks": 34
  },
  {
    "id": "20dc0a3c3a4bce47eedc95df0541ff6f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "CSS 來進行核心樣式設計。我們需要高亮玩家應該輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來實現這些功能。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好設計頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 在創建了用戶界面後，現在我們將重點放在提供邏輯的 JavaScript 上。我們將把它分成幾個步驟： 創建常量 為開始遊戲添加事件監聽器 為輸入添加事件監聽器 首先，創建一個名為 scriptjs 的新文件。 創建常量 我們需要一些項目來讓編程更輕鬆。這有點像食譜，以下是我們需要的內容： 包含所有文字段落的數組 用於存儲當前段落中所有單詞的空數組 用於存儲玩家當前輸入單詞索引的空間 玩家點擊開始時的時間 我們還需要引用用戶界面中的元素： 文本框（typed-value） 顯示文字的區域（quote） 訊息區域（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth',\n'There is nothing more deceptive than an obvious fact",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 564,
    "chunk_index": 16,
    "total_chunks": 34
  },
  {
    "id": "32b084b36f791715d8575ea450ec0f56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好設計頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 在創建了用戶界面後，現在我們將重點放在提供邏輯的 JavaScript 上。我們將把它分成幾個步驟： 創建常量 為開始遊戲添加事件監聽器 為輸入添加事件監聽器 首先，創建一個名為 scriptjs 的新文件。 創建常量 我們需要一些項目來讓編程更輕鬆。這有點像食譜，以下是我們需要的內容： 包含所有文字段落的數組 用於存儲當前段落中所有單詞的空數組 用於存儲玩家當前輸入單詞索引的空間 玩家點擊開始時的時間 我們還需要引用用戶界面中的元素： 文本框（typed-value） 顯示文字的區域（quote） 訊息區域（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth', 'There is nothing more deceptive than an obvious fact',\n'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation ',\n'I never make exceptions An exception disproves the rule ',\n'What one man can invent another can discover",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 17,
    "total_chunks": 34
  },
  {
    "id": "b61807d4e055647b0f5ffe959a96c177",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "= [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth', 'There is nothing more deceptive than an obvious fact', 'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation ', 'I never make exceptions An exception disproves the rule ', 'What one man can invent another can discover',\n'Nothing clears up a case so much as stating it to another person ',\n'Education never ends, Watson It is a series of lessons, with the greatest for the last ',\n];\n// store the list of words and the index of the word the player is currently typing\nlet words = [];\nlet wordIndex = 0;\n// the starting time\nlet startTime = Date now();\n// page elements\nconst quoteElement = document getElementById('quote');\nconst messageElement = document getElementById('message');\nconst typedValueElement = document getElementById('typed-value');\n✅ 為你的遊戲添加更多的段落\nNOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vue",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 287,
    "chunk_index": 18,
    "total_chunks": 34
  },
  {
    "id": "42a963cae938dd5a27c31ccb5d15d50c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "ends, Watson It is a series of lessons, with the greatest for the last ', ]; // store the list of words and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。\n花點時間觀看一段關於使用 const、let 和 var 的視頻\n🎥 點擊上方圖片觀看關於變量的視頻。\n添加開始邏輯\n為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。\n當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。\n```javascript\n// at the end of script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 526,
    "chunk_index": 19,
    "total_chunks": 34
  },
  {
    "id": "f598961d5e7f0e16431d2be778be97c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 501,
    "chunk_index": 20,
    "total_chunks": 34
  },
  {
    "id": "1b1ad7729b98b24608575be1b21bcef0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 504,
    "chunk_index": 21,
    "total_chunks": 34
  },
  {
    "id": "f8811f38dc94240b96994f9d1eb2ddf2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => {\n// get a quote\nconst quoteIndex = Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 22,
    "total_chunks": 34
  },
  {
    "id": "d4c01702aaa7a01f316489f22c13bcd5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 511,
    "chunk_index": 23,
    "total_chunks": 34
  },
  {
    "id": "46dca30a1db288007ec951ccb089cd0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quotes",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 515,
    "chunk_index": 24,
    "total_chunks": 34
  },
  {
    "id": "63ddef9c6196362d137ddc2a4b26ff12",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "= 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength);\nconst quote = quotes[quoteIndex];\n// Put the quote into an array of words\nwords = quote",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 25,
    "total_chunks": 34
  },
  {
    "id": "8c1be37155e77e6ae45256f98f88fd1c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "= document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多的段落 NOTE: 我們可以在代碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常量可以避免字符串拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理代碼。 花點時間觀看一段關於使用 const、let 和 var 的視頻 🎥 點擊上方圖片觀看關於變量的視頻。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' ');\n// reset the word index for tracking\nwordIndex = 0;\n// UI updates\n// Create an array of span elements so we can set a class\nconst spanWords = words",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 554,
    "chunk_index": 26,
    "total_chunks": 34
  },
  {
    "id": "c82424f0e832097e8f93bbf5525d37fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件）並執行代碼作為響應。在我們的例子中，我們希望在用戶點擊開始時執行代碼。 當用戶點擊 開始 時，我們需要選擇一段文字，設置用戶界面，並設置當前單詞和計時的追蹤。以下是你需要添加的 JavaScript；我們會在代碼塊後進行討論。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' '); // reset the word index for tracking wordIndex = 0; // UI updates // Create an array of span elements so we can set a class const spanWords = wordsmap(function(word) { return <span>${word} </span>});\n// Convert into string and set as innerHTML on quote display\nquoteElement innerHTML = spanWords join('');\n// Highlight the first word\nquoteElement childNodes[0] className = 'highlight';\n// Clear any prior messages\nmessageElement innerText = '';\n// Setup the textbox\n// Clear the textbox\ntypedValueElement value = '';\n// set focus\ntypedValueElement focus();\n// set the event handler\n// Start the timer\nstartTime = new Date() getTime();\n});\n```\n讓我們分解代碼！\n設置單詞追蹤\n使用 Math floor 和 Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 27,
    "total_chunks": 34
  },
  {
    "id": "2711b604f07450fc8c43b9eff6851ec0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "</span>}); // Convert into string and set as innerHTML on quote display quoteElement innerHTML = spanWords join(''); // Highlight the first word quoteElement childNodes[0] className = 'highlight'; // Clear any prior messages messageElement innerText = ''; // Setup the textbox // Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` 讓我們分解代碼！ 設置單詞追蹤 使用 Math floor 和 Mathrandom 隨機選擇 quotes 數組中的一段文字\n將 quote 轉換為 words 數組，以便追蹤玩家當前輸入的單詞\n將 wordIndex 設置為 0，因為玩家將從第一個單詞開始\n設置用戶界面\n創建一個 spanWords 數組，其中包含每個單詞的 span 元素\n這樣可以高亮顯示顯示區域中的單詞\n使用 join 將數組轉換為字符串，並更新 quoteElement 的 innerHTML\n這將顯示文字給玩家\n將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色\n將 messageElement 的 innerText 設置為 '' 清空訊息\n設置文本框\n清空 typedValueElement 的當前 value\n將焦點設置到 typedValueElement\n通過調用 getTime 開始計時\n添加輸入邏輯\n當玩家輸入時，會觸發 input 事件。這個事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。在 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 517,
    "chunk_index": 28,
    "total_chunks": 34
  },
  {
    "id": "2d4b6defa451b1cd10768746ad3d3b52",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "set the event handler // Start the timer startTime = new Date() getTime(); }); ``` 讓我們分解代碼！ 設置單詞追蹤 使用 Math floor 和 Mathrandom 隨機選擇 quotes 數組中的一段文字 將 quote 轉換為 words 數組，以便追蹤玩家當前輸入的單詞 將 wordIndex 設置為 0，因為玩家將從第一個單詞開始 設置用戶界面 創建一個 spanWords 數組，其中包含每個單詞的 span 元素 這樣可以高亮顯示顯示區域中的單詞 使用 join 將數組轉換為字符串，並更新 quoteElement 的 innerHTML 這將顯示文字給玩家 將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色 將 messageElement 的 innerText 設置為 '' 清空訊息 設置文本框 清空 typedValueElement 的當前 value 將焦點設置到 typedValueElement 通過調用 getTime 開始計時 添加輸入邏輯 當玩家輸入時，會觸發 input 事件。這個事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。在 scriptjs 中，將以下代碼添加到末尾。我們會在代碼塊後進行討論。\n```javascript\n// at the end of script js\ntypedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 29,
    "total_chunks": 34
  },
  {
    "id": "55e74318e503780c6a5ce4791ee5efca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "new Date() getTime(); }); ``` 讓我們分解代碼！ 設置單詞追蹤 使用 Math floor 和 Mathrandom 隨機選擇 quotes 數組中的一段文字 將 quote 轉換為 words 數組，以便追蹤玩家當前輸入的單詞 將 wordIndex 設置為 0，因為玩家將從第一個單詞開始 設置用戶界面 創建一個 spanWords 數組，其中包含每個單詞的 span 元素 這樣可以高亮顯示顯示區域中的單詞 使用 join 將數組轉換為字符串，並更新 quoteElement 的 innerHTML 這將顯示文字給玩家 將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色 將 messageElement 的 innerText 設置為 '' 清空訊息 設置文本框 清空 typedValueElement 的當前 value 將焦點設置到 typedValueElement 通過調用 getTime 開始計時 添加輸入邏輯 當玩家輸入時，會觸發 input 事件。這個事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。在 scriptjs 中，將以下代碼添加到末尾。我們會在代碼塊後進行討論。 ```javascript // at the end of script js typedValueElementaddEventListener('input', () => {\n// Get the current word\nconst currentWord = words[wordIndex];\n// get the current value\nconst typedValue = typedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 30,
    "total_chunks": 34
  },
  {
    "id": "766649194311a1482ae4cc1318cd7587",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "wordIndex 設置為 0，因為玩家將從第一個單詞開始 設置用戶界面 創建一個 spanWords 數組，其中包含每個單詞的 span 元素 這樣可以高亮顯示顯示區域中的單詞 使用 join 將數組轉換為字符串，並更新 quoteElement 的 innerHTML 這將顯示文字給玩家 將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色 將 messageElement 的 innerText 設置為 '' 清空訊息 設置文本框 清空 typedValueElement 的當前 value 將焦點設置到 typedValueElement 通過調用 getTime 開始計時 添加輸入邏輯 當玩家輸入時，會觸發 input 事件。這個事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。在 scriptjs 中，將以下代碼添加到末尾。我們會在代碼塊後進行討論。 ```javascript // at the end of script js typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue;\nif (typedValue === currentWord && wordIndex === words length - 1) {\n// end of sentence\n// Display success\nconst elapsedTime = new Date() getTime() - startTime;\nconst message = CONGRATULATIONS You finished in ${elapsedTime / 1000} seconds ;\nmessageElement innerText = message;\n} else if (typedValue endsWith(' ') && typedValue",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 31,
    "total_chunks": 34
  },
  {
    "id": "163d6bf68f7e86ce6f2157234dad8439",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "of script js typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue; if (typedValue === currentWord && wordIndex === words length - 1) { // end of sentence // Display success const elapsedTime = new Date() getTime() - startTime; const message = CONGRATULATIONS You finished in ${elapsedTime / 1000} seconds ; messageElement innerText = message; } else if (typedValue endsWith(' ') && typedValuetrim() === currentWord) {\n// end of word\n// clear the typedValueElement for the new word\ntypedValueElement value = '';\n// move to the next word\nwordIndex++;\n// reset the class name for all elements in quote\nfor (const wordElement of quoteElement childNodes) {\nwordElement className = '';\n}\n// highlight the new word\nquoteElement childNodes[wordIndex] className = 'highlight';\n} else if (currentWord startsWith(typedValue)) {\n// currently correct\n// highlight the next word\ntypedValueElement className = '';\n} else {\n// error state\ntypedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 243,
    "chunk_index": 32,
    "total_chunks": 34
  },
  {
    "id": "dd2e578fe5440acf5f3ae4ed227bdace",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "// clear the typedValueElement for the new word typedValueElement value = ''; // move to the next word wordIndex++; // reset the class name for all elements in quote for (const wordElement of quoteElement childNodes) { wordElement className = ''; } // highlight the new word quoteElement childNodes[wordIndex] className = 'highlight'; } else if (currentWord startsWith(typedValue)) { // currently correct // highlight the next word typedValueElement className = ''; } else { // error state typedValueElementclassName = 'error';\n}\n});\n```\n讓我們分解代碼！我們首先獲取當前單詞和玩家目前輸入的值。然後，我們使用瀑布邏輯檢查以下情況：整段文字是否完成，單詞是否完成，單詞是否正確，或者（最後）是否有錯誤。\n整段文字完成，當 typedValue 等於 currentWord，且 wordIndex 等於 words 的 length 減一時\n通過將當前時間減去 startTime 計算 elapsedTime\n將 elapsedTime 除以 1,000，將毫秒轉換為秒\n顯示成功訊息\n單詞完成，當 typedValue 以空格結尾（單詞結束）且 typedValue 等於 currentWord 時\n將 typedElement 的 value 設置為 ''，以便輸入下一個單詞\n增加 wordIndex，移動到下一個單詞\n遍歷 quoteElement 的所有 childNodes，將 className 設置為 ''，恢復默認顯示\n將當前單詞的 className 設置為 highlight，標記為下一個需要輸入的單詞\n單詞當前輸入正確（但未完成），當 currentWord 以 typedValue 開頭時\n通過清空 className 確保 typedValueElement 顯示為默認狀態\n如果到這裡，說明有錯誤\n將 typedValueElement 的 className 設置為 error\n測試你的應用程式\n你已經完成了！最後一步是確保應用程式正常運行。試試看吧！如果有錯誤，不用擔心；所有開發者都會遇到錯誤。檢查訊息並進行調試。\n點擊 開始，然後開始輸入！它應該看起來像我們之前看到的動畫。\n🚀 挑戰\n添加更多功能\n在完成後禁用 input 事件監聽器，並在按下按鈕時重新啟用\n在玩家完成文字後禁用文本框\n顯示一個模態對話框，包含成功訊息\n使用 localStorage 儲存高分\n課後測驗\n課後測驗\n回顧與自學\n閱讀 所有可用的事件，了解網頁瀏覽器提供給開發者的功能，並思考在什麼情境下會使用每個事件。\n作業\n創建一個新的鍵盤遊戲\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17126,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1083,
    "chunk_index": 33,
    "total_chunks": 34
  },
  {
    "id": "5ad60667a0441feceefca9ceb447faba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\solution\\README.md",
    "source_type": "git_repo",
    "title": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的項目 🌵🌱",
    "content": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的項目 🌵🌱\n一個小型的拖放代碼冥想項目。通過一點 HTML、JS 和 CSS，你可以構建一個網頁界面，為其設計樣式，並添加互動功能。\n鳴謝\n由 Jen Looper 用 ♥️ 編寫\n這個通過 CSS 創建的微型植物園靈感來自 Jakub Mandra 的玻璃罐 codepen。\n插圖由 Jen Looper 使用 Procreate 手繪完成。\n部署你的微型植物園\n你可以使用 Azure 靜態網頁應用程序將你的微型植物園部署或發布到網絡上。\nFork 此倉庫\n按下這個按鈕\n按照向導創建你的應用程序。確保將應用程序根目錄設置為 /solution 或你的代碼庫根目錄。此應用程序中沒有 API，因此不需要擔心添加它。一個",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2033,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 351,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "47e369c1594c262e7c654777d9507add",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\solution\\README.md",
    "source_type": "git_repo",
    "title": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的項目 🌵🌱",
    "content": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的項目 🌵🌱\n一個小型的拖放代碼冥想項目。通過一點 HTML、JS 和 CSS，你可以構建一個網頁界面，為其設計樣式，並添加互動功能。\n鳴謝\n由 Jen Looper 用 ♥️ 編寫\n這個通過 CSS 創建的微型植物園靈感來自 Jakub Mandra 的玻璃罐 codepen。\n插圖由 Jen Looper 使用 Procreate 手繪完成。\n部署你的微型植物園\n你可以使用 Azure 靜態網頁應用程序將你的微型植物園部署或發布到網絡上。\nFork 此倉庫\n按下這個按鈕\n按照向導創建你的應用程序。確保將應用程序根目錄設置為 /solution 或你的代碼庫根目錄。此應用程序中沒有 API，因此不需要擔心添加它。一個github 文件夾將會在你 fork 的倉庫中創建，這將幫助 Azure 靜態網頁應用程序的構建服務構建並將你的應用程序發布到一個新的 URL。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2033,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 609,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "32a44ea4eaa0ca834effe057a9683567",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\assignment.md",
    "source_type": "git_repo",
    "title": "資料類型練習",
    "content": "資料類型練習\n指引\n假設你正在建立一個購物車。撰寫一些有關完成購物體驗所需資料類型的文件。你是如何選擇這些資料類型的？\n評分標準\n標準 | 優秀 | 合格 | 需要改進\n--- | --- | --- | --- |\n||詳細列出並探討六種資料類型，並記錄其用途|探討四種資料類型|探討兩種資料類型|\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1044,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 363,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "334aa7b85d5c2c276371232621aaffaf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "微型生態瓶項目第二部分：CSS簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓您的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性和外觀，還可以使用 CSS 創建響應式網頁設計（Responsive Web Design，RWD），使您的應用程式在任何螢幕尺寸下都能保持良好的顯示效果。CSS 不僅僅是讓您的應用程式看起來更漂亮，它的規範還包括動畫和變換功能，能為您的應用程式提供更複雜的互動效果。CSS 工作組負責維護最新的 CSS 規範，您可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 419,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "991b6aaa24ecc1050a2b75777d15bb84",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "微型生態瓶項目第二部分：CSS簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓您的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性和外觀，還可以使用 CSS 創建響應式網頁設計（Responsive Web Design，RWD），使您的應用程式在任何螢幕尺寸下都能保持良好的顯示效果。CSS 不僅僅是讓您的應用程式看起來更漂亮，它的規範還包括動畫和變換功能，能為您的應用程式提供更複雜的互動效果。CSS 工作組負責維護最新的 CSS 規範，您可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUsecom 檢查您的實現。\n在本課中，我們將為線上微型生態瓶添加樣式，並深入了解幾個 CSS 概念：層疊、繼承，以及選擇器的使用、定位和使用 CSS 建立佈局。在此過程中，我們將設計微型生態瓶的佈局並創建實際的生態瓶。\n先決條件\n您應該已經建立好微型生態瓶的 HTML，並準備好進行樣式設計。\n查看影片\n任務\n在您的微型生態瓶資料夾中，創建一個名為 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "073eee3a060af2661369c80ebbb5bcbb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "微型生態瓶項目第二部分：CSS簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓您的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性和外觀，還可以使用 CSS 創建響應式網頁設計（Responsive Web Design，RWD），使您的應用程式在任何螢幕尺寸下都能保持良好的顯示效果。CSS 不僅僅是讓您的應用程式看起來更漂亮，它的規範還包括動畫和變換功能，能為您的應用程式提供更複雜的互動效果。CSS 工作組負責維護最新的 CSS 規範，您可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUsecom 檢查您的實現。\n在本課中，我們將為線上微型生態瓶添加樣式，並深入了解幾個 CSS 概念：層疊、繼承，以及選擇器的使用、定位和使用 CSS 建立佈局。在此過程中，我們將設計微型生態瓶的佈局並創建實際的生態瓶。\n先決條件\n您應該已經建立好微型生態瓶的 HTML，並準備好進行樣式設計。\n查看影片\n任務\n在您的微型生態瓶資料夾中，創建一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 部分：\nhtml\n<link rel=\"stylesheet\" href=\"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 691,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "723433496c1000c625e0488a3e9126ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "微型生態瓶項目第二部分：CSS簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓您的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性和外觀，還可以使用 CSS 創建響應式網頁設計（Responsive Web Design，RWD），使您的應用程式在任何螢幕尺寸下都能保持良好的顯示效果。CSS 不僅僅是讓您的應用程式看起來更漂亮，它的規範還包括動畫和變換功能，能為您的應用程式提供更複雜的互動效果。CSS 工作組負責維護最新的 CSS 規範，您可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUsecom 檢查您的實現。\n在本課中，我們將為線上微型生態瓶添加樣式，並深入了解幾個 CSS 概念：層疊、繼承，以及選擇器的使用、定位和使用 CSS 建立佈局。在此過程中，我們將設計微型生態瓶的佈局並創建實際的生態瓶。\n先決條件\n您應該已經建立好微型生態瓶的 HTML，並準備好進行樣式設計。\n查看影片\n任務\n在您的微型生態瓶資料夾中，創建一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 部分：\nhtml\n<link rel=\"stylesheet\" href=\"/style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 692,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "afca91ae472ccad72403d6c947ed439e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "微型生態瓶項目第二部分：CSS簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓您的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性和外觀，還可以使用 CSS 創建響應式網頁設計（Responsive Web Design，RWD），使您的應用程式在任何螢幕尺寸下都能保持良好的顯示效果。CSS 不僅僅是讓您的應用程式看起來更漂亮，它的規範還包括動畫和變換功能，能為您的應用程式提供更複雜的互動效果。CSS 工作組負責維護最新的 CSS 規範，您可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUsecom 檢查您的實現。\n在本課中，我們將為線上微型生態瓶添加樣式，並深入了解幾個 CSS 概念：層疊、繼承，以及選擇器的使用、定位和使用 CSS 建立佈局。在此過程中，我們將設計微型生態瓶的佈局並創建實際的生態瓶。\n先決條件\n您應該已經建立好微型生態瓶的 HTML，並準備好進行樣式設計。\n查看影片\n任務\n在您的微型生態瓶資料夾中，創建一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 部分：\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\n層疊\n層疊樣式表包含樣式“層疊”的概念，即樣式的應用是由其優先級決定的。由網站作者設定的樣式優先於瀏覽器設定的樣式。內聯樣式的優先級高於外部樣式表中的樣式。\n任務\n為您的 <h1> 標籤添加內聯樣式 \"color: red\"：\n```HTML\nMy Terrarium\n```\n然後，將以下程式碼添加到您的 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 877,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "6290f211732f7b5680850a87e9518b67",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "微型生態瓶項目第二部分：CSS簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓您的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性和外觀，還可以使用 CSS 創建響應式網頁設計（Responsive Web Design，RWD），使您的應用程式在任何螢幕尺寸下都能保持良好的顯示效果。CSS 不僅僅是讓您的應用程式看起來更漂亮，它的規範還包括動畫和變換功能，能為您的應用程式提供更複雜的互動效果。CSS 工作組負責維護最新的 CSS 規範，您可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUsecom 檢查您的實現。\n在本課中，我們將為線上微型生態瓶添加樣式，並深入了解幾個 CSS 概念：層疊、繼承，以及選擇器的使用、定位和使用 CSS 建立佈局。在此過程中，我們將設計微型生態瓶的佈局並創建實際的生態瓶。\n先決條件\n您應該已經建立好微型生態瓶的 HTML，並準備好進行樣式設計。\n查看影片\n任務\n在您的微型生態瓶資料夾中，創建一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 部分：\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\n層疊\n層疊樣式表包含樣式“層疊”的概念，即樣式的應用是由其優先級決定的。由網站作者設定的樣式優先於瀏覽器設定的樣式。內聯樣式的優先級高於外部樣式表中的樣式。\n任務\n為您的 <h1> 標籤添加內聯樣式 \"color: red\"：\n```HTML\nMy Terrarium\n```\n然後，將以下程式碼添加到您的 stylecss 檔案中：\nCSS\nh1 {\ncolor: blue;\n}\n✅ 您的網頁應用程式中顯示了哪種顏色？為什麼？您能找到覆蓋樣式的方法嗎？什麼情況下您會希望這樣做，或者不希望這樣做？\n繼承\n樣式是從祖先樣式繼承到後代的，嵌套元素會繼承其父元素的樣式。\n任務\n將 body 的字體設置為指定字體，並檢查嵌套元素的字體：\nCSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\n打開瀏覽器的控制台，進入“元素”標籤，觀察 H1 的字體。它繼承了 body 的字體，如瀏覽器所示：\n✅ 您能否讓嵌套樣式繼承不同的屬性？\nCSS 選擇器\n標籤\n到目前為止，您的 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1225,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "52875e504989f773d813241bd7b8bcb3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "Web Consortium 的網站上關注他們的工作。 注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範部分。請隨時透過 CanIUsecom 檢查您的實現。 在本課中，我們將為線上微型生態瓶添加樣式，並深入了解幾個 CSS 概念：層疊、繼承，以及選擇器的使用、定位和使用 CSS 建立佈局。在此過程中，我們將設計微型生態瓶的佈局並創建實際的生態瓶。 先決條件 您應該已經建立好微型生態瓶的 HTML，並準備好進行樣式設計。 查看影片 任務 在您的微型生態瓶資料夾中，創建一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 部分： html <link rel=\"stylesheet\" href=\"/stylecss\" /> 層疊 層疊樣式表包含樣式“層疊”的概念，即樣式的應用是由其優先級決定的。由網站作者設定的樣式優先於瀏覽器設定的樣式。內聯樣式的優先級高於外部樣式表中的樣式。 任務 為您的 <h1> 標籤添加內聯樣式 \"color: red\"： ```HTML My Terrarium ``` 然後，將以下程式碼添加到您的 stylecss 檔案中： CSS h1 { color: blue; } ✅ 您的網頁應用程式中顯示了哪種顏色？為什麼？您能找到覆蓋樣式的方法嗎？什麼情況下您會希望這樣做，或者不希望這樣做？ 繼承 樣式是從祖先樣式繼承到後代的，嵌套元素會繼承其父元素的樣式。 任務 將 body 的字體設置為指定字體，並檢查嵌套元素的字體： CSS body { font-family: helvetica, arial, sans-serif; } 打開瀏覽器的控制台，進入“元素”標籤，觀察 H1 的字體。它繼承了 body 的字體，如瀏覽器所示： ✅ 您能否讓嵌套樣式繼承不同的屬性？ CSS 選擇器 標籤 到目前為止，您的 stylecss 檔案只設置了少量標籤樣式，應用程式看起來有點奇怪：\n```CSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nh1 {\ncolor: #3a241d;\ntext-align: center;\n}\n```\n這種設置標籤樣式的方法使您可以控制獨特的元素，但您需要控制微型生態瓶中許多植物的樣式。為此，您需要利用 CSS 選擇器。\nIds\n為左側和右側容器添加一些樣式。由於標記中只有一個左側容器和一個右側容器，因此它們被賦予 id。要設置它們的樣式，使用 #：\n```CSS\nleft-container {\nbackground-color: #eee;\nwidth: 15%;\nleft: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\nright-container {\nbackground-color: #eee;\nwidth: 15%;\nright: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\n```\n在這裡，您使用絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們可以適應小型行動裝置螢幕。\n✅ 此程式碼重複性較高，因此不符合“DRY”（Don't Repeat Yourself）的原則；您能否找到更好的方法來設置這些 id 的樣式，例如使用 id 和 class 的組合？您需要更改標記並重構 CSS：\n```html\n```\nClasses\n在上述示例中，您設置了螢幕上的兩個獨特元素的樣式。如果您希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。\n注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供您稍後添加的 JavaScript 使用，以操作微型生態瓶中的植物位置。而 class 則為所有植物提供了統一的樣式。\n```html\n```\n將以下內容添加到您的 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1598,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "0ec07413a518275fb4db9ff300a3f5e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "CSS 選擇器。 Ids 為左側和右側容器添加一些樣式。由於標記中只有一個左側容器和一個右側容器，因此它們被賦予 id。要設置它們的樣式，使用 #： ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` 在這裡，您使用絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們可以適應小型行動裝置螢幕。 ✅ 此程式碼重複性較高，因此不符合“DRY”（Don't Repeat Yourself）的原則；您能否找到更好的方法來設置這些 id 的樣式，例如使用 id 和 class 的組合？您需要更改標記並重構 CSS： ```html ``` Classes 在上述示例中，您設置了螢幕上的兩個獨特元素的樣式。如果您希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。 注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供您稍後添加的 JavaScript 使用，以操作微型生態瓶中的植物位置。而 class 則為所有植物提供了統一的樣式。 ```html ``` 將以下內容添加到您的 stylecss 檔案中：\n```CSS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 562,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "b0473ed1b204e1ba1a33fb89f9e823ed",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "Ids 為左側和右側容器添加一些樣式。由於標記中只有一個左側容器和一個右側容器，因此它們被賦予 id。要設置它們的樣式，使用 #： ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` 在這裡，您使用絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們可以適應小型行動裝置螢幕。 ✅ 此程式碼重複性較高，因此不符合“DRY”（Don't Repeat Yourself）的原則；您能否找到更好的方法來設置這些 id 的樣式，例如使用 id 和 class 的組合？您需要更改標記並重構 CSS： ```html ``` Classes 在上述示例中，您設置了螢幕上的兩個獨特元素的樣式。如果您希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。 注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供您稍後添加的 JavaScript 使用，以操作微型生態瓶中的植物位置。而 class 則為所有植物提供了統一的樣式。 ```html ``` 將以下內容添加到您的 stylecss 檔案中： ```CSSplant-holder {\nposition: relative;\nheight: 13%;\nleft: -10px;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 571,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "366cdd0b8a30b09b9d154b9da25f0088",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "#eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` 在這裡，您使用絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們可以適應小型行動裝置螢幕。 ✅ 此程式碼重複性較高，因此不符合“DRY”（Don't Repeat Yourself）的原則；您能否找到更好的方法來設置這些 id 的樣式，例如使用 id 和 class 的組合？您需要更改標記並重構 CSS： ```html ``` Classes 在上述示例中，您設置了螢幕上的兩個獨特元素的樣式。如果您希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。 注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供您稍後添加的 JavaScript 使用，以操作微型生態瓶中的植物位置。而 class 則為所有植物提供了統一的樣式。 ```html ``` 將以下內容添加到您的 stylecss 檔案中： ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant {\nposition: absolute;\nmax-width: 150%;\nmax-height: 150%;\nz-index: 2;\n}\n```\n此程式碼片段中值得注意的是相對定位和絕對定位的混合，我們將在下一節中進一步探討。請查看高度如何通過百分比處理：\n您將植物容器的高度設置為 13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。\n您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。\n然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。\n另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。\n✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？\nCSS 定位\n混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。\n絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。\n相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。\n在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。\nplant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。\n✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？\nCSS 佈局\n現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！\n首先，使用 CSS 將",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1312,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "0bb9169a2aefe855b9455fbe400b4448",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "的組合。這裡的 id 是供您稍後添加的 JavaScript 使用，以操作微型生態瓶中的植物位置。而 class 則為所有植物提供了統一的樣式。 ```html ``` 將以下內容添加到您的 stylecss 檔案中： ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼片段中值得注意的是相對定位和絕對定位的混合，我們將在下一節中進一步探討。請查看高度如何通過百分比處理： 您將植物容器的高度設置為 13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。 您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。 然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形：\n```CSS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 965,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "349cc97163129eebef00fa1c24f223f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "JavaScript 使用，以操作微型生態瓶中的植物位置。而 class 則為所有植物提供了統一的樣式。 ```html ``` 將以下內容添加到您的 stylecss 檔案中： ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼片段中值得注意的是相對定位和絕對定位的混合，我們將在下一節中進一步探討。請查看高度如何通過百分比處理： 您將植物容器的高度設置為 13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。 您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。 然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls {\nheight: 80%;\nwidth: 60%;\nbackground: #d1e1df;\nborder-radius: 1rem;\nposition: absolute;\nbottom: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 985,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "8989a6a193711932da33b8286eb3eeac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼片段中值得注意的是相對定位和絕對定位的混合，我們將在下一節中進一步探討。請查看高度如何通過百分比處理： 您將植物容器的高度設置為 13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。 您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。 然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 918,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "c9618cd60e5c6126d6cba4449cfaef25",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "}plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼片段中值得注意的是相對定位和絕對定位的混合，我們將在下一節中進一步探討。請查看高度如何通過百分比處理： 您將植物容器的高度設置為 13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。 您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。 然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05;\nz-index: 1;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 915,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "f9b4ddaeabeabe069efff8b610c82f8d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼片段中值得注意的是相對定位和絕對定位的混合，我們將在下一節中進一步探討。請查看高度如何通過百分比處理： 您將植物容器的高度設置為 13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。 您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。 然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top {\nwidth: 50%;\nheight: 5%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 80",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 940,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "44058b1e7a55ad41a142e0019186aabf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "13%，這是一個不錯的數值，確保所有植物都能顯示在每個垂直容器中，而無需滾動。 您將植物容器向左移動，使植物在其容器中更居中。圖片有大量透明背景，以便使它們更易於拖動，因此需要向左移動以更好地適應螢幕。 然後，植物本身的最大寬度設置為 150%。這使得它能隨瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在其容器中，但縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%;\nleft: 25%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 837,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "6e2aa18443320511a783dd7264dfd724",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放置在微型生態瓶內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07;\nz-index: 1;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 622,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "746498ac81ec4f839609f74641872f75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky 定位）可能有點棘手，但如果使用得當，則可以很好地控制頁面上的元素。 絕對定位的元素是相對於其最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom {\nwidth: 50%;\nheight: 1%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 0%;\nleft: 25%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 599,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "15f929ce9af839a989646d0cbe8fc6da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "CSS 的指示，從其初始位置調整其位置。 在我們的示例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也具有絕對定位，這是使其可拖動所必需的，您將在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在，您將使用所學知識完全使用 CSS 建立微型生態瓶！ 首先，使用 CSS 將terrarium div 子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07;\n} dirt {\nwidth: 60%;\nheight: 5%;\nbackground: #3a241d;\nposition: absolute;\nborder-radius: 0 0 1rem 1rem;\nbottom: 1%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "65d705787cfc3260114721557cfbf0bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; } dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07;\nz-index: -1;\n}\n```\n注意此處使用的百分比。如果您縮小瀏覽器，您可以看到瓶子也會縮小。還請注意瓶子元素的寬度和高度百分比，以及每個元素如何絕對定位在中心，固定在視窗底部。\n我們還使用了 rem 作為邊框半徑的單位，這是一種相對於字體的長度。可以在 CSS 規範 中了解更多關於這種相對測量的方法。\n✅ 嘗試更改瓶子顏色和透明度與泥土的顏色和透明度。會發生什麼？為什麼？\n🚀挑戰\n在瓶子的左下角添加一個“氣泡”光澤，使其看起來更像玻璃。您將設置 jar-glossy-long 和",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "b57be4c76b23b31812295b658c6d82fb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "微型生態瓶項目第二部分：CSS簡介",
    "content": "05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; } dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07; z-index: -1; } ``` 注意此處使用的百分比。如果您縮小瀏覽器，您可以看到瓶子也會縮小。還請注意瓶子元素的寬度和高度百分比，以及每個元素如何絕對定位在中心，固定在視窗底部。 我們還使用了 rem 作為邊框半徑的單位，這是一種相對於字體的長度。可以在 CSS 規範 中了解更多關於這種相對測量的方法。 ✅ 嘗試更改瓶子顏色和透明度與泥土的顏色和透明度。會發生什麼？為什麼？ 🚀挑戰 在瓶子的左下角添加一個“氣泡”光澤，使其看起來更像玻璃。您將設置 jar-glossy-long 和jar-glossy-short 的樣式，使其看起來像反射的光澤。完成後效果如下：\n要完成課後測驗，請通過以下 Learn 模組：使用 CSS 為 HTML 應用程式設置樣式\n課後測驗\n課後測驗\n回顧與自學\nCSS 看似簡單，但在嘗試為所有瀏覽器和所有螢幕尺寸完美設計應用程式時，會遇到許多挑戰。CSS-Grid 和 Flexbox 是為使工作更結構化、更可靠而開發的工具。通過玩 Flexbox Froggy 和 Grid Garden 來學習這些工具。\n作業\nCSS 重構\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10384,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 868,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "371f49b32905984e1bf95fe5635be578",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\assignment.md",
    "source_type": "git_repo",
    "title": "玩轉函數",
    "content": "玩轉函數\n指引\n創建不同的函數，包括會返回值的函數和不會返回值的函數。\n試試看能否創建一個同時包含普通參數和帶有預設值參數的函數。\n評分標準\n| 評分標準 | 卓越                                                                                     | 合格                                                         | 需要改進         |\n| -------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------ | ----------------- |\n|          | 提供的解決方案包含兩個或以上表現良好的函數，並且參數多樣化                               | 提供的解決方案包含一個函數，並且參數較少                     | 解決方案有錯誤   |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1546,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 415,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "39745f4862b965c839673d63e4f0814a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "JavaScript 基礎：數據類型\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n這節課涵蓋了 JavaScript 的基礎知識，這是一種為網頁提供互動性的語言。\n你可以在 Microsoft Learn 上學習這節課！\n🎥 點擊上方圖片觀看有關變數和數據類型的影片\n讓我們從變數和填充它們的數據類型開始吧！\n變數\n變數用來存儲可以在程式中使用和更改的值。\n創建和宣告一個變數的語法是 [關鍵字] [名稱]。它由以下兩部分組成：\n關鍵字。關鍵字可以是 let 或 var。\n✅ 關鍵字 let 是在 ES6 中引入的，為變數提供了所謂的 區塊作用域。建議使用 let 而不是 var。我們會在後續部分更深入地討論區塊作用域。\n- 變數名稱，這是你自己選擇的名稱。\n任務 - 使用變數\n宣告一個變數。讓我們使用 let 關鍵字宣告一個變數：\njavascript\nlet myVariable;\n現在 myVariable 已經使用 let 關鍵字宣告了。它目前還沒有值。\n賦值。使用 = 運算符將值存儲到變數中，後面跟著期望的值。\njavascript\nmyVariable = 123;\n注意：在本課中，= 的使用表示我們使用了一個 \"賦值運算符\"，用於將值設置給變數。它並不表示等於。\n現在 myVariable 已經被初始化為值 123。\n重構。用以下語句替換你的程式碼。\njavascript\nlet myVariable = 123;\n上述操作稱為 顯式初始化，即在宣告變數的同時賦予其值。\n更改變數值。以以下方式更改變數值：\njavascript\nmyVariable = 321;\n一旦變數被宣告，你可以在程式中的任何地方使用 = 運算符和新值來更改其值。\n✅ 試試看！你可以直接在瀏覽器中撰寫 JavaScript。打開瀏覽器窗口並導航到開發者工具。在控制台中，你會看到一個提示符；輸入 let myVariable = 123，按下回車，然後輸入 myVariable。會發生什麼？注意，你會在後續課程中學到更多這些概念。\n常數\n常數的宣告和初始化與變數的概念相同，不過使用的是 const 關鍵字。常數通常用全大寫字母宣告。\njavascript\nconst MY_VARIABLE = 123;\n常數與變數相似，但有兩個例外：\n必須有值。常數必須被初始化，否則在執行程式時會出錯。\n引用不能更改。常數的引用一旦初始化後就不能更改，否則在執行程式時會出錯。我們來看兩個例子：\n簡單值。以下是不允許的：\njavascript\nconst PI = 3;\nPI = 4; // not allowed\n物件引用受保護。以下是不允許的：\njavascript\nconst obj = { a: 3 };\nobj = { b: 5 } // not allowed\n物件值不受保護。以下是允許的：\njavascript\nconst obj = { a: 3 };\nobj",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1133,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "63911798c44485bfa0ef31b601da8403",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "重構。用以下語句替換你的程式碼。 javascript let myVariable = 123; 上述操作稱為 顯式初始化，即在宣告變數的同時賦予其值。 更改變數值。以以下方式更改變數值： javascript myVariable = 321; 一旦變數被宣告，你可以在程式中的任何地方使用 = 運算符和新值來更改其值。 ✅ 試試看！你可以直接在瀏覽器中撰寫 JavaScript。打開瀏覽器窗口並導航到開發者工具。在控制台中，你會看到一個提示符；輸入 let myVariable = 123，按下回車，然後輸入 myVariable。會發生什麼？注意，你會在後續課程中學到更多這些概念。 常數 常數的宣告和初始化與變數的概念相同，不過使用的是 const 關鍵字。常數通常用全大寫字母宣告。 javascript const MY_VARIABLE = 123; 常數與變數相似，但有兩個例外： 必須有值。常數必須被初始化，否則在執行程式時會出錯。 引用不能更改。常數的引用一旦初始化後就不能更改，否則在執行程式時會出錯。我們來看兩個例子： 簡單值。以下是不允許的： javascript const PI = 3; PI = 4; // not allowed 物件引用受保護。以下是不允許的： javascript const obj = { a: 3 }; obj = { b: 5 } // not allowed 物件值不受保護。以下是允許的： javascript const obj = { a: 3 }; obja = 5;  // allowed\n上述操作更改了物件的值，但沒有更改其引用本身，因此是允許的。\n注意，const 表示引用受到重新賦值的保護。然而，值並不是 不可變 的，尤其是當它是像物件這樣的複雜結構時，值仍然可以更改。\n數據類型\n變數可以存儲多種不同類型的值，例如數字和文字。這些不同類型的值被稱為 數據類型。數據類型是軟件開發中的重要部分，因為它幫助開發者決定程式應該如何編寫以及軟件應該如何運行。此外，一些數據類型具有獨特的功能，可以幫助轉換或提取值中的附加信息。\n✅ 數據類型也被稱為 JavaScript 的數據原始類型，因為它們是語言提供的最低級別的數據類型。共有 7 種原始數據類型：string、number、bigint、boolean、undefined、null 和 symbol。花點時間想像一下這些原始類型各自代表什麼。例如，什麼是 zebra？0 呢？true 呢？\n數字\n在上一節中，myVariable 的值是一個數字數據類型。\nlet myVariable = 123;\n變數可以存儲所有類型的數字，包括小數或負數。數字還可以與算術運算符一起使用，這部分內容會在下一節中介紹。\n算術運算符\n在執行算術運算時可以使用多種類型的運算符，以下列出了一些：\n| 符號  | 描述                                                                      | 範例                              |\n| ------ | ------------------------------------------------------------------------ | -------------------------------- |\n| +    | 加法：計算兩個數字的和                                              | 1 + 2 //預期答案是 3           |\n| -    | 減法：計算兩個數字的差                                              | 1 - 2 //預期答案是 -1          |\n| *    | 乘法：計算兩個數字的乘積                                            | 1 * 2 //預期答案是 2           |\n| /    | 除法：計算兩個數字的商                                              | 1 / 2 //預期答案是 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1303,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "07effe69549c5bec61a6f445eea9c2b8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "JavaScript 的數據原始類型，因為它們是語言提供的最低級別的數據類型。共有 7 種原始數據類型：string、number、bigint、boolean、undefined、null 和 symbol。花點時間想像一下這些原始類型各自代表什麼。例如，什麼是 zebra？0 呢？true 呢？ 數字 在上一節中，myVariable 的值是一個數字數據類型。 let myVariable = 123; 變數可以存儲所有類型的數字，包括小數或負數。數字還可以與算術運算符一起使用，這部分內容會在下一節中介紹。 算術運算符 在執行算術運算時可以使用多種類型的運算符，以下列出了一些： | 符號 | 描述 | 範例 | | ------ | ------------------------------------------------------------------------ | -------------------------------- | | + | 加法：計算兩個數字的和 | 1 + 2 //預期答案是 3 | | - | 減法：計算兩個數字的差 | 1 - 2 //預期答案是 -1 | | * | 乘法：計算兩個數字的乘積 | 1 * 2 //預期答案是 2 | | / | 除法：計算兩個數字的商 | 1 / 2 //預期答案是 05         |\n| %    | 餘數：計算兩個數字相除後的餘數                                      | 1 % 2 //預期答案是 1           |\n✅ 試試看！在瀏覽器的控制台中嘗試一個算術運算。結果是否讓你感到驚訝？\n字串\n字串是一組位於單引號或雙引號之間的字符。\n'這是一個字串'\n\"這也是一個字串\"\nlet myString = '這是一個存儲在變數中的字串值';\n記得在撰寫字串時使用引號，否則 JavaScript 會假設它是一個變數名稱。\n格式化字串\n字串是文本，可能需要不時進行格式化。\n要連接兩個或多個字串，或將它們拼接在一起，可以使用 + 運算符。\n```javascript\nlet myString1 = \"Hello\";\nlet myString2 = \"World\";\nmyString1 + myString2 + \"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "e1a2e96764c42d035803a5870e35a307",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "| - | 減法：計算兩個數字的差 | 1 - 2 //預期答案是 -1 | | * | 乘法：計算兩個數字的乘積 | 1 * 2 //預期答案是 2 | | / | 除法：計算兩個數字的商 | 1 / 2 //預期答案是 05 | | % | 餘數：計算兩個數字相除後的餘數 | 1 % 2 //預期答案是 1 | ✅ 試試看！在瀏覽器的控制台中嘗試一個算術運算。結果是否讓你感到驚訝？ 字串 字串是一組位於單引號或雙引號之間的字符。 '這是一個字串' \"這也是一個字串\" let myString = '這是一個存儲在變數中的字串值'; 記得在撰寫字串時使用引號，否則 JavaScript 會假設它是一個變數名稱。 格式化字串 字串是文本，可能需要不時進行格式化。 要連接兩個或多個字串，或將它們拼接在一起，可以使用 + 運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 445,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "e2c812666305d20501ed08c8249116a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "/ | 除法：計算兩個數字的商 | 1 / 2 //預期答案是 05 | | % | 餘數：計算兩個數字相除後的餘數 | 1 % 2 //預期答案是 1 | ✅ 試試看！在瀏覽器的控制台中嘗試一個算術運算。結果是否讓你感到驚訝？ 字串 字串是一組位於單引號或雙引號之間的字符。 '這是一個字串' \"這也是一個字串\" let myString = '這是一個存儲在變數中的字串值'; 記得在撰寫字串時使用引號，否則 JavaScript 會假設它是一個變數名稱。 格式化字串 字串是文本，可能需要不時進行格式化。 要連接兩個或多個字串，或將它們拼接在一起，可以使用 + 運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World```\n✅ 為什麼在 JavaScript 中 1 + 1 = 2，但 '1' + '1' = 11？想一想。那 '1' + 1 呢？\n模板字串是格式化字串的另一種方式，不過使用的是反引號而不是引號。任何非純文本的內容都必須放在 ${ } 區塊中，包括可能是字串的變數。\n```javascript\nlet myString1 = \"Hello\";\nlet myString2 = \"World\";\n${myString1} ${myString2}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "e657ef2f5d8425542b78a4a4a9450740",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "會假設它是一個變數名稱。 格式化字串 字串是文本，可能需要不時進行格式化。 要連接兩個或多個字串，或將它們拼接在一起，可以使用 + 運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World``` ✅ 為什麼在 JavaScript 中 1 + 1 = 2，但 '1' + '1' = 11？想一想。那 '1' + 1 呢？ 模板字串是格式化字串的另一種方式，不過使用的是反引號而不是引號。任何非純文本的內容都必須放在 ${ } 區塊中，包括可能是字串的變數。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; ${myString1} ${myString2}//Hello World ${myString1}, ${myString2} //Hello, World",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 314,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "a45cbd886c6ed929b764140e7116f255",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：數據類型",
    "content": "運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World``` ✅ 為什麼在 JavaScript 中 1 + 1 = 2，但 '1' + '1' = 11？想一想。那 '1' + 1 呢？ 模板字串是格式化字串的另一種方式，不過使用的是反引號而不是引號。任何非純文本的內容都必須放在 ${ } 區塊中，包括可能是字串的變數。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; ${myString1} ${myString2}//Hello World ${myString1}, ${myString2} //Hello, World```\n你可以使用任一方法實現格式化目標，但模板字串會保留所有空格和換行。\n✅ 什麼時候你會使用模板字串而不是普通字串？\n布林值\n布林值只有兩個值：true 或 false。布林值可以幫助決定在滿足某些條件時應該執行哪些程式碼。在許多情況下，運算符會協助設置布林值，你會經常看到並撰寫變數在初始化或更新其值時使用運算符。\nlet myTrueBool = true\nlet myFalseBool = false\n✅ 如果一個變數被認為是 \"truthy\"，那麼它會評估為布林值 true。有趣的是，在 JavaScript 中，所有值都是 truthy，除非被定義為 falsy。\n🚀 挑戰\nJavaScript 因其在處理數據類型時偶爾會有令人驚訝的行為而聞名。研究一下這些 \"陷阱\"。例如：大小寫敏感可能會讓你吃虧！在控制台中試試這個：let age = 1; let Age = 2; age == Age（結果是 false —— 為什麼？）。你還能找到哪些陷阱？\n課後測驗\n課後測驗\n複習與自學\n看看這份 JavaScript 練習列表，試著完成一個。你學到了什麼？\n作業\n數據類型練習\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9508,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 920,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "e87207ce508805a6f52f369f38a037f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\assignment.md",
    "source_type": "git_repo",
    "title": "運算符",
    "content": "運算符\n指引\n試試運用運算符。以下是一個你可以實現的程式建議：\n你有一組來自兩個不同評分系統的學生。\n第一個評分系統\n第一個評分系統的分數範圍是1到5，其中3分或以上表示通過課程。\n第二個評分系統\n另一個評分系統的分數包括 A, A-, B, B-, C, C-，其中 A 是最高分，C 是最低的及格分數。\n任務\n給定以下陣列 allStudents，表示所有學生及其分數，構建一個新的陣列 studentsWhoPass，包含所有通過的學生。\nTIP，使用 for-loop 和 if",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1845,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 231,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "02c56e5ccb27f6a65edb6e68a01b8b72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\assignment.md",
    "source_type": "git_repo",
    "title": "運算符",
    "content": "運算符\n指引\n試試運用運算符。以下是一個你可以實現的程式建議：\n你有一組來自兩個不同評分系統的學生。\n第一個評分系統\n第一個評分系統的分數範圍是1到5，其中3分或以上表示通過課程。\n第二個評分系統\n另一個評分系統的分數包括 A, A-, B, B-, C, C-，其中 A 是最高分，C 是最低的及格分數。\n任務\n給定以下陣列 allStudents，表示所有學生及其分數，構建一個新的陣列 studentsWhoPass，包含所有通過的學生。\nTIP，使用 for-loop 和 ifelse 以及比較運算符：\n```javascript\nlet allStudents = [\n'A',\n'B-',\n1,\n4,\n5,\n2\n]\nlet studentsWhoPass = [];\n```\n評分標準\n| 標準     | 優秀表現                     | 合格表現                     | 需要改進                     |\n| -------- | ---------------------------- | ---------------------------- | ---------------------------- |\n|          | 提供完整的解決方案           | 提供部分解決方案             | 提供有錯誤的解決方案         |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1845,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 553,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "05807e8ef763e4fbda66324164a357af",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "JavaScript 基礎：作出決策\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n作出決策並控制程式碼執行的順序可以讓你的程式碼更具可重用性和穩健性。本節將介紹在 JavaScript 中控制資料流的語法，以及它在使用布林值時的重要性。\n🎥 點擊上方圖片觀看有關作出決策的影片。\n你可以在 Microsoft Learn 上學習這節課！\n布林值簡介\n布林值只有兩個可能的值：true 或 false。布林值可以幫助決定在特定條件下應執行哪些程式碼。\n你可以像這樣設定布林值為 true 或 false：\nlet myTrueBool = true\nlet myFalseBool = false\n✅ 布林值的名稱來自英國數學家、哲學家和邏輯學家 George Boole (1815–1864)。\n比較運算符與布林值\n運算符用於通過比較來評估條件，並生成布林值。以下是一些常用的運算符。\n| 符號  | 描述                                                                                                                                                   | 範例                |\n| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------ |\n| <    | 小於：比較兩個值，若左側值小於右側值，則返回 true 布林值                                                                                          | 5 < 6 // true    |\n| <=   | 小於或等於：比較兩個值，若左側值小於或等於右側值，則返回 true 布林值                                                                              | 5 <= 6 // true   |\n| >    | 大於：比較兩個值，若左側值大於右側值，則返回 true 布林值                                                                                          | 5 > 6 // false   |\n| >=   | 大於或等於：比較兩個值，若左側值大於或等於右側值，則返回 true 布林值                                                                              | 5 >= 6 // false  |\n| ===  | 嚴格相等：比較兩個值，若左右兩側的值相等且類型相同，則返回 true 布林值                                                                            | 5 === 6 // false |\n|",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 701,
    "chunk_index": 0,
    "total_chunks": 8
  },
  {
    "id": "6ce97c3e689f7f125bd231efa4ac285a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "| 範例 | | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------ | | < | 小於：比較兩個值，若左側值小於右側值，則返回 true 布林值 | 5 < 6 // true | | <= | 小於或等於：比較兩個值，若左側值小於或等於右側值，則返回 true 布林值 | 5 <= 6 // true | | > | 大於：比較兩個值，若左側值大於右側值，則返回 true 布林值 | 5 > 6 // false | | >= | 大於或等於：比較兩個值，若左側值大於或等於右側值，則返回 true 布林值 | 5 >= 6 // false | | === | 嚴格相等：比較兩個值，若左右兩側的值相等且類型相同，則返回 true 布林值 | 5 === 6 // false | |==  | 不相等：比較兩個值，返回與嚴格相等運算符相反的布林值                                                                                               | 5 == 6 // true  |\n✅ 在瀏覽器的控制台中寫一些比較來檢查你的知識。返回的數據是否有讓你感到驚訝？\nIf 語句\nIf 語句會在條件為 true 時執行其區塊中的程式碼。\njavascript\nif (condition) {\n//Condition is true Code in this block will run",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 457,
    "chunk_index": 1,
    "total_chunks": 8
  },
  {
    "id": "b390bc92392de1e260bf74ce88de6912",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "5 <= 6 // true | | > | 大於：比較兩個值，若左側值大於右側值，則返回 true 布林值 | 5 > 6 // false | | >= | 大於或等於：比較兩個值，若左側值大於或等於右側值，則返回 true 布林值 | 5 >= 6 // false | | === | 嚴格相等：比較兩個值，若左右兩側的值相等且類型相同，則返回 true 布林值 | 5 === 6 // false | |== | 不相等：比較兩個值，返回與嚴格相等運算符相反的布林值 | 5 == 6 // true | ✅ 在瀏覽器的控制台中寫一些比較來檢查你的知識。返回的數據是否有讓你感到驚訝？ If 語句 If 語句會在條件為 true 時執行其區塊中的程式碼。 javascript if (condition) { //Condition is true Code in this block will run}\n邏輯運算符通常用於形成條件。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nif (currentMoney >= laptopPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n}\n```\nIf Else 語句\nelse 語句會在條件為 false 時執行其區塊中的程式碼。它是 if 語句的可選部分。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nif (currentMoney >= laptopPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n} else {\n//Condition is false",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 2,
    "total_chunks": 8
  },
  {
    "id": "4ff33ad89dbf1f2538217c4e4677a04f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "is true Code in this block will run} 邏輯運算符通常用於形成條件。 ```javascript let currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } ``` If Else 語句 else 語句會在條件為 false 時執行其區塊中的程式碼。它是 if 語句的可選部分。 ```javascript let currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } else { //Condition is falseCode in this block will run console log(\"Can't afford a new laptop, yet \");\n}\n```\n✅ 在瀏覽器控制台中執行此程式碼以及以下程式碼來測試你的理解。更改 currentMoney 和 laptopPrice 變數的值以改變返回的 console log()。\nSwitch 語句\nswitch 語句用於根據不同條件執行不同的操作。使用 switch 語句選擇要執行的多個程式碼區塊之一。\njavascript\nswitch (expression) {\ncase x:\n// code block\nbreak;\ncase y:\n// code block\nbreak;\ndefault:\n// code block\n}\n```javascript\n// program using switch statement\nlet a = 2;\nswitch (a) {\ncase 1:\na = \"one\";\nbreak;\ncase 2:\na = \"two\";\nbreak;\ndefault:\na = \"not found\";\nbreak;\n}\nconsole log(The value is ${a});\n```\n✅ 在瀏覽器控制台中執行此程式碼以及以下程式碼來測試你的理解。更改變數 a 的值以改變返回的 console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 3,
    "total_chunks": 8
  },
  {
    "id": "54bc613cdf65860053ae09b7eac5d2fc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "currentMoney 和 laptopPrice 變數的值以改變返回的 console log()。 Switch 語句 switch 語句用於根據不同條件執行不同的操作。使用 switch 語句選擇要執行的多個程式碼區塊之一。 javascript switch (expression) { case x: // code block break; case y: // code block break; default: // code block } ```javascript // program using switch statement let a = 2; switch (a) { case 1: a = \"one\"; break; case 2: a = \"two\"; break; default: a = \"not found\"; break; } console log(The value is ${a}); ``` ✅ 在瀏覽器控制台中執行此程式碼以及以下程式碼來測試你的理解。更改變數 a 的值以改變返回的 consolelog()。\n邏輯運算符與布林值\n決策可能需要多個比較，可以使用邏輯運算符串聯起來生成布林值。\n| 符號  | 描述                                                                                     | 範例                                                                 |\n| ------ | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| &&   | 邏輯 AND：比較兩個布林表達式。僅當兩側都為 true 時返回 true                          | (5 > 6) && (5 < 6 ) //一側為 false，另一側為 true。返回 false     |\n| \\|\\| | 邏輯 OR：比較兩個布林表達式。只要有一側為 true 就返回 true                          | (5 > 6) \\|\\| (5 < 6) //一側為 false，另一側為 true。返回 true     |\n|",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 4,
    "total_chunks": 8
  },
  {
    "id": "8af59e17fc2239f62821f29c3ae61287",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "= \"not found\"; break; } console log(The value is ${a}); ``` ✅ 在瀏覽器控制台中執行此程式碼以及以下程式碼來測試你的理解。更改變數 a 的值以改變返回的 consolelog()。 邏輯運算符與布林值 決策可能需要多個比較，可以使用邏輯運算符串聯起來生成布林值。 | 符號 | 描述 | 範例 | | ------ | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------- | | && | 邏輯 AND：比較兩個布林表達式。僅當兩側都為 true 時返回 true | (5 > 6) && (5 < 6 ) //一側為 false，另一側為 true。返回 false | | \\|\\| | 邏輯 OR：比較兩個布林表達式。只要有一側為 true 就返回 true | (5 > 6) \\|\\| (5 < 6) //一側為 false，另一側為 true。返回 true | || 邏輯 NOT：返回布林表達式的相反值                                                     | (5 > 6) // 5 不大於 6，但 \" \" 會返回 true                        |\n使用邏輯運算符進行條件判斷與決策\n邏輯運算符可以用於在 if else 語句中形成條件。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nlet laptopDiscountPrice = laptopPrice - laptopPrice * 0 2; //Laptop price at 20 percent off\nif (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n} else {\n//Condition is true",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 5,
    "total_chunks": 8
  },
  {
    "id": "a4878dcb23a24eb873c06415cbd5b0b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "//一側為 false，另一側為 true。返回 true | || 邏輯 NOT：返回布林表達式的相反值 | (5 > 6) // 5 不大於 6，但 \" \" 會返回 true | 使用邏輯運算符進行條件判斷與決策 邏輯運算符可以用於在 if else 語句中形成條件。 ```javascript let currentMoney; let laptopPrice; let laptopDiscountPrice = laptopPrice - laptopPrice * 0 2; //Laptop price at 20 percent off if (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } else { //Condition is trueCode in this block will run console log(\"Can't afford a new laptop, yet \");\n}\n```\n否定運算符\n到目前為止，你已經看到如何使用 if else 語句來創建條件邏輯。任何進入 if 的內容都需要評估為 true 或 false。通過使用 運算符，你可以否定表達式。它看起來像這樣：\njavascript\nif ( condition) {\n// runs if condition is false\n} else {\n// runs if condition is true\n}\n三元運算符\nif else 不是表達決策邏輯的唯一方式。你還可以使用一種稱為三元運算符的方式。其語法如下：\njavascript\nlet variable = condition <return this if true> : <return this if false>\n以下是一個更具體的例子：\njavascript\nlet firstNumber = 20;\nlet secondNumber = 10;\nlet biggestNumber = firstNumber > secondNumber",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 6,
    "total_chunks": 8
  },
  {
    "id": "22eb002a9a355458a6a82afc9f5e643e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：作出決策",
    "content": "console log(\"Can't afford a new laptop, yet \"); } ``` 否定運算符 到目前為止，你已經看到如何使用 if else 語句來創建條件邏輯。任何進入 if 的內容都需要評估為 true 或 false。通過使用 運算符，你可以否定表達式。它看起來像這樣： javascript if ( condition) { // runs if condition is false } else { // runs if condition is true } 三元運算符 if else 不是表達決策邏輯的唯一方式。你還可以使用一種稱為三元運算符的方式。其語法如下： javascript let variable = condition <return this if true> : <return this if false> 以下是一個更具體的例子： javascript let firstNumber = 20; let secondNumber = 10; let biggestNumber = firstNumber > secondNumberfirstNumber : secondNumber;\n✅ 花點時間多讀幾遍這段程式碼。你理解這些運算符是如何工作的嗎？\n上述程式碼表示：\n如果 firstNumber 大於 secondNumber\n那麼將 firstNumber 賦值給 biggestNumber\n否則將 secondNumber 賦值給 biggestNumber。\n三元運算符只是以下程式碼的簡潔寫法：\njavascript\nlet biggestNumber;\nif (firstNumber > secondNumber) {\nbiggestNumber = firstNumber;\n} else {\nbiggestNumber = secondNumber;\n}\n🚀 挑戰\n創建一個程式，首先使用邏輯運算符編寫，然後使用三元運算符重寫。你更喜歡哪種語法？\n課後測驗\n課後測驗\n回顧與自學\n閱讀更多有關使用者可用的運算符 在 MDN。\n瀏覽 Josh Comeau 的精彩 運算符查詢工具！\n作業\n運算符\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9130,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 740,
    "chunk_index": 7,
    "total_chunks": 8
  },
  {
    "id": "e548b376f2945923d8f71e64dcf700a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\assignment.md",
    "source_type": "git_repo",
    "title": "遍歷陣列",
    "content": "遍歷陣列\n指示\n建立一個程式，列出1到20之間的每第三個數字，並將其打印到控制台。\n提示：使用for迴圈並修改迴圈的迭代表達式\n評分標準\n| 評分標準 | 表現卓越                               | 表現尚可                 | 需要改進                      |\n| -------- | --------------------------------------- | ------------------------ | ------------------------------ |\n|          | 程式運行正確且有註解                   | 程式沒有註解             | 程式不完整或有錯誤            |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1280,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 365,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "99ef71f8561b4a264d2d9770ee438bea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "JavaScript 基礎：方法與函數\nSketchnote 由 Tomomi Imura 提供\n課前測驗\n課前測驗\n當我們考慮撰寫程式碼時，總是希望程式碼具有可讀性。雖然這聽起來有些違背直覺，但程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函數，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函數的影片。\n你可以在 Microsoft Learn 上學習這節課！\n函數\n從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！\n同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。\n建立與調用函數\n函數的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函數來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 598,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "e4cf17616aca48a654e6ae07dff8bbe8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "JavaScript 基礎：方法與函數\nSketchnote 由 Tomomi Imura 提供\n課前測驗\n課前測驗\n當我們考慮撰寫程式碼時，總是希望程式碼具有可讀性。雖然這聽起來有些違背直覺，但程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函數，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函數的影片。\n你可以在 Microsoft Learn 上學習這節課！\n函數\n從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！\n同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。\n建立與調用函數\n函數的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函數來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 603,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "5c4d7e0195409cb6f1039e1906b7de49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "JavaScript 基礎：方法與函數\nSketchnote 由 Tomomi Imura 提供\n課前測驗\n課前測驗\n當我們考慮撰寫程式碼時，總是希望程式碼具有可讀性。雖然這聽起來有些違背直覺，但程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函數，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函數的影片。\n你可以在 Microsoft Learn 上學習這節課！\n函數\n從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！\n同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。\n建立與調用函數\n函數的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函數來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 751,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "6823321045a3769c5051fc26026fc7b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "JavaScript 基礎：方法與函數\nSketchnote 由 Tomomi Imura 提供\n課前測驗\n課前測驗\n當我們考慮撰寫程式碼時，總是希望程式碼具有可讀性。雖然這聽起來有些違背直覺，但程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函數，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函數的影片。\n你可以在 Microsoft Learn 上學習這節課！\n函數\n從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！\n同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。\n建立與調用函數\n函數的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函數來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函數的區別在於，方法附加在一個物件上（在我們的例子中是 console），而函數則是獨立的。你會發現許多開發者會將這些術語交替使用。\n函數的最佳實踐\n在建立函數時，有一些最佳實踐需要記住：\n一如既往，使用描述性的名稱，這樣你就知道函數的用途\n使用 camelCasing 來組合單詞\n讓你的函數專注於特定的任務\n傳遞資訊給函數\n為了讓函數更具重用性，你通常會希望向函數傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1037,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "be635fa6a1ddbafa75fe21d889889c0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "JavaScript 基礎：方法與函數\nSketchnote 由 Tomomi Imura 提供\n課前測驗\n課前測驗\n當我們考慮撰寫程式碼時，總是希望程式碼具有可讀性。雖然這聽起來有些違背直覺，但程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函數，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函數的影片。\n你可以在 Microsoft Learn 上學習這節課！\n函數\n從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！\n同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。\n建立與調用函數\n函數的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函數來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函數的區別在於，方法附加在一個物件上（在我們的例子中是 console），而函數則是獨立的。你會發現許多開發者會將這些術語交替使用。\n函數的最佳實踐\n在建立函數時，有一些最佳實踐需要記住：\n一如既往，使用描述性的名稱，這樣你就知道函數的用途\n使用 camelCasing 來組合單詞\n讓你的函數專注於特定的任務\n傳遞資訊給函數\n為了讓函數更具重用性，你通常會希望向函數傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個最有用的函數。如果我們想讓它更靈活一些，比如允許指定要問候的人的名字，我們可以新增一個 參數。參數（有時也稱為 引數）是傳遞給函數的額外資訊。\n參數在定義部分列於括號內，並用逗號分隔，如下所示：\n```javascript\nfunction name(param, param2, param3) {\n}\n```\n我們可以更新 displayGreeting 來接受一個名字並顯示它。\njavascript\nfunction displayGreeting(name) {\nconst message = `Hello, ${name}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1241,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "229329f3aa2466d539c5356f6764986e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "上學習這節課！ 函數 從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！ 同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。 建立與調用函數 函數的語法如下所示： javascript function nameOfFunction() { // function definition // function definition/body } 如果我想建立一個函數來顯示問候語，它可能看起來像這樣： javascript function displayGreeting() { consolelog('Hello, world'); } 每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函數的區別在於，方法附加在一個物件上（在我們的例子中是 console），而函數則是獨立的。你會發現許多開發者會將這些術語交替使用。 函數的最佳實踐 在建立函數時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，這樣你就知道函數的用途 使用 camelCasing 來組合單詞 讓你的函數專注於特定的任務 傳遞資訊給函數 為了讓函數更具重用性，你通常會希望向函數傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個最有用的函數。如果我們想讓它更靈活一些，比如允許指定要問候的人的名字，我們可以新增一個 參數。參數（有時也稱為 引數）是傳遞給函數的額外資訊。 參數在定義部分列於括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 來接受一個名字並顯示它。 javascript function displayGreeting(name) { const message = `Hello, ${name}`;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1014,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "014e8e9f0f938c4202f2e31b2660d78b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "函數 從本質上來說，函數是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複相同的邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時調用它——甚至可以從其他函數中調用函數！ 同樣重要的是為函數命名的能力。雖然這看似微不足道，但名稱為程式碼的一部分提供了一種快速的文件化方式。你可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止計時。 建立與調用函數 函數的語法如下所示： javascript function nameOfFunction() { // function definition // function definition/body } 如果我想建立一個函數來顯示問候語，它可能看起來像這樣： javascript function displayGreeting() { consolelog('Hello, world'); } 每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函數的區別在於，方法附加在一個物件上（在我們的例子中是 console），而函數則是獨立的。你會發現許多開發者會將這些術語交替使用。 函數的最佳實踐 在建立函數時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，這樣你就知道函數的用途 使用 camelCasing 來組合單詞 讓你的函數專注於特定的任務 傳遞資訊給函數 為了讓函數更具重用性，你通常會希望向函數傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個最有用的函數。如果我們想讓它更靈活一些，比如允許指定要問候的人的名字，我們可以新增一個 參數。參數（有時也稱為 引數）是傳遞給函數的額外資訊。 參數在定義部分列於括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 來接受一個名字並顯示它。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message);\n}\n當我們想要調用函數並傳遞參數時，我們在括號內指定它。\njavascript\ndisplayGreeting('Christopher');\n// displays \"Hello, Christopher",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1063,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "5b6004a01c30731faa880594b1735993",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "{ // function definition // function definition/body } 如果我想建立一個函數來顯示問候語，它可能看起來像這樣： javascript function displayGreeting() { consolelog('Hello, world'); } 每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函數的區別在於，方法附加在一個物件上（在我們的例子中是 console），而函數則是獨立的。你會發現許多開發者會將這些術語交替使用。 函數的最佳實踐 在建立函數時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，這樣你就知道函數的用途 使用 camelCasing 來組合單詞 讓你的函數專注於特定的任務 傳遞資訊給函數 為了讓函數更具重用性，你通常會希望向函數傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個最有用的函數。如果我們想讓它更靈活一些，比如允許指定要問候的人的名字，我們可以新增一個 參數。參數（有時也稱為 引數）是傳遞給函數的額外資訊。 參數在定義部分列於括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 來接受一個名字並顯示它。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message); } 當我們想要調用函數並傳遞參數時，我們在括號內指定它。 javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" when run\n預設值\n我們可以通過新增更多參數使函數更加靈活。但如果我們不希望每個值都必須指定呢？以我們的問候語示例為例，我們可以將名字設為必需（我們需要知道要問候誰），但我們希望允許問候語本身根據需要進行自定義。如果有人不想自定義它，我們可以提供一個預設值。要為參數提供預設值，我們可以像為變數設置值一樣進行設置 - parameterName = 'defaultValue'。以下是一個完整的示例：\njavascript\nfunction displayGreeting(name, salutation='Hello') {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 996,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "4e4ca114fb98724b22cdcec6836bcf45",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "world'); } 每當我們想要調用（或執行）函數時，我們使用函數名稱後加上 ()。值得注意的是，我們的函數可以在調用之前或之後定義；JavaScript 編譯器會幫你找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函數稱為 方法，你已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函數的區別在於，方法附加在一個物件上（在我們的例子中是 console），而函數則是獨立的。你會發現許多開發者會將這些術語交替使用。 函數的最佳實踐 在建立函數時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，這樣你就知道函數的用途 使用 camelCasing 來組合單詞 讓你的函數專注於特定的任務 傳遞資訊給函數 為了讓函數更具重用性，你通常會希望向函數傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個最有用的函數。如果我們想讓它更靈活一些，比如允許指定要問候的人的名字，我們可以新增一個 參數。參數（有時也稱為 引數）是傳遞給函數的額外資訊。 參數在定義部分列於括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 來接受一個名字並顯示它。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message); } 當我們想要調用函數並傳遞參數時，我們在括號內指定它。 javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" when run 預設值 我們可以通過新增更多參數使函數更加靈活。但如果我們不希望每個值都必須指定呢？以我們的問候語示例為例，我們可以將名字設為必需（我們需要知道要問候誰），但我們希望允許問候語本身根據需要進行自定義。如果有人不想自定義它，我們可以提供一個預設值。要為參數提供預設值，我們可以像為變數設置值一樣進行設置 - parameterName = 'defaultValue'。以下是一個完整的示例： javascript function displayGreeting(name, salutation='Hello') { consolelog(`${salutation}, ${name}`);\n}\n當我們調用函數時，我們可以決定是否為 salutation 設置值。\n```javascript\ndisplayGreeting('Christopher');\n// displays \"Hello, Christopher\"\ndisplayGreeting('Christopher', 'Hi');\n// displays \"Hi, Christopher\"\n```\n返回值\n到目前為止，我們建立的函數會始終輸出到 console。有時這正是我們所需要的，特別是當我們建立會調用其他服務的函數時。但如果我想建立一個輔助函數來執行計算並將值返回，以便在其他地方使用呢？\n我們可以通過使用 返回值 來實現。返回值由函數返回，並可以像存儲字串或數字這樣的靜態值一樣存儲在變數中。\n如果函數確實返回某些內容，那麼會使用關鍵字 return。return 關鍵字需要一個值或引用作為返回內容，如下所示：\njavascript\nreturn myVariable;\n我們可以建立一個函數來建立問候語訊息並將值返回給調用者。\njavascript\nfunction createGreetingMessage(name) {\nconst message = `Hello, ${name}`;\nreturn message;\n}\n當調用這個函數時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。\njavascript\nconst greetingMessage = createGreetingMessage('Christopher');\n函數作為函數的參數\n隨著你在程式設計職涯中的進步，你會遇到接受函數作為參數的函數。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要在響應中執行某個操作的情況。\n例如，考慮 setTimeout，它啟動一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函數的完美工作！\n如果你運行以下程式碼，3 秒後你會看到訊息 3 seconds has elapsed。\njavascript\nfunction displayDone() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1665,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "5d59e88de23655d192ce4c00fa9caf0d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "= 'defaultValue'。以下是一個完整的示例： javascript function displayGreeting(name, salutation='Hello') { consolelog(`${salutation}, ${name}`); } 當我們調用函數時，我們可以決定是否為 salutation 設置值。 ```javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" displayGreeting('Christopher', 'Hi'); // displays \"Hi, Christopher\" ``` 返回值 到目前為止，我們建立的函數會始終輸出到 console。有時這正是我們所需要的，特別是當我們建立會調用其他服務的函數時。但如果我想建立一個輔助函數來執行計算並將值返回，以便在其他地方使用呢？ 我們可以通過使用 返回值 來實現。返回值由函數返回，並可以像存儲字串或數字這樣的靜態值一樣存儲在變數中。 如果函數確實返回某些內容，那麼會使用關鍵字 return。return 關鍵字需要一個值或引用作為返回內容，如下所示： javascript return myVariable; 我們可以建立一個函數來建立問候語訊息並將值返回給調用者。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } 當調用這個函數時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。 javascript const greetingMessage = createGreetingMessage('Christopher'); 函數作為函數的參數 隨著你在程式設計職涯中的進步，你會遇到接受函數作為參數的函數。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要在響應中執行某個操作的情況。 例如，考慮 setTimeout，它啟動一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函數的完美工作！ 如果你運行以下程式碼，3 秒後你會看到訊息 3 seconds has elapsed。 javascript function displayDone() { consolelog('3 seconds has elapsed');\n}\n// timer value is in milliseconds\nsetTimeout(displayDone, 3000);\n匿名函數\n讓我們再看看我們建立的內容。我們建立了一個將被使用一次的具名函數。隨著應用程式變得更加複雜，我們可能會建立許多只會被調用一次的函數。這並不理想。事實證明，我們並不總是需要提供名稱！\n當我們將函數作為參數傳遞時，我們可以跳過事先建立它，而是在參數中直接建立。我們使用相同的 function 關鍵字，但將其作為參數的一部分來建立。\n讓我們重寫上面的程式碼以使用匿名函數：\njavascript\nsetTimeout(function() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1038,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "8ecbb5d58071aa8b11570aeb5f5851c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "displays \"Hi, Christopher\" ``` 返回值 到目前為止，我們建立的函數會始終輸出到 console。有時這正是我們所需要的，特別是當我們建立會調用其他服務的函數時。但如果我想建立一個輔助函數來執行計算並將值返回，以便在其他地方使用呢？ 我們可以通過使用 返回值 來實現。返回值由函數返回，並可以像存儲字串或數字這樣的靜態值一樣存儲在變數中。 如果函數確實返回某些內容，那麼會使用關鍵字 return。return 關鍵字需要一個值或引用作為返回內容，如下所示： javascript return myVariable; 我們可以建立一個函數來建立問候語訊息並將值返回給調用者。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } 當調用這個函數時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。 javascript const greetingMessage = createGreetingMessage('Christopher'); 函數作為函數的參數 隨著你在程式設計職涯中的進步，你會遇到接受函數作為參數的函數。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要在響應中執行某個操作的情況。 例如，考慮 setTimeout，它啟動一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函數的完美工作！ 如果你運行以下程式碼，3 秒後你會看到訊息 3 seconds has elapsed。 javascript function displayDone() { consolelog('3 seconds has elapsed'); } // timer value is in milliseconds setTimeout(displayDone, 3000); 匿名函數 讓我們再看看我們建立的內容。我們建立了一個將被使用一次的具名函數。隨著應用程式變得更加複雜，我們可能會建立許多只會被調用一次的函數。這並不理想。事實證明，我們並不總是需要提供名稱！ 當我們將函數作為參數傳遞時，我們可以跳過事先建立它，而是在參數中直接建立。我們使用相同的 function 關鍵字，但將其作為參數的一部分來建立。 讓我們重寫上面的程式碼以使用匿名函數： javascript setTimeout(function() { consolelog('3 seconds has elapsed');\n}, 3000);\n如果你運行我們的新程式碼，你會注意到我們得到了相同的結果。我們建立了一個函數，但不需要給它命名！\nFat Arrow 函數\n許多程式語言（包括 JavaScript）中常見的一個快捷方式是使用所謂的 箭頭函數 或 Fat Arrow 函數。它使用一個特殊的符號 =>，看起來像一個箭頭——因此得名！通過使用 =>，我們可以跳過 function 關鍵字。\n讓我們再一次重寫程式碼以使用 Fat Arrow 函數：\njavascript\nsetTimeout(() => {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1151,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "ef617991b133d61b8d7460e67e6fc10d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函數",
    "content": "當調用這個函數時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。 javascript const greetingMessage = createGreetingMessage('Christopher'); 函數作為函數的參數 隨著你在程式設計職涯中的進步，你會遇到接受函數作為參數的函數。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要在響應中執行某個操作的情況。 例如，考慮 setTimeout，它啟動一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函數的完美工作！ 如果你運行以下程式碼，3 秒後你會看到訊息 3 seconds has elapsed。 javascript function displayDone() { consolelog('3 seconds has elapsed'); } // timer value is in milliseconds setTimeout(displayDone, 3000); 匿名函數 讓我們再看看我們建立的內容。我們建立了一個將被使用一次的具名函數。隨著應用程式變得更加複雜，我們可能會建立許多只會被調用一次的函數。這並不理想。事實證明，我們並不總是需要提供名稱！ 當我們將函數作為參數傳遞時，我們可以跳過事先建立它，而是在參數中直接建立。我們使用相同的 function 關鍵字，但將其作為參數的一部分來建立。 讓我們重寫上面的程式碼以使用匿名函數： javascript setTimeout(function() { consolelog('3 seconds has elapsed'); }, 3000); 如果你運行我們的新程式碼，你會注意到我們得到了相同的結果。我們建立了一個函數，但不需要給它命名！ Fat Arrow 函數 許多程式語言（包括 JavaScript）中常見的一個快捷方式是使用所謂的 箭頭函數 或 Fat Arrow 函數。它使用一個特殊的符號 =>，看起來像一個箭頭——因此得名！通過使用 =>，我們可以跳過 function 關鍵字。 讓我們再一次重寫程式碼以使用 Fat Arrow 函數： javascript setTimeout(() => { consolelog('3 seconds has elapsed');\n}, 3000);\n何時使用哪種策略\n你現在已經看到了三種將函數作為參數的方式，可能會想知道何時使用哪一種。如果你知道你會多次使用該函數，請按正常方式建立它。如果你只會在一個地方使用它，通常最好使用匿名函數。至於你是否使用 Fat Arrow 函數或更傳統的 function 語法，這取決於你，但你會注意到大多數現代開發者更喜歡使用 =>。\n🚀 挑戰\n你能用一句話說明函數與方法的區別嗎？試試看！\n課後測驗\n課後測驗\n複習與自學\n值得多了解一些有關箭頭函數的內容，因為它們在程式碼中越來越常用。練習撰寫一個函數，然後用這種語法重寫它。\n作業\n函數的樂趣\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9573,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1358,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "58bbb535cd3b9b1e4f28092113aa1b42",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\assignment.md",
    "source_type": "git_repo",
    "title": "閱讀文檔",
    "content": "閱讀文檔\n指引\n網頁開發者可能需要使用許多工具，這些工具可以在 MDN 的客戶端工具文檔 中找到。請選擇 3 種課堂中未涵蓋的工具，解釋為什麼網頁開發者會使用這些工具，並搜尋一個屬於此類別的工具，分享其文檔。請勿使用 MDN 文檔中的相同工具範例。\n評分標準\n優秀 | 足夠 | 需要改進\n--- | --- | -- |\n| 解釋了為什麼網頁開發者會使用該工具 | 解釋了如何使用，但未說明為什麼開發者會使用該工具 | 未提及開發者如何或為什麼會使用該工具 |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1412,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "71d0328e272204a3404493be0aee69f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "Terrarium Project Part 3: DOM 操作與閉包\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n簡介\n操作 DOM（Document Object Model，文件物件模型）是網頁開發中的重要部分。根據 MDN 的說法：「Document Object Model (DOM) 是網頁文件結構和內容的物件數據表示形式。」網頁上的 DOM 操作挑戰通常是促使開發者使用 JavaScript 框架而非原生 JavaScript 來管理 DOM 的原因，但我們將嘗試自己完成！\n此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。\nJavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。\n我們將使用閉包來操作 DOM。\n可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。\nDOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui\n在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。\n前置條件\n你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。\n任務\n在你的 terrarium 文件夾中，創建一個名為 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 707,
    "chunk_index": 0,
    "total_chunks": 50
  },
  {
    "id": "2efa8738221071c9e8f1e30fa1984b14",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "Terrarium Project Part 3: DOM 操作與閉包\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n簡介\n操作 DOM（Document Object Model，文件物件模型）是網頁開發中的重要部分。根據 MDN 的說法：「Document Object Model (DOM) 是網頁文件結構和內容的物件數據表示形式。」網頁上的 DOM 操作挑戰通常是促使開發者使用 JavaScript 框架而非原生 JavaScript 來管理 DOM 的原因，但我們將嘗試自己完成！\n此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。\nJavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。\n我們將使用閉包來操作 DOM。\n可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。\nDOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui\n在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。\n前置條件\n你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。\n任務\n在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件：\nhtml\n<script src=\"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 734,
    "chunk_index": 1,
    "total_chunks": 50
  },
  {
    "id": "11d967f05fdb34acf0c78db8a2fb4155",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "Project Part 3: DOM 操作與閉包 Sketchnote by Tomomi Imura 課前測驗 課前測驗 簡介 操作 DOM（Document Object Model，文件物件模型）是網頁開發中的重要部分。根據 MDN 的說法：「Document Object Model (DOM) 是網頁文件結構和內容的物件數據表示形式。」網頁上的 DOM 操作挑戰通常是促使開發者使用 JavaScript 框架而非原生 JavaScript 來管理 DOM 的原因，但我們將嘗試自己完成！ 此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 735,
    "chunk_index": 2,
    "total_chunks": 50
  },
  {
    "id": "cebf036bbf5dd78d48d58d6f516c85b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "Project Part 3: DOM 操作與閉包 Sketchnote by Tomomi Imura 課前測驗 課前測驗 簡介 操作 DOM（Document Object Model，文件物件模型）是網頁開發中的重要部分。根據 MDN 的說法：「Document Object Model (DOM) 是網頁文件結構和內容的物件數據表示形式。」網頁上的 DOM 操作挑戰通常是促使開發者使用 JavaScript 框架而非原生 JavaScript 來管理 DOM 的原因，但我們將嘗試自己完成！ 此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script>\n注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。\nDOM 元素\n首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。\n任務\nhtml\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 921,
    "chunk_index": 3,
    "total_chunks": 50
  },
  {
    "id": "2509d93a8716016ff07c88736dbcfc1a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "來管理 DOM 的原因，但我們將嘗試自己完成！ 此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 773,
    "chunk_index": 4,
    "total_chunks": 50
  },
  {
    "id": "8e6c427c6fe85667ab024f333106b41f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "DOM 的原因，但我們將嘗試自己完成！ 此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 779,
    "chunk_index": 5,
    "total_chunks": 50
  },
  {
    "id": "83c7db2203688cb5b08e29dc99432cd0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "的原因，但我們將嘗試自己完成！ 此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 787,
    "chunk_index": 6,
    "total_chunks": 50
  },
  {
    "id": "51c863d93399f037ba9ef77ef9818217",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "此外，本課程將介紹 JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 775,
    "chunk_index": 7,
    "total_chunks": 50
  },
  {
    "id": "e08d6d6501a777d055892894149b761d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "JavaScript 閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 772,
    "chunk_index": 8,
    "total_chunks": 50
  },
  {
    "id": "b4a846737042ba1488953557589a9724",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "閉包 的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 780,
    "chunk_index": 9,
    "total_chunks": 50
  },
  {
    "id": "849174018890527f2c8e32576cd12cf6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "的概念。閉包可以理解為一個函數包裹著另一個函數，使內部函數能夠訪問外部函數的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 786,
    "chunk_index": 10,
    "total_chunks": 50
  },
  {
    "id": "66f5aab4b3ee0b290371c8a80aa65f87",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 11,
    "total_chunks": 50
  },
  {
    "id": "78fe6921a331fd0f7b5aa0dadae231ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念。在這個 terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 12,
    "total_chunks": 50
  },
  {
    "id": "4c48beeffdcb467e53028f91b386153a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "terrarium 的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 702,
    "chunk_index": 13,
    "total_chunks": 50
  },
  {
    "id": "d26a5c37e54e2c942c8854d7620d9bf5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "的代碼中，你會看到一個閉包：一個內部函數和一個外部函數的結構，允許內部函數訪問外部函數的作用域。若想深入了解其工作原理，請參閱 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 709,
    "chunk_index": 14,
    "total_chunks": 50
  },
  {
    "id": "f9afbc2d4dedd2d788778aa73acc100d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 624,
    "chunk_index": 15,
    "total_chunks": 50
  },
  {
    "id": "83e932ca0fa9359cf9967d00dd8c007c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 623,
    "chunk_index": 16,
    "total_chunks": 50
  },
  {
    "id": "65026285b159444b9717e56a9baa73d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）已被編寫，使得程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、更改、重新排列或其他管理操作。 DOM 和 HTML 標記的表示形式。來源：Olfa Nasraoui 在本課程中，我們將完成互動式 terrarium 項目，通過創建 JavaScript 代碼，讓用戶能夠在頁面上操作植物。 前置條件 你應該已經完成了 terrarium 的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖動將植物移入或移出 terrarium。 任務 在你的 terrarium 文件夾中，創建一個名為 scriptjs 的新文件。並在 <head> 部分導入該文件： html <script src=\"/scriptjs\" defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14'));\n這裡發生了什麼？你正在引用文件並在其 DOM 中查找具有特定 Id 的元素。記得在 HTML 的第一課中，你為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些努力。在識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函數，稍後你將構建該函數。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。\n✅ 為什麼我們通過 Id 引用元素？為什麼不通過它們的 CSS 類？你可以回顧之前的 CSS 課程來回答這個問題。\n閉包\n現在你準備創建 dragElement 閉包，這是一個外部函數，包裹著一個或多個內部函數（在我們的例子中，我們將有三個）。\n當一個或多個函數需要訪問外部函數的作用域時，閉包非常有用。以下是一個例子：\njavascript\nfunction displayCandy(){\nlet candy = ['jellybeans'];\nfunction addCandy(candyType) {\ncandy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1019,
    "chunk_index": 17,
    "total_chunks": 50
  },
  {
    "id": "e2abed838b8d2097475fabed0b908c72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "defer></script> 注意：在將外部 JavaScript 文件導入 HTML 文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 這裡發生了什麼？你正在引用文件並在其 DOM 中查找具有特定 Id 的元素。記得在 HTML 的第一課中，你為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些努力。在識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函數，稍後你將構建該函數。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不通過它們的 CSS 類？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你準備創建 dragElement 閉包，這是一個外部函數，包裹著一個或多個內部函數（在我們的例子中，我們將有三個）。 當一個或多個函數需要訪問外部函數的作用域時，閉包非常有用。以下是一個例子： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType)\n}\naddCandy('gumdrops');\n}\ndisplayCandy();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 729,
    "chunk_index": 18,
    "total_chunks": 50
  },
  {
    "id": "e3fe7586f78cbda67ff83917b3c7a684",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "文件時，使用 defer 屬性，以便讓 JavaScript 在 HTML 文件完全加載後執行。你也可以使用 async 屬性，允許腳本在 HTML 文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 這裡發生了什麼？你正在引用文件並在其 DOM 中查找具有特定 Id 的元素。記得在 HTML 的第一課中，你為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些努力。在識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函數，稍後你將構建該函數。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不通過它們的 CSS 類？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你準備創建 dragElement 閉包，這是一個外部函數，包裹著一個或多個內部函數（在我們的例子中，我們將有三個）。 當一個或多個函數需要訪問外部函數的作用域時，閉包非常有用。以下是一個例子： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy)\n在這個例子中，displayCandy 函數包裹著一個函數，該函數將新的糖果類型推入已存在於函數中的數組。如果你運行這段代碼，candy 數組將是未定義的，因為它是一個局部變數（局限於閉包）。\n✅ 如何使 candy 數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。\n任務\n在 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 907,
    "chunk_index": 19,
    "total_chunks": 50
  },
  {
    "id": "81f341af7bdab1687e3714e416b63305",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "文件解析時執行，但在我們的情況下，重要的是在執行拖動腳本之前，HTML 元素必須完全可用。 DOM 元素 首先，你需要在 DOM 中創建對要操作的元素的引用。在我們的例子中，它們是側邊欄中等待的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 這裡發生了什麼？你正在引用文件並在其 DOM 中查找具有特定 Id 的元素。記得在 HTML 的第一課中，你為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些努力。在識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函數，稍後你將構建該函數。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不通過它們的 CSS 類？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你準備創建 dragElement 閉包，這是一個外部函數，包裹著一個或多個內部函數（在我們的例子中，我們將有三個）。 當一個或多個函數需要訪問外部函數的作用域時，閉包非常有用。以下是一個例子： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在這個例子中，displayCandy 函數包裹著一個函數，該函數將新的糖果類型推入已存在於函數中的數組。如果你運行這段代碼，candy 數組將是未定義的，因為它是一個局部變數（局限於閉包）。 ✅ 如何使 candy 數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。 任務 在 scriptjs 中的元素聲明下，創建一個函數：\njavascript\nfunction dragElement(terrariumElement) {\n//set 4 positions for positioning on the screen\nlet pos1 = 0,\npos2 = 0,\npos3 = 0,\npos4 = 0;\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 929,
    "chunk_index": 20,
    "total_chunks": 50
  },
  {
    "id": "7e3d1146125beee3f3041a4db0de1970",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "中查找具有特定 Id 的元素。記得在 HTML 的第一課中，你為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些努力。在識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函數，稍後你將構建該函數。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不通過它們的 CSS 類？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你準備創建 dragElement 閉包，這是一個外部函數，包裹著一個或多個內部函數（在我們的例子中，我們將有三個）。 當一個或多個函數需要訪問外部函數的作用域時，閉包非常有用。以下是一個例子： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在這個例子中，displayCandy 函數包裹著一個函數，該函數將新的糖果類型推入已存在於函數中的數組。如果你運行這段代碼，candy 數組將是未定義的，因為它是一個局部變數（局限於閉包）。 ✅ 如何使 candy 數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。 任務 在 scriptjs 中的元素聲明下，創建一個函數： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag;\n}\ndragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。\n此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。\n✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。\nPointerdrag 函數\nterrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1113,
    "chunk_index": 21,
    "total_chunks": 50
  },
  {
    "id": "af6ef4b55af8cf92c9d97ca166fbb0fb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在這個例子中，displayCandy 函數包裹著一個函數，該函數將新的糖果類型推入已存在於函數中的數組。如果你運行這段代碼，candy 數組將是未定義的，因為它是一個局部變數（局限於閉包）。 ✅ 如何使 candy 數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。 任務 在 scriptjs 中的元素聲明下，創建一個函數： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;：\n任務\njavascript\nfunction pointerDrag(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 760,
    "chunk_index": 22,
    "total_chunks": 50
  },
  {
    "id": "0c9c642116b4729f091a779ab3cfcbc9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "數組將是未定義的，因為它是一個局部變數（局限於閉包）。 ✅ 如何使 candy 數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。 任務 在 scriptjs 中的元素聲明下，創建一個函數： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 658,
    "chunk_index": 23,
    "total_chunks": 50
  },
  {
    "id": "4f62de5b46f42baf56ba1c7f0f26b474",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "✅ 如何使 candy 數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。 任務 在 scriptjs 中的元素聲明下，創建一個函數： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e);\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 24,
    "total_chunks": 50
  },
  {
    "id": "1e87c889e3a9fbeeab3ccee7608f5aee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "數組可訪問？嘗試將其移到閉包之外。這樣，數組就成為全局的，而不是僅限於閉包的局部作用域。 任務 在 scriptjs 中的元素聲明下，創建一個函數： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 628,
    "chunk_index": 25,
    "total_chunks": 50
  },
  {
    "id": "a19f7aaa472fed2a120e61e3431c1ca5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "scriptjs 中的元素聲明下，創建一個函數： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY;\n}\n發生了幾件事。首先，你使用 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 580,
    "chunk_index": 26,
    "total_chunks": 50
  },
  {
    "id": "cee4fa479efc686c23cad88ada6c6d5f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。\n當你完全構建腳本文件後，回到這行代碼並嘗試不使用 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 27,
    "total_chunks": 50
  },
  {
    "id": "25cfbf1c0440951f74e6ab9ecca1145f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？\n其次，在瀏覽器窗口中打開 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 655,
    "chunk_index": 28,
    "total_chunks": 50
  },
  {
    "id": "b3171e33377555ab8dd02d1cf516926c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！\n接下來，注意如何將局部變數 pos3 和 pos4 設置為 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 754,
    "chunk_index": 29,
    "total_chunks": 50
  },
  {
    "id": "ceee39bc84df6cdd819a25e66351e571",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。\n✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？\n完成初始函數，添加兩個指針事件操作到 pos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 939,
    "chunk_index": 30,
    "total_chunks": 50
  },
  {
    "id": "ba097aab5f4573fe30a83009dabfeca5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "對象。然後，你為傳遞到函數的對象設置一些初始位置為 0 的局部變數。這些是每個元素的局部變數，當你在閉包中為每個元素添加拖放功能時，這些變數將被操作。這些被拖動的元素將填充 terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方：\nhtml\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 900,
    "chunk_index": 31,
    "total_chunks": 50
  },
  {
    "id": "3d08cd7bca0bfba7059df7fd17cdc92a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "terrarium，因此應用程序需要跟踪它們的放置位置。 此外，傳遞給該函數的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 792,
    "chunk_index": 32,
    "total_chunks": 50
  },
  {
    "id": "cb04353b3992208e35aae420655cabae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的例子中，當觸摸可拖動的元素時觸發。該事件處理程序適用於 網頁和移動瀏覽器，但有少數例外。 ✅ 事件處理程序 onclick 在跨瀏覽器中有更廣泛的支持；為什麼不在這裡使用它？思考一下你想要創建的精確屏幕交互類型。 Pointerdrag 函數 terrariumElement 已準備好被拖動；當觸發 onpointerdown 事件時，函數 pointerDrag 被調用。在這行代碼下方添加該函數：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag;\n現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。\nelementDrag 和 stopElementDrag 函數\n你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。\n任務\n在 pointerDrag 的閉括號後添加 elementDrag 函數：\njavascript\nfunction elementDrag(e) {\npos1 = pos3 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1090,
    "chunk_index": 33,
    "total_chunks": 50
  },
  {
    "id": "d309c1221d24f43b213c77672a8ca965",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "eclientY; } 發生了幾件事。首先，你使用 epreventDefault(); 阻止了通常在 pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX;\npos2 = pos4 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 804,
    "chunk_index": 34,
    "total_chunks": 50
  },
  {
    "id": "91bc30c4e26307f1398d624f03b6161a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pointerdown 上發生的默認事件。這樣你可以更好地控制界面的行為。 當你完全構建腳本文件後，回到這行代碼並嘗試不使用 epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY;\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 780,
    "chunk_index": 35,
    "total_chunks": 50
  },
  {
    "id": "4ec7fdd5484b953ab53c6ed5811d26cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "epreventDefault()——會發生什麼？ 其次，在瀏覽器窗口中打開 indexhtml，並檢查界面。當你點擊植物時，你可以看到如何捕獲 'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 720,
    "chunk_index": 36,
    "total_chunks": 50
  },
  {
    "id": "d4dbac1ee8d4a80f00e954e50c509bee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "'e' 事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 653,
    "chunk_index": 37,
    "total_chunks": 50
  },
  {
    "id": "b9031273a056dc7367466dd388559fc8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "事件。深入研究該事件，看看一次 pointerdown 事件收集了多少信息！ 接下來，注意如何將局部變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4);\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 666,
    "chunk_index": 38,
    "total_chunks": 50
  },
  {
    "id": "d8e442b61f1fa5962bef873d1927fad2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 39,
    "total_chunks": 50
  },
  {
    "id": "67386d217785266b5dfb39f27368c6c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 40,
    "total_chunks": 50
  },
  {
    "id": "0a42094c5c484de44a008f638f1252dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px';\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 635,
    "chunk_index": 41,
    "total_chunks": 50
  },
  {
    "id": "a729a77dfb4997591a372c1134dbb0c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 580,
    "chunk_index": 42,
    "total_chunks": 50
  },
  {
    "id": "0b82da2bbe53607cb21035a0c6c22fb9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "x 和 y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 585,
    "chunk_index": 43,
    "total_chunks": 50
  },
  {
    "id": "f855a0bacac2543ad375a8b75bbdbc17",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "y 坐標。你需要對植物的行為進行精細控制，因此需要跟踪它們的坐標。 ✅ 現在是否更清楚為什麼整個應用程序是用一個大的閉包構建的？如果不是閉包，你如何為 14 個可拖動的植物維持作用域？ 完成初始函數，添加兩個指針事件操作到 pos4 = eclientY 下方： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px';\n}\n在這個函數中，你對外部函數中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？\n當你拖動時，你通過將 pos3（之前設置為 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 678,
    "chunk_index": 44,
    "total_chunks": 50
  },
  {
    "id": "8a63a8b697300792f78deb300a221275",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函數中，你對外部函數中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 530,
    "chunk_index": 45,
    "total_chunks": 50
  },
  {
    "id": "1150ebf328f08efbdb28d0089094af49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示植物隨著指針移動而被拖動，並在取消選擇植物時停止拖動手勢。onpointermove 和 onpointerup 都是與 onpointerdown 相同的 API 的一部分。界面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函數，因此接下來構建它們。 elementDrag 和 stopElementDrag 函數 你將通過添加兩個內部函數來完成閉包，這些函數將處理拖動植物和停止拖動植物時的行為。你希望的行為是，隨時可以拖動任何植物並將其放置在屏幕上的任何位置。這個界面非常靈活（例如，沒有放置區域），允許你通過添加、移除和重新定位植物來自由設計你的 terrarium。 任務 在 pointerDrag 的閉括號後添加 elementDrag 函數： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函數中，你對外部函數中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 eclientX 值來重新分配 pos1。你對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重置為元素的新 X 和 Y 坐標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據 pos1 和 pos2 的新位置計算植物的頂部和左側 X 和 Y 坐標，並設置其新位置。\noffsetTop 和 offsetLeft 是 CSS 屬性，根據其父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。\n所有這些位置重新計算使你能夠微調 terrarium 和植物的行為。\n任務\n完成界面的最後一步是在 elementDrag 的閉括號後添加 stopElementDrag 函數：\njavascript\nfunction stopElementDrag() {\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 796,
    "chunk_index": 46,
    "total_chunks": 50
  },
  {
    "id": "f5513dca574ad88d459439ab74402980",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函數中，你對外部函數中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 eclientX 值來重新分配 pos1。你對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重置為元素的新 X 和 Y 坐標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據 pos1 和 pos2 的新位置計算植物的頂部和左側 X 和 Y 坐標，並設置其新位置。 offsetTop 和 offsetLeft 是 CSS 屬性，根據其父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。 所有這些位置重新計算使你能夠微調 terrarium 和植物的行為。 任務 完成界面的最後一步是在 elementDrag 的閉括號後添加 stopElementDrag 函數： javascript function stopElementDrag() { documentonpointerup = null;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 439,
    "chunk_index": 47,
    "total_chunks": 50
  },
  {
    "id": "3121a4d157220b4ae2cfd9c8dc88a832",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函數中，你對外部函數中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 eclientX 值來重新分配 pos1。你對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重置為元素的新 X 和 Y 坐標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據 pos1 和 pos2 的新位置計算植物的頂部和左側 X 和 Y 坐標，並設置其新位置。 offsetTop 和 offsetLeft 是 CSS 屬性，根據其父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。 所有這些位置重新計算使你能夠微調 terrarium 和植物的行為。 任務 完成界面的最後一步是在 elementDrag 的閉括號後添加 stopElementDrag 函數： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null;\n}\n這個小函數重置了 onpointerup 和 onpointermove 事件，使你可以重新開始拖動植物，或者開始拖動新的植物。\n✅ 如果不將這些事件設置為 null，會發生什麼？\n現在你已完成你的項目！\n🥇恭喜！你已完成美麗的 terrarium！\n🚀挑戰\n為你的閉包添加新的事件處理程序，讓植物有更多的互動；例如，雙擊植物使其置於最前方。發揮創意！\n課後測驗\n課後測驗\n回顧與自學\n雖然在屏幕上拖動元素看似簡單，但有許多方法可以實現，並且根據你想要的效果可能會遇到許多陷阱。事實上，有一個完整的 拖放 API 供你嘗試。我們在本模組中沒有使用它，因為我們想要的效果有所不同，但可以在自己的項目中嘗試該 API，看看能實現什麼。\n在 W3C 文檔 和 MDN 網頁文檔 中找到更多關於指針事件的信息。\n始終使用 CanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 845,
    "chunk_index": 48,
    "total_chunks": 50
  },
  {
    "id": "5df32bf0a0447da14ec819ef6a16c5e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 3: DOM 操作與閉包",
    "content": "pos3 和 pos4 重置為元素的新 X 和 Y 坐標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據 pos1 和 pos2 的新位置計算植物的頂部和左側 X 和 Y 坐標，並設置其新位置。 offsetTop 和 offsetLeft 是 CSS 屬性，根據其父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。 所有這些位置重新計算使你能夠微調 terrarium 和植物的行為。 任務 完成界面的最後一步是在 elementDrag 的閉括號後添加 stopElementDrag 函數： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null; } 這個小函數重置了 onpointerup 和 onpointermove 事件，使你可以重新開始拖動植物，或者開始拖動新的植物。 ✅ 如果不將這些事件設置為 null，會發生什麼？ 現在你已完成你的項目！ 🥇恭喜！你已完成美麗的 terrarium！ 🚀挑戰 為你的閉包添加新的事件處理程序，讓植物有更多的互動；例如，雙擊植物使其置於最前方。發揮創意！ 課後測驗 課後測驗 回顧與自學 雖然在屏幕上拖動元素看似簡單，但有許多方法可以實現，並且根據你想要的效果可能會遇到許多陷阱。事實上，有一個完整的 拖放 API 供你嘗試。我們在本模組中沒有使用它，因為我們想要的效果有所不同，但可以在自己的項目中嘗試該 API，看看能實現什麼。 在 W3C 文檔 和 MDN 網頁文檔 中找到更多關於指針事件的信息。 始終使用 CanIUsecom 檢查瀏覽器的兼容性。\n作業\n進一步操作 DOM\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12398,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 861,
    "chunk_index": 49,
    "total_chunks": 50
  },
  {
    "id": "88ecee6000552a0026dd095d39545754",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "JavaScript 基礎：陣列與迴圈\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n這節課涵蓋了 JavaScript 的基礎知識，這是一種為網頁提供互動性的語言。在這節課中，你將學習有關陣列和迴圈的知識，這些工具用於操作數據。\n🎥 點擊上方圖片觀看有關陣列和迴圈的影片。\n你可以在 Microsoft Learn 上學習這節課！\n陣列\n處理數據是任何程式語言中的常見任務，而當數據以結構化格式（例如陣列）組織時，這項任務會變得更加簡單。使用陣列，數據以類似清單的結構存儲。陣列的一大優勢是你可以在一個陣列中存儲不同類型的數據。\n✅ 陣列在我們周圍隨處可見！你能想到一個現實生活中的陣列例子嗎，例如太陽能板陣列？\n陣列的語法是一對方括號。\njavascript\nlet myArray = [];\n這是一個空陣列，但陣列可以在宣告時已經填充數據。陣列中的多個值用逗號分隔。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\n陣列中的值被分配了一個獨特的值，稱為 索引，這是一個基於其距離陣列開頭的整數。在上面的例子中，字串值 \"Chocolate\" 的索引是 0，而 \"Rocky Road\" 的索引是 4。使用索引和方括號可以檢索、更改或插入陣列中的值。\n✅ 你是否感到驚訝，陣列的索引是從 0 開始的？在某些程式語言中，索引是從 1 開始的。這背後有一段有趣的歷史，你可以在 維基百科 上閱讀相關內容。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\niceCreamFlavors[2]; //\"Vanilla\"\n你可以利用索引來更改值，例如：\njavascript\niceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\"\n你也可以在指定的索引處插入新值，例如：\njavascript\niceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\"\n✅ 更常見的方式是使用陣列操作符，例如 array",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 848,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "c64819ba0b13ade5b3878d90bee33aa4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "Learn 上學習這節課！ 陣列 處理數據是任何程式語言中的常見任務，而當數據以結構化格式（例如陣列）組織時，這項任務會變得更加簡單。使用陣列，數據以類似清單的結構存儲。陣列的一大優勢是你可以在一個陣列中存儲不同類型的數據。 ✅ 陣列在我們周圍隨處可見！你能想到一個現實生活中的陣列例子嗎，例如太陽能板陣列？ 陣列的語法是一對方括號。 javascript let myArray = []; 這是一個空陣列，但陣列可以在宣告時已經填充數據。陣列中的多個值用逗號分隔。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; 陣列中的值被分配了一個獨特的值，稱為 索引，這是一個基於其距離陣列開頭的整數。在上面的例子中，字串值 \"Chocolate\" 的索引是 0，而 \"Rocky Road\" 的索引是 4。使用索引和方括號可以檢索、更改或插入陣列中的值。 ✅ 你是否感到驚訝，陣列的索引是從 0 開始的？在某些程式語言中，索引是從 1 開始的。這背後有一段有趣的歷史，你可以在 維基百科 上閱讀相關內容。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" 你可以利用索引來更改值，例如： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" 你也可以在指定的索引處插入新值，例如： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 更常見的方式是使用陣列操作符，例如 arraypush()，來向陣列中添加值。\n要知道陣列中有多少項，可以使用 length 屬性。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\niceCreamFlavors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 744,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "93f72c4334313c575b93c89a07c2be7c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; 陣列中的值被分配了一個獨特的值，稱為 索引，這是一個基於其距離陣列開頭的整數。在上面的例子中，字串值 \"Chocolate\" 的索引是 0，而 \"Rocky Road\" 的索引是 4。使用索引和方括號可以檢索、更改或插入陣列中的值。 ✅ 你是否感到驚訝，陣列的索引是從 0 開始的？在某些程式語言中，索引是從 1 開始的。這背後有一段有趣的歷史，你可以在 維基百科 上閱讀相關內容。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" 你可以利用索引來更改值，例如： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" 你也可以在指定的索引處插入新值，例如： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 更常見的方式是使用陣列操作符，例如 arraypush()，來向陣列中添加值。 要知道陣列中有多少項，可以使用 length 屬性。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5\n✅ 試試看！使用瀏覽器的控制台創建並操作一個你自己設計的陣列。\n迴圈\n迴圈允許我們執行重複或 迭代 的任務，可以節省大量時間和程式碼。每次迭代可以在變數、值和條件上有所不同。JavaScript 中有不同類型的迴圈，它們之間有些微差異，但基本上都做同樣的事情：迴圈處理數據。\nFor 迴圈\nfor 迴圈需要三個部分來進行迭代：\n- counter 一個變數，通常初始化為一個數字，用於計算迭代次數\n- condition 使用比較運算符的表達式，當結果為 false 時迴圈停止\n- iteration-expression 在每次迭代結束時執行，通常用於更改計數器的值\njavascript\n// Counting up to 10\nfor (let i = 0; i < 10; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 779,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "1b2a3bc515c64c94d4da588d28d45295",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" 你也可以在指定的索引處插入新值，例如： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 更常見的方式是使用陣列操作符，例如 arraypush()，來向陣列中添加值。 要知道陣列中有多少項，可以使用 length 屬性。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5 ✅ 試試看！使用瀏覽器的控制台創建並操作一個你自己設計的陣列。 迴圈 迴圈允許我們執行重複或 迭代 的任務，可以節省大量時間和程式碼。每次迭代可以在變數、值和條件上有所不同。JavaScript 中有不同類型的迴圈，它們之間有些微差異，但基本上都做同樣的事情：迴圈處理數據。 For 迴圈 for 迴圈需要三個部分來進行迭代： - counter 一個變數，通常初始化為一個數字，用於計算迭代次數 - condition 使用比較運算符的表達式，當結果為 false 時迴圈停止 - iteration-expression 在每次迭代結束時執行，通常用於更改計數器的值 javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i);\n}\n✅ 在瀏覽器控制台中運行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒著運行，創建一個倒數嗎？\nWhile 迴圈\n與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值，例如計數器，並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外創建，並且任何滿足條件的表達式（包括更改計數器）必須在迴圈內維護。\njavascript\n//Counting up to 10\nlet i = 0;\nwhile (i < 10) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 765,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "3fcd8d2c06614282f2e558090248c0f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5 ✅ 試試看！使用瀏覽器的控制台創建並操作一個你自己設計的陣列。 迴圈 迴圈允許我們執行重複或 迭代 的任務，可以節省大量時間和程式碼。每次迭代可以在變數、值和條件上有所不同。JavaScript 中有不同類型的迴圈，它們之間有些微差異，但基本上都做同樣的事情：迴圈處理數據。 For 迴圈 for 迴圈需要三個部分來進行迭代： - counter 一個變數，通常初始化為一個數字，用於計算迭代次數 - condition 使用比較運算符的表達式，當結果為 false 時迴圈停止 - iteration-expression 在每次迭代結束時執行，通常用於更改計數器的值 javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ 在瀏覽器控制台中運行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒著運行，創建一個倒數嗎？ While 迴圈 與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值，例如計數器，並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外創建，並且任何滿足條件的表達式（包括更改計數器）必須在迴圈內維護。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i);\ni++;\n}\n✅ 為什麼你會選擇使用 for 迴圈而不是 while 迴圈？17K 名觀眾在 StackOverflow 上有同樣的疑問，一些意見可能 對你有趣。\n迴圈與陣列\n陣列通常與迴圈一起使用，因為大多數條件需要陣列的長度來停止迴圈，而索引也可以作為計數器的值。\n```javascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\nfor (let i = 0; i < iceCreamFlavors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 830,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "e84c79a5bc1083de2fae1abcb9d98af7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "在每次迭代結束時執行，通常用於更改計數器的值 javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ 在瀏覽器控制台中運行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒著運行，創建一個倒數嗎？ While 迴圈 與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值，例如計數器，並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外創建，並且任何滿足條件的表達式（包括更改計數器）必須在迴圈內維護。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i); i++; } ✅ 為什麼你會選擇使用 for 迴圈而不是 while 迴圈？17K 名觀眾在 StackOverflow 上有同樣的疑問，一些意見可能 對你有趣。 迴圈與陣列 陣列通常與迴圈一起使用，因為大多數條件需要陣列的長度來停止迴圈，而索引也可以作為計數器的值。 ```javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; for (let i = 0; i < iceCreamFlavorslength; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "f12852df552539e2376358ae1d3d59fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ 在瀏覽器控制台中運行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒著運行，創建一個倒數嗎？ While 迴圈 與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值，例如計數器，並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外創建，並且任何滿足條件的表達式（包括更改計數器）必須在迴圈內維護。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i); i++; } ✅ 為什麼你會選擇使用 for 迴圈而不是 while 迴圈？17K 名觀眾在 StackOverflow 上有同樣的疑問，一些意見可能 對你有趣。 迴圈與陣列 陣列通常與迴圈一起使用，因為大多數條件需要陣列的長度來停止迴圈，而索引也可以作為計數器的值。 ```javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; for (let i = 0; i < iceCreamFlavorslength; i++) { consolelog(iceCreamFlavors[i]);\n} //Ends when all flavors are printed\n```\n✅ 在瀏覽器的控制台中嘗試迴圈處理一個你自己設計的陣列。\n🚀 挑戰\n除了 for 和 while 迴圈之外，還有其他方式可以迴圈處理陣列，例如 forEach、for-of 和 map。使用其中一種技術重寫你的陣列迴圈。\n課後測驗\n課後測驗\n回顧與自學\nJavaScript 中的陣列附帶了許多方法，這些方法對數據操作非常有用。閱讀這些方法，並嘗試在你自己設計的陣列上使用一些方法（例如 push、pop、slice 和 splice）。\n作業\n迴圈處理陣列\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 931,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "37b981adaadf29074507e498db4b1ec9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\assignment.md",
    "source_type": "git_repo",
    "title": "分析一個無法訪問的網站",
    "content": "分析一個無法訪問的網站\n指引\n找出一個你認為無法訪問的網站，並制定一個行動計劃來改善其可訪問性。\n你的第一個任務是識別這個網站，詳細說明你認為它無法訪問的原因（不使用分析工具），然後提交給 Lighthouse 進行分析。將分析結果保存為 PDF，並列出一個包含至少十點的詳細計劃，說明如何改善該網站。\n測試網站可訪問性的表格\n| 標準     | 優秀       | 合格       | 需要改善         |\n|----------|-----------|----------|----------------|\n|          | 缺少 <10% 的必要條件 | 缺少 20% 的必要條件 | 缺少 50% 的必要條件 |\n學生報告：包括描述網站無法訪問的段落、Lighthouse 報告的 PDF 截圖、一份包含十點改善建議的清單，以及詳細說明如何改善的內容\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1583,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "199c4171c5b190ee4a5bde88f6d7fbb4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "程式語言與工具介紹\n本課程涵蓋了程式語言的基礎知識。這些主題適用於當今大多數現代程式語言。在「工具介紹」部分，您將學習一些對開發者有幫助的實用軟件。\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將涵蓋以下內容：\n什麼是程式設計？\n程式語言的種類\n程式的基本元素\n專業開發者的實用軟件與工具\n您可以在 Microsoft Learn 上學習本課程！\n什麼是程式設計？\n程式設計（也稱為編碼）是為電腦或移動設備等設備編寫指令的過程。我們使用程式語言來編寫這些指令，然後由設備解讀這些指令。這些指令集可能有不同的名稱，例如 程式、電腦程式、應用程式 (app) 和 可執行檔 等。\n程式 可以是任何用程式碼編寫的東西；網站、遊戲和手機應用程式都是程式。雖然可以在不編寫程式碼的情況下創建程式，但其底層邏輯仍需由設備解讀，而這些邏輯很可能是用程式碼編寫的。一個正在 運行 或 執行 程式碼的程式正在執行指令。您正在使用的設備正運行一個程式，將這篇課程顯示在您的螢幕上。\n✅ 做一些研究：誰被認為是世界上第一位電腦程式設計師？\n程式語言\n程式語言使開發者能夠為設備編寫指令。設備只能理解二進制（1 和 0），而對於 大多數 開發者來說，這並不是一種高效的溝通方式。程式語言是人類與電腦之間的溝通工具。\n程式語言有不同的格式，可能用於不同的目的。例如，JavaScript 主要用於網頁應用程式，而 Bash 主要用於操作系統。\n低階語言 通常需要比 高階語言 更少的步驟來讓設備解讀指令。然而，高階語言因其可讀性和支援性而受到歡迎。JavaScript 被認為是一種高階語言。\n以下程式碼展示了使用高階語言（JavaScript）與低階語言（ARM 組合語言）的差異。\n```javascript\nlet number = 10\nlet n1 = 0, n2 = 1, nextTerm;\nfor (let i = 1; i <= number; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11918,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 960,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "c57facdaf35de9155523d3c8a9fd05fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "程式語言與工具介紹\n本課程涵蓋了程式語言的基礎知識。這些主題適用於當今大多數現代程式語言。在「工具介紹」部分，您將學習一些對開發者有幫助的實用軟件。\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將涵蓋以下內容：\n什麼是程式設計？\n程式語言的種類\n程式的基本元素\n專業開發者的實用軟件與工具\n您可以在 Microsoft Learn 上學習本課程！\n什麼是程式設計？\n程式設計（也稱為編碼）是為電腦或移動設備等設備編寫指令的過程。我們使用程式語言來編寫這些指令，然後由設備解讀這些指令。這些指令集可能有不同的名稱，例如 程式、電腦程式、應用程式 (app) 和 可執行檔 等。\n程式 可以是任何用程式碼編寫的東西；網站、遊戲和手機應用程式都是程式。雖然可以在不編寫程式碼的情況下創建程式，但其底層邏輯仍需由設備解讀，而這些邏輯很可能是用程式碼編寫的。一個正在 運行 或 執行 程式碼的程式正在執行指令。您正在使用的設備正運行一個程式，將這篇課程顯示在您的螢幕上。\n✅ 做一些研究：誰被認為是世界上第一位電腦程式設計師？\n程式語言\n程式語言使開發者能夠為設備編寫指令。設備只能理解二進制（1 和 0），而對於 大多數 開發者來說，這並不是一種高效的溝通方式。程式語言是人類與電腦之間的溝通工具。\n程式語言有不同的格式，可能用於不同的目的。例如，JavaScript 主要用於網頁應用程式，而 Bash 主要用於操作系統。\n低階語言 通常需要比 高階語言 更少的步驟來讓設備解讀指令。然而，高階語言因其可讀性和支援性而受到歡迎。JavaScript 被認為是一種高階語言。\n以下程式碼展示了使用高階語言（JavaScript）與低階語言（ARM 組合語言）的差異。\n```javascript\nlet number = 10\nlet n1 = 0, n2 = 1, nextTerm;\nfor (let i = 1; i <= number; i++) {\nconsolelog(n1);\nnextTerm = n1 + n2;\nn1 = n2;\nn2 = nextTerm;\n}\n```\nc\narea ascen,code,readonly\nentry\ncode32\nadr r0,thumb+1\nbx r0\ncode16\nthumb\nmov r0,#00\nsub r0,r0,#01\nmov r1,#01\nmov r4,#10\nldr r2,=0x40000000\nback add r0,r1\nstr r0,[r2]\nadd r2,#04\nmov r3,r0\nmov r0,r1\nmov r1,r3\nsub r4,#01\ncmp r4,#00\nbne back\nend\n相信或不相信，它們都在做同一件事：打印出前 10 個 Fibonacci 數列。\n✅ Fibonacci 數列被定義為一組數字，其中每個數字是前兩個數字的總和，從 0 和 1 開始。前 10 個 Fibonacci 數列的數字是 0, 1, 1, 2, 3, 5, 8, 13, 21 和 34。\n程式的基本元素\n程式中的單一指令稱為 語句，通常會有一個字符或行間距來標記指令的結束，或稱為 終止。程式如何終止因語言而異。\n程式中的語句可能依賴用戶或其他地方提供的數據來執行指令。數據可以改變程式的行為，因此程式語言提供了一種臨時存儲數據的方法，以便稍後使用。這些被稱為 變數。變數是指令，指示設備將數據存儲在其記憶體中。程式中的變數類似於代數中的變數，它們有一個唯一的名稱，其值可能會隨時間改變。\n有些語句可能不會被設備執行。這通常是開發者設計的結果，或者是意外錯誤導致的。這種對應用程式的控制使其更加健壯和可維護。通常，這些控制的變化發生在滿足某些條件時。現代程式設計中常用的一種語句是 if",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11918,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1660,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "39076266771604067cc34d1df949224c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "c area ascen,code,readonly entry code32 adr r0,thumb+1 bx r0 code16 thumb mov r0,#00 sub r0,r0,#01 mov r1,#01 mov r4,#10 ldr r2,=0x40000000 back add r0,r1 str r0,[r2] add r2,#04 mov r3,r0 mov r0,r1 mov r1,r3 sub r4,#01 cmp r4,#00 bne back end 相信或不相信，它們都在做同一件事：打印出前 10 個 Fibonacci 數列。 ✅ Fibonacci 數列被定義為一組數字，其中每個數字是前兩個數字的總和，從 0 和 1 開始。前 10 個 Fibonacci 數列的數字是 0, 1, 1, 2, 3, 5, 8, 13, 21 和 34。 程式的基本元素 程式中的單一指令稱為 語句，通常會有一個字符或行間距來標記指令的結束，或稱為 終止。程式如何終止因語言而異。 程式中的語句可能依賴用戶或其他地方提供的數據來執行指令。數據可以改變程式的行為，因此程式語言提供了一種臨時存儲數據的方法，以便稍後使用。這些被稱為 變數。變數是指令，指示設備將數據存儲在其記憶體中。程式中的變數類似於代數中的變數，它們有一個唯一的名稱，其值可能會隨時間改變。 有些語句可能不會被設備執行。這通常是開發者設計的結果，或者是意外錯誤導致的。這種對應用程式的控制使其更加健壯和可維護。通常，這些控制的變化發生在滿足某些條件時。現代程式設計中常用的一種語句是 ifelse 語句。\n✅ 您將在後續課程中學習更多關於這種類型語句的內容。\n工具介紹\n🎥 點擊上方圖片觀看有關工具的影片\n在本節中，您將學習一些在開始專業開發旅程時可能非常有用的軟件。\n開發環境 是開發者在編寫軟件時經常使用的一組獨特工具和功能。其中一些工具已根據開發者的特定需求進行了自定義，並可能隨著開發者的工作重點、個人項目或使用不同程式語言而改變。開發環境如同開發者本身一樣獨特。\n編輯器\n編輯器是軟件開發中最重要的工具之一。編輯器是您編寫程式碼的地方，有時也是您運行程式碼的地方。\n開發者依賴編輯器的其他原因包括：\n除錯 幫助逐行檢查程式碼，發現錯誤和問題。一些編輯器具有除錯功能；它們可以針對特定程式語言進行自定義和添加。\n語法高亮 為程式碼添加顏色和文本格式，使其更易於閱讀。大多數編輯器允許自定義語法高亮。\n擴展與整合 是為開發者設計的專用工具，這些工具並未內建於基礎編輯器中。例如，許多開發者會為程式碼添加文檔以解釋其工作原理。他們可能會安裝拼寫檢查擴展來幫助發現文檔中的拼寫錯誤。大多數擴展是針對特定編輯器使用的，而大多數編輯器都提供了搜索可用擴展的方法。\n自定義 使開發者能夠創建適合其需求的獨特開發環境。大多數編輯器都非常可自定義，並且可能允許開發者創建自定義擴展。\n流行的編輯器與網頁開發擴展\nVisual Studio Code\nCode Spell Checker\nLive Share\nPrettier - Code formatter\nAtom\nspell-check\nteletype\natom-beautify\nSublimetext\nemmet\nSublimeLinter\n瀏覽器\n另一個重要的工具是瀏覽器。網頁開發者依賴瀏覽器來查看其程式碼在網頁上的運行效果。瀏覽器還用於顯示在編輯器中編寫的網頁的視覺元素，例如 HTML。\n許多瀏覽器都內建 開發者工具（DevTools），其中包含一組有用的功能和資訊，幫助開發者收集和捕獲有關其應用程式的重要資訊。例如：如果網頁出現錯誤，有時知道錯誤發生的時間會很有幫助。瀏覽器中的開發者工具可以配置為捕獲此類資訊。\n流行的瀏覽器與開發者工具\nEdge\nChrome\nFirefox\n命令列工具\n一些開發者更喜歡使用較少圖形化的界面來完成日常任務，並依賴命令列來實現這一點。編寫程式碼需要大量的打字，一些開發者更喜歡不打斷鍵盤上的工作流程。他們會使用鍵盤快捷鍵在桌面窗口之間切換、處理不同的文件以及使用工具。大多數任務可以用滑鼠完成，但使用命令列的一個好處是可以在不需要滑鼠和鍵盤之間切換的情況下完成許多操作。命令列的另一個好處是它們是可配置的，您可以保存自定義配置，稍後更改，並將其導入到其他開發機器中。由於開發環境對每個開發者來說都是獨特的，有些人會完全避免使用命令列，有些人會完全依賴它，而有些人則喜歡兩者結合使用。\n流行的命令列選項\n命令列的選項會根據您使用的操作系統而有所不同。\n💻 = 預裝於操作系統中。\nWindows\nPowershell 💻\nCommand Line（也稱為 CMD）💻\nWindows Terminal\nmintty\nMacOS\nTerminal 💻\niTerm\nPowershell\nLinux\nBash 💻\nKDE Konsole\nPowershell\n流行的命令列工具\nGit (💻 在大多數操作系統中)\nNPM\nYarn\n文件\n當開發者想學習新事物時，他們很可能會轉向文件來學習如何使用它。開發者經常依賴文件來指導他們正確使用工具和語言，並深入了解其工作原理。\n流行的網頁開發文件\nMozilla Developer Network (MDN)，由 Firefox 瀏覽器的發行商 Mozilla 提供\nFrontend Masters\nWeb",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11918,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2364,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "0571cccad48f1ab21eb59ef47936314c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "流行的編輯器與網頁開發擴展 Visual Studio Code Code Spell Checker Live Share Prettier - Code formatter Atom spell-check teletype atom-beautify Sublimetext emmet SublimeLinter 瀏覽器 另一個重要的工具是瀏覽器。網頁開發者依賴瀏覽器來查看其程式碼在網頁上的運行效果。瀏覽器還用於顯示在編輯器中編寫的網頁的視覺元素，例如 HTML。 許多瀏覽器都內建 開發者工具（DevTools），其中包含一組有用的功能和資訊，幫助開發者收集和捕獲有關其應用程式的重要資訊。例如：如果網頁出現錯誤，有時知道錯誤發生的時間會很有幫助。瀏覽器中的開發者工具可以配置為捕獲此類資訊。 流行的瀏覽器與開發者工具 Edge Chrome Firefox 命令列工具 一些開發者更喜歡使用較少圖形化的界面來完成日常任務，並依賴命令列來實現這一點。編寫程式碼需要大量的打字，一些開發者更喜歡不打斷鍵盤上的工作流程。他們會使用鍵盤快捷鍵在桌面窗口之間切換、處理不同的文件以及使用工具。大多數任務可以用滑鼠完成，但使用命令列的一個好處是可以在不需要滑鼠和鍵盤之間切換的情況下完成許多操作。命令列的另一個好處是它們是可配置的，您可以保存自定義配置，稍後更改，並將其導入到其他開發機器中。由於開發環境對每個開發者來說都是獨特的，有些人會完全避免使用命令列，有些人會完全依賴它，而有些人則喜歡兩者結合使用。 流行的命令列選項 命令列的選項會根據您使用的操作系統而有所不同。 💻 = 預裝於操作系統中。 Windows Powershell 💻 Command Line（也稱為 CMD）💻 Windows Terminal mintty MacOS Terminal 💻 iTerm Powershell Linux Bash 💻 KDE Konsole Powershell 流行的命令列工具 Git (💻 在大多數操作系統中) NPM Yarn 文件 當開發者想學習新事物時，他們很可能會轉向文件來學習如何使用它。開發者經常依賴文件來指導他們正確使用工具和語言，並深入了解其工作原理。 流行的網頁開發文件 Mozilla Developer Network (MDN)，由 Firefox 瀏覽器的發行商 Mozilla 提供 Frontend Masters Webdev，由 Chrome 的發行商 Google 提供\nMicrosoft 的開發者文檔，適用於 Microsoft Edge\nW3 Schools\n✅ 做一些研究：現在您已了解網頁開發者的環境，試著將其與網頁設計師的環境進行比較和對比。\n🚀 挑戰\n比較一些程式語言。JavaScript 與 Java 有哪些獨特的特性？COBOL 與 Go 又如何？\n課後測驗\n課後測驗\n回顧與自學\n學習一下程式設計師可用的不同語言。嘗試用一種語言寫一行程式碼，然後用另外兩種語言重寫它。您學到了什麼？\n作業\n閱讀文件\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11918,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1396,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "8165504bc9a39adbf170a3cc5f1a800f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\1-getting-started-lessons\\README.md",
    "source_type": "git_repo",
    "title": "वेब डेवलपमेंट की शुरुआत",
    "content": "वेब डेवलपमेंट की शुरुआत\nइस पाठ्यक्रम के इस भाग में, आपको उन गैर-प्रोजेक्ट आधारित अवधारणाओं से परिचित कराया जाएगा जो एक पेशेवर डेवलपर बनने के लिए महत्वपूर्ण हैं।\nविषय\nप्रोग्रामिंग भाषाओं और उपकरणों का परिचय\nGitHub का परिचय\nएक्सेसिबिलिटी की मूल बातें\nश्रेय\nप्रोग्रामिंग भाषाओं और उपकरणों का परिचय ♥️ के साथ जैस्मिन ग्रीनअवे द्वारा लिखा गया था।\nGitHub का परिचय ♥️ के साथ फ्लोर ड्रेस द्वारा लिखा गया था।\nएक्सेसिबिलिटी की मूल बातें ♥️ के साथ क्रिस्टोफर हैरिसन द्वारा लिखा गया था।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2876,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\1-getting-started-lessons\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 878,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "fa8b95ffd114eaa17442b3f06a06b45a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\2-js-basics\\README.md",
    "source_type": "git_repo",
    "title": "जावास्क्रिप्ट का परिचय",
    "content": "जावास्क्रिप्ट का परिचय\nजावास्क्रिप्ट वेब की भाषा है। इन चार पाठों में, आप इसके मूलभूत सिद्धांत सीखेंगे।\nविषय\nवेरिएबल्स और डेटा प्रकार\nफंक्शन्स और मेथड्स\nजावास्क्रिप्ट के साथ निर्णय लेना\nएरेज़ और लूप्स\nश्रेय\nये पाठ ♥️ के साथ लिखे गए हैं जैस्मिन ग्रीनवे, क्रिस्टोफर हैरिसन और क्रिस नोरिंग द्वारा।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को आधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2431,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\2-js-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 717,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "040ee312483c7ab425cc10faac56d8a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\README.md",
    "source_type": "git_repo",
    "title": "मेरा टेरारियम: HTML, CSS, और DOM मैनिपुलेशन को JavaScript के साथ सीखने का प्रोजेक्ट 🌵🌱",
    "content": "मेरा टेरारियम: HTML, CSS, और DOM मैनिपुलेशन को JavaScript के साथ सीखने का प्रोजेक्ट 🌵🌱\nएक छोटा सा ड्रैग और ड्रॉप कोड-मेडिटेशन। थोड़े से HTML, JS और CSS के साथ, आप एक वेब इंटरफेस बना सकते हैं, उसे स्टाइल कर सकते हैं, और अपनी पसंद के अनुसार कई इंटरैक्शन भी जोड़ सकते हैं।\nपाठ\nHTML का परिचय\nCSS का परिचय\nDOM और JS क्लोज़र्स का परिचय\nश्रेय\n♥️ के साथ लिखा गया Jen Looper द्वारा।\nCSS के माध्यम से बनाया गया टेरारियम Jakub Mandra के ग्लास जार कोडपेन से प्रेरित है।\nकलाकृति Jen Looper द्वारा हाथ से बनाई गई है, Procreate की मदद से।\nअपना टेरारियम डिप्लॉय करें\nआप अपने टेरारियम को वेब पर Azure Static Web Apps का उपयोग करके डिप्लॉय या प्रकाशित कर सकते हैं।\nइस रिपॉजिटरी को फोर्क करें\nइस बटन को दबाएं\nविज़ार्ड के माध्यम से अपनी ऐप बनाएं। सुनिश्चित करें कि आप ऐप रूट को /solution या अपने कोडबेस की रूट पर सेट करें। इस ऐप में कोई API नहीं है, इसलिए इसकी चिंता न करें। एक GitHub फ़ोल्डर आपकी फोर्क की गई रिपॉजिटरी में बनाया जाएगा, जो Azure Static Web Apps की बिल्ड सेवाओं को आपकी ऐप को एक नए URL पर बिल्ड और प्रकाशित करने में मदद करेगा।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4367,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1310,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f98903ab0be34feacd1cf6d78a1827c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "建立無障礙的網頁\nSketchnote 由 Tomomi Imura 提供\n課前測驗\n課前測驗\n網絡的力量在於其普遍性。無論是否有殘障，人人都能訪問是其基本特徵。\n- 提姆·伯納斯-李爵士，W3C 主任及全球資訊網的發明者\n這句話完美地突顯了建立無障礙網站的重要性。一個無法讓所有人訪問的應用程式，本質上就是排他的。作為網頁開發者，我們應該時刻考慮無障礙性。從一開始就專注於此，將確保您創建的頁面能被所有人訪問。在本課中，您將學習如何使用工具來確保您的網頁資產是無障礙的，以及如何以無障礙性為核心進行構建。\n您可以在 Microsoft Learn 上學習本課！\n可用工具\n螢幕閱讀器\n最知名的無障礙工具之一是螢幕閱讀器。\n螢幕閱讀器 是視障人士常用的客戶端。我們花時間確保瀏覽器能正確傳達我們想分享的信息，同樣也必須確保螢幕閱讀器能做到這一點。\n最基本的螢幕閱讀器會從上到下以語音方式讀取頁面。如果您的頁面全是文字，閱讀器會以類似於瀏覽器的方式傳達信息。然而，網頁很少僅僅是文字；它們通常包含連結、圖片、顏色和其他視覺元素。我們需要小心確保這些信息能被螢幕閱讀器正確讀取。\n每位網頁開發者都應熟悉螢幕閱讀器。正如上文所述，這是您的用戶將使用的客戶端。就像您熟悉瀏覽器的操作一樣，您也應該了解螢幕閱讀器的操作。幸運的是，大多數操作系統都內建了螢幕閱讀器。\n一些瀏覽器還內建了工具和擴展，可以朗讀文字，甚至提供一些基本的導航功能，例如 這些專注於無障礙性的 Edge 瀏覽器工具。這些工具也是重要的無障礙工具，但它們的功能與螢幕閱讀器非常不同，不能將其視為螢幕閱讀器測試工具。\n✅ 試用螢幕閱讀器和瀏覽器文字閱讀器。在 Windows 上，Narrator 是預設內建的，您也可以安裝 JAWS 和 NVDA。在 macOS 和 iOS 上，VoiceOver 是預設內建的。\n放大功能\n另一個視障人士常用的工具是放大功能。最基本的放大功能是靜態放大，可以通過 Control + 加號 (+) 或降低螢幕解析度來控制。這種放大方式會使整個頁面重新調整大小，因此使用響應式設計 對於在高放大級別下提供良好的用戶體驗非常重要。\n另一種放大方式依賴於專門的軟體來放大螢幕的一個區域並進行平移，就像使用真正的放大鏡一樣。在 Windows 上，Magnifier 是內建的，而 ZoomText 是一款第三方放大軟體，功能更多且用戶群更大。在 macOS 和 iOS 上，內建的放大軟體叫 Zoom。\n對比檢查工具\n網站上的顏色需要仔細選擇，以滿足色盲用戶或難以辨識低對比度顏色的人的需求。\n✅ 使用瀏覽器擴展，例如 WCAG 的顏色檢查工具，測試您喜歡的網站的顏色使用情況。您學到了什麼？\nLighthouse\n在瀏覽器的開發者工具區域，您會找到 Lighthouse 工具。這個工具對於初步檢視網站的無障礙性（以及其他分析）非常重要。雖然不應完全依賴 Lighthouse，但獲得 100% 的分數作為基準是非常有幫助的。\n✅ 在瀏覽器的開發者工具面板中找到 Lighthouse，並對任何網站進行分析。您發現了什麼？\n為無障礙性進行設計\n無障礙性是一個相對較大的主題。為了幫助您，有許多資源可供使用。\nAccessible U - 明尼蘇達大學\n雖然我們無法涵蓋創建無障礙網站的每個方面，但以下是一些您需要實施的核心原則。從一開始就設計一個無障礙的頁面總是比事後對現有頁面進行修改更容易。\n良好的顯示原則\n安全的色彩調色盤\n人們以不同的方式看待世界，包括顏色。在為您的網站選擇配色方案時，您應確保它對所有人都是無障礙的。一個很棒的生成調色盤的工具是 Color Safe。\n✅ 找出一個在顏色使用上非常有問題的網站。為什麼？\n使用正確的 HTML\n通過 CSS 和 JavaScript，可以使任何元素看起來像任何類型的控制項。例如，<span> 可以用來創建 <button>，而 <b> 可以變成超連結。雖然這樣可能更容易設計樣式，但對於螢幕閱讀器來說，這並沒有傳達任何信息。在頁面上創建控制項時，請使用適當的 HTML。如果您需要一個超連結，請使用 <a>。使用正確的 HTML 創建控制項被稱為使用語義化 HTML。\n✅ 打開任何網站，看看設計師和開發者是否正確使用了 HTML。您能找到應該是連結但實際上是按鈕的例子嗎？提示：右鍵點擊並選擇瀏覽器中的“檢視頁面原始碼”來查看底層代碼。\n創建描述性的標題層次結構\n螢幕閱讀器用戶非常依賴標題來查找信息並導航頁面。撰寫描述性的標題內容並使用語義化的標題標籤，對於為螢幕閱讀器用戶創建易於導航的網站非常重要。\n使用良好的視覺提示\nCSS 提供了對頁面上任何元素外觀的完全控制。您可以創建沒有邊框的文字框或沒有下劃線的超連結。不幸的是，移除這些提示可能會使依賴它們的人更難識別控制項的類型。\n超連結文字的重要性\n超連結是網絡導航的核心。因此，確保螢幕閱讀器能正確讀取連結，讓所有用戶都能導航您的網站。\n螢幕閱讀器與連結\n正如您所預期的，螢幕閱讀器會像讀取頁面上的其他文字一樣讀取連結文字。考慮到這一點，下面的文字示例可能看起來完全可以接受。\n小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。點擊這裡 獲取更多信息。\n小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。訪問 https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2665,
    "chunk_index": 0,
    "total_chunks": 8
  },
  {
    "id": "8990a7a72554ee509ba2777954cd6dff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "加號 (+) 或降低螢幕解析度來控制。這種放大方式會使整個頁面重新調整大小，因此使用響應式設計 對於在高放大級別下提供良好的用戶體驗非常重要。 另一種放大方式依賴於專門的軟體來放大螢幕的一個區域並進行平移，就像使用真正的放大鏡一樣。在 Windows 上，Magnifier 是內建的，而 ZoomText 是一款第三方放大軟體，功能更多且用戶群更大。在 macOS 和 iOS 上，內建的放大軟體叫 Zoom。 對比檢查工具 網站上的顏色需要仔細選擇，以滿足色盲用戶或難以辨識低對比度顏色的人的需求。 ✅ 使用瀏覽器擴展，例如 WCAG 的顏色檢查工具，測試您喜歡的網站的顏色使用情況。您學到了什麼？ Lighthouse 在瀏覽器的開發者工具區域，您會找到 Lighthouse 工具。這個工具對於初步檢視網站的無障礙性（以及其他分析）非常重要。雖然不應完全依賴 Lighthouse，但獲得 100% 的分數作為基準是非常有幫助的。 ✅ 在瀏覽器的開發者工具面板中找到 Lighthouse，並對任何網站進行分析。您發現了什麼？ 為無障礙性進行設計 無障礙性是一個相對較大的主題。為了幫助您，有許多資源可供使用。 Accessible U - 明尼蘇達大學 雖然我們無法涵蓋創建無障礙網站的每個方面，但以下是一些您需要實施的核心原則。從一開始就設計一個無障礙的頁面總是比事後對現有頁面進行修改更容易。 良好的顯示原則 安全的色彩調色盤 人們以不同的方式看待世界，包括顏色。在為您的網站選擇配色方案時，您應確保它對所有人都是無障礙的。一個很棒的生成調色盤的工具是 Color Safe。 ✅ 找出一個在顏色使用上非常有問題的網站。為什麼？ 使用正確的 HTML 通過 CSS 和 JavaScript，可以使任何元素看起來像任何類型的控制項。例如，<span> 可以用來創建 <button>，而 <b> 可以變成超連結。雖然這樣可能更容易設計樣式，但對於螢幕閱讀器來說，這並沒有傳達任何信息。在頁面上創建控制項時，請使用適當的 HTML。如果您需要一個超連結，請使用 <a>。使用正確的 HTML 創建控制項被稱為使用語義化 HTML。 ✅ 打開任何網站，看看設計師和開發者是否正確使用了 HTML。您能找到應該是連結但實際上是按鈕的例子嗎？提示：右鍵點擊並選擇瀏覽器中的“檢視頁面原始碼”來查看底層代碼。 創建描述性的標題層次結構 螢幕閱讀器用戶非常依賴標題來查找信息並導航頁面。撰寫描述性的標題內容並使用語義化的標題標籤，對於為螢幕閱讀器用戶創建易於導航的網站非常重要。 使用良好的視覺提示 CSS 提供了對頁面上任何元素外觀的完全控制。您可以創建沒有邊框的文字框或沒有下劃線的超連結。不幸的是，移除這些提示可能會使依賴它們的人更難識別控制項的類型。 超連結文字的重要性 超連結是網絡導航的核心。因此，確保螢幕閱讀器能正確讀取連結，讓所有用戶都能導航您的網站。 螢幕閱讀器與連結 正如您所預期的，螢幕閱讀器會像讀取頁面上的其他文字一樣讀取連結文字。考慮到這一點，下面的文字示例可能看起來完全可以接受。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。點擊這裡 獲取更多信息。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。訪問 https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1655,
    "chunk_index": 1,
    "total_chunks": 8
  },
  {
    "id": "8a47af40a8b193bad1e57b916a6f5a32",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "加號 (+) 或降低螢幕解析度來控制。這種放大方式會使整個頁面重新調整大小，因此使用響應式設計 對於在高放大級別下提供良好的用戶體驗非常重要。 另一種放大方式依賴於專門的軟體來放大螢幕的一個區域並進行平移，就像使用真正的放大鏡一樣。在 Windows 上，Magnifier 是內建的，而 ZoomText 是一款第三方放大軟體，功能更多且用戶群更大。在 macOS 和 iOS 上，內建的放大軟體叫 Zoom。 對比檢查工具 網站上的顏色需要仔細選擇，以滿足色盲用戶或難以辨識低對比度顏色的人的需求。 ✅ 使用瀏覽器擴展，例如 WCAG 的顏色檢查工具，測試您喜歡的網站的顏色使用情況。您學到了什麼？ Lighthouse 在瀏覽器的開發者工具區域，您會找到 Lighthouse 工具。這個工具對於初步檢視網站的無障礙性（以及其他分析）非常重要。雖然不應完全依賴 Lighthouse，但獲得 100% 的分數作為基準是非常有幫助的。 ✅ 在瀏覽器的開發者工具面板中找到 Lighthouse，並對任何網站進行分析。您發現了什麼？ 為無障礙性進行設計 無障礙性是一個相對較大的主題。為了幫助您，有許多資源可供使用。 Accessible U - 明尼蘇達大學 雖然我們無法涵蓋創建無障礙網站的每個方面，但以下是一些您需要實施的核心原則。從一開始就設計一個無障礙的頁面總是比事後對現有頁面進行修改更容易。 良好的顯示原則 安全的色彩調色盤 人們以不同的方式看待世界，包括顏色。在為您的網站選擇配色方案時，您應確保它對所有人都是無障礙的。一個很棒的生成調色盤的工具是 Color Safe。 ✅ 找出一個在顏色使用上非常有問題的網站。為什麼？ 使用正確的 HTML 通過 CSS 和 JavaScript，可以使任何元素看起來像任何類型的控制項。例如，<span> 可以用來創建 <button>，而 <b> 可以變成超連結。雖然這樣可能更容易設計樣式，但對於螢幕閱讀器來說，這並沒有傳達任何信息。在頁面上創建控制項時，請使用適當的 HTML。如果您需要一個超連結，請使用 <a>。使用正確的 HTML 創建控制項被稱為使用語義化 HTML。 ✅ 打開任何網站，看看設計師和開發者是否正確使用了 HTML。您能找到應該是連結但實際上是按鈕的例子嗎？提示：右鍵點擊並選擇瀏覽器中的“檢視頁面原始碼”來查看底層代碼。 創建描述性的標題層次結構 螢幕閱讀器用戶非常依賴標題來查找信息並導航頁面。撰寫描述性的標題內容並使用語義化的標題標籤，對於為螢幕閱讀器用戶創建易於導航的網站非常重要。 使用良好的視覺提示 CSS 提供了對頁面上任何元素外觀的完全控制。您可以創建沒有邊框的文字框或沒有下劃線的超連結。不幸的是，移除這些提示可能會使依賴它們的人更難識別控制項的類型。 超連結文字的重要性 超連結是網絡導航的核心。因此，確保螢幕閱讀器能正確讀取連結，讓所有用戶都能導航您的網站。 螢幕閱讀器與連結 正如您所預期的，螢幕閱讀器會像讀取頁面上的其他文字一樣讀取連結文字。考慮到這一點，下面的文字示例可能看起來完全可以接受。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。點擊這裡 獲取更多信息。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。訪問 https://enwikipediaorg/wiki/Little_penguin 獲取更多信息。\n注意 如您即將閱讀的內容，您應該永遠不要創建如上所示的連結。\n請記住，螢幕閱讀器與瀏覽器是不同的介面，具有不同的功能集。\n使用 URL 的問題\n螢幕閱讀器會讀取文字。如果文字中出現 URL，螢幕閱讀器會讀取該 URL。一般來說，URL 並不能傳達有意義的信息，並且聽起來可能很煩人。如果您的手機曾經語音讀取過帶有 URL 的簡訊，您可能會有這樣的體驗。\n使用“點擊這裡”的問題\n螢幕閱讀器還能僅讀取頁面上的超連結，就像視力正常的人會掃描頁面尋找連結一樣。如果連結文字總是“點擊這裡”，用戶聽到的將是“點擊這裡，點擊這裡，點擊這裡，點擊這裡，點擊這裡，……”所有連結現在都無法區分。\n良好的連結文字\n良好的連結文字應簡要描述連結的內容。在上面關於小企鵝的例子中，連結指向該物種的維基百科頁面。短語小企鵝將是完美的連結文字，因為它清楚地表明點擊該連結後會學到什麼——小企鵝。\n小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。\n✅ 瀏覽網絡幾分鐘，找出使用模糊連結策略的頁面。將它們與其他連結更好的網站進行比較。您學到了什麼？\n搜索引擎提示\n確保您的網站對所有人無障礙，還能幫助搜索引擎導航您的網站。搜索引擎使用連結文字來了解頁面的主題。因此，使用良好的連結文字對所有人都有幫助！\nARIA\n想像以下頁面：\n| 產品          | 描述              | 訂購          |\n| ------------- | ----------------- | ------------- |\n| Widget        | 描述   |\n| Super widget  | 描述   |\n在這個例子中，對於使用瀏覽器的人來說，重複描述和訂購的文字是有意義的。然而，使用螢幕閱讀器的人只會聽到“描述”和“訂購”重複出現，沒有上下文。\n為了支持這類場景，HTML 支援一組屬性，稱為無障礙豐富網絡應用程式 (ARIA)。這些屬性允許您為螢幕閱讀器提供額外的信息。\n注意：與 HTML 的許多方面一樣，瀏覽器和螢幕閱讀器的支援可能會有所不同。然而，大多數主流客戶端都支援 ARIA 屬性。\n您可以使用 aria-label 來描述連結，當頁面的格式不允許您這樣做時。例如，Widget 的描述可以設置為：\nhtml\n<a href=\"#\" aria-label=\"Widget description\">description</a>\n✅ 一般來說，使用上述的語義化標記比使用 ARIA 更優先，但有時某些 HTML 元件並沒有語義等價物。例如樹狀結構。HTML 中沒有樹的等價物，因此您需要為這個元素的通用 <div> 添加適當的角色和 ARIA 值。MDN 上的 ARIA 文檔 包含更多有用的信息。\n```html\nFile Viewer\nUploads\n```\n圖片\n不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片無障礙並不需要太多工作——這正是 alt 屬性的作用所在。所有有意義的圖片都應該有一個 alt 來描述它們的內容。\n純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。\n✅ 正如您所預期的，搜索引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保您的頁面無障礙還能帶來額外的好處！\n鍵盤\n有些用戶無法使用滑鼠或觸控板，而是依賴鍵盤操作來逐一切換元素。確保您的網站以邏輯順序呈現內容，這樣鍵盤用戶就可以按順序訪問每個互動元素。如果您使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，您的網站應該是可通過鍵盤導航的，但手動測試這一方面仍然很重要。了解更多鍵盤導航策略。\n✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些有效，哪些無效？為什麼？\n總結\n一個僅對部分人無障礙的網絡並不是真正的“全球資訊網”。確保您創建的網站無障礙的最佳方式是從一開始就採用無障礙性最佳實踐。雖然這需要額外的步驟，但現在將這些技能融入您的工作流程，意味著您創建的所有頁面都將是無障礙的。\n🚀 挑戰\n使用您學到的策略，將以下 HTML 重寫為盡可能無障礙的版本。\n```html\nExample\nTurtle Ipsum\nThe World's Premier Turtle Fan Club\nResources\n\"I like turtles\"\nBasic Turtle Info\nChocolate Turtles\nWelcome to Turtle Ipsum",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 3657,
    "chunk_index": 2,
    "total_chunks": 8
  },
  {
    "id": "7c8a89805f1b9838203423840493fe49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "來描述連結，當頁面的格式不允許您這樣做時。例如，Widget 的描述可以設置為： html <a href=\"#\" aria-label=\"Widget description\">description</a> ✅ 一般來說，使用上述的語義化標記比使用 ARIA 更優先，但有時某些 HTML 元件並沒有語義等價物。例如樹狀結構。HTML 中沒有樹的等價物，因此您需要為這個元素的通用 <div> 添加適當的角色和 ARIA 值。MDN 上的 ARIA 文檔 包含更多有用的信息。 ```html File Viewer Uploads ``` 圖片 不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片無障礙並不需要太多工作——這正是 alt 屬性的作用所在。所有有意義的圖片都應該有一個 alt 來描述它們的內容。 純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。 ✅ 正如您所預期的，搜索引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保您的頁面無障礙還能帶來額外的好處！ 鍵盤 有些用戶無法使用滑鼠或觸控板，而是依賴鍵盤操作來逐一切換元素。確保您的網站以邏輯順序呈現內容，這樣鍵盤用戶就可以按順序訪問每個互動元素。如果您使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，您的網站應該是可通過鍵盤導航的，但手動測試這一方面仍然很重要。了解更多鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網絡並不是真正的“全球資訊網”。確保您創建的網站無障礙的最佳方式是從一開始就採用無障礙性最佳實踐。雖然這需要額外的步驟，但現在將這些技能融入您的工作流程，意味著您創建的所有頁面都將是無障礙的。 🚀 挑戰 使用您學到的策略，將以下 HTML 重寫為盡可能無障礙的版本。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn more",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 942,
    "chunk_index": 3,
    "total_chunks": 8
  },
  {
    "id": "189b6502ff3a5ab0d0ceeb6d8bcff555",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "href=\"#\" aria-label=\"Widget description\">description</a> ✅ 一般來說，使用上述的語義化標記比使用 ARIA 更優先，但有時某些 HTML 元件並沒有語義等價物。例如樹狀結構。HTML 中沒有樹的等價物，因此您需要為這個元素的通用 <div> 添加適當的角色和 ARIA 值。MDN 上的 ARIA 文檔 包含更多有用的信息。 ```html File Viewer Uploads ``` 圖片 不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片無障礙並不需要太多工作——這正是 alt 屬性的作用所在。所有有意義的圖片都應該有一個 alt 來描述它們的內容。 純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。 ✅ 正如您所預期的，搜索引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保您的頁面無障礙還能帶來額外的好處！ 鍵盤 有些用戶無法使用滑鼠或觸控板，而是依賴鍵盤操作來逐一切換元素。確保您的網站以邏輯順序呈現內容，這樣鍵盤用戶就可以按順序訪問每個互動元素。如果您使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，您的網站應該是可通過鍵盤導航的，但手動測試這一方面仍然很重要。了解更多鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網絡並不是真正的“全球資訊網”。確保您創建的網站無障礙的最佳方式是從一開始就採用無障礙性最佳實踐。雖然這需要額外的步驟，但現在將這些技能融入您的工作流程，意味著您創建的所有頁面都將是無障礙的。 🚀 挑戰 使用您學到的策略，將以下 HTML 重寫為盡可能無障礙的版本。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 919,
    "chunk_index": 4,
    "total_chunks": 8
  },
  {
    "id": "6440275a3a71a380b49e097d17acdbf0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "```html File Viewer Uploads ``` 圖片 不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片無障礙並不需要太多工作——這正是 alt 屬性的作用所在。所有有意義的圖片都應該有一個 alt 來描述它們的內容。 純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。 ✅ 正如您所預期的，搜索引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保您的頁面無障礙還能帶來額外的好處！ 鍵盤 有些用戶無法使用滑鼠或觸控板，而是依賴鍵盤操作來逐一切換元素。確保您的網站以邏輯順序呈現內容，這樣鍵盤用戶就可以按順序訪問每個互動元素。如果您使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，您的網站應該是可通過鍵盤導航的，但手動測試這一方面仍然很重要。了解更多鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網絡並不是真正的“全球資訊網”。確保您創建的網站無障礙的最佳方式是從一開始就採用無障礙性最佳實踐。雖然這需要額外的步驟，但現在將這些技能融入您的工作流程，意味著您創建的所有頁面都將是無障礙的。 🚀 挑戰 使用您學到的策略，將以下 HTML 重寫為盡可能無障礙的版本。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliquaUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 790,
    "chunk_index": 5,
    "total_chunks": 8
  },
  {
    "id": "54a548acd792df0c01e383a591f3bd25",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "alt 文本。因此，再次確保您的頁面無障礙還能帶來額外的好處！ 鍵盤 有些用戶無法使用滑鼠或觸控板，而是依賴鍵盤操作來逐一切換元素。確保您的網站以邏輯順序呈現內容，這樣鍵盤用戶就可以按順序訪問每個互動元素。如果您使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，您的網站應該是可通過鍵盤導航的，但手動測試這一方面仍然很重要。了解更多鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網絡並不是真正的“全球資訊網”。確保您創建的網站無障礙的最佳方式是從一開始就採用無障礙性最佳實踐。雖然這需要額外的步驟，但現在將這些技能融入您的工作流程，意味著您創建的所有頁面都將是無障礙的。 🚀 挑戰 使用您學到的策略，將以下 HTML 重寫為盡可能無障礙的版本。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliquaUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequatDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 596,
    "chunk_index": 6,
    "total_chunks": 8
  },
  {
    "id": "027bf3e438568fc96ebf49311f92a8ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliquaUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequatDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariaturExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\nSign up for turtle news\nInternal Pages\nIndex\nSemantic Example\n© 2016 Instrument\n```\n課後測驗\n課後測驗\n回顧與自學\n許多政府都有關於無障礙要求的法律。了解一下你所在國家的無障礙法律。哪些內容涵蓋在內，哪些未涵蓋？例如：這個政府網站。\n作業\n分析一個不具無障礙功能的網站\n鳴謝：Turtle Ipsum by Instrument\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要信息，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15978,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 7,
    "total_chunks": 8
  },
  {
    "id": "55e1c43b44da04b1fb2d480c0d9cda1c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\README.md",
    "source_type": "git_repo",
    "title": "इवेंट-ड्रिवन प्रोग्रामिंग - एक टाइपिंग गेम बनाएं",
    "content": "इवेंट-ड्रिवन प्रोग्रामिंग - एक टाइपिंग गेम बनाएं\nपरिचय\nटाइपिंग एक डेवलपर की सबसे कम आंकी जाने वाली कौशलों में से एक है। अपने विचारों को जल्दी से अपने एडिटर में स्थानांतरित करने की क्षमता रचनात्मकता को स्वतंत्र रूप से प्रवाहित होने देती है। सीखने का सबसे अच्छा तरीका खेलना है तो चलिए, एक टाइपिंग गेम बनाते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4155,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 303,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "142e074fa1df139af982f53094096819",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\README.md",
    "source_type": "git_repo",
    "title": "इवेंट-ड्रिवन प्रोग्रामिंग - एक टाइपिंग गेम बनाएं",
    "content": "इवेंट-ड्रिवन प्रोग्रामिंग - एक टाइपिंग गेम बनाएं\nपरिचय\nटाइपिंग एक डेवलपर की सबसे कम आंकी जाने वाली कौशलों में से एक है। अपने विचारों को जल्दी से अपने एडिटर में स्थानांतरित करने की क्षमता रचनात्मकता को स्वतंत्र रूप से प्रवाहित होने देती है। सीखने का सबसे अच्छा तरीका खेलना है तो चलिए, एक टाइपिंग गेम बनाते हैंआप अब तक सीखी गई JavaScript, HTML और CSS की स्किल्स का उपयोग करके एक टाइपिंग गेम बनाएंगे। यह गेम खिलाड़ी को एक रैंडम कोट (हम शर्लक होम्स के कोट्स का उपयोग कर रहे हैं) देगा और यह मापेगा कि खिलाड़ी इसे सही तरीके से टाइप करने में कितना समय लेता है। आप अब तक सीखी गई JavaScript, HTML और CSS की स्किल्स का उपयोग करके एक टाइपिंग गेम बनाएंगे।\nपूर्वापेक्षाएँ\nयह पाठ मानता है कि आप निम्नलिखित अवधारणाओं से परिचित हैं:\nटेक्स्ट इनपुट और बटन कंट्रोल्स बनाना\nCSS और क्लासेस का उपयोग करके स्टाइल सेट करना\nJavaScript की बुनियादी बातें\nएक ऐरे बनाना\nएक रैंडम नंबर बनाना\nवर्तमान समय प्राप्त करना\nपाठ\nइवेंट-ड्रिवन प्रोग्रामिंग का उपयोग करके टाइपिंग गेम बनाना\nक्रेडिट्स\n♥️ के साथ लिखा गया क्रिस्टोफर हैरिसन द्वारा\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4155,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1368,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "3f0da7d4707ecde155eed5252491227b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन बनाना",
    "content": "ब्राउज़र एक्सटेंशन बनाना\nब्राउज़र एक्सटेंशन बनाना आपके ऐप्स के प्रदर्शन के बारे में सोचने का एक मजेदार और दिलचस्प तरीका है, साथ ही एक अलग प्रकार की वेब संपत्ति बनाने का अनुभव भी देता है। इस मॉड्यूल में यह सिखाया गया है कि ब्राउज़र कैसे काम करते हैं और ब्राउज़र एक्सटेंशन को कैसे डिप्लॉय किया जाए, फॉर्म कैसे बनाया जाए, API को कॉल कैसे किया जाए, लोकल स्टोरेज का उपयोग कैसे किया जाए, और आपकी वेबसाइट के प्रदर्शन को कैसे मापा और बेहतर किया जाए।\nआप एक ऐसा ब्राउज़र एक्सटेंशन बनाएंगे जो Edge, Chrome और Firefox पर काम करता है। यह एक्सटेंशन, जो एक छोटे वेब साइट की तरह है और एक विशेष कार्य के लिए डिज़ाइन किया गया है, C02 Signal API की मदद से किसी दिए गए क्षेत्र की बिजली खपत और कार्बन तीव्रता की जांच करता है और उस क्षेत्र के कार्बन फुटप्रिंट का रीडिंग देता है।\nयह एक्सटेंशन उपयोगकर्ता द्वारा तब कॉल किया जा सकता है जब एक API कुंजी और क्षेत्र कोड को फॉर्म में इनपुट किया जाए, ताकि स्थानीय बिजली खपत का पता लगाया जा सके और उपयोगकर्ता के बिजली उपयोग के निर्णयों को प्रभावित करने वाले डेटा प्रदान किए जा सकें। उदाहरण के लिए, यह सुझाव दिया जा सकता है कि कपड़े सुखाने वाले ड्रायर (जो एक कार्बन-गहन गतिविधि है) को आपके क्षेत्र में उच्च बिजली खपत के समय के दौरान चलाने में देरी करना बेहतर हो सकता है।\nविषय\nब्राउज़र के बारे में\nफॉर्म और लोकल स्टोरेज\nबैकग्राउंड टास्क और प्रदर्शन\nक्रेडिट्स\nक्रेडिट्स\nइस वेब कार्बन ट्रिगर का विचार माइक्रोसॉफ्ट के ग्रीन क्लाउड एडवोकेसी टीम के लीड और Green Principles के लेखक असीम हुसैन द्वारा दिया गया था। यह मूल रूप से एक वेब साइट प्रोजेक्ट था।\nब्राउज़र एक्सटेंशन की संरचना Adebola Adeniran's COVID extension से प्रेरित थी।\n'डॉट' आइकन सिस्टम की अवधारणा Energy Lollipop ब्राउज़र एक्सटेंशन के कैलिफोर्निया उत्सर्जन के आइकन संरचना से प्रेरित थी।\nये पाठ ♥️ के साथ Jen Looper द्वारा लिखे गए हैं।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को आधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6182,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2034,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c1f515e511dc72bc7f1b554708f427e2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\README.md",
    "source_type": "git_repo",
    "title": ":dollar: एक बैंक बनाएं",
    "content": ":dollar: एक बैंक बनाएं\nइस प्रोजेक्ट में, आप एक काल्पनिक बैंक बनाने का तरीका सीखेंगे। इन पाठों में यह सिखाया जाएगा कि वेब ऐप को कैसे डिज़ाइन करें और रूट्स प्रदान करें, फॉर्म बनाएं, स्टेट को मैनेज करें, और API से डेटा प्राप्त करें जिससे आप बैंक का डेटा ले सकें।\n|  |  |\n|--------------------------------|--------------------------------|\nपाठ\nवेब ऐप में HTML टेम्पलेट्स और रूट्स\nलॉगिन और रजिस्ट्रेशन फॉर्म बनाएं\nडेटा प्राप्त करने और उपयोग करने के तरीके\nस्टेट मैनेजमेंट के कॉन्सेप्ट्स\nक्रेडिट्स\nये पाठ :hearts: के साथ Yohan Lasorsa द्वारा लिखे गए हैं।\nयदि आप इन पाठों में उपयोग किए गए सर्वर API को बनाना सीखने में रुचि रखते हैं, तो आप इस वीडियो सीरीज़ (विशेष रूप से वीडियो 17 से 21) को देख सकते हैं।\nआप इस इंटरएक्टिव लर्न ट्यूटोरियल पर भी नज़र डाल सकते हैं।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3564,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1084,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "bdaa6aaa85f3bae2508e206fd8589224",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\docs\\_navbar.md",
    "source_type": "git_repo",
    "title": "_navbar",
    "content": "अनुवाद\nEnglish (United States)\nবাংলা\n中文(中国)\n中文(台湾)\nEspañol\nFrançais\nΕλληνικά\nहिन्दी\nBahasa Melayu\nമലയാളം\nதமிழ்\nతెలుగు\nBahasa Indonesia\nItaliano\n日本語\nNederlands\nनेपाली\nPortuguês\nРусский\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2294,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\docs\\_navbar.md",
      "source_type": "git_repo"
    },
    "token_count": 546,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "59c9e059fa4dc4914e1789e2778d24d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\docs\\_sidebar.md",
    "source_type": "git_repo",
    "title": "_sidebar",
    "content": "परिचय\n1\n2\n3\nJS मूल बातें\n4\n5\n6\n7\nHTML, CSS, JS\n8\n9\n10\nटाइपिंग गेम\n11\nब्राउज़र एक्सटेंशन\n12\n13\n14\nस्पेस गेम\n15\n16\n17\n18\n19\n20\nबैंक प्रोजेक्ट\n21\n22\n23\n24\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3017,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\docs\\_sidebar.md",
      "source_type": "git_repo"
    },
    "token_count": 551,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "4e6271cb6a99058a822f87e375078e8d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "GitHub 簡介\n這節課涵蓋了 GitHub 的基礎知識，這是一個用於託管和管理程式碼變更的平台。\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n在這節課中，我們將學習：\n如何追蹤你在電腦上的工作\n如何與他人合作完成專案\n如何為開源軟件做出貢獻\n先決條件\n在開始之前，你需要檢查是否已安裝 Git。在終端機輸入：\ngit --version\n如果未安裝 Git，請下載 Git。然後，在終端機中設置你的本地 Git 配置檔：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要檢查 Git 是否已配置，可以輸入：\ngit config --list\n你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。\n前往 github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 343,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "0241977f18c9152fe3d4ccb1bfecff15",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "GitHub 簡介\n這節課涵蓋了 GitHub 的基礎知識，這是一個用於託管和管理程式碼變更的平台。\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n在這節課中，我們將學習：\n如何追蹤你在電腦上的工作\n如何與他人合作完成專案\n如何為開源軟件做出貢獻\n先決條件\n在開始之前，你需要檢查是否已安裝 Git。在終端機輸入：\ngit --version\n如果未安裝 Git，請下載 Git。然後，在終端機中設置你的本地 Git 配置檔：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要檢查 Git 是否已配置，可以輸入：\ngit config --list\n你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。\n前往 githubcom 註冊帳戶（如果尚未註冊），或者登入並完善你的個人資料。\n✅ GitHub 並不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。\n準備工作\n你需要在本地電腦（筆記本或 PC）上準備一個包含程式碼專案的資料夾，還需要在 GitHub 上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。\n程式碼管理\n假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。\n任務：建立儲存庫並提交程式碼\n查看影片\n在 GitHub 上建立儲存庫。在 GitHub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 749,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "2949c3224ff0dd4128048beb91df49c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "GitHub 簡介\n這節課涵蓋了 GitHub 的基礎知識，這是一個用於託管和管理程式碼變更的平台。\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n在這節課中，我們將學習：\n如何追蹤你在電腦上的工作\n如何與他人合作完成專案\n如何為開源軟件做出貢獻\n先決條件\n在開始之前，你需要檢查是否已安裝 Git。在終端機輸入：\ngit --version\n如果未安裝 Git，請下載 Git。然後，在終端機中設置你的本地 Git 配置檔：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要檢查 Git 是否已配置，可以輸入：\ngit config --list\n你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。\n前往 githubcom 註冊帳戶（如果尚未註冊），或者登入並完善你的個人資料。\n✅ GitHub 並不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。\n準備工作\n你需要在本地電腦（筆記本或 PC）上準備一個包含程式碼專案的資料夾，還需要在 GitHub 上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。\n程式碼管理\n假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。\n任務：建立儲存庫並提交程式碼\n查看影片\n在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。\n為你的儲存庫（資料夾）命名\n選擇 create repository。\n導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入：\nbash\ncd [name of your folder]\n初始化 Git 儲存庫。在你的專案中輸入：\nbash\ngit init\n檢查狀態。要檢查儲存庫的狀態，輸入：\nbash\ngit status\n輸出可能看起來像這樣：\n```output\nChanges not staged for commit:\n(use \"git add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 986,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "e7a108b4c344b6ae64f5d5b36d0949d4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "config --global user email \"your-email\" 要檢查 Git 是否已配置，可以輸入： git config --list 你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。 前往 githubcom 註冊帳戶（如果尚未註冊），或者登入並完善你的個人資料。 ✅ GitHub 並不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記本或 PC）上準備一個包含程式碼專案的資料夾，還需要在 GitHub 上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出可能看起來像這樣： ```output Changes not staged for commit: (use \"git add\" to update what will be committed)\n(use \"git checkout --",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 744,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "92fb10e3c70730475de86bc39e0e28ff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "--list 你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。 前往 githubcom 註冊帳戶（如果尚未註冊），或者登入並完善你的個人資料。 ✅ GitHub 並不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記本或 PC）上準備一個包含程式碼專案的資料夾，還需要在 GitHub 上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出可能看起來像這樣： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory)\nmodified:   file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 728,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "2bce82359d977ceeaeed0de663fe5f69",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "githubcom 註冊帳戶（如果尚未註冊），或者登入並完善你的個人資料。 ✅ GitHub 並不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記本或 PC）上準備一個包含程式碼專案的資料夾，還需要在 GitHub 上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出可能看起來像這樣： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt\nmodified:   file2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 673,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "bd91564a1e62b7e5d76c38402fd4ead2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "✅ GitHub 並不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記本或 PC）上準備一個包含程式碼專案的資料夾，還需要在 GitHub 上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出可能看起來像這樣： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt\n```\n通常，git status 命令會告訴你哪些檔案已準備好被「保存」到儲存庫，或者有哪些檔案有更改需要持久化。\n添加所有檔案進行追蹤\n這也稱為暫存檔案/將檔案添加到暫存區。\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 747,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "cad50719a7d8afc49778e5ba94b7048b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "上建立一個公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出可能看起來像這樣： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好被「保存」到儲存庫，或者有哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 647,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "8429acc83d7ca60123d9713b87cae874",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）開始追蹤你的進度。有些人將使用 Git 比作寫一封給未來自己的情書。當你幾天、幾週甚至幾個月後閱讀你的提交訊息時，你將能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 上，進入儲存庫標籤，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你想要開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出可能看起來像這樣： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好被「保存」到儲存庫，或者有哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示將所有檔案和更改添加到追蹤中。\n選擇性添加檔案進行追蹤\nbash\ngit add [file or folder name]\n當你不想一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。\n取消暫存所有檔案\nbash\ngit reset\n此命令可幫助我們一次取消暫存所有檔案。\n取消暫存特定檔案\nbash\ngit reset [file or folder name]\n此命令可幫助我們一次取消暫存特定檔案，這些檔案我們不想包含在下一次提交中。\n保存你的工作。此時，你已將檔案添加到所謂的 暫存區，這是一個 Git 正在追蹤你的檔案的地方。要使更改永久化，你需要 提交 這些檔案。為此，你需要使用 git commit 命令創建一個 提交。提交 代表儲存庫歷史中的一個保存點。輸入以下命令以創建一個 提交：\nbash\ngit commit -m \"first commit\"\n這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。\n將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令：\n注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1250,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "fd615e87f992073c8b88b6970b1c1365",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "``` 通常，git status 命令會告訴你哪些檔案已準備好被「保存」到儲存庫，或者有哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示將所有檔案和更改添加到追蹤中。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不想一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令可幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令可幫助我們一次取消暫存特定檔案，這些檔案我們不想包含在下一次提交中。 保存你的工作。此時，你已將檔案添加到所謂的 暫存區，這是一個 Git 正在追蹤你的檔案的地方。要使更改永久化，你需要 提交 這些檔案。為此，你需要使用 git commit 命令創建一個 提交。提交 代表儲存庫歷史中的一個保存點。輸入以下命令以創建一個 提交： bash git commit -m \"first commit\" 這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 779,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "541df6dbcf217c44903e3734a02fcb49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "``` 通常，git status 命令會告訴你哪些檔案已準備好被「保存」到儲存庫，或者有哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示將所有檔案和更改添加到追蹤中。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不想一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令可幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令可幫助我們一次取消暫存特定檔案，這些檔案我們不想包含在下一次提交中。 保存你的工作。此時，你已將檔案添加到所謂的 暫存區，這是一個 Git 正在追蹤你的檔案的地方。要使更改永久化，你需要 提交 這些檔案。為此，你需要使用 git commit 命令創建一個 提交。提交 代表儲存庫歷史中的一個保存點。輸入以下命令以創建一個 提交： bash git commit -m \"first commit\" 這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。\nbash\ngit remote add origin https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 801,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "187c8173b03120b33259e9d64b3da9ff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "add 加上參數表示將所有檔案和更改添加到追蹤中。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不想一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令可幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令可幫助我們一次取消暫存特定檔案，這些檔案我們不想包含在下一次提交中。 保存你的工作。此時，你已將檔案添加到所謂的 暫存區，這是一個 Git 正在追蹤你的檔案的地方。要使更改永久化，你需要 提交 這些檔案。為此，你需要使用 git commit 命令創建一個 提交。提交 代表儲存庫歷史中的一個保存點。輸入以下命令以創建一個 提交： bash git commit -m \"first commit\" 這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 692,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "00f75ec080203927081c9850d0a5cf88",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "add 加上參數表示將所有檔案和更改添加到追蹤中。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不想一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令可幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令可幫助我們一次取消暫存特定檔案，這些檔案我們不想包含在下一次提交中。 保存你的工作。此時，你已將檔案添加到所謂的 暫存區，這是一個 Git 正在追蹤你的檔案的地方。要使更改永久化，你需要 提交 這些檔案。為此，你需要使用 git commit 命令創建一個 提交。提交 代表儲存庫歷史中的一個保存點。輸入以下命令以創建一個 提交： bash git commit -m \"first commit\" 這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit\n這會創建一個名為 \"origin\" 的 遠端，指向你之前創建的 GitHub 儲存庫。\n將本地檔案發送到 GitHub。到目前為止，你已經在本地儲存庫和 GitHub 儲存庫之間建立了 連接。現在使用以下命令 git push 將這些檔案發送到 GitHub，如下所示：\n注意，你的分支名稱可能與 main 預設不同。\nbash\ngit push -u origin main\n這會將你的「main」分支中的提交發送到 GitHub。\n添加更多更改。如果你想繼續進行更改並將它們推送到 GitHub，你只需要使用以下三個命令：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 918,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "6e46a4635552745ae0aa3af8e4406215",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "git commit 命令創建一個 提交。提交 代表儲存庫歷史中的一個保存點。輸入以下命令以創建一個 提交： bash git commit -m \"first commit\" 這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 這會創建一個名為 \"origin\" 的 遠端，指向你之前創建的 GitHub 儲存庫。 將本地檔案發送到 GitHub。到目前為止，你已經在本地儲存庫和 GitHub 儲存庫之間建立了 連接。現在使用以下命令 git push 將這些檔案發送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 預設不同。 bash git push -u origin main 這會將你的「main」分支中的提交發送到 GitHub。 添加更多更改。如果你想繼續進行更改並將它們推送到 GitHub，你只需要使用以下三個命令： bash git addgit commit -m \"type your commit message here\"\ngit push\n提示，你可能還想採用",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 644,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "ed98398df09900b4cd9abc1413df0b47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "\"first commit\" 這會提交所有檔案，並添加訊息「first commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 這會創建一個名為 \"origin\" 的 遠端，指向你之前創建的 GitHub 儲存庫。 將本地檔案發送到 GitHub。到目前為止，你已經在本地儲存庫和 GitHub 儲存庫之間建立了 連接。現在使用以下命令 git push 將這些檔案發送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 預設不同。 bash git push -u origin main 這會將你的「main」分支中的提交發送到 GitHub。 添加更多更改。如果你想繼續進行更改並將它們推送到 GitHub，你只需要使用以下三個命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能還想採用gitignore 檔案，以防止你不想追蹤的檔案出現在 GitHub 上——例如，你存儲在同一資料夾中的筆記檔案，但它不適合放在公共儲存庫中。你可以在",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 661,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "c0da9f8da4d9c0fc1e6f221255dd3131",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "commit」。對於未來的提交訊息，你需要更具描述性，以傳達你所做更改的類型。 將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 這會創建一個名為 \"origin\" 的 遠端，指向你之前創建的 GitHub 儲存庫。 將本地檔案發送到 GitHub。到目前為止，你已經在本地儲存庫和 GitHub 儲存庫之間建立了 連接。現在使用以下命令 git push 將這些檔案發送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 預設不同。 bash git push -u origin main 這會將你的「main」分支中的提交發送到 GitHub。 添加更多更改。如果你想繼續進行更改並將它們推送到 GitHub，你只需要使用以下三個命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能還想採用gitignore 檔案，以防止你不想追蹤的檔案出現在 GitHub 上——例如，你存儲在同一資料夾中的筆記檔案，但它不適合放在公共儲存庫中。你可以在gitignore 模板中找到",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 645,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "9629c56834f7f3eb0754748c51f1cb75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "將本地 Git 儲存庫與 GitHub 連接。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你一起合作。一個很棒的地方就是 GitHub。記得我們已經在 GitHub 上創建了一個儲存庫，所以現在唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以做到這一點。輸入以下命令： 注意，在輸入命令之前，請前往你的 GitHub 儲存庫頁面找到儲存庫的 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 這會創建一個名為 \"origin\" 的 遠端，指向你之前創建的 GitHub 儲存庫。 將本地檔案發送到 GitHub。到目前為止，你已經在本地儲存庫和 GitHub 儲存庫之間建立了 連接。現在使用以下命令 git push 將這些檔案發送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 預設不同。 bash git push -u origin main 這會將你的「main」分支中的提交發送到 GitHub。 添加更多更改。如果你想繼續進行更改並將它們推送到 GitHub，你只需要使用以下三個命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能還想採用gitignore 檔案，以防止你不想追蹤的檔案出現在 GitHub 上——例如，你存儲在同一資料夾中的筆記檔案，但它不適合放在公共儲存庫中。你可以在gitignore 模板中找到gitignore 檔案的模板。\n提交訊息\n一個好的 Git 提交主題行應該能完成以下句子：\n如果應用，這次提交將 <你的主題行在此>\n主題行應使用祈使句，現在時態：「更改」而不是「已更改」或「正在更改」。\n與主題行一樣，在正文（可選）中也使用祈使句，現在時態。正文應包括更改的動機，並與之前的行為形成對比。你是在解釋「為什麼」，而不是「如何」。\n✅ 花幾分鐘瀏覽 GitHub。你能找到一個非常棒的提交訊息嗎？你能找到一個非常簡略的嗎？你認為在提交訊息中傳達哪些資訊最重要且最有用？\n任務：協作\n將內容放到 GitHub 上的主要原因是讓其他開發者能夠協作。\n與他人合作專案\n查看影片\n在你的儲存庫中，導航到 Insights > Community，查看你的專案與推薦的社群標準相比如何。\n以下是一些可以改進你的 GitHub 儲存庫的事項：\n- 描述。你是否為你的專案添加了描述？\n- README。你是否添加了 README？GitHub 提供了撰寫 README 的指導。\n- 貢獻指南。你的專案是否有貢獻指南？\n- 行為準則。是否有行為準則？\n- 授權條款。或許最重要的是，是否有授權條款？\n所有這些資源都將有助於新團隊成員的加入。而這些通常是新貢獻者在查看你的程式碼之前會先查看的內容，以確定你的專案是否值得他們投入時間。\n✅ README 檔案雖然需要時間準備，但經常被忙碌的維護者忽略。你能找到一個特別詳細的例子嗎？注意：有一些工具可以幫助創建好的 README，你可能會想試試看。\n任務：合併一些程式碼\n貢獻文檔幫助人們為專案做出貢獻。它解釋了你正在尋找的貢獻類型以及流程如何運作。貢獻者需要完成一系列步驟才能為你的 GitHub 儲存庫做出貢獻：\n分叉你的儲存庫。你可能希望人們 分叉 你的專案。分叉意味著在他們的 GitHub 個人檔案上創建你的儲存庫的副本。\n克隆。接著，他們會將專案克隆到本地電腦。\n創建分支。你會希望他們為自己的工作創建一個 分支。\n專注於一個區域的更改。請求貢獻者一次專注於一件事——這樣你能合併他們工作的機率會更高。想像一下，他們修復了一個錯誤，添加了一個新功能，並更新了幾個測試——如果你只想實施其中的 2 項或 1 項更改，該怎麼辦？\n✅ 想像一個情況，分支對於撰寫和交付良好的程式碼特別重要。你能想到哪些使用情境？\n注意，成為你希望看到的改變，為自己的工作也創建分支。你所做的任何提交都將在你當前「檢出」的分支上進行。使用 git status 查看當前所在的分支。\n讓我們來看看貢獻者的工作流程。假設貢獻者已經 分叉 並 克隆 了儲存庫，因此他們在本地電腦上有一個可以工作的 Git 儲存庫：\n創建分支。使用 git branch 命令創建一個包含他們想要貢獻的更改的分支：\nbash\ngit branch [branch-name]\n切換到工作分支。切換到指定分支並使用 git switch 更新工作目錄：\nbash\ngit switch [branch-name]\n進行工作。此時，你可以添加更改。別忘了使用以下命令告訴 Git：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2029,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "9ca02f4f04fe0acaeeef171e8b0d6738",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "Insights > Community，查看你的專案與推薦的社群標準相比如何。 以下是一些可以改進你的 GitHub 儲存庫的事項： - 描述。你是否為你的專案添加了描述？ - README。你是否添加了 README？GitHub 提供了撰寫 README 的指導。 - 貢獻指南。你的專案是否有貢獻指南？ - 行為準則。是否有行為準則？ - 授權條款。或許最重要的是，是否有授權條款？ 所有這些資源都將有助於新團隊成員的加入。而這些通常是新貢獻者在查看你的程式碼之前會先查看的內容，以確定你的專案是否值得他們投入時間。 ✅ README 檔案雖然需要時間準備，但經常被忙碌的維護者忽略。你能找到一個特別詳細的例子嗎？注意：有一些工具可以幫助創建好的 README，你可能會想試試看。 任務：合併一些程式碼 貢獻文檔幫助人們為專案做出貢獻。它解釋了你正在尋找的貢獻類型以及流程如何運作。貢獻者需要完成一系列步驟才能為你的 GitHub 儲存庫做出貢獻： 分叉你的儲存庫。你可能希望人們 分叉 你的專案。分叉意味著在他們的 GitHub 個人檔案上創建你的儲存庫的副本。 克隆。接著，他們會將專案克隆到本地電腦。 創建分支。你會希望他們為自己的工作創建一個 分支。 專注於一個區域的更改。請求貢獻者一次專注於一件事——這樣你能合併他們工作的機率會更高。想像一下，他們修復了一個錯誤，添加了一個新功能，並更新了幾個測試——如果你只想實施其中的 2 項或 1 項更改，該怎麼辦？ ✅ 想像一個情況，分支對於撰寫和交付良好的程式碼特別重要。你能想到哪些使用情境？ 注意，成為你希望看到的改變，為自己的工作也創建分支。你所做的任何提交都將在你當前「檢出」的分支上進行。使用 git status 查看當前所在的分支。 讓我們來看看貢獻者的工作流程。假設貢獻者已經 分叉 並 克隆 了儲存庫，因此他們在本地電腦上有一個可以工作的 Git 儲存庫： 創建分支。使用 git branch 命令創建一個包含他們想要貢獻的更改的分支： bash git branch [branch-name] 切換到工作分支。切換到指定分支並使用 git switch 更新工作目錄： bash git switch [branch-name] 進行工作。此時，你可以添加更改。別忘了使用以下命令告訴 Git： bash git addgit commit -m \"my changes\"\n確保為你的提交命名得當，這對你自己以及你幫助的儲存庫維護者都很重要。\n將你的工作與 main 分支合併。當你完成工作並希望將你的更改與 main 分支合併時，main 分支可能已經發生了變化，因此請確保首先使用以下命令更新它：\nbash\ngit switch main\ngit pull\n此時，你需要確保任何 衝突（Git 無法輕鬆 合併 的更改）發生在你的工作分支中。因此，運行以下命令：\nbash\ngit switch [branch_name]\ngit merge main\n這將把 main 中的所有更改帶入你的分支，希望你可以繼續。如果不能，VS Code 會告訴你 Git 困惑 的地方，你只需修改受影響的檔案，指出哪個內容最準確即可。\n將你的工作發送到 GitHub。將你的工作發送到 GitHub 意味著兩件事。將你的分支推送到你的儲存庫，然後打開一個 PR（Pull Request）。\nbash\ngit push --set-upstream origin [branch-name]\n上述命令會在你的分叉儲存庫上創建該分支。\n打開 PR。接下來，你需要打開一個 PR。你可以通過導航到 GitHub 上的分叉儲存庫來完成此操作。你會在 GitHub 上看到一個提示，詢問你是否要創建一個新的 PR，點擊它，你將進入一個介面，可以更改提交訊息標題，並給出更合適的描述。現在，你分叉的儲存庫的維護者將看到這個 PR，希望 他們會欣賞並 合併 你的 PR。你現在是一名貢獻者，太棒了 :)\n清理。成功合併 PR 後，清理工作被認為是良好的做法。你需要清理本地分支和推送到 GitHub 的分支。首先，使用以下命令在本地刪除它：\nbash\ngit branch -d [branch-name]\n確保你前往 GitHub 頁面，找到你剛剛推送的分支，並移除該遠端分支。\nPull request 這個詞聽起來有點奇怪，因為實際上你是想將你的更改推送到專案中。但專案的維護者（專案擁有者）或核心團隊需要在合併到專案的 \"main\" 分支之前審核你的更改，因此你實際上是在向維護者請求更改的決定。\nPull request 是一個用來比較和討論分支中引入的差異的地方，並且可以進行審核、評論、整合測試等操作。一個好的 pull request 大致遵循與提交訊息相同的規則。當你的工作解決了一個問題時，你可以在問題追蹤器中引用該問題。這可以通過使用 # 後接問題編號來完成。例如 #97。\n🤞希望所有檢查都通過，並且專案擁有者合併你的更改到專案中🤞\n更新你目前的本地工作分支，將 GitHub 上對應的遠端分支的所有新提交拉取下來：\ngit pull\n如何貢獻開源專案\n首先，找到一個你感興趣並希望貢獻更改的 GitHub 儲存庫（或 repo）。你需要將其內容複製到你的電腦上。\n✅ 找到「適合初學者」的儲存庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。\n有幾種複製程式碼的方法，其中一種是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」儲存庫的內容。\n打開你的終端機，像這樣克隆儲存庫：\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2377,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "f9d4027e1f0e7224bb0ce2ea5f33c797",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "意味著兩件事。將你的分支推送到你的儲存庫，然後打開一個 PR（Pull Request）。 bash git push --set-upstream origin [branch-name] 上述命令會在你的分叉儲存庫上創建該分支。 打開 PR。接下來，你需要打開一個 PR。你可以通過導航到 GitHub 上的分叉儲存庫來完成此操作。你會在 GitHub 上看到一個提示，詢問你是否要創建一個新的 PR，點擊它，你將進入一個介面，可以更改提交訊息標題，並給出更合適的描述。現在，你分叉的儲存庫的維護者將看到這個 PR，希望 他們會欣賞並 合併 你的 PR。你現在是一名貢獻者，太棒了 :) 清理。成功合併 PR 後，清理工作被認為是良好的做法。你需要清理本地分支和推送到 GitHub 的分支。首先，使用以下命令在本地刪除它： bash git branch -d [branch-name] 確保你前往 GitHub 頁面，找到你剛剛推送的分支，並移除該遠端分支。 Pull request 這個詞聽起來有點奇怪，因為實際上你是想將你的更改推送到專案中。但專案的維護者（專案擁有者）或核心團隊需要在合併到專案的 \"main\" 分支之前審核你的更改，因此你實際上是在向維護者請求更改的決定。 Pull request 是一個用來比較和討論分支中引入的差異的地方，並且可以進行審核、評論、整合測試等操作。一個好的 pull request 大致遵循與提交訊息相同的規則。當你的工作解決了一個問題時，你可以在問題追蹤器中引用該問題。這可以通過使用 # 後接問題編號來完成。例如 #97。 🤞希望所有檢查都通過，並且專案擁有者合併你的更改到專案中🤞 更新你目前的本地工作分支，將 GitHub 上對應的遠端分支的所有新提交拉取下來： git pull 如何貢獻開源專案 首先，找到一個你感興趣並希望貢獻更改的 GitHub 儲存庫（或 repo）。你需要將其內容複製到你的電腦上。 ✅ 找到「適合初學者」的儲存庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。 有幾種複製程式碼的方法，其中一種是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」儲存庫的內容。 打開你的終端機，像這樣克隆儲存庫： git clone https://githubcom/ProjectURL\n要開始專案工作，切換到正確的資料夾：\ncd ProjectURL\n你也可以使用 Codespaces（GitHub 的嵌入式程式碼編輯器/雲端開發環境）或 GitHub Desktop 打開整個專案。\n最後，你也可以下載壓縮檔案形式的程式碼。\n關於 GitHub 的一些有趣事\n你可以對 GitHub 上的任何公共儲存庫進行加星、關注或「fork」。你可以在右上角的下拉選單中找到你加星的儲存庫。這就像為程式碼加書籤。\n專案通常有一個問題追蹤器，大多數情況下在 GitHub 的 \"Issues\" 標籤中，除非另有說明。在這裡，人們討論與專案相關的問題。而在 Pull Requests 標籤中，人們討論和審核正在進行的更改。\n專案可能還有論壇、郵件列表或像 Slack、Discord 或 IRC 這樣的聊天頻道進行討論。\n✅ 瀏覽你的新 GitHub 儲存庫並嘗試一些操作，例如編輯設定、向儲存庫添加資訊，以及創建專案（例如看板）。你可以做很多事情！\n🚀 挑戰\n與朋友配對，互相合作處理彼此的程式碼。共同創建一個專案，fork 程式碼，創建分支並合併更改。\n課後測驗\n課後測驗\n回顧與自學\n閱讀更多關於 如何貢獻開源軟體。\nGit 速查表。\n多練習，多嘗試。GitHub 提供了很棒的學習路徑：skills",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1564,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "f46b539f7d7d05d93251d06eaa3c566b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "request 大致遵循與提交訊息相同的規則。當你的工作解決了一個問題時，你可以在問題追蹤器中引用該問題。這可以通過使用 # 後接問題編號來完成。例如 #97。 🤞希望所有檢查都通過，並且專案擁有者合併你的更改到專案中🤞 更新你目前的本地工作分支，將 GitHub 上對應的遠端分支的所有新提交拉取下來： git pull 如何貢獻開源專案 首先，找到一個你感興趣並希望貢獻更改的 GitHub 儲存庫（或 repo）。你需要將其內容複製到你的電腦上。 ✅ 找到「適合初學者」的儲存庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。 有幾種複製程式碼的方法，其中一種是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」儲存庫的內容。 打開你的終端機，像這樣克隆儲存庫： git clone https://githubcom/ProjectURL 要開始專案工作，切換到正確的資料夾： cd ProjectURL 你也可以使用 Codespaces（GitHub 的嵌入式程式碼編輯器/雲端開發環境）或 GitHub Desktop 打開整個專案。 最後，你也可以下載壓縮檔案形式的程式碼。 關於 GitHub 的一些有趣事 你可以對 GitHub 上的任何公共儲存庫進行加星、關注或「fork」。你可以在右上角的下拉選單中找到你加星的儲存庫。這就像為程式碼加書籤。 專案通常有一個問題追蹤器，大多數情況下在 GitHub 的 \"Issues\" 標籤中，除非另有說明。在這裡，人們討論與專案相關的問題。而在 Pull Requests 標籤中，人們討論和審核正在進行的更改。 專案可能還有論壇、郵件列表或像 Slack、Discord 或 IRC 這樣的聊天頻道進行討論。 ✅ 瀏覽你的新 GitHub 儲存庫並嘗試一些操作，例如編輯設定、向儲存庫添加資訊，以及創建專案（例如看板）。你可以做很多事情！ 🚀 挑戰 與朋友配對，互相合作處理彼此的程式碼。共同創建一個專案，fork 程式碼，創建分支並合併更改。 課後測驗 課後測驗 回顧與自學 閱讀更多關於 如何貢獻開源軟體。 Git 速查表。 多練習，多嘗試。GitHub 提供了很棒的學習路徑：skillsgithub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 981,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "d0a48a26c21239d452980252c5a0edbf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "request 大致遵循與提交訊息相同的規則。當你的工作解決了一個問題時，你可以在問題追蹤器中引用該問題。這可以通過使用 # 後接問題編號來完成。例如 #97。 🤞希望所有檢查都通過，並且專案擁有者合併你的更改到專案中🤞 更新你目前的本地工作分支，將 GitHub 上對應的遠端分支的所有新提交拉取下來： git pull 如何貢獻開源專案 首先，找到一個你感興趣並希望貢獻更改的 GitHub 儲存庫（或 repo）。你需要將其內容複製到你的電腦上。 ✅ 找到「適合初學者」的儲存庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。 有幾種複製程式碼的方法，其中一種是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」儲存庫的內容。 打開你的終端機，像這樣克隆儲存庫： git clone https://githubcom/ProjectURL 要開始專案工作，切換到正確的資料夾： cd ProjectURL 你也可以使用 Codespaces（GitHub 的嵌入式程式碼編輯器/雲端開發環境）或 GitHub Desktop 打開整個專案。 最後，你也可以下載壓縮檔案形式的程式碼。 關於 GitHub 的一些有趣事 你可以對 GitHub 上的任何公共儲存庫進行加星、關注或「fork」。你可以在右上角的下拉選單中找到你加星的儲存庫。這就像為程式碼加書籤。 專案通常有一個問題追蹤器，大多數情況下在 GitHub 的 \"Issues\" 標籤中，除非另有說明。在這裡，人們討論與專案相關的問題。而在 Pull Requests 標籤中，人們討論和審核正在進行的更改。 專案可能還有論壇、郵件列表或像 Slack、Discord 或 IRC 這樣的聊天頻道進行討論。 ✅ 瀏覽你的新 GitHub 儲存庫並嘗試一些操作，例如編輯設定、向儲存庫添加資訊，以及創建專案（例如看板）。你可以做很多事情！ 🚀 挑戰 與朋友配對，互相合作處理彼此的程式碼。共同創建一個專案，fork 程式碼，創建分支並合併更改。 課後測驗 課後測驗 回顧與自學 閱讀更多關於 如何貢獻開源軟體。 Git 速查表。 多練習，多嘗試。GitHub 提供了很棒的學習路徑：skillsgithubcom:\nGitHub 的第一週\n你還可以找到更多進階課程。\n作業\n完成 GitHub 的第一週課程。\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16747,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1198,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "e85b62b06adadf9748569313ce86358e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं",
    "content": "स्पेस गेम बनाएं\nएक स्पेस गेम जो उन्नत जावास्क्रिप्ट के मूलभूत सिद्धांत सिखाएगा\nइस पाठ में आप अपना खुद का स्पेस गेम बनाना सीखेंगे। अगर आपने कभी \"स्पेस इनवेडर्स\" गेम खेला है, तो यह गेम उसी विचार पर आधारित है: एक स्पेसशिप को चलाना और ऊपर से आने वाले मॉन्स्टर्स पर फायर करना। तैयार गेम कुछ इस तरह दिखेगा:\nइन छह पाठों में आप निम्नलिखित सीखेंगे:\nइंटरैक्ट करें Canvas एलिमेंट के साथ ताकि स्क्रीन पर चीजें बनाई जा सकें\nसमझें कार्टेशियन कोऑर्डिनेट सिस्टम\nसीखें Pub-Sub पैटर्न ताकि गेम आर्किटेक्चर को बनाए रखना और विस्तार करना आसान हो\nलाभ उठाएं Async/Await का गेम संसाधनों को लोड करने के लिए\nहैंडल करें कीबोर्ड इवेंट्स\nअवलोकन\nसिद्धांत\nजावास्क्रिप्ट के साथ गेम बनाने का परिचय\nअभ्यास\nCanvas पर ड्रॉ करना\nस्क्रीन पर एलिमेंट्स को मूव करना\nटकराव का पता लगाना\nस्कोर रखना\nगेम को समाप्त करना और फिर से शुरू करना\nक्रेडिट्स\nइस गेम में उपयोग किए गए एसेट्स https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4271,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 802,
    "chunk_index": 0,
    "total_chunks": 3
  },
  {
    "id": "09c91d451e6d29d6cdd4bbb7f006c8b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं",
    "content": "कार्टेशियन कोऑर्डिनेट सिस्टम सीखें Pub-Sub पैटर्न ताकि गेम आर्किटेक्चर को बनाए रखना और विस्तार करना आसान हो लाभ उठाएं Async/Await का गेम संसाधनों को लोड करने के लिए हैंडल करें कीबोर्ड इवेंट्स अवलोकन सिद्धांत जावास्क्रिप्ट के साथ गेम बनाने का परिचय अभ्यास Canvas पर ड्रॉ करना स्क्रीन पर एलिमेंट्स को मूव करना टकराव का पता लगाना स्कोर रखना गेम को समाप्त करना और फिर से शुरू करना क्रेडिट्स इस गेम में उपयोग किए गए एसेट्स https://wwwkenney",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4271,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 385,
    "chunk_index": 1,
    "total_chunks": 3
  },
  {
    "id": "1b36dbeb378e95fa9b6cc909d519bf6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं",
    "content": "कार्टेशियन कोऑर्डिनेट सिस्टम सीखें Pub-Sub पैटर्न ताकि गेम आर्किटेक्चर को बनाए रखना और विस्तार करना आसान हो लाभ उठाएं Async/Await का गेम संसाधनों को लोड करने के लिए हैंडल करें कीबोर्ड इवेंट्स अवलोकन सिद्धांत जावास्क्रिप्ट के साथ गेम बनाने का परिचय अभ्यास Canvas पर ड्रॉ करना स्क्रीन पर एलिमेंट्स को मूव करना टकराव का पता लगाना स्कोर रखना गेम को समाप्त करना और फिर से शुरू करना क्रेडिट्स इस गेम में उपयोग किए गए एसेट्स https://wwwkenneynl/ से लिए गए हैं।\nअगर आप गेम बनाने में रुचि रखते हैं, तो ये कुछ बेहतरीन एसेट्स हैं। इनमें से बहुत कुछ मुफ्त है और कुछ भुगतान किए गए हैं।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4271,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 955,
    "chunk_index": 2,
    "total_chunks": 3
  },
  {
    "id": "e80664229d4d5d6842899346b599713a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\lesson-template\\assignment.md",
    "source_type": "git_repo",
    "title": "[असाइनमेंट का नाम]",
    "content": "[असाइनमेंट का नाम]\nनिर्देश\nमूल्यांकन मानदंड\n| मापदंड | उत्कृष्ट | पर्याप्त | सुधार की आवश्यकता |\n| ------- | -------- | -------- | ------------------ |\n|         |          |          |                    |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1801,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\lesson-template\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 542,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "55df8c781b7e1246c0d553d5c8c68505",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\lesson-template\\README.md",
    "source_type": "git_repo",
    "title": "[पाठ का विषय]",
    "content": "[पाठ का विषय]\nपाठ से पहले का क्विज़\n[विवरण दें कि हम क्या सीखेंगे]\nपरिचय\nबताएं कि इस पाठ में क्या कवर किया जाएगा\nनोट्स\nपूर्वापेक्षा\nइस पाठ से पहले किन चरणों को पूरा किया जाना चाहिए",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3638,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\lesson-template\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 171,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "6017727ea9df00475f69100b73ca14b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\lesson-template\\README.md",
    "source_type": "git_repo",
    "title": "[पाठ का विषय]",
    "content": "[पाठ का विषय]\nपाठ से पहले का क्विज़\n[विवरण दें कि हम क्या सीखेंगे]\nपरिचय\nबताएं कि इस पाठ में क्या कवर किया जाएगा\nनोट्स\nपूर्वापेक्षा\nइस पाठ से पहले किन चरणों को पूरा किया जाना चाहिएतैयारी\nइस पाठ को शुरू करने के लिए तैयारी के चरण\n[सामग्री को ब्लॉक्स में चरणबद्ध करें]\n[विषय 1]\nकार्य:\nसाझा कोड के साथ प्रोजेक्ट बनाने के लिए अपने कोडबेस को प्रगतिशील रूप से बेहतर बनाने के लिए मिलकर काम करें:\nhtml\ncode blocks\n✅ ज्ञान जांच - छात्रों के ज्ञान को खुले प्रश्नों के साथ बढ़ाने के लिए इस समय का उपयोग करें\n[विषय 2]\n[विषय 3]\n🚀 चुनौती: छात्रों को कक्षा में प्रोजेक्ट को बेहतर बनाने के लिए सामूहिक रूप से काम करने की चुनौती दें\nवैकल्पिक: यदि उपयुक्त हो, तो पूर्ण पाठ के UI का स्क्रीनशॉट जोड़ें\nपाठ के बाद का क्विज़\nसमीक्षा और स्व-अध्ययन\nअसाइनमेंट की समय सीमा [MM/YY]: असाइनमेंट का नाम\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3638,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\lesson-template\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1147,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "87c6be86f9826ae8401bbfb8d527363c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "क्विज़ ऐप\nये क्विज़ डेटा साइंस पाठ्यक्रम के लिए प्री- और पोस्ट-लेक्चर क्विज़ हैं, जो https://aka",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 82,
    "chunk_index": 0,
    "total_chunks": 10
  },
  {
    "id": "20383138ad8619838018f56c37d495ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "क्विज़ ऐप\nये क्विज़ डेटा साइंस पाठ्यक्रम के लिए प्री- और पोस्ट-लेक्चर क्विज़ हैं, जो https://akams/webdev-beginners पर उपलब्ध है।\nअनुवादित क्विज़ सेट जोड़ना\nकिसी क्विज़ का अनुवाद जोड़ने के लिए, assets/translations फोल्डर में समान क्विज़ संरचनाएँ बनाएं। मूल क्विज़ assets/translations/en में हैं। क्विज़ को कई समूहों में विभाजित किया गया है। सुनिश्चित करें कि सही क्विज़ सेक्शन के साथ नंबरिंग मेल खाती हो। इस पाठ्यक्रम में कुल 40 क्विज़ हैं, जिनकी गिनती 0 से शुरू होती है।\nयहाँ अनुवाद फ़ाइल की संरचना दी गई है:\n```\n[\n{\n\"title\": \"A title\",\n\"complete\": \"A complete button title\",\n\"error\": \"An error message upon selecting the wrong answer\",\n\"quizzes\": [\n{\n\"id\": 1,\n\"title\": \"Title\",\n\"quiz\": [\n{\n\"questionText\": \"The question asked\",\n\"answerOptions\": [\n{\n\"answerText\": \"Option 1 title\",\n\"isCorrect\": true\n},\n{\n\"answerText\": \"Option 2 title\",\n\"isCorrect\": false\n}\n]\n}\n]\n}\n]\n}\n]\n```\nअनुवाद संपादित करने के बाद, en में दिए गए नियमों का पालन करते हुए, अनुवाद फोल्डर में index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 631,
    "chunk_index": 1,
    "total_chunks": 10
  },
  {
    "id": "6aebde3bf34f94d789ed86050ff3c995",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "{ \"title\": \"A title\", \"complete\": \"A complete button title\", \"error\": \"An error message upon selecting the wrong answer\", \"quizzes\": [ { \"id\": 1, \"title\": \"Title\", \"quiz\": [ { \"questionText\": \"The question asked\", \"answerOptions\": [ { \"answerText\": \"Option 1 title\", \"isCorrect\": true }, { \"answerText\": \"Option 2 title\", \"isCorrect\": false } ] } ] } ] } ] ``` अनुवाद संपादित करने के बाद, en में दिए गए नियमों का पालन करते हुए, अनुवाद फोल्डर में indexjs फ़ाइल को संपादित करें और सभी फाइलें इम्पोर्ट करें।\nassets/translations में index js फ़ाइल को संपादित करें और नई अनुवादित फाइलें इम्पोर्ट करें।\nउदाहरण के लिए, यदि आपका अनुवाद JSON ex json में है, तो 'ex' को स्थानीयकरण कुंजी बनाएं और इसे नीचे दिखाए गए अनुसार इम्पोर्ट करें:\nindex js\n```\nimport ex from \" /ex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 440,
    "chunk_index": 2,
    "total_chunks": 10
  },
  {
    "id": "19af13ef77588c5503458fa73e55c99e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "] ``` अनुवाद संपादित करने के बाद, en में दिए गए नियमों का पालन करते हुए, अनुवाद फोल्डर में indexjs फ़ाइल को संपादित करें और सभी फाइलें इम्पोर्ट करें। assets/translations में index js फ़ाइल को संपादित करें और नई अनुवादित फाइलें इम्पोर्ट करें। उदाहरण के लिए, यदि आपका अनुवाद JSON ex json में है, तो 'ex' को स्थानीयकरण कुंजी बनाएं और इसे नीचे दिखाए गए अनुसार इम्पोर्ट करें: index js ``` import ex from \" /exjson\";\n// if 'ex' is localization key then enter it like so in `messages` to expose it\nconst messages = {\nex: ex[0],\n};\nexport default messages;\n```\nक्विज़ ऐप को लोकल रूप से चलाएं\nआवश्यकताएँ\nएक GitHub खाता\nNode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 426,
    "chunk_index": 3,
    "total_chunks": 10
  },
  {
    "id": "015137fcf7ca2f58e47ab796364a157a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "अनुवादित फाइलें इम्पोर्ट करें। उदाहरण के लिए, यदि आपका अनुवाद JSON ex json में है, तो 'ex' को स्थानीयकरण कुंजी बनाएं और इसे नीचे दिखाए गए अनुसार इम्पोर्ट करें: index js ``` import ex from \" /exjson\"; // if 'ex' is localization key then enter it like so in `messages` to expose it const messages = { ex: ex[0], }; export default messages; ``` क्विज़ ऐप को लोकल रूप से चलाएं आवश्यकताएँ एक GitHub खाता Nodejs और Git\nइंस्टॉल और सेटअप\nइस टेम्पलेट से एक रिपॉजिटरी बनाएं।\nअपनी नई रिपॉजिटरी को क्लोन करें और क्विज़-ऐप पर नेविगेट करें:\nbash\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 384,
    "chunk_index": 4,
    "total_chunks": 10
  },
  {
    "id": "14844a9ad4749ea49b4b1c3f2e047295",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "अनुसार इम्पोर्ट करें: index js ``` import ex from \" /exjson\"; // if 'ex' is localization key then enter it like so in `messages` to expose it const messages = { ex: ex[0], }; export default messages; ``` क्विज़ ऐप को लोकल रूप से चलाएं आवश्यकताएँ एक GitHub खाता Nodejs और Git इंस्टॉल और सेटअप इस टेम्पलेट से एक रिपॉजिटरी बनाएं। अपनी नई रिपॉजिटरी को क्लोन करें और क्विज़-ऐप पर नेविगेट करें: bash git clone https://githubcom/your-github-organization/repo-name\ncd repo-name/quiz-app\nnpm पैकेज और डिपेंडेंसी इंस्टॉल करें:\nbash\nnpm install\nऐप बनाएं\nसमाधान बनाने के लिए, यह कमांड चलाएं:\nbash\nnpm run build\nऐप शुरू करें\nसमाधान चलाने के लिए, यह कमांड चलाएं:\nbash\nnpm run dev\n[वैकल्पिक] लिंटिंग\nकोड को लिंट करने के लिए, यह कमांड चलाएं:\nbash\nnpm run lint\nक्विज़ ऐप को Azure पर डिप्लॉय करें\nआवश्यकताएँ\nएक Azure सब्सक्रिप्शन। यहाँ मुफ्त में साइन अप करें।\nइस क्विज़ ऐप को डिप्लॉय करने की लागत: मुफ्त\nऊपर दिए गए लिंक के माध्यम से Azure पर साइन इन करने के बाद, एक सब्सक्रिप्शन और रिसोर्स ग्रुप चुनें, फिर:\nस्टैटिक वेब ऐप विवरण: एक नाम प्रदान करें और होस्टिंग प्लान चुनें।\nGitHub लॉगिन: अपना डिप्लॉयमेंट स्रोत GitHub के रूप में सेट करें, फिर लॉग इन करें और फॉर्म में आवश्यक फ़ील्ड भरें:\nOrganization – अपना संगठन चुनें।\nRepository – Web Dev for Beginners पाठ्यक्रम रिपॉजिटरी चुनें।\nBranch - एक ब्रांच चुनें (main)।\nबिल्ड प्रीसेट्स: Azure Static Web Apps आपके ऐप्लिकेशन में उपयोग किए गए फ्रेमवर्क का पता लगाने के लिए एक डिटेक्शन एल्गोरिदम का उपयोग करता है।\nApp location -",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1088,
    "chunk_index": 5,
    "total_chunks": 10
  },
  {
    "id": "0f8801a30f105ee0aa24599ae73295d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "नाम प्रदान करें और होस्टिंग प्लान चुनें। GitHub लॉगिन: अपना डिप्लॉयमेंट स्रोत GitHub के रूप में सेट करें, फिर लॉग इन करें और फॉर्म में आवश्यक फ़ील्ड भरें: Organization – अपना संगठन चुनें। Repository – Web Dev for Beginners पाठ्यक्रम रिपॉजिटरी चुनें। Branch - एक ब्रांच चुनें (main)। बिल्ड प्रीसेट्स: Azure Static Web Apps आपके ऐप्लिकेशन में उपयोग किए गए फ्रेमवर्क का पता लगाने के लिए एक डिटेक्शन एल्गोरिदम का उपयोग करता है। App location -/quiz-app\nApi location -\nOutput location - dist\nडिप्लॉयमेंट: 'Review + Create' पर क्लिक करें, फिर 'Create' पर क्लिक करें।\nएक बार डिप्लॉय होने के बाद, आपकी रिपॉजिटरी की",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 460,
    "chunk_index": 6,
    "total_chunks": 10
  },
  {
    "id": "361ee374d54a4dcb76b71f39d9cc1254",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "Organization – अपना संगठन चुनें। Repository – Web Dev for Beginners पाठ्यक्रम रिपॉजिटरी चुनें। Branch - एक ब्रांच चुनें (main)। बिल्ड प्रीसेट्स: Azure Static Web Apps आपके ऐप्लिकेशन में उपयोग किए गए फ्रेमवर्क का पता लगाने के लिए एक डिटेक्शन एल्गोरिदम का उपयोग करता है। App location -/quiz-app Api location - Output location - dist डिप्लॉयमेंट: 'Review + Create' पर क्लिक करें, फिर 'Create' पर क्लिक करें। एक बार डिप्लॉय होने के बाद, आपकी रिपॉजिटरी कीgithub डायरेक्टरी में एक वर्कफ़्लो फ़ाइल बनाई जाएगी। यह वर्कफ़्लो फ़ाइल उन इवेंट्स के निर्देश देती है जो ऐप को Azure पर फिर से डिप्लॉय करेंगे, जैसे कि ब्रांच main पर push।\nवर्कफ़्लो फ़ाइल का उदाहरण\nयहाँ GitHub Actions वर्कफ़्लो फ़ाइल का एक उदाहरण दिया गया है:\nname: Azure Static Web Apps CI/CD\n```\non:\npush:\nbranches:\n- main\npull_request:\ntypes: [opened, synchronize, reopened, closed]\nbranches:\n- main\njobs:\nbuild_and_deploy_job:\nruns-on: ubuntu-latest\nname: Build and Deploy Job\nsteps:\n- uses: actions/checkout@v2\n- name: Build And Deploy\nid: builddeploy\nuses: Azure/static-web-apps-deploy@v1\nwith:\nazure_static_web_apps_api_token: ${{ secrets",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 673,
    "chunk_index": 7,
    "total_chunks": 10
  },
  {
    "id": "0699aff23cfb15b7e9138f125e728e4b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "ऐप को Azure पर फिर से डिप्लॉय करेंगे, जैसे कि ब्रांच main पर push। वर्कफ़्लो फ़ाइल का उदाहरण यहाँ GitHub Actions वर्कफ़्लो फ़ाइल का एक उदाहरण दिया गया है: name: Azure Static Web Apps CI/CD ``` on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v2 - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secretsAZURE_STATIC_WEB_APPS_API_TOKEN }}\nrepo_token: ${{ secrets",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 253,
    "chunk_index": 8,
    "total_chunks": 10
  },
  {
    "id": "3d4440951479b6050aef45d9572894a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "क्विज़ ऐप",
    "content": "फिर से डिप्लॉय करेंगे, जैसे कि ब्रांच main पर push। वर्कफ़्लो फ़ाइल का उदाहरण यहाँ GitHub Actions वर्कफ़्लो फ़ाइल का एक उदाहरण दिया गया है: name: Azure Static Web Apps CI/CD ``` on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v2 - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secretsAZURE_STATIC_WEB_APPS_API_TOKEN }} repo_token: ${{ secretsGITHUB_TOKEN }}\naction: \"upload\"\napp_location: \"quiz-app\" # App source code path\napi_location: \"\"API source code path optional\noutput_location: \"dist\" #Built app content directory - optional\n```\nपोस्ट-डिप्लॉयमेंट: डिप्लॉयमेंट पूरा होने के बाद, 'Go to Deployment' पर क्लिक करें और फिर 'View app in browser' पर क्लिक करें।\nएक बार जब आपका GitHub Action (वर्कफ़्लो) सफलतापूर्वक निष्पादित हो जाए, तो लाइव पेज को रिफ्रेश करें और अपना ऐप्लिकेशन देखें।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10424,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 918,
    "chunk_index": 9,
    "total_chunks": 10
  },
  {
    "id": "6d9c42be9177760fc6e1529c39f1713d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "VSCode dev का उपयोग करके एक रिज़्यूमे-वेबसाइट बनाएं\nकितना अच्छा होगा अगर कोई रिक्रूटर आपसे आपका रिज़्यूमे मांगे और आप उन्हें एक URL भेज दें 😎\nउद्देश्य\nइस असाइनमेंट के बाद, आप सीखेंगे कि:\nअपने रिज़्यूमे को प्रदर्शित करने के लिए एक वेबसाइट कैसे बनाएं\nआवश्यकताएँ\nएक GitHub अकाउंट। GitHub पर जाएं और यदि आपने पहले से अकाउंट नहीं बनाया है तो एक नया अकाउंट बनाएं।\nचरण\nचरण 1: एक नया GitHub रिपॉजिटरी बनाएं और इसे my-resume नाम दें।\nचरण 2: अपने रिपॉजिटरी में एक index html फाइल बनाएं। हम github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 470,
    "chunk_index": 0,
    "total_chunks": 19
  },
  {
    "id": "9e871dfc02bcc8dc9d2ae22baf607749",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "आपका रिज़्यूमे मांगे और आप उन्हें एक URL भेज दें 😎 उद्देश्य इस असाइनमेंट के बाद, आप सीखेंगे कि: अपने रिज़्यूमे को प्रदर्शित करने के लिए एक वेबसाइट कैसे बनाएं आवश्यकताएँ एक GitHub अकाउंट। GitHub पर जाएं और यदि आपने पहले से अकाउंट नहीं बनाया है तो एक नया अकाउंट बनाएं। चरण चरण 1: एक नया GitHub रिपॉजिटरी बनाएं और इसे my-resume नाम दें। चरण 2: अपने रिपॉजिटरी में एक index html फाइल बनाएं। हम githubcom पर कम से कम एक फाइल जोड़ेंगे क्योंकि आप vscode dev पर खाली रिपॉजिटरी नहीं खोल सकते।\ncreating a new file लिंक पर क्लिक करें, नाम index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 1,
    "total_chunks": 19
  },
  {
    "id": "918977f8ec84227a8eaacc0e8260efa1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "वेबसाइट कैसे बनाएं आवश्यकताएँ एक GitHub अकाउंट। GitHub पर जाएं और यदि आपने पहले से अकाउंट नहीं बनाया है तो एक नया अकाउंट बनाएं। चरण चरण 1: एक नया GitHub रिपॉजिटरी बनाएं और इसे my-resume नाम दें। चरण 2: अपने रिपॉजिटरी में एक index html फाइल बनाएं। हम githubcom पर कम से कम एक फाइल जोड़ेंगे क्योंकि आप vscode dev पर खाली रिपॉजिटरी नहीं खोल सकते। creating a new file लिंक पर क्लिक करें, नाम indexhtml टाइप करें और Commit new file बटन चुनें।\nचरण 3: VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 374,
    "chunk_index": 2,
    "total_chunks": 19
  },
  {
    "id": "26a04305656d3c30e7e05597da77cd54",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "यदि आपने पहले से अकाउंट नहीं बनाया है तो एक नया अकाउंट बनाएं। चरण चरण 1: एक नया GitHub रिपॉजिटरी बनाएं और इसे my-resume नाम दें। चरण 2: अपने रिपॉजिटरी में एक index html फाइल बनाएं। हम githubcom पर कम से कम एक फाइल जोड़ेंगे क्योंकि आप vscode dev पर खाली रिपॉजिटरी नहीं खोल सकते। creating a new file लिंक पर क्लिक करें, नाम indexhtml टाइप करें और Commit new file बटन चुनें। चरण 3: VSCodedev खोलें और Open Remote Repository बटन चुनें।\nउस रिपॉजिटरी का URL कॉपी करें जिसे आपने अभी अपने रिज़्यूमे साइट के लिए बनाया है और इसे इनपुट बॉक्स में पेस्ट करें:\nyour-username को अपने GitHub यूजरनेम से बदलें\nhttps://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 3,
    "total_chunks": 19
  },
  {
    "id": "193e1c3d0fea301a305c0a1f021937aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "पर कम से कम एक फाइल जोड़ेंगे क्योंकि आप vscode dev पर खाली रिपॉजिटरी नहीं खोल सकते। creating a new file लिंक पर क्लिक करें, नाम indexhtml टाइप करें और Commit new file बटन चुनें। चरण 3: VSCodedev खोलें और Open Remote Repository बटन चुनें। उस रिपॉजिटरी का URL कॉपी करें जिसे आपने अभी अपने रिज़्यूमे साइट के लिए बनाया है और इसे इनपुट बॉक्स में पेस्ट करें: your-username को अपने GitHub यूजरनेम से बदलें https://githubcom/your-username/my-resume\n✅ यदि सफल हुआ, तो आप अपने प्रोजेक्ट और index html फाइल को ब्राउज़र पर टेक्स्ट एडिटर में खुला हुआ देखेंगे।\nचरण 4: index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 430,
    "chunk_index": 4,
    "total_chunks": 19
  },
  {
    "id": "d64bd82a5b687e75f7c1ad9dbbfb6961",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "करें, नाम indexhtml टाइप करें और Commit new file बटन चुनें। चरण 3: VSCodedev खोलें और Open Remote Repository बटन चुनें। उस रिपॉजिटरी का URL कॉपी करें जिसे आपने अभी अपने रिज़्यूमे साइट के लिए बनाया है और इसे इनपुट बॉक्स में पेस्ट करें: your-username को अपने GitHub यूजरनेम से बदलें https://githubcom/your-username/my-resume ✅ यदि सफल हुआ, तो आप अपने प्रोजेक्ट और index html फाइल को ब्राउज़र पर टेक्स्ट एडिटर में खुला हुआ देखेंगे। चरण 4: indexhtml फाइल खोलें, नीचे दिए गए कोड को अपने कोड एरिया में पेस्ट करें और सेव करें।\nHTML कोड जो आपकी रिज़्यूमे वेबसाइट की सामग्री के लिए जिम्मेदार है।\nआपका नाम यहां लिखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 5,
    "total_chunks": 19
  },
  {
    "id": "3778af99a6986c95f76a830159b5ec68",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "साइट के लिए बनाया है और इसे इनपुट बॉक्स में पेस्ट करें: your-username को अपने GitHub यूजरनेम से बदलें https://githubcom/your-username/my-resume ✅ यदि सफल हुआ, तो आप अपने प्रोजेक्ट और index html फाइल को ब्राउज़र पर टेक्स्ट एडिटर में खुला हुआ देखेंगे। चरण 4: indexhtml फाइल खोलें, नीचे दिए गए कोड को अपने कोड एरिया में पेस्ट करें और सेव करें। HTML कोड जो आपकी रिज़्यूमे वेबसाइट की सामग्री के लिए जिम्मेदार है। आपका नाम यहां लिखेंआपका नाम यहां लिखें आपका रोल संपर्क\nअपना ईमेल यहां लिखें\nअपना यूजरनेम यहां लिखें अपना यूजरनेम यहां लिखें कौशल\nकौशल 1 कौशल 2 कौशल 3",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 6,
    "total_chunks": 19
  },
  {
    "id": "474dfc3b9cec89faaf804c844eff0c03",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "आप अपने प्रोजेक्ट और index html फाइल को ब्राउज़र पर टेक्स्ट एडिटर में खुला हुआ देखेंगे। चरण 4: indexhtml फाइल खोलें, नीचे दिए गए कोड को अपने कोड एरिया में पेस्ट करें और सेव करें। HTML कोड जो आपकी रिज़्यूमे वेबसाइट की सामग्री के लिए जिम्मेदार है। आपका नाम यहां लिखेंआपका नाम यहां लिखें आपका रोल संपर्क अपना ईमेल यहां लिखें अपना यूजरनेम यहां लिखें अपना यूजरनेम यहां लिखें कौशल कौशल 1 कौशल 2 कौशल 3कौशल 4 शिक्षा\nअपना कोर्स यहां लिखें अपना संस्थान यहां लिखें प्रारंभ - समाप्ति तिथि\nमेरे बारे में\nअपने बारे में कुछ लिखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 7,
    "total_chunks": 19
  },
  {
    "id": "cdabfbdf6b872267ac018f682e7dec35",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "दिए गए कोड को अपने कोड एरिया में पेस्ट करें और सेव करें। HTML कोड जो आपकी रिज़्यूमे वेबसाइट की सामग्री के लिए जिम्मेदार है। आपका नाम यहां लिखेंआपका नाम यहां लिखें आपका रोल संपर्क अपना ईमेल यहां लिखें अपना यूजरनेम यहां लिखें अपना यूजरनेम यहां लिखें कौशल कौशल 1 कौशल 2 कौशल 3कौशल 4 शिक्षा अपना कोर्स यहां लिखें अपना संस्थान यहां लिखें प्रारंभ - समाप्ति तिथि मेरे बारे में अपने बारे में कुछ लिखेंकार्य अनुभव\nजॉब टाइटल\nसंगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना\nकार्य 1 - आपने क्या किया लिखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 8,
    "total_chunks": 19
  },
  {
    "id": "2942bab1db78aa8680e9539927fb4681",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "के लिए जिम्मेदार है। आपका नाम यहां लिखेंआपका नाम यहां लिखें आपका रोल संपर्क अपना ईमेल यहां लिखें अपना यूजरनेम यहां लिखें अपना यूजरनेम यहां लिखें कौशल कौशल 1 कौशल 2 कौशल 3कौशल 4 शिक्षा अपना कोर्स यहां लिखें अपना संस्थान यहां लिखें प्रारंभ - समाप्ति तिथि मेरे बारे में अपने बारे में कुछ लिखेंकार्य अनुभव जॉब टाइटल संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 423,
    "chunk_index": 9,
    "total_chunks": 19
  },
  {
    "id": "a7489661337757a8283260719516de7d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "यहां लिखेंआपका नाम यहां लिखें आपका रोल संपर्क अपना ईमेल यहां लिखें अपना यूजरनेम यहां लिखें अपना यूजरनेम यहां लिखें कौशल कौशल 1 कौशल 2 कौशल 3कौशल 4 शिक्षा अपना कोर्स यहां लिखें अपना संस्थान यहां लिखें प्रारंभ - समाप्ति तिथि मेरे बारे में अपने बारे में कुछ लिखेंकार्य अनुभव जॉब टाइटल संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें\nजॉब टाइटल 2\nसंगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना\nकार्य 1 - आपने क्या किया लिखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 523,
    "chunk_index": 10,
    "total_chunks": 19
  },
  {
    "id": "fe9e6c88aa058f11a4d6bae484f68f9e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "कौशल 3कौशल 4 शिक्षा अपना कोर्स यहां लिखें अपना संस्थान यहां लिखें प्रारंभ - समाप्ति तिथि मेरे बारे में अपने बारे में कुछ लिखेंकार्य अनुभव जॉब टाइटल संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें जॉब टाइटल 2 संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 406,
    "chunk_index": 11,
    "total_chunks": 19
  },
  {
    "id": "e64e94b541b802cb9c0451940151d55a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "यहां लिखें अपना संस्थान यहां लिखें प्रारंभ - समाप्ति तिथि मेरे बारे में अपने बारे में कुछ लिखेंकार्य अनुभव जॉब टाइटल संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें जॉब टाइटल 2 संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें\nअपने रिज़्यूमे की जानकारी को HTML कोड में प्लेसहोल्डर टेक्स्ट के स्थान पर जोड़ें।\nचरण 5: My-Resume फोल्डर पर होवर करें, New File",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 519,
    "chunk_index": 12,
    "total_chunks": 19
  },
  {
    "id": "ae7bce568d78bff06f6b4e94f60b281c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें जॉब टाइटल 2 संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें अपने रिज़्यूमे की जानकारी को HTML कोड में प्लेसहोल्डर टेक्स्ट के स्थान पर जोड़ें। चरण 5: My-Resume फोल्डर पर होवर करें, New Fileआइकन पर क्लिक करें और अपने प्रोजेक्ट में 2 नई फाइलें बनाएं: style css और codeswing json फाइलें।\nचरण 6: style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 461,
    "chunk_index": 13,
    "total_chunks": 19
  },
  {
    "id": "f84812f50bf5afaca13a19ce65120730",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "परिणाम/प्रभाव लिखें जॉब टाइटल 2 संगठन का नाम यहां लिखें | प्रारंभ महीना – समाप्ति महीना कार्य 1 - आपने क्या किया लिखेंकार्य 2 - आपने क्या किया लिखेंअपने योगदान के परिणाम/प्रभाव लिखें अपने रिज़्यूमे की जानकारी को HTML कोड में प्लेसहोल्डर टेक्स्ट के स्थान पर जोड़ें। चरण 5: My-Resume फोल्डर पर होवर करें, New Fileआइकन पर क्लिक करें और अपने प्रोजेक्ट में 2 नई फाइलें बनाएं: style css और codeswing json फाइलें। चरण 6: stylecss फाइल खोलें, नीचे दिए गए कोड को पेस्ट करें और सेव करें।\nसाइट के लेआउट को फॉर्मेट करने के लिए CSS कोड।\nbody {\nfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\nfont-size: 16px;\nmax-width: 960px;\nmargin: auto;\n}\nh1 {\nfont-size: 3em;\nletter-spacing:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 516,
    "chunk_index": 14,
    "total_chunks": 19
  },
  {
    "id": "5306fb2e9ff93a534c7e900116f0a5fc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "के स्थान पर जोड़ें। चरण 5: My-Resume फोल्डर पर होवर करें, New Fileआइकन पर क्लिक करें और अपने प्रोजेक्ट में 2 नई फाइलें बनाएं: style css और codeswing json फाइलें। चरण 6: stylecss फाइल खोलें, नीचे दिए गए कोड को पेस्ट करें और सेव करें। साइट के लेआउट को फॉर्मेट करने के लिए CSS कोड। body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em;\npadding-top: 1em;\npadding-bottom: 1em;\n}\nh2 {\nfont-size: 1 5em;\npadding-bottom: 1em;\n}\nh3 {\nfont-size: 1em;\npadding-bottom: 1em;\n}\nmain {\ndisplay: grid;\ngrid-template-columns: 40% 60%;\nmargin-top: 3em;\n}\nheader {\ntext-align: center;\nmargin: auto 2em;\n}\nsection {\nmargin: auto 1em 4em 2em;\n}\ni {\nmargin-right: 5em;\n}\np {\nmargin: 2em auto\n}\nhr {\nborder: none;\nbackground-color: lightgray;\nheight: 1px;\n}\nh1, h2, h3 {\nfont-weight: 100;\nmargin-bottom: 0;\n}\n#mainLeft {\nborder-right: 1px solid lightgray;\n}\nचरण 6: codeswing",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 15,
    "total_chunks": 19
  },
  {
    "id": "b6369e45544e2b959adc3e97d9bcd147",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "5em; padding-bottom: 1em; } h3 { font-size: 1em; padding-bottom: 1em; } main { display: grid; grid-template-columns: 40% 60%; margin-top: 3em; } header { text-align: center; margin: auto 2em; } section { margin: auto 1em 4em 2em; } i { margin-right: 5em; } p { margin: 2em auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } चरण 6: codeswingjson फाइल खोलें, नीचे दिए गए कोड को पेस्ट करें और सेव करें।\n{\n\"scripts\": [],\n\"styles\": []\n}\nचरण 7: Codeswing एक्सटेंशन इंस्टॉल करें ताकि आप कोड एरिया में रिज़्यूमे वेबसाइट को विज़ुअलाइज़ कर सकें।\nExtensions आइकन पर क्लिक करें और Codeswing टाइप करें। या तो विस्तारित एक्टिविटी बार पर ब्लू इंस्टॉल बटन पर क्लिक करें या कोड एरिया में इंस्टॉल बटन का उपयोग करें। एक्सटेंशन इंस्टॉल करने के तुरंत बाद, अपने प्रोजेक्ट में बदलाव देखें 😃\nयह वह है जो आप अपने स्क्रीन पर देखेंगे जब आप एक्सटेंशन इंस्टॉल करेंगे।\nयदि आप अपने द्वारा किए गए बदलावों से संतुष्ट हैं, तो Changes फोल्डर पर होवर करें और + बटन पर क्लिक करें।\nएक कमिट मैसेज टाइप करें (आपने प्रोजेक्ट में जो बदलाव किए हैं उसका विवरण) और अपने बदलावों को कमिट करने के लिए check पर क्लिक करें। जब आप अपने प्रोजेक्ट पर काम पूरा कर लें, तो टॉप लेफ्ट पर हैमबर्गर मेनू आइकन चुनें और GitHub पर रिपॉजिटरी पर लौटें।\nबधाई हो 🎉 आपने कुछ ही चरणों में vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 986,
    "chunk_index": 16,
    "total_chunks": 19
  },
  {
    "id": "1b816498ed889c08f8532ba5bc3a3c2c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "किए गए बदलावों से संतुष्ट हैं, तो Changes फोल्डर पर होवर करें और + बटन पर क्लिक करें। एक कमिट मैसेज टाइप करें (आपने प्रोजेक्ट में जो बदलाव किए हैं उसका विवरण) और अपने बदलावों को कमिट करने के लिए check पर क्लिक करें। जब आप अपने प्रोजेक्ट पर काम पूरा कर लें, तो टॉप लेफ्ट पर हैमबर्गर मेनू आइकन चुनें और GitHub पर रिपॉजिटरी पर लौटें। बधाई हो 🎉 आपने कुछ ही चरणों में vscodedev का उपयोग करके अपनी रिज़्यूमे वेबसाइट बना ली है।\n🚀 चुनौती\nएक रिमोट रिपॉजिटरी खोलें जिसमें आपको बदलाव करने की अनुमति हो और कुछ फाइलें अपडेट करें। इसके बाद, अपने बदलावों के साथ एक नई ब्रांच बनाने और एक Pull Request करने का प्रयास करें।\nसमीक्षा और स्व-अध्ययन\nVSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 596,
    "chunk_index": 17,
    "total_chunks": 19
  },
  {
    "id": "f97352088061eaca8661fd435ff0e343",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "आपका नाम यहां लिखें!",
    "content": "काम पूरा कर लें, तो टॉप लेफ्ट पर हैमबर्गर मेनू आइकन चुनें और GitHub पर रिपॉजिटरी पर लौटें। बधाई हो 🎉 आपने कुछ ही चरणों में vscodedev का उपयोग करके अपनी रिज़्यूमे वेबसाइट बना ली है। 🚀 चुनौती एक रिमोट रिपॉजिटरी खोलें जिसमें आपको बदलाव करने की अनुमति हो और कुछ फाइलें अपडेट करें। इसके बाद, अपने बदलावों के साथ एक नई ब्रांच बनाने और एक Pull Request करने का प्रयास करें। समीक्षा और स्व-अध्ययन VSCodedev और इसकी अन्य विशेषताओं के बारे में अधिक पढ़ें।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15645,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 18,
    "total_chunks": 19
  },
  {
    "id": "e9de6733191507cc945ad21a38490ed4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\assignment.md",
    "source_type": "git_repo",
    "title": "रूटिंग में सुधार करें",
    "content": "रूटिंग में सुधार करें\nनिर्देश\nरूट्स डिक्लेरेशन में फिलहाल केवल टेम्पलेट ID का उपयोग किया गया है। लेकिन जब एक नया पेज दिखाया जाता है, तो कभी-कभी इससे अधिक की आवश्यकता होती है। चलिए हमारी रूटिंग इम्प्लीमेंटेशन को दो अतिरिक्त फीचर्स के साथ बेहतर बनाते हैं:\nप्रत्येक टेम्पलेट को टाइटल दें और जब टेम्पलेट बदलता है तो विंडो टाइटल को इस नए टाइटल के साथ अपडेट करें।\nटेम्पलेट बदलने के बाद कुछ कोड चलाने का विकल्प जोड़ें। हम चाहते हैं कि हर बार जब डैशबोर्ड पेज दिखाया जाए, तो डेवलपर कंसोल में 'Dashboard is shown' प्रिंट हो।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                                                                                          | पर्याप्त                                                                                                                                                                                  | सुधार की आवश्यकता                                       |\n| -------- | ---------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- |\n|          | दोनों फीचर्स लागू किए गए हैं और काम कर रहे हैं। टाइटल और कोड जोड़ने का फीचर routes डिक्लेरेशन में एक नए रूट के लिए भी काम करता है। | दोनों फीचर्स काम करते हैं, लेकिन व्यवहार हार्डकोडेड है और routes डिक्लेरेशन के माध्यम से कॉन्फ़िगर करने योग्य नहीं है। टाइटल और कोड जोड़ने के साथ तीसरा रूट जोड़ना काम नहीं करता या आंशिक रूप से काम करता है। | एक फीचर गायब है या सही तरीके से काम नहीं कर रहा है। |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4646,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1401,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "9a983028f955a6f9caba2728ef12a80c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने बैंक ऐप को स्टाइल करें",
    "content": "अपने बैंक ऐप को स्टाइल करें\nनिर्देश\nएक नया styles css फ़ाइल बनाएं और इसे अपनी मौजूदा index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3941,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 82,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "33fbe690707d39ed08afa97cc25fce49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने बैंक ऐप को स्टाइल करें",
    "content": "अपने बैंक ऐप को स्टाइल करें\nनिर्देश\nएक नया styles css फ़ाइल बनाएं और इसे अपनी मौजूदा indexhtml फ़ाइल में लिंक करें। जिस CSS फ़ाइल को आपने अभी बनाया है, उसमें कुछ स्टाइलिंग जोड़ें ताकि लॉगिन और डैशबोर्ड पेज अच्छे और व्यवस्थित दिखें। अपने ऐप को उसकी खुद की ब्रांडिंग देने के लिए एक रंग थीम बनाने की कोशिश करें।\nटिप: यदि आवश्यक हो, तो आप HTML को संशोधित कर सकते हैं और नए एलिमेंट्स और क्लासेस जोड़ सकते हैं।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                                                                               | पर्याप्त                                                                       | सुधार की आवश्यकता                                                                             |\n| -------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- |\n|          | सभी पेज साफ और पढ़ने योग्य दिखते हैं, एक सुसंगत रंग थीम के साथ और विभिन्न सेक्शन स्पष्ट रूप से अलग-अलग दिखाई देते हैं। | पेज स्टाइल किए गए हैं लेकिन बिना थीम के या सेक्शन स्पष्ट रूप से सीमांकित नहीं हैं। | पेज में स्टाइलिंग की कमी है, सेक्शन अव्यवस्थित दिखते हैं और जानकारी पढ़ने में कठिन है। |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3941,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1194,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "777a72c09d1e1e88267911122ae66ed4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "कोड एडिटर का उपयोग करना\nयह पाठ VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 34,
    "chunk_index": 0,
    "total_chunks": 23
  },
  {
    "id": "5f7bdd23509c6ca4b180a9090016b752",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "कोड एडिटर का उपयोग करना\nयह पाठ VSCodedev नामक एक वेब-आधारित कोड एडिटर के उपयोग की मूल बातें कवर करता है, ताकि आप अपने कोड में बदलाव कर सकें और किसी प्रोजेक्ट में योगदान दे सकें, बिना अपने कंप्यूटर पर कुछ भी इंस्टॉल किए।\nसीखने के उद्देश्य\nइस पाठ में, आप सीखेंगे:\nकोड प्रोजेक्ट में कोड एडिटर का उपयोग करना\nवर्शन कंट्रोल के साथ बदलावों को ट्रैक करना\nविकास के लिए एडिटर को कस्टमाइज़ करना\nपूर्वापेक्षाएँ\nशुरू करने से पहले, आपको GitHub पर एक खाता बनाना होगा। GitHub पर जाएं और यदि आपने पहले से खाता नहीं बनाया है, तो एक खाता बनाएं।\nपरिचय\nकोड एडिटर प्रोग्राम लिखने और मौजूदा कोडिंग प्रोजेक्ट्स के साथ सहयोग करने के लिए एक आवश्यक उपकरण है। एक बार जब आप एडिटर की मूल बातें और इसकी विशेषताओं का उपयोग करना समझ जाते हैं, तो आप इन्हें कोड लिखने में लागू कर सकते हैं।\nVSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 742,
    "chunk_index": 1,
    "total_chunks": 23
  },
  {
    "id": "1711067755f45d11051e54d67b20f1c2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "करना पूर्वापेक्षाएँ शुरू करने से पहले, आपको GitHub पर एक खाता बनाना होगा। GitHub पर जाएं और यदि आपने पहले से खाता नहीं बनाया है, तो एक खाता बनाएं। परिचय कोड एडिटर प्रोग्राम लिखने और मौजूदा कोडिंग प्रोजेक्ट्स के साथ सहयोग करने के लिए एक आवश्यक उपकरण है। एक बार जब आप एडिटर की मूल बातें और इसकी विशेषताओं का उपयोग करना समझ जाते हैं, तो आप इन्हें कोड लिखने में लागू कर सकते हैं। VSCodedev के साथ शुरुआत करना\nVSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 388,
    "chunk_index": 2,
    "total_chunks": 23
  },
  {
    "id": "7d8aefd555fd2cee17bc08e24bdbdc65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "पहले, आपको GitHub पर एक खाता बनाना होगा। GitHub पर जाएं और यदि आपने पहले से खाता नहीं बनाया है, तो एक खाता बनाएं। परिचय कोड एडिटर प्रोग्राम लिखने और मौजूदा कोडिंग प्रोजेक्ट्स के साथ सहयोग करने के लिए एक आवश्यक उपकरण है। एक बार जब आप एडिटर की मूल बातें और इसकी विशेषताओं का उपयोग करना समझ जाते हैं, तो आप इन्हें कोड लिखने में लागू कर सकते हैं। VSCodedev के साथ शुरुआत करना VSCodedev एक वेब-आधारित कोड एडिटर है। इसे उपयोग करने के लिए आपको कुछ भी इंस्टॉल करने की आवश्यकता नहीं है, यह किसी अन्य वेबसाइट खोलने जैसा है। एडिटर के साथ शुरुआत करने के लिए, निम्न लिंक खोलें: https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 549,
    "chunk_index": 3,
    "total_chunks": 23
  },
  {
    "id": "7ea7fdd9ad8bcb144f04cc012a4f9fd7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "के लिए एक आवश्यक उपकरण है। एक बार जब आप एडिटर की मूल बातें और इसकी विशेषताओं का उपयोग करना समझ जाते हैं, तो आप इन्हें कोड लिखने में लागू कर सकते हैं। VSCodedev के साथ शुरुआत करना VSCodedev एक वेब-आधारित कोड एडिटर है। इसे उपयोग करने के लिए आपको कुछ भी इंस्टॉल करने की आवश्यकता नहीं है, यह किसी अन्य वेबसाइट खोलने जैसा है। एडिटर के साथ शुरुआत करने के लिए, निम्न लिंक खोलें: https://vscodedev। यदि आप GitHub में साइन इन नहीं हैं, तो साइन इन करने या नया खाता बनाने के लिए दिए गए निर्देशों का पालन करें और फिर साइन इन करें।\nलोड होने के बाद, यह इस छवि के समान दिखना चाहिए:\nयहां तीन मुख्य खंड हैं, बाईं ओर से दाईं ओर बढ़ते हुए:\nएक्टिविटी बार, जिसमें कुछ आइकन शामिल हैं, जैसे मैग्निफाइंग ग्लास 🔎, गियर ⚙️, और कुछ अन्य।\nविस्तारित एक्टिविटी बार, जो डिफ़ॉल्ट रूप से एक्सप्लोरर पर सेट होता है, जिसे साइड बार कहा जाता है।\nऔर अंत में, कोड क्षेत्र दाईं ओर।\nप्रत्येक आइकन पर क्लिक करें ताकि एक अलग मेनू प्रदर्शित हो। जब हो जाए, तो एक्सप्लोरर पर क्लिक करें ताकि आप वहीं वापस आ जाएं जहां आपने शुरुआत की थी।\nजब आप कोड बनाना शुरू करते हैं या मौजूदा कोड में बदलाव करते हैं, तो यह सबसे बड़े क्षेत्र में दाईं ओर होगा। आप इस क्षेत्र का उपयोग मौजूदा कोड को देखने के लिए भी करेंगे, जो आप अगले चरण में करेंगे।\nएक GitHub रिपॉजिटरी खोलें\nपहली चीज़ जो आपको चाहिए, वह है एक GitHub रिपॉजिटरी खोलना। रिपॉजिटरी खोलने के कई तरीके हैं। इस खंड में आप दो अलग-अलग तरीके देखेंगे जिनसे आप रिपॉजिटरी खोल सकते हैं और बदलावों पर काम शुरू कर सकते हैं।\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1388,
    "chunk_index": 4,
    "total_chunks": 23
  },
  {
    "id": "a6ccdfa315aa0d8fba5e6910fafa2c71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "में बदलाव करते हैं, तो यह सबसे बड़े क्षेत्र में दाईं ओर होगा। आप इस क्षेत्र का उपयोग मौजूदा कोड को देखने के लिए भी करेंगे, जो आप अगले चरण में करेंगे। एक GitHub रिपॉजिटरी खोलें पहली चीज़ जो आपको चाहिए, वह है एक GitHub रिपॉजिटरी खोलना। रिपॉजिटरी खोलने के कई तरीके हैं। इस खंड में आप दो अलग-अलग तरीके देखेंगे जिनसे आप रिपॉजिटरी खोल सकते हैं और बदलावों पर काम शुरू कर सकते हैं। 1एडिटर के साथ\nएडिटर का उपयोग करके एक रिमोट रिपॉजिटरी खोलें। यदि आप VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 5,
    "total_chunks": 23
  },
  {
    "id": "8e97ab6794a97baae7630a8c0b08d563",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "आप इस क्षेत्र का उपयोग मौजूदा कोड को देखने के लिए भी करेंगे, जो आप अगले चरण में करेंगे। एक GitHub रिपॉजिटरी खोलें पहली चीज़ जो आपको चाहिए, वह है एक GitHub रिपॉजिटरी खोलना। रिपॉजिटरी खोलने के कई तरीके हैं। इस खंड में आप दो अलग-अलग तरीके देखेंगे जिनसे आप रिपॉजिटरी खोल सकते हैं और बदलावों पर काम शुरू कर सकते हैं। 1एडिटर के साथ एडिटर का उपयोग करके एक रिमोट रिपॉजिटरी खोलें। यदि आप VSCodedev पर जाते हैं, तो आपको एक \"Open Remote Repository\" बटन दिखाई देगा:\nआप कमांड पैलेट का भी उपयोग कर सकते हैं। कमांड पैलेट एक इनपुट बॉक्स है जहां आप किसी भी कमांड या एक्शन का नाम टाइप कर सकते हैं ताकि सही कमांड को निष्पादित किया जा सके। ऊपर-बाईं ओर मेनू का उपयोग करें, फिर View चुनें, और फिर Command Palette चुनें, या निम्न कीबोर्ड शॉर्टकट का उपयोग करें: Ctrl-Shift-P (MacOS पर यह Command-Shift-P होगा)।\nमेनू खुलने के बाद, open remote repository टाइप करें, और फिर पहला विकल्प चुनें। कई रिपॉजिटरी जो आपसे संबंधित हैं या जिन्हें आपने हाल ही में खोला है, दिखाई देंगी। आप एक पूर्ण GitHub URL का भी उपयोग कर सकते हैं। निम्न URL का उपयोग करें और इसे बॉक्स में पेस्ट करें:\nhttps://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 956,
    "chunk_index": 6,
    "total_chunks": 23
  },
  {
    "id": "7b675933a85b9620444d60135382b59c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "उपयोग करें, फिर View चुनें, और फिर Command Palette चुनें, या निम्न कीबोर्ड शॉर्टकट का उपयोग करें: Ctrl-Shift-P (MacOS पर यह Command-Shift-P होगा)। मेनू खुलने के बाद, open remote repository टाइप करें, और फिर पहला विकल्प चुनें। कई रिपॉजिटरी जो आपसे संबंधित हैं या जिन्हें आपने हाल ही में खोला है, दिखाई देंगी। आप एक पूर्ण GitHub URL का भी उपयोग कर सकते हैं। निम्न URL का उपयोग करें और इसे बॉक्स में पेस्ट करें: https://githubcom/microsoft/Web-Dev-For-Beginners\n✅ यदि सफल रहा, तो आप इस रिपॉजिटरी की सभी फाइलों को टेक्स्ट एडिटर में लोड होते हुए देखेंगे।\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 7,
    "total_chunks": 23
  },
  {
    "id": "1e28ea30b3ae72f99649e2f845b6e1d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "यह Command-Shift-P होगा)। मेनू खुलने के बाद, open remote repository टाइप करें, और फिर पहला विकल्प चुनें। कई रिपॉजिटरी जो आपसे संबंधित हैं या जिन्हें आपने हाल ही में खोला है, दिखाई देंगी। आप एक पूर्ण GitHub URL का भी उपयोग कर सकते हैं। निम्न URL का उपयोग करें और इसे बॉक्स में पेस्ट करें: https://githubcom/microsoft/Web-Dev-For-Beginners ✅ यदि सफल रहा, तो आप इस रिपॉजिटरी की सभी फाइलों को टेक्स्ट एडिटर में लोड होते हुए देखेंगे। 2URL का उपयोग करके\nआप सीधे URL का उपयोग करके भी रिपॉजिटरी लोड कर सकते हैं। उदाहरण के लिए, वर्तमान रिपॉजिटरी का पूर्ण URL https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 8,
    "total_chunks": 23
  },
  {
    "id": "ea5725991c395c58da2ccc57581923fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "जिन्हें आपने हाल ही में खोला है, दिखाई देंगी। आप एक पूर्ण GitHub URL का भी उपयोग कर सकते हैं। निम्न URL का उपयोग करें और इसे बॉक्स में पेस्ट करें: https://githubcom/microsoft/Web-Dev-For-Beginners ✅ यदि सफल रहा, तो आप इस रिपॉजिटरी की सभी फाइलों को टेक्स्ट एडिटर में लोड होते हुए देखेंगे। 2URL का उपयोग करके आप सीधे URL का उपयोग करके भी रिपॉजिटरी लोड कर सकते हैं। उदाहरण के लिए, वर्तमान रिपॉजिटरी का पूर्ण URL https://githubcom/microsoft/Web-Dev-For-Beginners है, लेकिन आप GitHub डोमेन को VSCode dev/github से बदल सकते हैं और रिपॉजिटरी को सीधे लोड कर सकते हैं। परिणामी URL होगा https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 468,
    "chunk_index": 9,
    "total_chunks": 23
  },
  {
    "id": "59db6bcb195ac830caee0507e7405fa2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "करें और इसे बॉक्स में पेस्ट करें: https://githubcom/microsoft/Web-Dev-For-Beginners ✅ यदि सफल रहा, तो आप इस रिपॉजिटरी की सभी फाइलों को टेक्स्ट एडिटर में लोड होते हुए देखेंगे। 2URL का उपयोग करके आप सीधे URL का उपयोग करके भी रिपॉजिटरी लोड कर सकते हैं। उदाहरण के लिए, वर्तमान रिपॉजिटरी का पूर्ण URL https://githubcom/microsoft/Web-Dev-For-Beginners है, लेकिन आप GitHub डोमेन को VSCode dev/github से बदल सकते हैं और रिपॉजिटरी को सीधे लोड कर सकते हैं। परिणामी URL होगा https://vscodedev/github/microsoft/Web-Dev-For-Beginners।\nफाइलें संपादित करें\nएक बार जब आपने ब्राउज़र/VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 431,
    "chunk_index": 10,
    "total_chunks": 23
  },
  {
    "id": "120ed2f2ef9b48abe05d1c480cfa67a0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "✅ यदि सफल रहा, तो आप इस रिपॉजिटरी की सभी फाइलों को टेक्स्ट एडिटर में लोड होते हुए देखेंगे। 2URL का उपयोग करके आप सीधे URL का उपयोग करके भी रिपॉजिटरी लोड कर सकते हैं। उदाहरण के लिए, वर्तमान रिपॉजिटरी का पूर्ण URL https://githubcom/microsoft/Web-Dev-For-Beginners है, लेकिन आप GitHub डोमेन को VSCode dev/github से बदल सकते हैं और रिपॉजिटरी को सीधे लोड कर सकते हैं। परिणामी URL होगा https://vscodedev/github/microsoft/Web-Dev-For-Beginners। फाइलें संपादित करें एक बार जब आपने ब्राउज़र/VSCodedev पर रिपॉजिटरी खोल ली, तो अगला कदम प्रोजेक्ट में अपडेट या बदलाव करना होगा।\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 11,
    "total_chunks": 23
  },
  {
    "id": "7c1c59c6794767b6e10d9b428cc1bdae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "लोड होते हुए देखेंगे। 2URL का उपयोग करके आप सीधे URL का उपयोग करके भी रिपॉजिटरी लोड कर सकते हैं। उदाहरण के लिए, वर्तमान रिपॉजिटरी का पूर्ण URL https://githubcom/microsoft/Web-Dev-For-Beginners है, लेकिन आप GitHub डोमेन को VSCode dev/github से बदल सकते हैं और रिपॉजिटरी को सीधे लोड कर सकते हैं। परिणामी URL होगा https://vscodedev/github/microsoft/Web-Dev-For-Beginners। फाइलें संपादित करें एक बार जब आपने ब्राउज़र/VSCodedev पर रिपॉजिटरी खोल ली, तो अगला कदम प्रोजेक्ट में अपडेट या बदलाव करना होगा। 1एक नई फाइल बनाएं\nआप या तो मौजूदा फोल्डर के अंदर एक फाइल बना सकते हैं, या इसे रूट डायरेक्टरी/फोल्डर में बना सकते हैं। एक नई फाइल बनाने के लिए, उस स्थान/डायरेक्टरी को खोलें जहां आप फाइल को सेव करना चाहते हैं और 'New file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 12,
    "total_chunks": 23
  },
  {
    "id": "5cbd59d62f565a7fb5e8f89f1722e945",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "सीधे लोड कर सकते हैं। परिणामी URL होगा https://vscodedev/github/microsoft/Web-Dev-For-Beginners। फाइलें संपादित करें एक बार जब आपने ब्राउज़र/VSCodedev पर रिपॉजिटरी खोल ली, तो अगला कदम प्रोजेक्ट में अपडेट या बदलाव करना होगा। 1एक नई फाइल बनाएं आप या तो मौजूदा फोल्डर के अंदर एक फाइल बना सकते हैं, या इसे रूट डायरेक्टरी/फोल्डर में बना सकते हैं। एक नई फाइल बनाने के लिए, उस स्थान/डायरेक्टरी को खोलें जहां आप फाइल को सेव करना चाहते हैं और 'New file' आइकन को एक्टिविटी बार (बाईं ओर) पर चुनें, इसे एक नाम दें और एंटर दबाएं।\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 469,
    "chunk_index": 13,
    "total_chunks": 23
  },
  {
    "id": "f4d1c1a800d2bf318240acb4f0c04f72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "ब्राउज़र/VSCodedev पर रिपॉजिटरी खोल ली, तो अगला कदम प्रोजेक्ट में अपडेट या बदलाव करना होगा। 1एक नई फाइल बनाएं आप या तो मौजूदा फोल्डर के अंदर एक फाइल बना सकते हैं, या इसे रूट डायरेक्टरी/फोल्डर में बना सकते हैं। एक नई फाइल बनाने के लिए, उस स्थान/डायरेक्टरी को खोलें जहां आप फाइल को सेव करना चाहते हैं और 'New file' आइकन को एक्टिविटी बार (बाईं ओर) पर चुनें, इसे एक नाम दें और एंटर दबाएं। 2रिपॉजिटरी पर फाइल संपादित करें और सेव करें\nजब भी आप अपने प्रोजेक्ट में त्वरित अपडेट करना चाहते हैं, तो vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 14,
    "total_chunks": 23
  },
  {
    "id": "46a83cad59c897b3482de5d9fed8974e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "या तो मौजूदा फोल्डर के अंदर एक फाइल बना सकते हैं, या इसे रूट डायरेक्टरी/फोल्डर में बना सकते हैं। एक नई फाइल बनाने के लिए, उस स्थान/डायरेक्टरी को खोलें जहां आप फाइल को सेव करना चाहते हैं और 'New file' आइकन को एक्टिविटी बार (बाईं ओर) पर चुनें, इसे एक नाम दें और एंटर दबाएं। 2रिपॉजिटरी पर फाइल संपादित करें और सेव करें जब भी आप अपने प्रोजेक्ट में त्वरित अपडेट करना चाहते हैं, तो vscodedev का उपयोग करना सहायक होता है, बिना किसी सॉफ़्टवेयर को स्थानीय रूप से लोड किए।\nअपने कोड को अपडेट करने के लिए, 'Explorer' आइकन पर क्लिक करें, जो एक्टिविटी बार पर स्थित है, ताकि रिपॉजिटरी में फाइलें और फोल्डर देख सकें।\nएक फाइल चुनें, इसे कोड क्षेत्र में खोलें, अपने बदलाव करें और सेव करें।\nजब आप अपने प्रोजेक्ट को अपडेट कर लें, तो source control आइकन चुनें, जिसमें आपके द्वारा रिपॉजिटरी में किए गए सभी नए बदलाव शामिल हैं।\nअपने प्रोजेक्ट में किए गए बदलावों को देखने के लिए, विस्तारित एक्टिविटी बार में Changes फोल्डर में फाइल(s) चुनें। यह एक 'Working Tree' खोलेगा, जिससे आप फाइल में किए गए बदलावों को विज़ुअली देख सकते हैं। लाल रंग प्रोजेक्ट में हटाने को दिखाता है, जबकि हरा रंग जोड़ने को दर्शाता है।\nयदि आप अपने किए गए बदलावों से संतुष्ट हैं, तो Changes फोल्डर पर होवर करें और बदलावों को स्टेज करने के लिए + बटन पर क्लिक करें। स्टेजिंग का मतलब है कि आप अपने बदलावों को GitHub पर कमिट करने के लिए तैयार कर रहे हैं।\nयदि आप कुछ बदलावों से असहज हैं और उन्हें हटाना चाहते हैं, तो Changes फोल्डर पर होवर करें और undo आइकन चुनें।\nफिर, एक commit message टाइप करें (आपके द्वारा प्रोजेक्ट में किए गए बदलावों का विवरण), और कमिट और पुश करने के लिए check icon पर क्लिक करें।\nजब आप अपने प्रोजेक्ट पर काम पूरा कर लें, तो ऊपर-बाईं ओर hamburger menu icon चुनें ताकि आप github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1501,
    "chunk_index": 15,
    "total_chunks": 23
  },
  {
    "id": "164cc6f0e93a2d0ce72b5555408904a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "कमिट करने के लिए तैयार कर रहे हैं। यदि आप कुछ बदलावों से असहज हैं और उन्हें हटाना चाहते हैं, तो Changes फोल्डर पर होवर करें और undo आइकन चुनें। फिर, एक commit message टाइप करें (आपके द्वारा प्रोजेक्ट में किए गए बदलावों का विवरण), और कमिट और पुश करने के लिए check icon पर क्लिक करें। जब आप अपने प्रोजेक्ट पर काम पूरा कर लें, तो ऊपर-बाईं ओर hamburger menu icon चुनें ताकि आप githubcom पर रिपॉजिटरी पर वापस जा सकें।\nएक्सटेंशन का उपयोग करना\nVSCode पर एक्सटेंशन इंस्टॉल करने से आप अपने एडिटर में नई सुविधाएं जोड़ सकते हैं और विकास कार्यप्रवाह को बेहतर बनाने के लिए कस्टमाइज़्ड विकल्प प्राप्त कर सकते हैं। ये एक्सटेंशन आपको कई प्रोग्रामिंग भाषाओं के लिए समर्थन जोड़ने में भी मदद करते हैं और अक्सर या तो सामान्य एक्सटेंशन होते हैं या भाषा-आधारित एक्सटेंशन।\nसभी उपलब्ध एक्सटेंशनों की सूची ब्राउज़ करने के लिए, एक्टिविटी बार पर Extensions icon पर क्लिक करें और 'Search Extensions in Marketplace' लेबल वाले टेक्स्ट फील्ड में एक्सटेंशन का नाम टाइप करना शुरू करें।\nआपको एक्सटेंशनों की एक सूची दिखाई देगी, जिसमें एक्सटेंशन का नाम, प्रकाशक का नाम, एक वाक्य का विवरण, डाउनलोड की संख्या और स्टार रेटिंग शामिल होगी।\nआप पहले से इंस्टॉल किए गए सभी एक्सटेंशनों को Installed folder में, अधिकांश डेवलपर्स द्वारा उपयोग किए जाने वाले लोकप्रिय एक्सटेंशनों को Popular folder में और आपके लिए अनुशंसित एक्सटेंशनों को recommended folder में देख सकते हैं।\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1179,
    "chunk_index": 16,
    "total_chunks": 23
  },
  {
    "id": "5620eb42888c50662f45821f5ab07f18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "लेबल वाले टेक्स्ट फील्ड में एक्सटेंशन का नाम टाइप करना शुरू करें। आपको एक्सटेंशनों की एक सूची दिखाई देगी, जिसमें एक्सटेंशन का नाम, प्रकाशक का नाम, एक वाक्य का विवरण, डाउनलोड की संख्या और स्टार रेटिंग शामिल होगी। आप पहले से इंस्टॉल किए गए सभी एक्सटेंशनों को Installed folder में, अधिकांश डेवलपर्स द्वारा उपयोग किए जाने वाले लोकप्रिय एक्सटेंशनों को Popular folder में और आपके लिए अनुशंसित एक्सटेंशनों को recommended folder में देख सकते हैं। 1एक्सटेंशन इंस्टॉल करें\nएक्सटेंशन इंस्टॉल करने के लिए, सर्च फील्ड में एक्सटेंशन का नाम टाइप करें और इसे चुनें। विस्तारित एक्टिविटी बार पर ब्लू इंस्टॉल बटन पर क्लिक करें या कोड क्षेत्र में दिखाई देने वाले इंस्टॉल बटन का उपयोग करें।\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 632,
    "chunk_index": 17,
    "total_chunks": 23
  },
  {
    "id": "cf4b17666374018b185cec3bc5075dc4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "इंस्टॉल किए गए सभी एक्सटेंशनों को Installed folder में, अधिकांश डेवलपर्स द्वारा उपयोग किए जाने वाले लोकप्रिय एक्सटेंशनों को Popular folder में और आपके लिए अनुशंसित एक्सटेंशनों को recommended folder में देख सकते हैं। 1एक्सटेंशन इंस्टॉल करें एक्सटेंशन इंस्टॉल करने के लिए, सर्च फील्ड में एक्सटेंशन का नाम टाइप करें और इसे चुनें। विस्तारित एक्टिविटी बार पर ब्लू इंस्टॉल बटन पर क्लिक करें या कोड क्षेत्र में दिखाई देने वाले इंस्टॉल बटन का उपयोग करें। 2एक्सटेंशन कस्टमाइज़ करें\nएक्सटेंशन इंस्टॉल करने के बाद, आपको इसकी कार्यक्षमता को संशोधित करने और अपनी प्राथमिकताओं के अनुसार इसे कस्टमाइज़ करने की आवश्यकता हो सकती है। ऐसा करने के लिए, एक्सटेंशन आइकन चुनें, और इस बार, आपका एक्सटेंशन Installed folder में दिखाई देगा। Gear icon पर क्लिक करें और Extensions Setting पर जाएं।\n3",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 692,
    "chunk_index": 18,
    "total_chunks": 23
  },
  {
    "id": "f065af29b1f686443e7787cbbf8dd0a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "एक्टिविटी बार पर ब्लू इंस्टॉल बटन पर क्लिक करें या कोड क्षेत्र में दिखाई देने वाले इंस्टॉल बटन का उपयोग करें। 2एक्सटेंशन कस्टमाइज़ करें एक्सटेंशन इंस्टॉल करने के बाद, आपको इसकी कार्यक्षमता को संशोधित करने और अपनी प्राथमिकताओं के अनुसार इसे कस्टमाइज़ करने की आवश्यकता हो सकती है। ऐसा करने के लिए, एक्सटेंशन आइकन चुनें, और इस बार, आपका एक्सटेंशन Installed folder में दिखाई देगा। Gear icon पर क्लिक करें और Extensions Setting पर जाएं। 3एक्सटेंशन प्रबंधित करें\nएक्सटेंशन इंस्टॉल और उपयोग करने के बाद, vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 19,
    "total_chunks": 23
  },
  {
    "id": "a482a839cdead047141671aa7000fc99",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "कोड क्षेत्र में दिखाई देने वाले इंस्टॉल बटन का उपयोग करें। 2एक्सटेंशन कस्टमाइज़ करें एक्सटेंशन इंस्टॉल करने के बाद, आपको इसकी कार्यक्षमता को संशोधित करने और अपनी प्राथमिकताओं के अनुसार इसे कस्टमाइज़ करने की आवश्यकता हो सकती है। ऐसा करने के लिए, एक्सटेंशन आइकन चुनें, और इस बार, आपका एक्सटेंशन Installed folder में दिखाई देगा। Gear icon पर क्लिक करें और Extensions Setting पर जाएं। 3एक्सटेंशन प्रबंधित करें एक्सटेंशन इंस्टॉल और उपयोग करने के बाद, vscodedev विभिन्न आवश्यकताओं के आधार पर आपके एक्सटेंशन को प्रबंधित करने के विकल्प प्रदान करता है। उदाहरण के लिए, आप चुन सकते हैं:\nडिसेबल करें: (जब आपको किसी एक्सटेंशन की आवश्यकता नहीं हो लेकिन आप इसे पूरी तरह से अनइंस्टॉल नहीं करना चाहते हैं, तो आप इसे अस्थायी रूप से डिसेबल कर सकते हैं)\nविस्तारित एक्टिविटी बार पर इंस्टॉल किए गए एक्सटेंशन का चयन करें > गियर आइकन पर क्लिक करें > 'Disable' या 'Disable (Workspace)' चुनें या कोड क्षेत्र में एक्सटेंशन खोलें और ब्लू Disable बटन पर क्लिक करें।\nअनइंस्टॉल करें: विस्तारित एक्टिविटी बार पर इंस्टॉल किए गए एक्सटेंशन का चयन करें > गियर आइकन पर क्लिक करें > 'Uninstall' चुनें या कोड क्षेत्र में एक्सटेंशन खोलें और ब्लू Uninstall बटन पर क्लिक करें।\nअसाइनमेंट\nVSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1053,
    "chunk_index": 20,
    "total_chunks": 23
  },
  {
    "id": "864836677e8859122b954d9e0c6fbb35",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "कर सकते हैं) विस्तारित एक्टिविटी बार पर इंस्टॉल किए गए एक्सटेंशन का चयन करें > गियर आइकन पर क्लिक करें > 'Disable' या 'Disable (Workspace)' चुनें या कोड क्षेत्र में एक्सटेंशन खोलें और ब्लू Disable बटन पर क्लिक करें। अनइंस्टॉल करें: विस्तारित एक्टिविटी बार पर इंस्टॉल किए गए एक्सटेंशन का चयन करें > गियर आइकन पर क्लिक करें > 'Uninstall' चुनें या कोड क्षेत्र में एक्सटेंशन खोलें और ब्लू Uninstall बटन पर क्लिक करें। असाइनमेंट VSCodedev का उपयोग करके एक रिज़्यूमे वेबसाइट बनाएं\nसमीक्षा और स्व-अध्ययन\nVSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 445,
    "chunk_index": 21,
    "total_chunks": 23
  },
  {
    "id": "bd642f4c889bb5b224b9aa7acf44d684",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "कोड एडिटर का उपयोग करना",
    "content": "का चयन करें > गियर आइकन पर क्लिक करें > 'Disable' या 'Disable (Workspace)' चुनें या कोड क्षेत्र में एक्सटेंशन खोलें और ब्लू Disable बटन पर क्लिक करें। अनइंस्टॉल करें: विस्तारित एक्टिविटी बार पर इंस्टॉल किए गए एक्सटेंशन का चयन करें > गियर आइकन पर क्लिक करें > 'Uninstall' चुनें या कोड क्षेत्र में एक्सटेंशन खोलें और ब्लू Uninstall बटन पर क्लिक करें। असाइनमेंट VSCodedev का उपयोग करके एक रिज़्यूमे वेबसाइट बनाएं समीक्षा और स्व-अध्ययन VSCodedev और इसकी अन्य विशेषताओं के बारे में अधिक पढ़ें।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 844,
    "chunk_index": 22,
    "total_chunks": 23
  },
  {
    "id": "a1ef3136f70cbec466144f6b149d4893",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने कोड को पुनर्गठित करें और टिप्पणियां जोड़ें",
    "content": "अपने कोड को पुनर्गठित करें और टिप्पणियां जोड़ें\nनिर्देश\nजैसे-जैसे आपका कोडबेस बढ़ता है, इसे समय-समय पर पुनर्गठित करना महत्वपूर्ण है ताकि यह पढ़ने और बनाए रखने में आसान बना रहे। अपने app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4555,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 192,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "da82c668ac6e3458a0929129ffc73c8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने कोड को पुनर्गठित करें और टिप्पणियां जोड़ें",
    "content": "अपने कोड को पुनर्गठित करें और टिप्पणियां जोड़ें\nनिर्देश\nजैसे-जैसे आपका कोडबेस बढ़ता है, इसे समय-समय पर पुनर्गठित करना महत्वपूर्ण है ताकि यह पढ़ने और बनाए रखने में आसान बना रहे। अपने appjs कोड की गुणवत्ता सुधारने के लिए टिप्पणियां जोड़ें और इसे पुनर्गठित करें:\nस्थिरांक (जैसे सर्वर API बेस URL) को अलग करें\nसमान कोड को व्यवस्थित करें: उदाहरण के लिए, आप sendRequest() नामक एक फ़ंक्शन बना सकते हैं जो createAccount() और getAccount() दोनों में उपयोग किए गए कोड को समेकित करता है\nकोड को पुनर्गठित करें ताकि इसे पढ़ना आसान हो, और टिप्पणियां जोड़ें\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                                                                                                                     | पर्याप्त                                                                                          | सुधार की आवश्यकता                                                                     |\n| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\n|          | कोड में टिप्पणियां हैं, विभिन्न अनुभागों में अच्छी तरह से व्यवस्थित है और पढ़ने में आसान है। स्थिरांक अलग किए गए हैं और एक समेकित sendRequest() फ़ंक्शन बनाया गया है। | कोड साफ है लेकिन इसे और अधिक टिप्पणियों, स्थिरांक अलग करने या समेकन के साथ बेहतर बनाया जा सकता है। | कोड अव्यवस्थित है, टिप्पणियां नहीं हैं, स्थिरांक अलग नहीं किए गए हैं और कोड समेकित नहीं है। |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4555,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1378,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "2c8e70e9e5020b42233973637a8e29c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "बैंकिंग ऐप बनाएं भाग 1: HTML टेम्पलेट्स और वेब ऐप में रूट्स\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nब्राउज़रों में जावास्क्रिप्ट के आगमन के बाद से, वेबसाइटें पहले से कहीं अधिक इंटरैक्टिव और जटिल हो गई हैं। वेब तकनीकों का उपयोग अब पूरी तरह से कार्यात्मक एप्लिकेशन बनाने के लिए किया जाता है, जो सीधे ब्राउज़र में चलते हैं, जिन्हें हम वेब एप्लिकेशन कहते हैं। चूंकि वेब ऐप्स अत्यधिक इंटरैक्टिव होते हैं, उपयोगकर्ता हर बार किसी क्रिया को करने पर पूरे पेज को फिर से लोड करने की प्रतीक्षा नहीं करना चाहते। यही कारण है कि जावास्क्रिप्ट का उपयोग HTML को सीधे DOM के माध्यम से अपडेट करने के लिए किया जाता है, ताकि उपयोगकर्ता अनुभव को अधिक सहज बनाया जा सके।\nइस पाठ में, हम HTML टेम्पलेट्स का उपयोग करके बैंक वेब ऐप बनाने की नींव रखेंगे, ताकि कई स्क्रीन बनाई जा सकें जिन्हें पूरे HTML पेज को फिर से लोड किए बिना प्रदर्शित और अपडेट किया जा सके।\nपूर्वापेक्षा\nइस पाठ में हम जो वेब ऐप बनाएंगे उसे परीक्षण करने के लिए आपको एक स्थानीय वेब सर्वर की आवश्यकता होगी। यदि आपके पास एक नहीं है, तो आप Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 944,
    "chunk_index": 0,
    "total_chunks": 34
  },
  {
    "id": "af61eed8781e06186517c5ef2bce3d95",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "अनुभव को अधिक सहज बनाया जा सके। इस पाठ में, हम HTML टेम्पलेट्स का उपयोग करके बैंक वेब ऐप बनाने की नींव रखेंगे, ताकि कई स्क्रीन बनाई जा सकें जिन्हें पूरे HTML पेज को फिर से लोड किए बिना प्रदर्शित और अपडेट किया जा सके। पूर्वापेक्षा इस पाठ में हम जो वेब ऐप बनाएंगे उसे परीक्षण करने के लिए आपको एक स्थानीय वेब सर्वर की आवश्यकता होगी। यदि आपके पास एक नहीं है, तो आप Nodejs इंस्टॉल कर सकते हैं और अपने प्रोजेक्ट फ़ोल्डर से npx lite-server कमांड का उपयोग कर सकते हैं। यह एक स्थानीय वेब सर्वर बनाएगा और आपके ऐप को ब्राउज़र में खोलेगा।\nतैयारी\nअपने कंप्यूटर पर bank नामक एक फ़ोल्डर बनाएं और उसमें index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 553,
    "chunk_index": 1,
    "total_chunks": 34
  },
  {
    "id": "23a6d3ae54e6f38f7a3bf96a809b9643",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "किया जा सके। पूर्वापेक्षा इस पाठ में हम जो वेब ऐप बनाएंगे उसे परीक्षण करने के लिए आपको एक स्थानीय वेब सर्वर की आवश्यकता होगी। यदि आपके पास एक नहीं है, तो आप Nodejs इंस्टॉल कर सकते हैं और अपने प्रोजेक्ट फ़ोल्डर से npx lite-server कमांड का उपयोग कर सकते हैं। यह एक स्थानीय वेब सर्वर बनाएगा और आपके ऐप को ब्राउज़र में खोलेगा। तैयारी अपने कंप्यूटर पर bank नामक एक फ़ोल्डर बनाएं और उसमें indexhtml नामक एक फ़ाइल रखें। हम इस HTML बॉयलरप्लेट से शुरुआत करेंगे:\n```html\nBank App\n```\nHTML टेम्पलेट्स\nयदि आप वेब पेज के लिए कई स्क्रीन बनाना चाहते हैं, तो एक समाधान यह होगा कि आप प्रत्येक स्क्रीन के लिए एक HTML फ़ाइल बनाएं जिसे आप प्रदर्शित करना चाहते हैं। हालांकि, इस समाधान में कुछ असुविधाएं हैं:\nस्क्रीन बदलते समय पूरे HTML को फिर से लोड करना पड़ता है, जो धीमा हो सकता है।\nविभिन्न स्क्रीन के बीच डेटा साझा करना कठिन होता है।\nएक अन्य दृष्टिकोण यह है कि केवल एक HTML फ़ाइल हो और <template> तत्व का उपयोग करके कई HTML टेम्पलेट्स परिभाषित किए जाएं। एक टेम्पलेट एक पुन: उपयोग योग्य HTML ब्लॉक है जिसे ब्राउज़र द्वारा प्रदर्शित नहीं किया जाता है और इसे रनटाइम पर जावास्क्रिप्ट का उपयोग करके इंस्टैंसिएट करना पड़ता है।\nकार्य\nहम एक बैंक ऐप बनाएंगे जिसमें दो स्क्रीन होंगी: लॉगिन पेज और डैशबोर्ड। सबसे पहले, HTML बॉडी में एक प्लेसहोल्डर तत्व जोड़ें जिसे हम अपने ऐप की विभिन्न स्क्रीन इंस्टैंसिएट करने के लिए उपयोग करेंगे:\n```html\nLoading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1222,
    "chunk_index": 2,
    "total_chunks": 34
  },
  {
    "id": "76e3115158efbd76e6aa1a78081e7c61",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "का उपयोग करके कई HTML टेम्पलेट्स परिभाषित किए जाएं। एक टेम्पलेट एक पुन: उपयोग योग्य HTML ब्लॉक है जिसे ब्राउज़र द्वारा प्रदर्शित नहीं किया जाता है और इसे रनटाइम पर जावास्क्रिप्ट का उपयोग करके इंस्टैंसिएट करना पड़ता है। कार्य हम एक बैंक ऐप बनाएंगे जिसमें दो स्क्रीन होंगी: लॉगिन पेज और डैशबोर्ड। सबसे पहले, HTML बॉडी में एक प्लेसहोल्डर तत्व जोड़ें जिसे हम अपने ऐप की विभिन्न स्क्रीन इंस्टैंसिएट करने के लिए उपयोग करेंगे: ```html Loading```\nहम इसे जावास्क्रिप्ट के साथ बाद में ढूंढने में आसानी के लिए एक id दे रहे हैं।\nटिप: चूंकि इस तत्व की सामग्री बदली जाएगी, हम इसमें एक लोडिंग संदेश या संकेतक डाल सकते हैं जो ऐप लोड होने के दौरान दिखाया जाएगा।\nअब, लॉगिन पेज के लिए HTML टेम्पलेट को नीचे जोड़ें। फिलहाल हम इसमें केवल एक शीर्षक और एक सेक्शन डालेंगे जिसमें एक लिंक होगा जिसका उपयोग हम नेविगेशन करने के लिए करेंगे।\n```html\nLogin\n```\nफिर हम डैशबोर्ड पेज के लिए एक और HTML टेम्पलेट जोड़ेंगे। इस पेज में विभिन्न सेक्शन होंगे:\nएक हेडर जिसमें एक शीर्षक और लॉगआउट लिंक होगा\nबैंक खाते का वर्तमान बैलेंस\nलेन-देन की सूची, जो एक टेबल में प्रदर्शित होगी\n```html\nBalance: 100$\nTransactions\nDate\nObject\nAmount\n```\nटिप: जब HTML टेम्पलेट्स बना रहे हों, यदि आप देखना चाहते हैं कि यह कैसा दिखेगा, तो आप <template> और </template> लाइनों को <",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1126,
    "chunk_index": 3,
    "total_chunks": 34
  },
  {
    "id": "e1cdd616b0c3dea63386cae6425b5eb9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "करेंगे। ```html Login ``` फिर हम डैशबोर्ड पेज के लिए एक और HTML टेम्पलेट जोड़ेंगे। इस पेज में विभिन्न सेक्शन होंगे: एक हेडर जिसमें एक शीर्षक और लॉगआउट लिंक होगा बैंक खाते का वर्तमान बैलेंस लेन-देन की सूची, जो एक टेबल में प्रदर्शित होगी ```html Balance: 100$ Transactions Date Object Amount ``` टिप: जब HTML टेम्पलेट्स बना रहे हों, यदि आप देखना चाहते हैं कि यह कैसा दिखेगा, तो आप <template> और </template> लाइनों को <-- --> के साथ घेरकर टिप्पणी कर सकते हैं।\n✅ आपको क्या लगता है कि हम टेम्पलेट्स पर id एट्रिब्यूट का उपयोग क्यों करते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 444,
    "chunk_index": 4,
    "total_chunks": 34
  },
  {
    "id": "bffb0d2bd81953369dcf35f7d25ef2b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "एक शीर्षक और लॉगआउट लिंक होगा बैंक खाते का वर्तमान बैलेंस लेन-देन की सूची, जो एक टेबल में प्रदर्शित होगी ```html Balance: 100$ Transactions Date Object Amount ``` टिप: जब HTML टेम्पलेट्स बना रहे हों, यदि आप देखना चाहते हैं कि यह कैसा दिखेगा, तो आप <template> और </template> लाइनों को <-- --> के साथ घेरकर टिप्पणी कर सकते हैं। ✅ आपको क्या लगता है कि हम टेम्पलेट्स पर id एट्रिब्यूट का उपयोग क्यों करते हैंक्या हम इसके बजाय कुछ और जैसे क्लासेस का उपयोग कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 386,
    "chunk_index": 5,
    "total_chunks": 34
  },
  {
    "id": "97878dd6767e6f81c1417021533f05a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "की सूची, जो एक टेबल में प्रदर्शित होगी ```html Balance: 100$ Transactions Date Object Amount ``` टिप: जब HTML टेम्पलेट्स बना रहे हों, यदि आप देखना चाहते हैं कि यह कैसा दिखेगा, तो आप <template> और </template> लाइनों को <-- --> के साथ घेरकर टिप्पणी कर सकते हैं। ✅ आपको क्या लगता है कि हम टेम्पलेट्स पर id एट्रिब्यूट का उपयोग क्यों करते हैंक्या हम इसके बजाय कुछ और जैसे क्लासेस का उपयोग कर सकते हैंजावास्क्रिप्ट के साथ टेम्पलेट्स प्रदर्शित करना\nयदि आप अपने वर्तमान HTML फ़ाइल को ब्राउज़र में आज़माते हैं, तो आप देखेंगे कि यह Loading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 437,
    "chunk_index": 6,
    "total_chunks": 34
  },
  {
    "id": "c849efb1eed4388cbb4ea0e6b2c3b670",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "हों, यदि आप देखना चाहते हैं कि यह कैसा दिखेगा, तो आप <template> और </template> लाइनों को <-- --> के साथ घेरकर टिप्पणी कर सकते हैं। ✅ आपको क्या लगता है कि हम टेम्पलेट्स पर id एट्रिब्यूट का उपयोग क्यों करते हैंक्या हम इसके बजाय कुछ और जैसे क्लासेस का उपयोग कर सकते हैंजावास्क्रिप्ट के साथ टेम्पलेट्स प्रदर्शित करना यदि आप अपने वर्तमान HTML फ़ाइल को ब्राउज़र में आज़माते हैं, तो आप देखेंगे कि यह Loadingदिखाने पर अटक जाती है। ऐसा इसलिए है क्योंकि हमें HTML टेम्पलेट्स को इंस्टैंसिएट और प्रदर्शित करने के लिए कुछ जावास्क्रिप्ट कोड जोड़ने की आवश्यकता है।\nटेम्पलेट को इंस्टैंसिएट करना आमतौर पर 3 चरणों में किया जाता है:\nDOM में टेम्पलेट तत्व को प्राप्त करें, उदाहरण के लिए document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 615,
    "chunk_index": 7,
    "total_chunks": 34
  },
  {
    "id": "652fc99f1e48bb8624d8f36e7d7d3431",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "क्लासेस का उपयोग कर सकते हैंजावास्क्रिप्ट के साथ टेम्पलेट्स प्रदर्शित करना यदि आप अपने वर्तमान HTML फ़ाइल को ब्राउज़र में आज़माते हैं, तो आप देखेंगे कि यह Loadingदिखाने पर अटक जाती है। ऐसा इसलिए है क्योंकि हमें HTML टेम्पलेट्स को इंस्टैंसिएट और प्रदर्शित करने के लिए कुछ जावास्क्रिप्ट कोड जोड़ने की आवश्यकता है। टेम्पलेट को इंस्टैंसिएट करना आमतौर पर 3 चरणों में किया जाता है: DOM में टेम्पलेट तत्व को प्राप्त करें, उदाहरण के लिए documentgetElementById का उपयोग करके।\nटेम्पलेट तत्व को क्लोन करें, cloneNode का उपयोग करके।\nइसे DOM में एक दृश्यमान तत्व के तहत संलग्न करें, उदाहरण के लिए appendChild का उपयोग करके।\n✅ हमें टेम्पलेट को DOM में संलग्न करने से पहले क्लोन करने की आवश्यकता क्यों है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 617,
    "chunk_index": 8,
    "total_chunks": 34
  },
  {
    "id": "176a9e05f8fd318fe5e26a708d0117a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "लिए कुछ जावास्क्रिप्ट कोड जोड़ने की आवश्यकता है। टेम्पलेट को इंस्टैंसिएट करना आमतौर पर 3 चरणों में किया जाता है: DOM में टेम्पलेट तत्व को प्राप्त करें, उदाहरण के लिए documentgetElementById का उपयोग करके। टेम्पलेट तत्व को क्लोन करें, cloneNode का उपयोग करके। इसे DOM में एक दृश्यमान तत्व के तहत संलग्न करें, उदाहरण के लिए appendChild का उपयोग करके। ✅ हमें टेम्पलेट को DOM में संलग्न करने से पहले क्लोन करने की आवश्यकता क्यों हैयदि हम इस चरण को छोड़ दें तो क्या होगा कार्य\nअपने प्रोजेक्ट फ़ोल्डर में app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 9,
    "total_chunks": 34
  },
  {
    "id": "5cb6c4a8429787786aa901eef524b7a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "चरणों में किया जाता है: DOM में टेम्पलेट तत्व को प्राप्त करें, उदाहरण के लिए documentgetElementById का उपयोग करके। टेम्पलेट तत्व को क्लोन करें, cloneNode का उपयोग करके। इसे DOM में एक दृश्यमान तत्व के तहत संलग्न करें, उदाहरण के लिए appendChild का उपयोग करके। ✅ हमें टेम्पलेट को DOM में संलग्न करने से पहले क्लोन करने की आवश्यकता क्यों हैयदि हम इस चरण को छोड़ दें तो क्या होगा कार्य अपने प्रोजेक्ट फ़ोल्डर में appjs नामक एक नई फ़ाइल बनाएं और उस फ़ाइल को अपने HTML के <head> सेक्शन में इंपोर्ट करें:\n```html\n```\nअब app js में, हम एक नया फ़ंक्शन updateRoute बनाएंगे:\njs\nfunction updateRoute(templateId) {\nconst template = document getElementById(templateId);\nconst view = template content",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 10,
    "total_chunks": 34
  },
  {
    "id": "21dd2ca10756a534cf946135be2a6330",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "उपयोग करके। ✅ हमें टेम्पलेट को DOM में संलग्न करने से पहले क्लोन करने की आवश्यकता क्यों हैयदि हम इस चरण को छोड़ दें तो क्या होगा कार्य अपने प्रोजेक्ट फ़ोल्डर में appjs नामक एक नई फ़ाइल बनाएं और उस फ़ाइल को अपने HTML के <head> सेक्शन में इंपोर्ट करें: ```html ``` अब app js में, हम एक नया फ़ंक्शन updateRoute बनाएंगे: js function updateRoute(templateId) { const template = document getElementById(templateId); const view = template contentcloneNode(true);\nconst app = document getElementById('app');\napp innerHTML = '';\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 315,
    "chunk_index": 11,
    "total_chunks": 34
  },
  {
    "id": "f5fe9f01aa166de7ef21b93c8b246aaf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "से पहले क्लोन करने की आवश्यकता क्यों हैयदि हम इस चरण को छोड़ दें तो क्या होगा कार्य अपने प्रोजेक्ट फ़ोल्डर में appjs नामक एक नई फ़ाइल बनाएं और उस फ़ाइल को अपने HTML के <head> सेक्शन में इंपोर्ट करें: ```html ``` अब app js में, हम एक नया फ़ंक्शन updateRoute बनाएंगे: js function updateRoute(templateId) { const template = document getElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view);\n}\nयहां हम ठीक वही 3 चरण करते हैं जो ऊपर वर्णित हैं। हम templateId के साथ टेम्पलेट को इंस्टैंसिएट करते हैं और इसके क्लोन किए गए कंटेंट को हमारे ऐप प्लेसहोल्डर में डालते हैं। ध्यान दें कि हमें पूरे टेम्पलेट सबट्री को कॉपी करने के लिए cloneNode(true) का उपयोग करना होगा।\nअब इस फ़ंक्शन को किसी एक टेम्पलेट के साथ कॉल करें और परिणाम देखें।\njs\nupdateRoute('login');\n✅ इस कोड app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 591,
    "chunk_index": 12,
    "total_chunks": 34
  },
  {
    "id": "c6ef0aeb2771f49068f3d13f9f4d614e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "innerHTML = ''; appappendChild(view); } यहां हम ठीक वही 3 चरण करते हैं जो ऊपर वर्णित हैं। हम templateId के साथ टेम्पलेट को इंस्टैंसिएट करते हैं और इसके क्लोन किए गए कंटेंट को हमारे ऐप प्लेसहोल्डर में डालते हैं। ध्यान दें कि हमें पूरे टेम्पलेट सबट्री को कॉपी करने के लिए cloneNode(true) का उपयोग करना होगा। अब इस फ़ंक्शन को किसी एक टेम्पलेट के साथ कॉल करें और परिणाम देखें। js updateRoute('login'); ✅ इस कोड appinnerHTML = ''; का उद्देश्य क्या है इसके बिना क्या होता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 366,
    "chunk_index": 13,
    "total_chunks": 34
  },
  {
    "id": "eec1deccd8b5c7aaf76144395f5a615c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "करते हैं जो ऊपर वर्णित हैं। हम templateId के साथ टेम्पलेट को इंस्टैंसिएट करते हैं और इसके क्लोन किए गए कंटेंट को हमारे ऐप प्लेसहोल्डर में डालते हैं। ध्यान दें कि हमें पूरे टेम्पलेट सबट्री को कॉपी करने के लिए cloneNode(true) का उपयोग करना होगा। अब इस फ़ंक्शन को किसी एक टेम्पलेट के साथ कॉल करें और परिणाम देखें। js updateRoute('login'); ✅ इस कोड appinnerHTML = ''; का उद्देश्य क्या है इसके बिना क्या होता हैरूट्स बनाना\nजब वेब ऐप की बात होती है, तो हम Routing को URLs को विशिष्ट स्क्रीन से मैप करने का इरादा कहते हैं जो प्रदर्शित की जानी चाहिए। कई HTML फ़ाइलों वाली वेबसाइट पर, यह स्वचालित रूप से किया जाता है क्योंकि फ़ाइल पथ URL पर प्रतिबिंबित होते हैं। उदाहरण के लिए, आपके प्रोजेक्ट फ़ोल्डर में इन फ़ाइलों के साथ:\nmywebsite/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 14,
    "total_chunks": 34
  },
  {
    "id": "7b84d58732809101de804ff85ed0b6d0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "✅ इस कोड appinnerHTML = ''; का उद्देश्य क्या है इसके बिना क्या होता हैरूट्स बनाना जब वेब ऐप की बात होती है, तो हम Routing को URLs को विशिष्ट स्क्रीन से मैप करने का इरादा कहते हैं जो प्रदर्शित की जानी चाहिए। कई HTML फ़ाइलों वाली वेबसाइट पर, यह स्वचालित रूप से किया जाता है क्योंकि फ़ाइल पथ URL पर प्रतिबिंबित होते हैं। उदाहरण के लिए, आपके प्रोजेक्ट फ़ोल्डर में इन फ़ाइलों के साथ: mywebsite/indexhtml\nmywebsite/login html\nmywebsite/admin/index html\nयदि आप mywebsite को रूट के रूप में वेब सर्वर बनाते हैं, तो URL मैपिंग होगी:\nhttps://site com            --> mywebsite/index html\nhttps://site com/login html --> mywebsite/login html\nhttps://site com/admin/     --> mywebsite/admin/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 15,
    "total_chunks": 34
  },
  {
    "id": "d229c3eafa2bc33ac75bdf77fd912efc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "इरादा कहते हैं जो प्रदर्शित की जानी चाहिए। कई HTML फ़ाइलों वाली वेबसाइट पर, यह स्वचालित रूप से किया जाता है क्योंकि फ़ाइल पथ URL पर प्रतिबिंबित होते हैं। उदाहरण के लिए, आपके प्रोजेक्ट फ़ोल्डर में इन फ़ाइलों के साथ: mywebsite/indexhtml mywebsite/login html mywebsite/admin/index html यदि आप mywebsite को रूट के रूप में वेब सर्वर बनाते हैं, तो URL मैपिंग होगी: https://site com --> mywebsite/index html https://site com/login html --> mywebsite/login html https://site com/admin/ --> mywebsite/admin/indexhtml\nहालांकि, हमारे वेब ऐप के लिए हम एक ही HTML फ़ाइल का उपयोग कर रहे हैं जिसमें सभी स्क्रीन हैं, इसलिए यह डिफ़ॉल्ट व्यवहार हमारी मदद नहीं करेगा। हमें इस मैप को मैन्युअल रूप से बनाना होगा और जावास्क्रिप्ट का उपयोग करके प्रदर्शित टेम्पलेट को अपडेट करना होगा।\nकार्य\nहम एक साधारण ऑब्जेक्ट का उपयोग करेंगे मैप को लागू करने के लिए, जो URL पथ और हमारे टेम्पलेट्स के बीच संबंध बनाएगा। इस ऑब्जेक्ट को अपने app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 702,
    "chunk_index": 16,
    "total_chunks": 34
  },
  {
    "id": "7d9f44ccc9494a0c68ede055f0e96970",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "हमारे वेब ऐप के लिए हम एक ही HTML फ़ाइल का उपयोग कर रहे हैं जिसमें सभी स्क्रीन हैं, इसलिए यह डिफ़ॉल्ट व्यवहार हमारी मदद नहीं करेगा। हमें इस मैप को मैन्युअल रूप से बनाना होगा और जावास्क्रिप्ट का उपयोग करके प्रदर्शित टेम्पलेट को अपडेट करना होगा। कार्य हम एक साधारण ऑब्जेक्ट का उपयोग करेंगे मैप को लागू करने के लिए, जो URL पथ और हमारे टेम्पलेट्स के बीच संबंध बनाएगा। इस ऑब्जेक्ट को अपने appjs फ़ाइल के शीर्ष पर जोड़ें।\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard' },\n};\nअब updateRoute फ़ंक्शन को थोड़ा संशोधित करें। सीधे templateId को तर्क के रूप में पास करने के बजाय, हम पहले वर्तमान URL को देखकर इसे प्राप्त करना चाहते हैं, और फिर हमारे मैप का उपयोग करके संबंधित टेम्पलेट ID मान प्राप्त करना चाहते हैं। हम window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 639,
    "chunk_index": 17,
    "total_chunks": 34
  },
  {
    "id": "e732f30a2adba4cb7dcb81db4cd3a949",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "के बीच संबंध बनाएगा। इस ऑब्जेक्ट को अपने appjs फ़ाइल के शीर्ष पर जोड़ें। js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; अब updateRoute फ़ंक्शन को थोड़ा संशोधित करें। सीधे templateId को तर्क के रूप में पास करने के बजाय, हम पहले वर्तमान URL को देखकर इसे प्राप्त करना चाहते हैं, और फिर हमारे मैप का उपयोग करके संबंधित टेम्पलेट ID मान प्राप्त करना चाहते हैं। हम windowlocation pathname का उपयोग करके URL से केवल पथ सेक्शन प्राप्त कर सकते हैं।\n```js\nfunction updateRoute() {\nconst path = window location pathname;\nconst route = routes[path];\nconst template = document getElementById(route templateId);\nconst view = template content cloneNode(true);\nconst app = document getElementById('app');\napp innerHTML = '';\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 414,
    "chunk_index": 18,
    "total_chunks": 34
  },
  {
    "id": "d1fecf7112ce868235c953b0083254b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "पहले वर्तमान URL को देखकर इसे प्राप्त करना चाहते हैं, और फिर हमारे मैप का उपयोग करके संबंधित टेम्पलेट ID मान प्राप्त करना चाहते हैं। हम windowlocation pathname का उपयोग करके URL से केवल पथ सेक्शन प्राप्त कर सकते हैं। ```js function updateRoute() { const path = window location pathname; const route = routes[path]; const template = document getElementById(route templateId); const view = template content cloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view);\n}\n```\nयहां हमने घोषित रूट्स को संबंधित टेम्पलेट से मैप किया। आप इसे मैन्युअल रूप से अपने ब्राउज़र में URL बदलकर आज़मा सकते हैं।\n✅ यदि आप URL में एक अज्ञात पथ दर्ज करते हैं तो क्या होता है हम इसे कैसे हल कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 436,
    "chunk_index": 19,
    "total_chunks": 34
  },
  {
    "id": "9c308401119fe93727196bfb76c4667f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "window location pathname; const route = routes[path]; const template = document getElementById(route templateId); const view = template content cloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } ``` यहां हमने घोषित रूट्स को संबंधित टेम्पलेट से मैप किया। आप इसे मैन्युअल रूप से अपने ब्राउज़र में URL बदलकर आज़मा सकते हैं। ✅ यदि आप URL में एक अज्ञात पथ दर्ज करते हैं तो क्या होता है हम इसे कैसे हल कर सकते हैंनेविगेशन जोड़ना\nहमारे ऐप का अगला चरण पेजों के बीच नेविगेट करने की संभावना जोड़ना है, बिना URL को मैन्युअल रूप से बदलने की आवश्यकता। इसमें दो चीजें शामिल हैं:\nवर्तमान URL को अपडेट करना\nनए URL के आधार पर प्रदर्शित टेम्पलेट को अपडेट करना\nहमने पहले ही updateRoute फ़ंक्शन के साथ दूसरे भाग का ध्यान रखा है, इसलिए हमें वर्तमान URL को अपडेट करने का तरीका पता लगाना होगा।\nहमें जावास्क्रिप्ट का उपयोग करना होगा और विशेष रूप से history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 645,
    "chunk_index": 20,
    "total_chunks": 34
  },
  {
    "id": "7ec1c2f835b14b82ef323c19cd38908c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "अगला चरण पेजों के बीच नेविगेट करने की संभावना जोड़ना है, बिना URL को मैन्युअल रूप से बदलने की आवश्यकता। इसमें दो चीजें शामिल हैं: वर्तमान URL को अपडेट करना नए URL के आधार पर प्रदर्शित टेम्पलेट को अपडेट करना हमने पहले ही updateRoute फ़ंक्शन के साथ दूसरे भाग का ध्यान रखा है, इसलिए हमें वर्तमान URL को अपडेट करने का तरीका पता लगाना होगा। हमें जावास्क्रिप्ट का उपयोग करना होगा और विशेष रूप से historypushState का उपयोग करना होगा, जो URL को अपडेट करने और ब्राउज़िंग इतिहास में एक नया एंट्री बनाने की अनुमति देता है, बिना HTML को फिर से लोड किए।\nनोट: जबकि HTML एंकर तत्व <a href> का उपयोग अपने आप विभिन्न URLs के लिए हाइपरलिंक बनाने के लिए किया जा सकता है, यह डिफ़ॉल्ट रूप से HTML को फिर से लोड कर देगा। जब कस्टम जावास्क्रिप्ट के साथ रूटिंग को संभालते हैं, तो इस व्यवहार को रोकना आवश्यक है, preventDefault() फ़ंक्शन का उपयोग करके क्लिक इवेंट पर।\nकार्य\nआइए एक नया फ़ंक्शन बनाएं जिसे हम अपने ऐप में नेविगेट करने के लिए उपयोग कर सकते हैं:\njs\nfunction navigate(path) {\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 862,
    "chunk_index": 21,
    "total_chunks": 34
  },
  {
    "id": "29cf9076478c60347ca5ccce5b56104b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "href> का उपयोग अपने आप विभिन्न URLs के लिए हाइपरलिंक बनाने के लिए किया जा सकता है, यह डिफ़ॉल्ट रूप से HTML को फिर से लोड कर देगा। जब कस्टम जावास्क्रिप्ट के साथ रूटिंग को संभालते हैं, तो इस व्यवहार को रोकना आवश्यक है, preventDefault() फ़ंक्शन का उपयोग करके क्लिक इवेंट पर। कार्य आइए एक नया फ़ंक्शन बनाएं जिसे हम अपने ऐप में नेविगेट करने के लिए उपयोग कर सकते हैं: js function navigate(path) { windowhistory pushState({}, path, path);\nupdateRoute();\n}\nयह विधि पहले दिए गए पथ के आधार पर वर्तमान URL को अपडेट करती है, फिर टेम्पलेट को अपडेट करती है। प्रॉपर्टी window location",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 455,
    "chunk_index": 22,
    "total_chunks": 34
  },
  {
    "id": "7c23e1231666c55139ae662959705d44",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "कस्टम जावास्क्रिप्ट के साथ रूटिंग को संभालते हैं, तो इस व्यवहार को रोकना आवश्यक है, preventDefault() फ़ंक्शन का उपयोग करके क्लिक इवेंट पर। कार्य आइए एक नया फ़ंक्शन बनाएं जिसे हम अपने ऐप में नेविगेट करने के लिए उपयोग कर सकते हैं: js function navigate(path) { windowhistory pushState({}, path, path); updateRoute(); } यह विधि पहले दिए गए पथ के आधार पर वर्तमान URL को अपडेट करती है, फिर टेम्पलेट को अपडेट करती है। प्रॉपर्टी window locationorigin URL रूट को लौटाती है, जिससे हमें दिए गए पथ से एक पूर्ण URL को पुनर्निर्मित करने की अनुमति मिलती है।\nअब जब हमारे पास यह फ़ंक्शन है, तो हम उस समस्या का ध्यान रख सकते हैं जो हमारे पास है यदि कोई पथ किसी परिभाषित रूट से मेल नहीं खाता। हम updateRoute फ़ंक्शन को संशोधित करेंगे और एक मौजूदा रूट पर वापस लौटने का विकल्प जोड़ेंगे यदि हम कोई मेल नहीं पा सकते।\n```js\nfunction updateRoute() {\nconst path = window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 23,
    "total_chunks": 34
  },
  {
    "id": "4082b00065c70160103e623eab4bfba9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "हमें दिए गए पथ से एक पूर्ण URL को पुनर्निर्मित करने की अनुमति मिलती है। अब जब हमारे पास यह फ़ंक्शन है, तो हम उस समस्या का ध्यान रख सकते हैं जो हमारे पास है यदि कोई पथ किसी परिभाषित रूट से मेल नहीं खाता। हम updateRoute फ़ंक्शन को संशोधित करेंगे और एक मौजूदा रूट पर वापस लौटने का विकल्प जोड़ेंगे यदि हम कोई मेल नहीं पा सकते। ```js function updateRoute() { const path = windowlocation pathname;\nconst route = routes[path];\nif ( route) {\nreturn navigate('/login');\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 338,
    "chunk_index": 24,
    "total_chunks": 34
  },
  {
    "id": "f387f2c36ab3a8bc59fe90f87f38ba3c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "अनुमति मिलती है। अब जब हमारे पास यह फ़ंक्शन है, तो हम उस समस्या का ध्यान रख सकते हैं जो हमारे पास है यदि कोई पथ किसी परिभाषित रूट से मेल नहीं खाता। हम updateRoute फ़ंक्शन को संशोधित करेंगे और एक मौजूदा रूट पर वापस लौटने का विकल्प जोड़ेंगे यदि हम कोई मेल नहीं पा सकते। ```js function updateRoute() { const path = windowlocation pathname; const route = routes[path]; if ( route) { return navigate('/login'); }```\nयदि कोई रूट नहीं पाया जा सकता है, तो अब हम login पेज पर रीडायरेक्ट करेंगे।\nअब एक फ़ंक्शन बनाएं जो लिंक पर क्लिक किए जाने पर URL प्राप्त करे और ब्राउज़र के डिफ़ॉल्ट लिंक व्यवहार को रोके:\njs\nfunction onLinkClick(event) {\nevent preventDefault();\nnavigate(event target",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 25,
    "total_chunks": 34
  },
  {
    "id": "4b3528f2dff89daac142e4c1cd14f27c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "का विकल्प जोड़ेंगे यदि हम कोई मेल नहीं पा सकते। ```js function updateRoute() { const path = windowlocation pathname; const route = routes[path]; if ( route) { return navigate('/login'); }``` यदि कोई रूट नहीं पाया जा सकता है, तो अब हम login पेज पर रीडायरेक्ट करेंगे। अब एक फ़ंक्शन बनाएं जो लिंक पर क्लिक किए जाने पर URL प्राप्त करे और ब्राउज़र के डिफ़ॉल्ट लिंक व्यवहार को रोके: js function onLinkClick(event) { event preventDefault(); navigate(event targethref);\n}\nआइए हमारे Login और Logout लिंक में HTML में बाइंडिंग जोड़कर नेविगेशन सिस्टम को पूरा करें।\nhtml\n<a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 369,
    "chunk_index": 26,
    "total_chunks": 34
  },
  {
    "id": "ca6bdba0c271cad4d8a86afa02bd9d19",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "= routes[path]; if ( route) { return navigate('/login'); }``` यदि कोई रूट नहीं पाया जा सकता है, तो अब हम login पेज पर रीडायरेक्ट करेंगे। अब एक फ़ंक्शन बनाएं जो लिंक पर क्लिक किए जाने पर URL प्राप्त करे और ब्राउज़र के डिफ़ॉल्ट लिंक व्यवहार को रोके: js function onLinkClick(event) { event preventDefault(); navigate(event targethref); } आइए हमारे Login और Logout लिंक में HTML में बाइंडिंग जोड़कर नेविगेशन सिस्टम को पूरा करें। html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a>\nऊपर event ऑब्जेक्ट क्लिक इवेंट को कैप्चर करता है और इसे हमारे onLinkClick फ़ंक्शन में पास करता है।\nonclick एट्रिब्यूट का उपयोग करके क्लिक इवेंट को जावास्क्रिप्ट कोड से बाइंड करें, यहां navigate() फ़ंक्शन को कॉल करें।\nइन लिंक पर क्लिक करके देखें, अब आपको अपने ऐप की विभिन्न स्क्रीन के बीच नेविगेट करने में सक्षम होना चाहिए।\n✅ history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 609,
    "chunk_index": 27,
    "total_chunks": 34
  },
  {
    "id": "1c7bb0154a99d779f9b3d475474587c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "में HTML में बाइंडिंग जोड़कर नेविगेशन सिस्टम को पूरा करें। html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> ऊपर event ऑब्जेक्ट क्लिक इवेंट को कैप्चर करता है और इसे हमारे onLinkClick फ़ंक्शन में पास करता है। onclick एट्रिब्यूट का उपयोग करके क्लिक इवेंट को जावास्क्रिप्ट कोड से बाइंड करें, यहां navigate() फ़ंक्शन को कॉल करें। इन लिंक पर क्लिक करके देखें, अब आपको अपने ऐप की विभिन्न स्क्रीन के बीच नेविगेट करने में सक्षम होना चाहिए। ✅ historypushState विधि HTML5 मानक का हिस्सा है और सभी आधुनिक ब्राउज़रों में लागू है। यदि आप पुराने ब्राउज़रों के लिए वेब ऐप बना रहे हैं, तो इस API के स्थान पर एक ट्रिक का उपयोग किया जा सकता है: पथ से पहले हैश (#) का उपयोग करके आप रूटिंग को लागू कर सकते हैं जो नियमित एंकर नेविगेशन के साथ काम करता है और पेज को फिर से लोड नहीं करता है, क्योंकि इसका उद्देश्य पेज के भीतर आंतरिक लिंक बनाना था।\nब्राउज़र के बैक और फॉरवर्ड बटन को संभालना\nhistory",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 28,
    "total_chunks": 34
  },
  {
    "id": "cf6bf754ac66ca4fbbb14b172263d7e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "आप पुराने ब्राउज़रों के लिए वेब ऐप बना रहे हैं, तो इस API के स्थान पर एक ट्रिक का उपयोग किया जा सकता है: पथ से पहले हैश (#) का उपयोग करके आप रूटिंग को लागू कर सकते हैं जो नियमित एंकर नेविगेशन के साथ काम करता है और पेज को फिर से लोड नहीं करता है, क्योंकि इसका उद्देश्य पेज के भीतर आंतरिक लिंक बनाना था। ब्राउज़र के बैक और फॉरवर्ड बटन को संभालना historypushState का उपयोग ब्राउज़र के नेविगेशन इतिहास में नए एंट्री बनाता है। आप इसे ब्राउज़र के बैक बटन को दबाकर देख सकते हैं, यह कुछ इस तरह दिखाना चाहिए:\nयदि आप बैक बटन पर कुछ बार क्लिक करते हैं, तो आप देखेंगे कि वर्तमान URL बदलता है और इतिहास अपडेट होता है, लेकिन वही टेम्पलेट प्रदर्शित होता रहता है।\nऐसा इसलिए है क्योंकि एप्लिकेशन को यह नहीं पता कि हमें हर बार इतिहास बदलने पर updateRoute() कॉल करने की आवश्यकता है। यदि आप history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 728,
    "chunk_index": 29,
    "total_chunks": 34
  },
  {
    "id": "32ea1ebdbadb013454b7544bb6e17863",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "नए एंट्री बनाता है। आप इसे ब्राउज़र के बैक बटन को दबाकर देख सकते हैं, यह कुछ इस तरह दिखाना चाहिए: यदि आप बैक बटन पर कुछ बार क्लिक करते हैं, तो आप देखेंगे कि वर्तमान URL बदलता है और इतिहास अपडेट होता है, लेकिन वही टेम्पलेट प्रदर्शित होता रहता है। ऐसा इसलिए है क्योंकि एप्लिकेशन को यह नहीं पता कि हमें हर बार इतिहास बदलने पर updateRoute() कॉल करने की आवश्यकता है। यदि आप historypushState के दस्तावेज़ को देखते हैं, तो आप देख सकते हैं कि यदि स्टेट बदलता है - यानी हम एक अलग URL पर चले गए - तो popstate इवेंट ट्रिगर होता है। हम इस समस्या को ठीक करने के लिए इसका उपयोग करेंगे।\nकार्य\nयह सुनिश्चित करने के लिए कि ब्राउज़र इतिहास बदलने पर प्रदर्शित टेम्पलेट अपडेट हो, हम एक नया फ़ंक्शन संलग्न करेंगे जो updateRoute() को कॉल करता है। हम इसे अपने app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 678,
    "chunk_index": 30,
    "total_chunks": 34
  },
  {
    "id": "35b0c85ee268ed90c5070c9c75a3cfcb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "यदि आप historypushState के दस्तावेज़ को देखते हैं, तो आप देख सकते हैं कि यदि स्टेट बदलता है - यानी हम एक अलग URL पर चले गए - तो popstate इवेंट ट्रिगर होता है। हम इस समस्या को ठीक करने के लिए इसका उपयोग करेंगे। कार्य यह सुनिश्चित करने के लिए कि ब्राउज़र इतिहास बदलने पर प्रदर्शित टेम्पलेट अपडेट हो, हम एक नया फ़ंक्शन संलग्न करेंगे जो updateRoute() को कॉल करता है। हम इसे अपने appjs फ़ाइल के नीचे करेंगे:\njs\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 359,
    "chunk_index": 31,
    "total_chunks": 34
  },
  {
    "id": "aa0d34ba29473ffe190557b5c103bbc4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "देखते हैं, तो आप देख सकते हैं कि यदि स्टेट बदलता है - यानी हम एक अलग URL पर चले गए - तो popstate इवेंट ट्रिगर होता है। हम इस समस्या को ठीक करने के लिए इसका उपयोग करेंगे। कार्य यह सुनिश्चित करने के लिए कि ब्राउज़र इतिहास बदलने पर प्रदर्शित टेम्पलेट अपडेट हो, हम एक नया फ़ंक्शन संलग्न करेंगे जो updateRoute() को कॉल करता है। हम इसे अपने appjs फ़ाइल के नीचे करेंगे: js windowonpopstate = () => updateRoute();\nupdateRoute();\nनोट: हमने यहां अपने popstate इवेंट हैंडलर को संक्षिप्तता के लिए एरो फ़ंक्शन का उपयोग करके घोषित किया, लेकिन एक नियमित फ़ंक्शन भी समान रूप से काम करेगा।\nयहां एरो फ़ंक्शन्स पर एक रिफ्रेशर वीडियो है:\n🎥 ऊपर दी गई छवि पर क्लिक करें एरो फ़ंक्शन्स के बारे में वीडियो देखने के लिए।\nअब ब्राउज़र के बैक और फॉरवर्ड बटन का उपयोग करने का प्रयास करें और जांचें कि इस बार प्रदर्शित रूट सही ढंग से अपडेट हो रहा है।\n🚀 चुनौती\nइस ऐप के क्रेडिट्स दिखाने के लिए एक तीसरे पेज के लिए एक नया टेम्पलेट और रूट जोड़ें।\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nरूटिंग वेब विकास के आश्चर्यजनक रूप से कठिन हिस्सों में से एक है, खासकर जब वेब पेज रिफ्रेश व्यवहार से सिंगल पेज एप्लिकेशन पेज रिफ्रेश में स्थानांतरित होता है। Azure Static Web App सेवा रूटिंग को कैसे संभालती है, इसके बारे में थोड़ा पढ़ें। क्या आप समझा सकते हैं कि उस दस्तावेज़ में वर्णित कुछ निर्णय क्यों आवश्यक हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1197,
    "chunk_index": 32,
    "total_chunks": 34
  },
  {
    "id": "4cc6c9ee8b1c3ee5382725e2c1ec4862",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "तीसरे पेज के लिए एक नया टेम्पलेट और रूट जोड़ें। पोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन रूटिंग वेब विकास के आश्चर्यजनक रूप से कठिन हिस्सों में से एक है, खासकर जब वेब पेज रिफ्रेश व्यवहार से सिंगल पेज एप्लिकेशन पेज रिफ्रेश में स्थानांतरित होता है। Azure Static Web App सेवा रूटिंग को कैसे संभालती है, इसके बारे में थोड़ा पढ़ें। क्या आप समझा सकते हैं कि उस दस्तावेज़ में वर्णित कुछ निर्णय क्यों आवश्यक हैंअसाइनमेंट\nरूटिंग में सुधार करें\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 30096,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 869,
    "chunk_index": 33,
    "total_chunks": 34
  },
  {
    "id": "830ae57e8c76fc1fbfec7cbd063f377d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\assignment.md",
    "source_type": "git_repo",
    "title": "\"लेन-देन जोड़ें\" संवाद लागू करें",
    "content": "\"लेन-देन जोड़ें\" संवाद लागू करें\nनिर्देश\nहमारे बैंक ऐप में अभी भी एक महत्वपूर्ण सुविधा की कमी है: नए लेन-देन दर्ज करने की संभावना। पिछले चार पाठों में आपने जो कुछ भी सीखा है, उसका उपयोग करते हुए \"लेन-देन जोड़ें\" संवाद को लागू करें:\nडैशबोर्ड पेज में \"लेन-देन जोड़ें\" बटन जोड़ें\nया तो एक नया पेज HTML टेम्पलेट के साथ बनाएं, या डैशबोर्ड पेज छोड़े बिना संवाद HTML को दिखाने/छिपाने के लिए JavaScript का उपयोग करें (इसके लिए आप hidden प्रॉपर्टी या CSS क्लास का उपयोग कर सकते हैं)\nसंवाद के लिए कीबोर्ड और स्क्रीन रीडर एक्सेसिबिलिटी को सुनिश्चित करें\nइनपुट डेटा प्राप्त करने के लिए एक HTML फॉर्म लागू करें\nफॉर्म डेटा से JSON डेटा बनाएं और इसे API को भेजें\nनए डेटा के साथ डैशबोर्ड पेज को अपडेट करें\nदेखें सर्वर API विनिर्देश यह जानने के लिए कि आपको कौन सी API कॉल करनी है और अपेक्षित JSON प्रारूप क्या है।\nयहां असाइनमेंट पूरा करने के बाद का एक उदाहरण परिणाम है:\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                                                          | पर्याप्त                                                                                                                | सुधार की आवश्यकता                              |\n| -------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- | --------------------------------------------|\n|          | लेन-देन जोड़ने को पाठों में देखे गए सभी सर्वोत्तम प्रथाओं का पालन करते हुए पूरी तरह से लागू किया गया है। | लेन-देन जोड़ने को लागू किया गया है, लेकिन पाठों में देखे गए सर्वोत्तम प्रथाओं का पालन नहीं किया गया है, या यह आंशिक रूप से काम कर रहा है। | लेन-देन जोड़ने की कार्यक्षमता बिल्कुल काम नहीं कर रही है। |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5443,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1603,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b2754bd7b950c87e55255cea13814079",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nलगभग सभी आधुनिक वेब ऐप्स में, आप एक खाता बना सकते हैं ताकि आपका अपना निजी स्थान हो। चूंकि कई उपयोगकर्ता एक ही समय में वेब ऐप का उपयोग कर सकते हैं, आपको प्रत्येक उपयोगकर्ता का व्यक्तिगत डेटा अलग से संग्रहीत करने और यह तय करने के लिए एक तंत्र की आवश्यकता होती है कि कौन सी जानकारी प्रदर्शित करनी है। हम उपयोगकर्ता पहचान को सुरक्षित रूप से प्रबंधित करने के तरीके को कवर नहीं करेंगे क्योंकि यह अपने आप में एक व्यापक विषय है, लेकिन हम यह सुनिश्चित करेंगे कि प्रत्येक उपयोगकर्ता हमारे ऐप पर एक (या अधिक) बैंक खाता बना सके।\nइस भाग में हम HTML फॉर्म का उपयोग करके हमारे वेब ऐप में लॉगिन और रजिस्ट्रेशन जोड़ेंगे। हम देखेंगे कि डेटा को प्रोग्रामेटिक रूप से सर्वर API पर कैसे भेजा जाए, और अंततः उपयोगकर्ता इनपुट के लिए बुनियादी सत्यापन नियम कैसे परिभाषित करें।\nपूर्वापेक्षा\nआपको इस पाठ के लिए वेब ऐप के HTML टेम्पलेट्स और रूटिंग को पूरा करना होगा। आपको Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 922,
    "chunk_index": 0,
    "total_chunks": 45
  },
  {
    "id": "e6ff75dc5c926448a747a0773156364b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "करेंगे कि प्रत्येक उपयोगकर्ता हमारे ऐप पर एक (या अधिक) बैंक खाता बना सके। इस भाग में हम HTML फॉर्म का उपयोग करके हमारे वेब ऐप में लॉगिन और रजिस्ट्रेशन जोड़ेंगे। हम देखेंगे कि डेटा को प्रोग्रामेटिक रूप से सर्वर API पर कैसे भेजा जाए, और अंततः उपयोगकर्ता इनपुट के लिए बुनियादी सत्यापन नियम कैसे परिभाषित करें। पूर्वापेक्षा आपको इस पाठ के लिए वेब ऐप के HTML टेम्पलेट्स और रूटिंग को पूरा करना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API चलाना होगा ताकि आप खाते बनाने के लिए डेटा भेज सकें।\nध्यान दें\nआपके पास एक ही समय में दो टर्मिनल चल रहे होंगे, जैसा कि नीचे सूचीबद्ध है:\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 552,
    "chunk_index": 1,
    "total_chunks": 45
  },
  {
    "id": "1e52742a90acbebb7904eff7acb95d5a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "प्रोग्रामेटिक रूप से सर्वर API पर कैसे भेजा जाए, और अंततः उपयोगकर्ता इनपुट के लिए बुनियादी सत्यापन नियम कैसे परिभाषित करें। पूर्वापेक्षा आपको इस पाठ के लिए वेब ऐप के HTML टेम्पलेट्स और रूटिंग को पूरा करना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API चलाना होगा ताकि आप खाते बनाने के लिए डेटा भेज सकें। ध्यान दें आपके पास एक ही समय में दो टर्मिनल चल रहे होंगे, जैसा कि नीचे सूचीबद्ध है: 1मुख्य बैंक ऐप के लिए जिसे हमने HTML टेम्पलेट्स और रूटिंग पाठ में बनाया था।\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 2,
    "total_chunks": 45
  },
  {
    "id": "3374349a64b78c6479dcb7c9eeb1b833",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "बुनियादी सत्यापन नियम कैसे परिभाषित करें। पूर्वापेक्षा आपको इस पाठ के लिए वेब ऐप के HTML टेम्पलेट्स और रूटिंग को पूरा करना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API चलाना होगा ताकि आप खाते बनाने के लिए डेटा भेज सकें। ध्यान दें आपके पास एक ही समय में दो टर्मिनल चल रहे होंगे, जैसा कि नीचे सूचीबद्ध है: 1मुख्य बैंक ऐप के लिए जिसे हमने HTML टेम्पलेट्स और रूटिंग पाठ में बनाया था। 2बैंक ऐप सर्वर API के लिए जिसे हमने ऊपर सेटअप किया।\nपाठ के बाकी हिस्सों का पालन करने के लिए आपको दोनों सर्वर चालू और चल रहे चाहिए। वे अलग-अलग पोर्ट (पोर्ट 3000 और पोर्ट 5000) पर सुन रहे हैं, इसलिए सब कुछ ठीक से काम करना चाहिए।\nआप यह कमांड टर्मिनल में चलाकर जांच सकते हैं कि सर्वर सही तरीके से चल रहा है या नहीं:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 3,
    "total_chunks": 45
  },
  {
    "id": "4ba8ccc5ce9694738bf6383c388674cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "2बैंक ऐप सर्वर API के लिए जिसे हमने ऊपर सेटअप किया। पाठ के बाकी हिस्सों का पालन करने के लिए आपको दोनों सर्वर चालू और चल रहे चाहिए। वे अलग-अलग पोर्ट (पोर्ट 3000 और पोर्ट 5000) पर सुन रहे हैं, इसलिए सब कुछ ठीक से काम करना चाहिए। आप यह कमांड टर्मिनल में चलाकर जांच सकते हैं कि सर्वर सही तरीके से चल रहा है या नहीं: ```sh curl http://localhost:5000/api -> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 306,
    "chunk_index": 4,
    "total_chunks": 45
  },
  {
    "id": "73b7640d8d13309d656264bf0df7f72f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "2बैंक ऐप सर्वर API के लिए जिसे हमने ऊपर सेटअप किया। पाठ के बाकी हिस्सों का पालन करने के लिए आपको दोनों सर्वर चालू और चल रहे चाहिए। वे अलग-अलग पोर्ट (पोर्ट 3000 और पोर्ट 5000) पर सुन रहे हैं, इसलिए सब कुछ ठीक से काम करना चाहिए। आप यह कमांड टर्मिनल में चलाकर जांच सकते हैं कि सर्वर सही तरीके से चल रहा है या नहीं: ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result\n```\nफॉर्म और नियंत्रण\n<form> तत्व HTML दस्तावेज़ के एक खंड को समाहित करता है जहां उपयोगकर्ता इंटरैक्टिव नियंत्रणों के साथ डेटा इनपुट और सबमिट कर सकता है। फॉर्म के भीतर उपयोग किए जा सकने वाले सभी प्रकार के उपयोगकर्ता इंटरफ़ेस (UI) नियंत्रण होते हैं, जिनमें सबसे आम <input> और <button> तत्व होते हैं।\n<input> के कई प्रकार होते हैं। उदाहरण के लिए, उपयोगकर्ता का उपयोगकर्ता नाम दर्ज करने के लिए आप इस प्रकार का उपयोग कर सकते हैं:\nhtml\n<input id=\"username\" name=\"username\" type=\"text\">\nname एट्रिब्यूट का उपयोग तब किया जाएगा जब फॉर्म डेटा भेजा जाएगा। id एट्रिब्यूट का उपयोग <label> को फॉर्म नियंत्रण से जोड़ने के लिए किया जाता है।\n<input> प्रकारों और अन्य फॉर्म नियंत्रणों की पूरी सूची पर एक नज़र डालें ताकि आप यह समझ सकें कि UI बनाने के लिए आप कौन-कौन से मूलभूत UI तत्वों का उपयोग कर सकते हैं।\n✅ ध्यान दें कि <input> एक खाली तत्व है, जिस पर आपको मिलान करने वाला समापन टैग नहीं जोड़ना चाहिए। आप हालांकि स्व-समापन <input/> नोटेशन का उपयोग कर सकते हैं, लेकिन यह आवश्यक नहीं है।\nफॉर्म के भीतर <button> तत्व थोड़ा विशेष है। यदि आप इसका type एट्रिब्यूट निर्दिष्ट नहीं करते हैं, तो इसे दबाने पर यह स्वचालित रूप से फॉर्म डेटा को सर्वर पर सबमिट कर देगा। यहां संभावित type मान दिए गए हैं:\nsubmit: फॉर्म के भीतर डिफ़ॉल्ट, बटन फॉर्म सबमिट क्रिया को ट्रिगर करता है।\nreset: बटन सभी फॉर्म नियंत्रणों को उनकी प्रारंभिक मानों पर रीसेट करता है।\nbutton: बटन दबाए जाने पर कोई डिफ़ॉल्ट व्यवहार असाइन नहीं करता। आप फिर इसे जावास्क्रिप्ट का उपयोग करके कस्टम क्रियाएं असाइन कर सकते हैं।\nकार्य\nआइए login टेम्पलेट में एक फॉर्म जोड़कर शुरू करें। हमें एक username फ़ील्ड और एक Login बटन की आवश्यकता होगी।\n```html\nLogin\nUsername\nLogin\n```\nयदि आप ध्यान से देखें, तो आप देख सकते हैं कि हमने यहां एक <label> तत्व भी जोड़ा है। <label> तत्वों का उपयोग UI नियंत्रणों, जैसे हमारे उपयोगकर्ता नाम फ़ील्ड, को नाम देने के लिए किया जाता है। लेबल आपके फॉर्म की पठनीयता के लिए महत्वपूर्ण हैं, लेकिन इसके अतिरिक्त लाभ भी हैं:\nएक लेबल को फॉर्म नियंत्रण से जोड़ने से सहायक तकनीकों (जैसे स्क्रीन रीडर) का उपयोग करने वाले उपयोगकर्ताओं को यह समझने में मदद मिलती है कि उनसे किस डेटा की अपेक्षा की जा रही है।\nआप लेबल पर क्लिक करके सीधे संबंधित इनपुट पर ध्यान केंद्रित कर सकते हैं, जिससे इसे टच-स्क्रीन आधारित उपकरणों पर पहुंचना आसान हो जाता है।\nवेब पर एक्सेसिबिलिटी एक बहुत ही महत्वपूर्ण विषय है जिसे अक्सर अनदेखा कर दिया जाता है। सामान्य HTML तत्वों के लिए धन्यवाद, यदि आप उनका सही तरीके से उपयोग करते हैं तो सुलभ सामग्री बनाना मुश्किल नहीं है। आप एक्सेसिबिलिटी के बारे में अधिक पढ़ सकते हैं ताकि सामान्य गलतियों से बचा जा सके और एक जिम्मेदार डेवलपर बन सकें।\nअब हम रजिस्ट्रेशन के लिए दूसरा फॉर्म जोड़ेंगे, ठीक पिछले फॉर्म के नीचे:\n```html\nRegister\nUsername\nCurrency\nDescription\nCurrent balance\nRegister\n```\nvalue एट्रिब्यूट का उपयोग करके हम किसी दिए गए इनपुट के लिए एक डिफ़ॉल्ट मान परिभाषित कर सकते हैं।\nध्यान दें कि balance के लिए इनपुट में number प्रकार है। क्या यह अन्य इनपुट से अलग दिखता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2908,
    "chunk_index": 5,
    "total_chunks": 45
  },
  {
    "id": "bc7be3de466c51b3cbe1548863957fbc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "पढ़ सकते हैं ताकि सामान्य गलतियों से बचा जा सके और एक जिम्मेदार डेवलपर बन सकें। अब हम रजिस्ट्रेशन के लिए दूसरा फॉर्म जोड़ेंगे, ठीक पिछले फॉर्म के नीचे: ```html Register Username Currency Description Current balance Register ``` value एट्रिब्यूट का उपयोग करके हम किसी दिए गए इनपुट के लिए एक डिफ़ॉल्ट मान परिभाषित कर सकते हैं। ध्यान दें कि balance के लिए इनपुट में number प्रकार है। क्या यह अन्य इनपुट से अलग दिखता हैइसे इंटरैक्ट करके देखें।\n✅ क्या आप केवल कीबोर्ड का उपयोग करके फॉर्म को नेविगेट और इंटरैक्ट कर सकते हैं आप ऐसा कैसे करेंगे",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 454,
    "chunk_index": 6,
    "total_chunks": 45
  },
  {
    "id": "9a5932d7d8e331d101b386c3ce2e6192",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "जोड़ेंगे, ठीक पिछले फॉर्म के नीचे: ```html Register Username Currency Description Current balance Register ``` value एट्रिब्यूट का उपयोग करके हम किसी दिए गए इनपुट के लिए एक डिफ़ॉल्ट मान परिभाषित कर सकते हैं। ध्यान दें कि balance के लिए इनपुट में number प्रकार है। क्या यह अन्य इनपुट से अलग दिखता हैइसे इंटरैक्ट करके देखें। ✅ क्या आप केवल कीबोर्ड का उपयोग करके फॉर्म को नेविगेट और इंटरैक्ट कर सकते हैं आप ऐसा कैसे करेंगेडेटा को सर्वर पर सबमिट करना\nअब जब हमारे पास एक कार्यात्मक UI है, तो अगला कदम डेटा को हमारे सर्वर पर भेजना है। आइए हमारे वर्तमान कोड का उपयोग करके एक त्वरित परीक्षण करें: क्या होता है यदि आप Login या Register बटन पर क्लिक करते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 542,
    "chunk_index": 7,
    "total_chunks": 45
  },
  {
    "id": "e54cfaf7d973e440827b6c42dbb82a6f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "अन्य इनपुट से अलग दिखता हैइसे इंटरैक्ट करके देखें। ✅ क्या आप केवल कीबोर्ड का उपयोग करके फॉर्म को नेविगेट और इंटरैक्ट कर सकते हैं आप ऐसा कैसे करेंगेडेटा को सर्वर पर सबमिट करना अब जब हमारे पास एक कार्यात्मक UI है, तो अगला कदम डेटा को हमारे सर्वर पर भेजना है। आइए हमारे वर्तमान कोड का उपयोग करके एक त्वरित परीक्षण करें: क्या होता है यदि आप Login या Register बटन पर क्लिक करते हैंक्या आपने अपने ब्राउज़र के URL सेक्शन में बदलाव देखा",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 402,
    "chunk_index": 8,
    "total_chunks": 45
  },
  {
    "id": "52ce70d1f14f78442e8550b17afb1ec6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "✅ क्या आप केवल कीबोर्ड का उपयोग करके फॉर्म को नेविगेट और इंटरैक्ट कर सकते हैं आप ऐसा कैसे करेंगेडेटा को सर्वर पर सबमिट करना अब जब हमारे पास एक कार्यात्मक UI है, तो अगला कदम डेटा को हमारे सर्वर पर भेजना है। आइए हमारे वर्तमान कोड का उपयोग करके एक त्वरित परीक्षण करें: क्या होता है यदि आप Login या Register बटन पर क्लिक करते हैंक्या आपने अपने ब्राउज़र के URL सेक्शन में बदलाव देखाडिफ़ॉल्ट रूप से <form> की क्रिया वर्तमान सर्वर URL पर GET विधि का उपयोग करके फॉर्म डेटा को सबमिट करना है, जो फॉर्म डेटा को सीधे URL में जोड़ देता है। हालांकि, इस विधि में कुछ कमियां हैं:\nभेजा गया डेटा आकार में बहुत सीमित है (लगभग 2000 अक्षर)\nडेटा URL में सीधे दिखाई देता है (पासवर्ड के लिए अच्छा नहीं है)\nयह फ़ाइल अपलोड के साथ काम नहीं करता\nइसीलिए आप इसे POST विधि का उपयोग करने के लिए बदल सकते हैं, जो फॉर्म डेटा को HTTP अनुरोध के बॉडी में सर्वर पर भेजता है, बिना उपरोक्त सीमाओं के।\nजबकि डेटा भेजने के लिए POST सबसे अधिक उपयोग की जाने वाली विधि है, कुछ विशिष्ट परिदृश्यों में GET विधि का उपयोग करना बेहतर होता है, जैसे कि एक सर्च फ़ील्ड को लागू करते समय।\nकार्य\nरजिस्ट्रेशन फॉर्म में action और method गुण जोड़ें:\n```html\n```\nअब अपने नाम के साथ एक नया खाता पंजीकृत करने का प्रयास करें। *Register* बटन पर क्लिक करने के बाद आपको कुछ इस तरह दिखाई देना चाहिए:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1133,
    "chunk_index": 9,
    "total_chunks": 45
  },
  {
    "id": "0a198f3f7b06bc95f5d2d2fae9d13937",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "उपरोक्त सीमाओं के। जबकि डेटा भेजने के लिए POST सबसे अधिक उपयोग की जाने वाली विधि है, कुछ विशिष्ट परिदृश्यों में GET विधि का उपयोग करना बेहतर होता है, जैसे कि एक सर्च फ़ील्ड को लागू करते समय। कार्य रजिस्ट्रेशन फॉर्म में action और method गुण जोड़ें: ```html ``` अब अपने नाम के साथ एक नया खाता पंजीकृत करने का प्रयास करें। *Register* बटन पर क्लिक करने के बाद आपको कुछ इस तरह दिखाई देना चाहिए:[ब्राउज़र विंडो जिसमें localhost:5000/api/accounts का पता दिख रहा है और उपयोगकर्ता डेटा के साथ JSON स्ट्रिंग]( / / / /7-bank-project/2-forms/images/form-post",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 448,
    "chunk_index": 10,
    "total_chunks": 45
  },
  {
    "id": "4abb723d0bfebcc75d2f4dbfa3fc0324",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "परिदृश्यों में GET विधि का उपयोग करना बेहतर होता है, जैसे कि एक सर्च फ़ील्ड को लागू करते समय। कार्य रजिस्ट्रेशन फॉर्म में action और method गुण जोड़ें: ```html ``` अब अपने नाम के साथ एक नया खाता पंजीकृत करने का प्रयास करें। *Register* बटन पर क्लिक करने के बाद आपको कुछ इस तरह दिखाई देना चाहिए:[ब्राउज़र विंडो जिसमें localhost:5000/api/accounts का पता दिख रहा है और उपयोगकर्ता डेटा के साथ JSON स्ट्रिंग]( / / / /7-bank-project/2-forms/images/form-postpng)\nयदि सब कुछ ठीक है, तो सर्वर आपके अनुरोध का उत्तर एक [JSON](https://www json org/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 418,
    "chunk_index": 11,
    "total_chunks": 45
  },
  {
    "id": "d387bdc68429d7a6d6115f9a106d3b38",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "को लागू करते समय। कार्य रजिस्ट्रेशन फॉर्म में action और method गुण जोड़ें: ```html ``` अब अपने नाम के साथ एक नया खाता पंजीकृत करने का प्रयास करें। *Register* बटन पर क्लिक करने के बाद आपको कुछ इस तरह दिखाई देना चाहिए:[ब्राउज़र विंडो जिसमें localhost:5000/api/accounts का पता दिख रहा है और उपयोगकर्ता डेटा के साथ JSON स्ट्रिंग]( / / / /7-bank-project/2-forms/images/form-postpng) यदि सब कुछ ठीक है, तो सर्वर आपके अनुरोध का उत्तर एक [JSON](https://www json org/json-enhtml) प्रतिक्रिया के साथ देगा जिसमें बनाए गए खाते का डेटा होगा।\n✅ एक ही नाम के साथ फिर से पंजीकरण करने का प्रयास करें। क्या होता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 463,
    "chunk_index": 12,
    "total_chunks": 45
  },
  {
    "id": "cd4ff73d49ecdf03d7dd201ee6e4c4f1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "करें। *Register* बटन पर क्लिक करने के बाद आपको कुछ इस तरह दिखाई देना चाहिए:[ब्राउज़र विंडो जिसमें localhost:5000/api/accounts का पता दिख रहा है और उपयोगकर्ता डेटा के साथ JSON स्ट्रिंग]( / / / /7-bank-project/2-forms/images/form-postpng) यदि सब कुछ ठीक है, तो सर्वर आपके अनुरोध का उत्तर एक [JSON](https://www json org/json-enhtml) प्रतिक्रिया के साथ देगा जिसमें बनाए गए खाते का डेटा होगा। ✅ एक ही नाम के साथ फिर से पंजीकरण करने का प्रयास करें। क्या होता है## पेज को रीलोड किए बिना डेटा सबमिट करना\nजैसा कि आपने देखा होगा, हमने जिस दृष्टिकोण का उपयोग किया उसमें एक छोटी सी समस्या है: फॉर्म सबमिट करते समय, हम अपने ऐप से बाहर निकल जाते हैं और ब्राउज़र सर्वर URL पर रीडायरेक्ट हो जाता है। हम अपने वेब ऐप के साथ सभी पेज रीलोड्स से बचने की कोशिश कर रहे हैं, क्योंकि हम एक [सिंगल-पेज एप्लिकेशन (SPA)](https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 665,
    "chunk_index": 13,
    "total_chunks": 45
  },
  {
    "id": "d2b72b839759017e25336757330b728a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "पंजीकरण करने का प्रयास करें। क्या होता है## पेज को रीलोड किए बिना डेटा सबमिट करना जैसा कि आपने देखा होगा, हमने जिस दृष्टिकोण का उपयोग किया उसमें एक छोटी सी समस्या है: फॉर्म सबमिट करते समय, हम अपने ऐप से बाहर निकल जाते हैं और ब्राउज़र सर्वर URL पर रीडायरेक्ट हो जाता है। हम अपने वेब ऐप के साथ सभी पेज रीलोड्स से बचने की कोशिश कर रहे हैं, क्योंकि हम एक [सिंगल-पेज एप्लिकेशन (SPA)](https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 362,
    "chunk_index": 14,
    "total_chunks": 45
  },
  {
    "id": "8d41236fe248639ddda3a47e7b94669c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "पंजीकरण करने का प्रयास करें। क्या होता है## पेज को रीलोड किए बिना डेटा सबमिट करना जैसा कि आपने देखा होगा, हमने जिस दृष्टिकोण का उपयोग किया उसमें एक छोटी सी समस्या है: फॉर्म सबमिट करते समय, हम अपने ऐप से बाहर निकल जाते हैं और ब्राउज़र सर्वर URL पर रीडायरेक्ट हो जाता है। हम अपने वेब ऐप के साथ सभी पेज रीलोड्स से बचने की कोशिश कर रहे हैं, क्योंकि हम एक [सिंगल-पेज एप्लिकेशन (SPA)](https://enwikipediaorg/wiki/Single-page_application) बना रहे हैं।\nफॉर्म डेटा को सर्वर पर भेजने के लिए बिना पेज रीलोड किए, हमें जावास्क्रिप्ट कोड का उपयोग करना होगा। `` तत्व के `action` गुण में URL डालने के बजाय, आप `javascript:` स्ट्रिंग के साथ किसी भी जावास्क्रिप्ट कोड को प्रीपेंड कर सकते हैं ताकि एक कस्टम क्रिया की जा सके। इसका उपयोग करने का मतलब यह भी है कि आपको कुछ कार्यों को लागू करना होगा जो पहले ब्राउज़र द्वारा स्वचालित रूप से किए जाते थे:\n- फॉर्म डेटा प्राप्त करें\n- फॉर्म डेटा को उपयुक्त प्रारूप में परिवर्तित और एन्कोड करें\n- HTTP अनुरोध बनाएं और इसे सर्वर पर भेजें\n### कार्य\nरजिस्ट्रेशन फॉर्म के `action` को बदलें:\n```html\n```\n`app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 891,
    "chunk_index": 15,
    "total_chunks": 45
  },
  {
    "id": "83da5fa9a02d00f81c2ba01a55757bf9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "जावास्क्रिप्ट कोड को प्रीपेंड कर सकते हैं ताकि एक कस्टम क्रिया की जा सके। इसका उपयोग करने का मतलब यह भी है कि आपको कुछ कार्यों को लागू करना होगा जो पहले ब्राउज़र द्वारा स्वचालित रूप से किए जाते थे: - फॉर्म डेटा प्राप्त करें - फॉर्म डेटा को उपयुक्त प्रारूप में परिवर्तित और एन्कोड करें - HTTP अनुरोध बनाएं और इसे सर्वर पर भेजें ### कार्य रजिस्ट्रेशन फॉर्म के `action` को बदलें: ```html ``` `appjs` खोलें और `register` नामक एक नई फ़ंक्शन जोड़ें:\n```js\nfunction register() {\nconst registerForm = document getElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst data = Object fromEntries(formData);\nconst jsonData = JSON stringify(data);\n}\n```\nयहां हम `getElementById()` का उपयोग करके फॉर्म तत्व प्राप्त करते हैं और [`FormData`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 16,
    "total_chunks": 45
  },
  {
    "id": "e540337e24a405b97a897db2afc5fffa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "को उपयुक्त प्रारूप में परिवर्तित और एन्कोड करें - HTTP अनुरोध बनाएं और इसे सर्वर पर भेजें ### कार्य रजिस्ट्रेशन फॉर्म के `action` को बदलें: ```html ``` `appjs` खोलें और `register` नामक एक नई फ़ंक्शन जोड़ें: ```js function register() { const registerForm = document getElementById('registerForm'); const formData = new FormData(registerForm); const data = Object fromEntries(formData); const jsonData = JSON stringify(data); } ``` यहां हम `getElementById()` का उपयोग करके फॉर्म तत्व प्राप्त करते हैं और [`FormData`](https://developer mozillaorg/docs/Web/API/FormData) हेल्पर का उपयोग करके फॉर्म नियंत्रणों से मानों को कुंजी/मान जोड़े के सेट के रूप में निकालते हैं। फिर हम डेटा को [`Object fromEntries()`](https://developer mozilla org/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) का उपयोग करके एक नियमित ऑब्जेक्ट में परिवर्तित करते हैं और अंत में डेटा को [JSON](https://www json org/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 17,
    "total_chunks": 45
  },
  {
    "id": "bf93fd7cf20fc0e109dd4308a9f2a9dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "getElementById('registerForm'); const formData = new FormData(registerForm); const data = Object fromEntries(formData); const jsonData = JSON stringify(data); } ``` यहां हम `getElementById()` का उपयोग करके फॉर्म तत्व प्राप्त करते हैं और [`FormData`](https://developer mozillaorg/docs/Web/API/FormData) हेल्पर का उपयोग करके फॉर्म नियंत्रणों से मानों को कुंजी/मान जोड़े के सेट के रूप में निकालते हैं। फिर हम डेटा को [`Object fromEntries()`](https://developer mozilla org/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) का उपयोग करके एक नियमित ऑब्जेक्ट में परिवर्तित करते हैं और अंत में डेटा को [JSON](https://www json org/json-enhtml) में सीरियलाइज़ करते हैं, जो वेब पर डेटा का आदान-प्रदान करने के लिए आमतौर पर उपयोग किया जाने वाला प्रारूप है।\nडेटा अब सर्वर पर भेजने के लिए तैयार है। `createAccount` नामक एक नई फ़ंक्शन बनाएं:\n```js\nasync function createAccount(account) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts', {\nmethod: 'POST',\nheaders: { 'Content-Type': 'application/json' },\nbody: account\n});\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 18,
    "total_chunks": 45
  },
  {
    "id": "84eee7b6d35618c370cc6d6e724dbd5b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "नियमित ऑब्जेक्ट में परिवर्तित करते हैं और अंत में डेटा को [JSON](https://www json org/json-enhtml) में सीरियलाइज़ करते हैं, जो वेब पर डेटा का आदान-प्रदान करने के लिए आमतौर पर उपयोग किया जाने वाला प्रारूप है। डेटा अब सर्वर पर भेजने के लिए तैयार है। `createAccount` नामक एक नई फ़ंक्शन बनाएं: ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson();\n} catch (error) {\nreturn { error: error message || 'Unknown error' };\n}\n}\n```\nयह फ़ंक्शन क्या कर रहा है सबसे पहले, यहां `async` कीवर्ड पर ध्यान दें। इसका मतलब है कि फ़ंक्शन में कोड है जो [**असिंक्रोनस रूप से**](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 443,
    "chunk_index": 19,
    "total_chunks": 45
  },
  {
    "id": "115db5b75be21f2f001c1e16650a76a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "है। `createAccount` नामक एक नई फ़ंक्शन बनाएं: ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` यह फ़ंक्शन क्या कर रहा है सबसे पहले, यहां `async` कीवर्ड पर ध्यान दें। इसका मतलब है कि फ़ंक्शन में कोड है जो [**असिंक्रोनस रूप से**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function) निष्पादित होगा। `await` कीवर्ड के साथ उपयोग किए जाने पर, यह असिंक्रोनस कोड के निष्पादन की प्रतीक्षा करने की अनुमति देता है - जैसे कि यहां सर्वर प्रतिक्रिया की प्रतीक्षा करना - इससे पहले कि आगे बढ़े।\n`fetch()` API का उपयोग करके हम JSON डेटा को सर्वर पर भेजते हैं। यह विधि 2 पैरामीटर लेती है:\n- सर्वर का URL, इसलिए हम यहां `//localhost:5000/api/accounts` डालते हैं।\n- अनुरोध की सेटिंग्स। यहीं पर हम विधि को `POST` पर सेट करते हैं और अनुरोध के लिए `body` प्रदान करते हैं। चूंकि हम सर्वर पर JSON डेटा भेज रहे हैं, हमें `Content-Type` हेडर को `application/json` पर सेट करने की भी आवश्यकता है ताकि सर्वर सामग्री को समझ सके।\nचूंकि सर्वर अनुरोध का उत्तर JSON के साथ देगा, हम `await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 793,
    "chunk_index": 20,
    "total_chunks": 45
  },
  {
    "id": "8ec1f2f106ec4cc0eee8e93a2f4fa9f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "विधि 2 पैरामीटर लेती है: - सर्वर का URL, इसलिए हम यहां `//localhost:5000/api/accounts` डालते हैं। - अनुरोध की सेटिंग्स। यहीं पर हम विधि को `POST` पर सेट करते हैं और अनुरोध के लिए `body` प्रदान करते हैं। चूंकि हम सर्वर पर JSON डेटा भेज रहे हैं, हमें `Content-Type` हेडर को `application/json` पर सेट करने की भी आवश्यकता है ताकि सर्वर सामग्री को समझ सके। चूंकि सर्वर अनुरोध का उत्तर JSON के साथ देगा, हम `await responsejson()` का उपयोग करके JSON सामग्री को पार्स कर सकते हैं और परिणामी ऑब्जेक्ट को वापस कर सकते हैं। ध्यान दें कि यह विधि असिंक्रोनस है, इसलिए हम यहां लौटने से पहले `await` कीवर्ड का उपयोग करते हैं ताकि यह सुनिश्चित हो सके कि पार्सिंग के दौरान कोई त्रुटि भी पकड़ी जाए।\nअब `register` फ़ंक्शन में `createAccount()` को कॉल करने के लिए कुछ कोड जोड़ें:\n```js\nconst result = await createAccount(jsonData);\n```\nक्योंकि हम यहां `await` कीवर्ड का उपयोग कर रहे हैं, हमें `register` फ़ंक्शन से पहले `async` कीवर्ड जोड़ने की आवश्यकता है:\n```js\nasync function register() {\n```\nअंत में, परिणाम की जांच करने के लिए कुछ लॉग जोड़ें। अंतिम फ़ंक्शन इस प्रकार दिखना चाहिए:\n```js\nasync function register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 839,
    "chunk_index": 21,
    "total_chunks": 45
  },
  {
    "id": "d1abb3c5571cb95c81506421c3d53b63",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "भी पकड़ी जाए। अब `register` फ़ंक्शन में `createAccount()` को कॉल करने के लिए कुछ कोड जोड़ें: ```js const result = await createAccount(jsonData); ``` क्योंकि हम यहां `await` कीवर्ड का उपयोग कर रहे हैं, हमें `register` फ़ंक्शन से पहले `async` कीवर्ड जोड़ने की आवश्यकता है: ```js async function register() { ``` अंत में, परिणाम की जांच करने के लिए कुछ लॉग जोड़ें। अंतिम फ़ंक्शन इस प्रकार दिखना चाहिए: ```js async function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst jsonData = JSON stringify(Object fromEntries(formData));\nconst result = await createAccount(jsonData);\nif (result error) {\nreturn console log('An error occurred:', result error);\n}\nconsole log('Account created ', result);\n}\n```\nयह थोड़ा लंबा था लेकिन हम वहां पहुंच गए यदि आप अपने [ब्राउज़र डेवलपर टूल्स](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 445,
    "chunk_index": 22,
    "total_chunks": 45
  },
  {
    "id": "ca31108f4f4d984a1d9a4e09e8cf4e74",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "में, परिणाम की जांच करने के लिए कुछ लॉग जोड़ें। अंतिम फ़ंक्शन इस प्रकार दिखना चाहिए: ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSON stringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return console log('An error occurred:', result error); } console log('Account created ', result); } ``` यह थोड़ा लंबा था लेकिन हम वहां पहुंच गए यदि आप अपने [ब्राउज़र डेवलपर टूल्स](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools) खोलते हैं और एक नया खाता पंजीकृत करने का प्रयास करते हैं, तो आपको वेब पेज पर कोई बदलाव नहीं दिखेगा लेकिन कंसोल में एक संदेश दिखाई देगा जो पुष्टि करता है कि सब कुछ काम कर रहा है। [ब्राउज़र कंसोल में लॉग संदेश दिखाने वाला स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/browser-console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 23,
    "total_chunks": 45
  },
  {
    "id": "d134133a3d8e47fd7d2110cd25a20f22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "error); } console log('Account created ', result); } ``` यह थोड़ा लंबा था लेकिन हम वहां पहुंच गए यदि आप अपने [ब्राउज़र डेवलपर टूल्स](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools) खोलते हैं और एक नया खाता पंजीकृत करने का प्रयास करते हैं, तो आपको वेब पेज पर कोई बदलाव नहीं दिखेगा लेकिन कंसोल में एक संदेश दिखाई देगा जो पुष्टि करता है कि सब कुछ काम कर रहा है। [ब्राउज़र कंसोल में लॉग संदेश दिखाने वाला स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/browser-consolepng)\n✅ क्या आपको लगता है कि डेटा सर्वर पर सुरक्षित रूप से भेजा गया है क्या होगा यदि कोई अनुरोध को इंटरसेप्ट करने में सक्षम हो आप [HTTPS](https://en wikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 24,
    "total_chunks": 45
  },
  {
    "id": "6b880d9d6bbb7e4b14dc93384fcff47b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "नया खाता पंजीकृत करने का प्रयास करते हैं, तो आपको वेब पेज पर कोई बदलाव नहीं दिखेगा लेकिन कंसोल में एक संदेश दिखाई देगा जो पुष्टि करता है कि सब कुछ काम कर रहा है। [ब्राउज़र कंसोल में लॉग संदेश दिखाने वाला स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ क्या आपको लगता है कि डेटा सर्वर पर सुरक्षित रूप से भेजा गया है क्या होगा यदि कोई अनुरोध को इंटरसेप्ट करने में सक्षम हो आप [HTTPS](https://en wikipediaorg/wiki/HTTPS) के बारे में पढ़ सकते हैं ताकि सुरक्षित डेटा संचार के बारे में अधिक जान सकें।\n## डेटा सत्यापन\nयदि आप पहले उपयोगकर्ता नाम सेट किए बिना एक नया खाता पंजीकृत करने का प्रयास करते हैं, तो आप देख सकते हैं कि सर्वर [400 (Bad Request)](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 562,
    "chunk_index": 25,
    "total_chunks": 45
  },
  {
    "id": "4a5344b037541e194473592c6376f25e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "/7-bank-project/2-forms/images/browser-consolepng) ✅ क्या आपको लगता है कि डेटा सर्वर पर सुरक्षित रूप से भेजा गया है क्या होगा यदि कोई अनुरोध को इंटरसेप्ट करने में सक्षम हो आप [HTTPS](https://en wikipediaorg/wiki/HTTPS) के बारे में पढ़ सकते हैं ताकि सुरक्षित डेटा संचार के बारे में अधिक जान सकें। ## डेटा सत्यापन यदि आप पहले उपयोगकर्ता नाम सेट किए बिना एक नया खाता पंजीकृत करने का प्रयास करते हैं, तो आप देख सकते हैं कि सर्वर [400 (Bad Request)](https://developermozilla org/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 395,
    "chunk_index": 26,
    "total_chunks": 45
  },
  {
    "id": "b362a7e1d3554b16ec0e020928cae997",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "✅ क्या आपको लगता है कि डेटा सर्वर पर सुरक्षित रूप से भेजा गया है क्या होगा यदि कोई अनुरोध को इंटरसेप्ट करने में सक्षम हो आप [HTTPS](https://en wikipediaorg/wiki/HTTPS) के बारे में पढ़ सकते हैं ताकि सुरक्षित डेटा संचार के बारे में अधिक जान सकें। ## डेटा सत्यापन यदि आप पहले उपयोगकर्ता नाम सेट किए बिना एक नया खाता पंजीकृत करने का प्रयास करते हैं, तो आप देख सकते हैं कि सर्वर [400 (Bad Request)](https://developermozilla org/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) स्थिति कोड के साथ एक त्रुटि लौटाता है।\nसर्वर को डेटा भेजने से पहले, यह सुनिश्चित करने के लिए [फॉर्म डेटा को सत्यापित करना](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 27,
    "total_chunks": 45
  },
  {
    "id": "99b2ed14e377b11ab5c90a76d54c12cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "हो आप [HTTPS](https://en wikipediaorg/wiki/HTTPS) के बारे में पढ़ सकते हैं ताकि सुरक्षित डेटा संचार के बारे में अधिक जान सकें। ## डेटा सत्यापन यदि आप पहले उपयोगकर्ता नाम सेट किए बिना एक नया खाता पंजीकृत करने का प्रयास करते हैं, तो आप देख सकते हैं कि सर्वर [400 (Bad Request)](https://developermozilla org/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) स्थिति कोड के साथ एक त्रुटि लौटाता है। सर्वर को डेटा भेजने से पहले, यह सुनिश्चित करने के लिए [फॉर्म डेटा को सत्यापित करना](https://developer mozillaorg/docs/Learn/Forms/Form_validation) एक अच्छा अभ्यास है कि आप एक मान्य अनुरोध भेज रहे हैं। HTML5 फॉर्म नियंत्रण विभिन्न एट्रिब्यूट्स का उपयोग करके अंतर्निहित सत्यापन प्रदान करते हैं:\n- `required`: फ़ील्ड को भरा जाना चाहिए अन्यथा फॉर्म सबमिट नहीं किया जा सकता।\n- `minlength` और `maxlength`: टेक्स्ट फ़ील्ड में वर्णों की न्यूनतम और अधिकतम संख्या को परिभाषित करता है।\n- `min` और `max`: एक संख्यात्मक फ़ील्ड के न्यूनतम और अधिकतम मान को परिभाषित करता है।\n- `type`: अपेक्षित डेटा के प्रकार को परिभाषित करता है, जैसे `number`, `email`, `file` या [अन्य अंतर्निहित प्रकार](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 858,
    "chunk_index": 28,
    "total_chunks": 45
  },
  {
    "id": "c13b12407dbc055dedbd834acd40aa3e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "नियंत्रण विभिन्न एट्रिब्यूट्स का उपयोग करके अंतर्निहित सत्यापन प्रदान करते हैं: - `required`: फ़ील्ड को भरा जाना चाहिए अन्यथा फॉर्म सबमिट नहीं किया जा सकता। - `minlength` और `maxlength`: टेक्स्ट फ़ील्ड में वर्णों की न्यूनतम और अधिकतम संख्या को परिभाषित करता है। - `min` और `max`: एक संख्यात्मक फ़ील्ड के न्यूनतम और अधिकतम मान को परिभाषित करता है। - `type`: अपेक्षित डेटा के प्रकार को परिभाषित करता है, जैसे `number`, `email`, `file` या [अन्य अंतर्निहित प्रकार](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 396,
    "chunk_index": 29,
    "total_chunks": 45
  },
  {
    "id": "3c44e3a1860de6ed0d1e053960bdf194",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "नियंत्रण विभिन्न एट्रिब्यूट्स का उपयोग करके अंतर्निहित सत्यापन प्रदान करते हैं: - `required`: फ़ील्ड को भरा जाना चाहिए अन्यथा फॉर्म सबमिट नहीं किया जा सकता। - `minlength` और `maxlength`: टेक्स्ट फ़ील्ड में वर्णों की न्यूनतम और अधिकतम संख्या को परिभाषित करता है। - `min` और `max`: एक संख्यात्मक फ़ील्ड के न्यूनतम और अधिकतम मान को परिभाषित करता है। - `type`: अपेक्षित डेटा के प्रकार को परिभाषित करता है, जैसे `number`, `email`, `file` या [अन्य अंतर्निहित प्रकार](https://developermozillaorg/docs/Web/HTML/Element/input)। यह एट्रिब्यूट फॉर्म नियंत्रण की दृश्य प्रस्तुति को भी बदल सकता है।\n- `pattern`: यह जांचने के लिए एक [नियमित अभिव्यक्ति](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 30,
    "total_chunks": 45
  },
  {
    "id": "35ee9ba69ccc26dd2c0f9988dc0d5a57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "नहीं किया जा सकता। - `minlength` और `maxlength`: टेक्स्ट फ़ील्ड में वर्णों की न्यूनतम और अधिकतम संख्या को परिभाषित करता है। - `min` और `max`: एक संख्यात्मक फ़ील्ड के न्यूनतम और अधिकतम मान को परिभाषित करता है। - `type`: अपेक्षित डेटा के प्रकार को परिभाषित करता है, जैसे `number`, `email`, `file` या [अन्य अंतर्निहित प्रकार](https://developermozillaorg/docs/Web/HTML/Element/input)। यह एट्रिब्यूट फॉर्म नियंत्रण की दृश्य प्रस्तुति को भी बदल सकता है। - `pattern`: यह जांचने के लिए एक [नियमित अभिव्यक्ति](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 396,
    "chunk_index": 31,
    "total_chunks": 45
  },
  {
    "id": "d8c2dc213effcc076f15ecd7e660b460",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "नहीं किया जा सकता। - `minlength` और `maxlength`: टेक्स्ट फ़ील्ड में वर्णों की न्यूनतम और अधिकतम संख्या को परिभाषित करता है। - `min` और `max`: एक संख्यात्मक फ़ील्ड के न्यूनतम और अधिकतम मान को परिभाषित करता है। - `type`: अपेक्षित डेटा के प्रकार को परिभाषित करता है, जैसे `number`, `email`, `file` या [अन्य अंतर्निहित प्रकार](https://developermozillaorg/docs/Web/HTML/Element/input)। यह एट्रिब्यूट फॉर्म नियंत्रण की दृश्य प्रस्तुति को भी बदल सकता है। - `pattern`: यह जांचने के लिए एक [नियमित अभिव्यक्ति](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions) पैटर्न को परिभाषित करने की अनुमति देता है कि दर्ज किया गया डेटा मान्य है या नहीं।\nसुझाव: आप अपने फॉर्म नियंत्रणों की उपस्थिति को उनकी वैधता के आधार पर अनुकूलित कर सकते हैं, इसके लिए `:valid` और `:invalid` CSS स्यूडो-क्लासेस का उपयोग करें।\n### कार्य\nएक वैध नया खाता बनाने के लिए दो आवश्यक फ़ील्ड्स हैं: उपयोगकर्ता नाम (username) और मुद्रा (currency), जबकि अन्य फ़ील्ड वैकल्पिक हैं। फॉर्म के HTML को अपडेट करें, `required` एट्रिब्यूट और फ़ील्ड के लेबल में टेक्स्ट का उपयोग करते हुए ताकि:\n```html\nUsername (required)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 863,
    "chunk_index": 32,
    "total_chunks": 45
  },
  {
    "id": "b29eee4a942a374518234e2f885da207",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "है या नहीं। सुझाव: आप अपने फॉर्म नियंत्रणों की उपस्थिति को उनकी वैधता के आधार पर अनुकूलित कर सकते हैं, इसके लिए `:valid` और `:invalid` CSS स्यूडो-क्लासेस का उपयोग करें। ### कार्य एक वैध नया खाता बनाने के लिए दो आवश्यक फ़ील्ड्स हैं: उपयोगकर्ता नाम (username) और मुद्रा (currency), जबकि अन्य फ़ील्ड वैकल्पिक हैं। फॉर्म के HTML को अपडेट करें, `required` एट्रिब्यूट और फ़ील्ड के लेबल में टेक्स्ट का उपयोग करते हुए ताकि: ```html Username (required)Currency (required)\n```\nहालांकि इस विशेष सर्वर इम्प्लीमेंटेशन में फ़ील्ड्स की अधिकतम लंबाई पर कोई विशिष्ट सीमा लागू नहीं की गई है, फिर भी किसी भी उपयोगकर्ता द्वारा दर्ज किए गए टेक्स्ट के लिए उचित सीमाएँ निर्धारित करना हमेशा एक अच्छा अभ्यास है।\nटेक्स्ट फ़ील्ड्स में `maxlength` एट्रिब्यूट जोड़ें:\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 663,
    "chunk_index": 33,
    "total_chunks": 45
  },
  {
    "id": "4088f9e73e2085fa02a148720f00d507",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "जबकि अन्य फ़ील्ड वैकल्पिक हैं। फॉर्म के HTML को अपडेट करें, `required` एट्रिब्यूट और फ़ील्ड के लेबल में टेक्स्ट का उपयोग करते हुए ताकि: ```html Username (required)Currency (required) ``` हालांकि इस विशेष सर्वर इम्प्लीमेंटेशन में फ़ील्ड्स की अधिकतम लंबाई पर कोई विशिष्ट सीमा लागू नहीं की गई है, फिर भी किसी भी उपयोगकर्ता द्वारा दर्ज किए गए टेक्स्ट के लिए उचित सीमाएँ निर्धारित करना हमेशा एक अच्छा अभ्यास है। टेक्स्ट फ़ील्ड्स में `maxlength` एट्रिब्यूट जोड़ें: ```html```\nअब यदि आप *Register* बटन दबाते हैं और कोई फ़ील्ड हमारे द्वारा परिभाषित वैलिडेशन नियम का पालन नहीं करता है, तो आपको कुछ इस प्रकार का संदेश दिखाई देगा:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 551,
    "chunk_index": 34,
    "total_chunks": 45
  },
  {
    "id": "a02820ff069c04d398a2629fb0b59299",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "हालांकि इस विशेष सर्वर इम्प्लीमेंटेशन में फ़ील्ड्स की अधिकतम लंबाई पर कोई विशिष्ट सीमा लागू नहीं की गई है, फिर भी किसी भी उपयोगकर्ता द्वारा दर्ज किए गए टेक्स्ट के लिए उचित सीमाएँ निर्धारित करना हमेशा एक अच्छा अभ्यास है। टेक्स्ट फ़ील्ड्स में `maxlength` एट्रिब्यूट जोड़ें: ```html``` अब यदि आप *Register* बटन दबाते हैं और कोई फ़ील्ड हमारे द्वारा परिभाषित वैलिडेशन नियम का पालन नहीं करता है, तो आपको कुछ इस प्रकार का संदेश दिखाई देगा:[फॉर्म सबमिट करने की कोशिश करते समय वैलिडेशन त्रुटि दिखाने वाला स्क्रीनशॉट]( / / /",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 35,
    "total_chunks": 45
  },
  {
    "id": "ddbbad2102288f65ff58cb06da581c6d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "लागू नहीं की गई है, फिर भी किसी भी उपयोगकर्ता द्वारा दर्ज किए गए टेक्स्ट के लिए उचित सीमाएँ निर्धारित करना हमेशा एक अच्छा अभ्यास है। टेक्स्ट फ़ील्ड्स में `maxlength` एट्रिब्यूट जोड़ें: ```html``` अब यदि आप *Register* बटन दबाते हैं और कोई फ़ील्ड हमारे द्वारा परिभाषित वैलिडेशन नियम का पालन नहीं करता है, तो आपको कुछ इस प्रकार का संदेश दिखाई देगा:[फॉर्म सबमिट करने की कोशिश करते समय वैलिडेशन त्रुटि दिखाने वाला स्क्रीनशॉट]( / / //7-bank-project/2-forms/images/validation-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 414,
    "chunk_index": 36,
    "total_chunks": 45
  },
  {
    "id": "0c8bf43581f2bf3f829b9d8c3f6c97b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "लागू नहीं की गई है, फिर भी किसी भी उपयोगकर्ता द्वारा दर्ज किए गए टेक्स्ट के लिए उचित सीमाएँ निर्धारित करना हमेशा एक अच्छा अभ्यास है। टेक्स्ट फ़ील्ड्स में `maxlength` एट्रिब्यूट जोड़ें: ```html``` अब यदि आप *Register* बटन दबाते हैं और कोई फ़ील्ड हमारे द्वारा परिभाषित वैलिडेशन नियम का पालन नहीं करता है, तो आपको कुछ इस प्रकार का संदेश दिखाई देगा:[फॉर्म सबमिट करने की कोशिश करते समय वैलिडेशन त्रुटि दिखाने वाला स्क्रीनशॉट]( / / //7-bank-project/2-forms/images/validation-errorpng)\nऐसी वैलिडेशन जो डेटा को सर्वर पर भेजने से *पहले* की जाती है, उसे **क्लाइंट-साइड** वैलिडेशन कहा जाता है। लेकिन ध्यान दें कि सभी चेक बिना डेटा भेजे करना हमेशा संभव नहीं होता। उदाहरण के लिए, हम यहां यह जांच नहीं कर सकते कि क्या पहले से ही उसी उपयोगकर्ता नाम के साथ कोई खाता मौजूद है, बिना सर्वर को अनुरोध भेजे। अतिरिक्त वैलिडेशन जो सर्वर पर की जाती है, उसे **सर्वर-साइड** वैलिडेशन कहा जाता है।\nआमतौर पर दोनों को लागू करना आवश्यक होता है। क्लाइंट-साइड वैलिडेशन उपयोगकर्ता अनुभव को बेहतर बनाता है क्योंकि यह उपयोगकर्ता को तुरंत प्रतिक्रिया देता है, जबकि सर्वर-साइड वैलिडेशन यह सुनिश्चित करने के लिए महत्वपूर्ण है कि आप जो उपयोगकर्ता डेटा प्रोसेस कर रहे हैं वह सही और सुरक्षित है।\n---\n## 🚀 चुनौती\nयदि उपयोगकर्ता पहले से मौजूद है, तो HTML में एक त्रुटि संदेश दिखाएं।\nयहां एक उदाहरण है कि CSS स्टाइलिंग के बाद अंतिम लॉगिन पेज कैसा दिख सकता है:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1236,
    "chunk_index": 37,
    "total_chunks": 45
  },
  {
    "id": "14318d7f47a0c1b0d66bfaeec5a735ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "आवश्यक होता है। क्लाइंट-साइड वैलिडेशन उपयोगकर्ता अनुभव को बेहतर बनाता है क्योंकि यह उपयोगकर्ता को तुरंत प्रतिक्रिया देता है, जबकि सर्वर-साइड वैलिडेशन यह सुनिश्चित करने के लिए महत्वपूर्ण है कि आप जो उपयोगकर्ता डेटा प्रोसेस कर रहे हैं वह सही और सुरक्षित है। --- ## 🚀 चुनौती यदि उपयोगकर्ता पहले से मौजूद है, तो HTML में एक त्रुटि संदेश दिखाएं। यहां एक उदाहरण है कि CSS स्टाइलिंग के बाद अंतिम लॉगिन पेज कैसा दिख सकता है:[CSS स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 38,
    "total_chunks": 45
  },
  {
    "id": "9b29dd1705cf537a1b23c28e6440107b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "यह उपयोगकर्ता को तुरंत प्रतिक्रिया देता है, जबकि सर्वर-साइड वैलिडेशन यह सुनिश्चित करने के लिए महत्वपूर्ण है कि आप जो उपयोगकर्ता डेटा प्रोसेस कर रहे हैं वह सही और सुरक्षित है। --- ## 🚀 चुनौती यदि उपयोगकर्ता पहले से मौजूद है, तो HTML में एक त्रुटि संदेश दिखाएं। यहां एक उदाहरण है कि CSS स्टाइलिंग के बाद अंतिम लॉगिन पेज कैसा दिख सकता है:[CSS स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/resultpng)\n## पोस्ट-लेक्चर क्विज़\n[पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 447,
    "chunk_index": 39,
    "total_chunks": 45
  },
  {
    "id": "9ad367fa3c68b8cf44d9eb63f1584909",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "जबकि सर्वर-साइड वैलिडेशन यह सुनिश्चित करने के लिए महत्वपूर्ण है कि आप जो उपयोगकर्ता डेटा प्रोसेस कर रहे हैं वह सही और सुरक्षित है। --- ## 🚀 चुनौती यदि उपयोगकर्ता पहले से मौजूद है, तो HTML में एक त्रुटि संदेश दिखाएं। यहां एक उदाहरण है कि CSS स्टाइलिंग के बाद अंतिम लॉगिन पेज कैसा दिख सकता है:[CSS स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/resultpng) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/44)\n## समीक्षा और स्व-अध्ययन\nडेवलपर्स ने फॉर्म बनाने के प्रयासों में, विशेष रूप से वैलिडेशन रणनीतियों के संबंध में, बहुत रचनात्मकता दिखाई है। [CodePen](https://codepen",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 557,
    "chunk_index": 40,
    "total_chunks": 45
  },
  {
    "id": "90ee076c3012829a3639eab9b7b04189",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "--- ## 🚀 चुनौती यदि उपयोगकर्ता पहले से मौजूद है, तो HTML में एक त्रुटि संदेश दिखाएं। यहां एक उदाहरण है कि CSS स्टाइलिंग के बाद अंतिम लॉगिन पेज कैसा दिख सकता है:[CSS स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/resultpng) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/44) ## समीक्षा और स्व-अध्ययन डेवलपर्स ने फॉर्म बनाने के प्रयासों में, विशेष रूप से वैलिडेशन रणनीतियों के संबंध में, बहुत रचनात्मकता दिखाई है। [CodePen](https://codepencom) पर विभिन्न फॉर्म फ्लो के बारे में जानें; क्या आप कुछ दिलचस्प और प्रेरणादायक फॉर्म ढूंढ सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 526,
    "chunk_index": 41,
    "total_chunks": 45
  },
  {
    "id": "6fdb851764a8220c0a1d968312188ca6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "एक उदाहरण है कि CSS स्टाइलिंग के बाद अंतिम लॉगिन पेज कैसा दिख सकता है:[CSS स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/resultpng) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/44) ## समीक्षा और स्व-अध्ययन डेवलपर्स ने फॉर्म बनाने के प्रयासों में, विशेष रूप से वैलिडेशन रणनीतियों के संबंध में, बहुत रचनात्मकता दिखाई है। [CodePen](https://codepencom) पर विभिन्न फॉर्म फ्लो के बारे में जानें; क्या आप कुछ दिलचस्प और प्रेरणादायक फॉर्म ढूंढ सकते हैं## असाइनमेंट\n[अपने बैंक ऐप को स्टाइल करें](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 42,
    "total_chunks": 45
  },
  {
    "id": "e334c16f8638dbc5bdf5b6dec2d4928b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "बाद अंतिम लॉगिन पेज कैसा दिख सकता है:[CSS स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/resultpng) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/44) ## समीक्षा और स्व-अध्ययन डेवलपर्स ने फॉर्म बनाने के प्रयासों में, विशेष रूप से वैलिडेशन रणनीतियों के संबंध में, बहुत रचनात्मकता दिखाई है। [CodePen](https://codepencom) पर विभिन्न फॉर्म फ्लो के बारे में जानें; क्या आप कुछ दिलचस्प और प्रेरणादायक फॉर्म ढूंढ सकते हैं## असाइनमेंट [अपने बैंक ऐप को स्टाइल करें](assignmentmd)\n**अस्वीकरण**:\nयह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 43,
    "total_chunks": 45
  },
  {
    "id": "f4451bf93b015b898b9bdc9b6a3a399e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 2: लॉगिन और रजिस्ट्रेशन फॉर्म बनाएं",
    "content": "स्टाइल जोड़ने के बाद लॉगिन पेज का स्क्रीनशॉट]( / / / /7-bank-project/2-forms/images/resultpng) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/44) ## समीक्षा और स्व-अध्ययन डेवलपर्स ने फॉर्म बनाने के प्रयासों में, विशेष रूप से वैलिडेशन रणनीतियों के संबंध में, बहुत रचनात्मकता दिखाई है। [CodePen](https://codepencom) पर विभिन्न फॉर्म फ्लो के बारे में जानें; क्या आप कुछ दिलचस्प और प्रेरणादायक फॉर्म ढूंढ सकते हैं## असाइनमेंट [अपने बैंक ऐप को स्टाइल करें](assignmentmd) **अस्वीकरण**: यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://githubcom/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 36697,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 842,
    "chunk_index": 44,
    "total_chunks": 45
  },
  {
    "id": "a3dc211c16508e57ec075ececc72bcf9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nहर वेब एप्लिकेशन के केंद्र में डेटा होता है। डेटा कई रूप ले सकता है, लेकिन इसका मुख्य उद्देश्य हमेशा उपयोगकर्ता को जानकारी प्रदर्शित करना होता है। जैसे-जैसे वेब ऐप्स अधिक इंटरैक्टिव और जटिल होते जा रहे हैं, उपयोगकर्ता द्वारा जानकारी तक पहुंचने और उसके साथ इंटरैक्ट करने का तरीका वेब विकास का एक महत्वपूर्ण हिस्सा बन गया है।\nइस पाठ में, हम देखेंगे कि सर्वर से डेटा को असिंक्रोनस रूप से कैसे प्राप्त किया जाए और इस डेटा का उपयोग HTML को रीलोड किए बिना वेब पेज पर जानकारी प्रदर्शित करने के लिए कैसे किया जाए।\nपूर्वापेक्षा\nइस पाठ के लिए आपको वेब ऐप का लॉगिन और रजिस्ट्रेशन फॉर्म भाग बनाना होगा। आपको Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 692,
    "chunk_index": 0,
    "total_chunks": 54
  },
  {
    "id": "e81385a738f48c3f1d710a64907ddc46",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "द्वारा जानकारी तक पहुंचने और उसके साथ इंटरैक्ट करने का तरीका वेब विकास का एक महत्वपूर्ण हिस्सा बन गया है। इस पाठ में, हम देखेंगे कि सर्वर से डेटा को असिंक्रोनस रूप से कैसे प्राप्त किया जाए और इस डेटा का उपयोग HTML को रीलोड किए बिना वेब पेज पर जानकारी प्रदर्शित करने के लिए कैसे किया जाए। पूर्वापेक्षा इस पाठ के लिए आपको वेब ऐप का लॉगिन और रजिस्ट्रेशन फॉर्म भाग बनाना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API को लोकली चलाना होगा ताकि आप खाता डेटा प्राप्त कर सकें।\nआप यह कमांड टर्मिनल में चलाकर यह जांच सकते हैं कि सर्वर सही तरीके से चल रहा है या नहीं:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 1,
    "total_chunks": 54
  },
  {
    "id": "18afaa2f989669bbb49032f8ebe579fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "बिना वेब पेज पर जानकारी प्रदर्शित करने के लिए कैसे किया जाए। पूर्वापेक्षा इस पाठ के लिए आपको वेब ऐप का लॉगिन और रजिस्ट्रेशन फॉर्म भाग बनाना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API को लोकली चलाना होगा ताकि आप खाता डेटा प्राप्त कर सकें। आप यह कमांड टर्मिनल में चलाकर यह जांच सकते हैं कि सर्वर सही तरीके से चल रहा है या नहीं: ```sh curl http://localhost:5000/api -> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 328,
    "chunk_index": 2,
    "total_chunks": 54
  },
  {
    "id": "239f5ace8087667bc1eb6baa901f7603",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "बिना वेब पेज पर जानकारी प्रदर्शित करने के लिए कैसे किया जाए। पूर्वापेक्षा इस पाठ के लिए आपको वेब ऐप का लॉगिन और रजिस्ट्रेशन फॉर्म भाग बनाना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API को लोकली चलाना होगा ताकि आप खाता डेटा प्राप्त कर सकें। आप यह कमांड टर्मिनल में चलाकर यह जांच सकते हैं कि सर्वर सही तरीके से चल रहा है या नहीं: ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result\n```\nAJAX और डेटा प्राप्त करना\nपारंपरिक वेबसाइटें उपयोगकर्ता द्वारा लिंक चुनने या फॉर्म के माध्यम से डेटा सबमिट करने पर प्रदर्शित सामग्री को अपडेट करती हैं, और इसके लिए पूरे HTML पेज को रीलोड करना पड़ता है। हर बार जब नया डेटा लोड करने की आवश्यकता होती है, तो वेब सर्वर एक नया HTML पेज लौटाता है जिसे ब्राउज़र द्वारा प्रोसेस किया जाना चाहिए, जिससे उपयोगकर्ता की वर्तमान क्रिया बाधित होती है और रीलोड के दौरान इंटरैक्शन सीमित हो जाते हैं। इस वर्कफ़्लो को मल्टी-पेज एप्लिकेशन या MPA भी कहा जाता है।\nजब वेब एप्लिकेशन अधिक जटिल और इंटरैक्टिव होने लगे, तो AJAX (Asynchronous JavaScript and XML) नामक एक नई तकनीक उभरी। यह तकनीक वेब ऐप्स को जावास्क्रिप्ट का उपयोग करके सर्वर से डेटा को असिंक्रोनस रूप से भेजने और प्राप्त करने की अनुमति देती है, बिना HTML पेज को रीलोड किए। इससे तेज़ अपडेट और स्मूथ उपयोगकर्ता इंटरैक्शन संभव हो पाते हैं। जब सर्वर से नया डेटा प्राप्त होता है, तो वर्तमान HTML पेज को जावास्क्रिप्ट का उपयोग करके DOM API के माध्यम से अपडेट किया जा सकता है। समय के साथ, यह दृष्टिकोण सिंगल-पेज एप्लिकेशन या SPA के रूप में विकसित हुआ।\nजब AJAX पहली बार पेश किया गया था, तो असिंक्रोनस रूप से डेटा प्राप्त करने के लिए केवल XMLHttpRequest API उपलब्ध था। लेकिन आधुनिक ब्राउज़र अब Fetch API को भी लागू करते हैं, जो अधिक सुविधाजनक और शक्तिशाली है। यह प्रॉमिस का उपयोग करता है और JSON डेटा को मैनेज करने के लिए बेहतर है।\nहालांकि सभी आधुनिक ब्राउज़र Fetch API का समर्थन करते हैं, यदि आप चाहते हैं कि आपका वेब एप्लिकेशन पुराने ब्राउज़रों पर भी काम करे, तो caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1662,
    "chunk_index": 3,
    "total_chunks": 54
  },
  {
    "id": "2ef02d53d406fde6a417482ad91f122c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "किया गया था, तो असिंक्रोनस रूप से डेटा प्राप्त करने के लिए केवल XMLHttpRequest API उपलब्ध था। लेकिन आधुनिक ब्राउज़र अब Fetch API को भी लागू करते हैं, जो अधिक सुविधाजनक और शक्तिशाली है। यह प्रॉमिस का उपयोग करता है और JSON डेटा को मैनेज करने के लिए बेहतर है। हालांकि सभी आधुनिक ब्राउज़र Fetch API का समर्थन करते हैं, यदि आप चाहते हैं कि आपका वेब एप्लिकेशन पुराने ब्राउज़रों पर भी काम करे, तो caniusecom पर संगतता तालिका की जांच करना हमेशा एक अच्छा विचार है।\nकार्य\nपिछले पाठ में हमने खाता बनाने के लिए रजिस्ट्रेशन फॉर्म को लागू किया था। अब हम मौजूदा खाते का उपयोग करके लॉगिन करने और उसका डेटा प्राप्त करने के लिए कोड जोड़ेंगे। app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 573,
    "chunk_index": 4,
    "total_chunks": 54
  },
  {
    "id": "00aaa1cc264f50327ab7fcc717e00ac5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "करने के लिए बेहतर है। हालांकि सभी आधुनिक ब्राउज़र Fetch API का समर्थन करते हैं, यदि आप चाहते हैं कि आपका वेब एप्लिकेशन पुराने ब्राउज़रों पर भी काम करे, तो caniusecom पर संगतता तालिका की जांच करना हमेशा एक अच्छा विचार है। कार्य पिछले पाठ में हमने खाता बनाने के लिए रजिस्ट्रेशन फॉर्म को लागू किया था। अब हम मौजूदा खाते का उपयोग करके लॉगिन करने और उसका डेटा प्राप्त करने के लिए कोड जोड़ेंगे। appjs फ़ाइल खोलें और एक नया login फ़ंक्शन जोड़ें:\njs\nasync function login() {\nconst loginForm = document getElementById('loginForm')\nconst user = loginForm user",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 437,
    "chunk_index": 5,
    "total_chunks": 54
  },
  {
    "id": "5715541aac707a653a836fe36e3d46b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "पुराने ब्राउज़रों पर भी काम करे, तो caniusecom पर संगतता तालिका की जांच करना हमेशा एक अच्छा विचार है। कार्य पिछले पाठ में हमने खाता बनाने के लिए रजिस्ट्रेशन फॉर्म को लागू किया था। अब हम मौजूदा खाते का उपयोग करके लॉगिन करने और उसका डेटा प्राप्त करने के लिए कोड जोड़ेंगे। appjs फ़ाइल खोलें और एक नया login फ़ंक्शन जोड़ें: js async function login() { const loginForm = document getElementById('loginForm') const user = loginForm uservalue;\n}\nयहां हम getElementById() का उपयोग करके फॉर्म एलिमेंट प्राप्त करते हैं, और फिर loginForm user",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 397,
    "chunk_index": 6,
    "total_chunks": 54
  },
  {
    "id": "6bac1eb340f04cdff7cab2511a092d39",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "अच्छा विचार है। कार्य पिछले पाठ में हमने खाता बनाने के लिए रजिस्ट्रेशन फॉर्म को लागू किया था। अब हम मौजूदा खाते का उपयोग करके लॉगिन करने और उसका डेटा प्राप्त करने के लिए कोड जोड़ेंगे। appjs फ़ाइल खोलें और एक नया login फ़ंक्शन जोड़ें: js async function login() { const loginForm = document getElementById('loginForm') const user = loginForm uservalue; } यहां हम getElementById() का उपयोग करके फॉर्म एलिमेंट प्राप्त करते हैं, और फिर loginForm uservalue के साथ इनपुट से उपयोगकर्ता नाम प्राप्त करते हैं। हर फॉर्म कंट्रोल को उसके नाम (HTML में name एट्रिब्यूट का उपयोग करके सेट किया गया) के माध्यम से फॉर्म की प्रॉपर्टी के रूप में एक्सेस किया जा सकता है।\nरजिस्ट्रेशन के लिए जो किया गया था, उसी तरह हम सर्वर अनुरोध करने के लिए एक और फ़ंक्शन बनाएंगे, लेकिन इस बार खाता डेटा प्राप्त करने के लिए:\njs\nasync function getAccount(user) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 670,
    "chunk_index": 7,
    "total_chunks": 54
  },
  {
    "id": "7e8a82bc1565f2da624abcac94f63f6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "हैं। हर फॉर्म कंट्रोल को उसके नाम (HTML में name एट्रिब्यूट का उपयोग करके सेट किया गया) के माध्यम से फॉर्म की प्रॉपर्टी के रूप में एक्सेस किया जा सकता है। रजिस्ट्रेशन के लिए जो किया गया था, उसी तरह हम सर्वर अनुरोध करने के लिए एक और फ़ंक्शन बनाएंगे, लेकिन इस बार खाता डेटा प्राप्त करने के लिए: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson();\n} catch (error) {\nreturn { error: error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 315,
    "chunk_index": 8,
    "total_chunks": 54
  },
  {
    "id": "5b76ca74ad33a3ba9b857cc3fc021892",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "में name एट्रिब्यूट का उपयोग करके सेट किया गया) के माध्यम से फॉर्म की प्रॉपर्टी के रूप में एक्सेस किया जा सकता है। रजिस्ट्रेशन के लिए जो किया गया था, उसी तरह हम सर्वर अनुरोध करने के लिए एक और फ़ंक्शन बनाएंगे, लेकिन इस बार खाता डेटा प्राप्त करने के लिए: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' };\n}\n}\nहम fetch API का उपयोग करके सर्वर से डेटा को असिंक्रोनस रूप से प्राप्त करते हैं, लेकिन इस बार हमें केवल URL के अलावा किसी अतिरिक्त पैरामीटर की आवश्यकता नहीं है, क्योंकि हम केवल डेटा क्वेरी कर रहे हैं। डिफ़ॉल्ट रूप से, fetch एक GET HTTP अनुरोध बनाता है, जो यहां हमारी आवश्यकता है।\n✅ encodeURIComponent() एक फ़ंक्शन है जो URL के लिए विशेष वर्णों को एस्केप करता है। यदि हम इस फ़ंक्शन को कॉल किए बिना सीधे user मान का उपयोग URL में करें तो हमें किन समस्याओं का सामना करना पड़ सकता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 699,
    "chunk_index": 9,
    "total_chunks": 54
  },
  {
    "id": "d23eb6541f83caf40fa2da94be652beb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "हमें केवल URL के अलावा किसी अतिरिक्त पैरामीटर की आवश्यकता नहीं है, क्योंकि हम केवल डेटा क्वेरी कर रहे हैं। डिफ़ॉल्ट रूप से, fetch एक GET HTTP अनुरोध बनाता है, जो यहां हमारी आवश्यकता है। ✅ encodeURIComponent() एक फ़ंक्शन है जो URL के लिए विशेष वर्णों को एस्केप करता है। यदि हम इस फ़ंक्शन को कॉल किए बिना सीधे user मान का उपयोग URL में करें तो हमें किन समस्याओं का सामना करना पड़ सकता हैअब हम अपने login फ़ंक्शन को getAccount का उपयोग करने के लिए अपडेट करेंगे:\n```js\nasync function login() {\nconst loginForm = document getElementById('loginForm')\nconst user = loginForm user value;\nconst data = await getAccount(user);\nif (data error) {\nreturn console log('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 440,
    "chunk_index": 10,
    "total_chunks": 54
  },
  {
    "id": "68307f3b1d4bda9d02605ba7c3b28185",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "के लिए विशेष वर्णों को एस्केप करता है। यदि हम इस फ़ंक्शन को कॉल किए बिना सीधे user मान का उपयोग URL में करें तो हमें किन समस्याओं का सामना करना पड़ सकता हैअब हम अपने login फ़ंक्शन को getAccount का उपयोग करने के लिए अपडेट करेंगे: ```js async function login() { const loginForm = document getElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror);\n}\naccount = data;\nnavigate('/dashboard');\n}\n```\nसबसे पहले, चूंकि getAccount एक असिंक्रोनस फ़ंक्शन है, हमें इसे await कीवर्ड के साथ मिलाना होगा ताकि सर्वर के परिणाम का इंतजार किया जा सके। किसी भी सर्वर अनुरोध के साथ, हमें त्रुटि मामलों से भी निपटना होगा। फिलहाल हम केवल त्रुटि प्रदर्शित करने के लिए एक लॉग संदेश जोड़ेंगे और बाद में इसे सुधारेंगे।\nफिर हमें डेटा को कहीं स्टोर करना होगा ताकि हम बाद में इसे डैशबोर्ड जानकारी प्रदर्शित करने के लिए उपयोग कर सकें। चूंकि account वेरिएबल अभी तक मौजूद नहीं है, हम इसे अपनी फ़ाइल के शीर्ष पर एक ग्लोबल वेरिएबल के रूप में बनाएंगे:\njs\nlet account = null;\nउपयोगकर्ता डेटा को वेरिएबल में सहेजने के बाद, हम लॉगिन पेज से डैशबोर्ड पर navigate() फ़ंक्शन का उपयोग करके जा सकते हैं।\nअंत में, हमें लॉगिन फॉर्म सबमिट होने पर अपने login फ़ंक्शन को कॉल करना होगा, HTML को संशोधित करके:\n```html\n```\nनए खाते को रजिस्टर करके और उसी खाते का उपयोग करके लॉगिन करने का प्रयास करके जांचें कि सब कुछ सही तरीके से काम कर रहा है।\nअगले भाग पर जाने से पहले, हम `register` फ़ंक्शन को इस कोड को फ़ंक्शन के अंत में जोड़कर पूरा कर सकते हैं:\n```js\naccount = result;\nnavigate('/dashboard');\n```\n✅ क्या आप जानते हैं कि डिफ़ॉल्ट रूप से, आप केवल उसी *डोमेन और पोर्ट* से सर्वर API को कॉल कर सकते हैं जिस पर आप वेब पेज देख रहे हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1304,
    "chunk_index": 11,
    "total_chunks": 54
  },
  {
    "id": "fc289d9a3c9f6ccfd6b127cc89a8fd22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "करके लॉगिन करने का प्रयास करके जांचें कि सब कुछ सही तरीके से काम कर रहा है। अगले भाग पर जाने से पहले, हम `register` फ़ंक्शन को इस कोड को फ़ंक्शन के अंत में जोड़कर पूरा कर सकते हैं: ```js account = result; navigate('/dashboard'); ``` ✅ क्या आप जानते हैं कि डिफ़ॉल्ट रूप से, आप केवल उसी *डोमेन और पोर्ट* से सर्वर API को कॉल कर सकते हैं जिस पर आप वेब पेज देख रहे हैंयह ब्राउज़र द्वारा लागू की गई सुरक्षा प्रणाली है। लेकिन रुको, हमारा वेब ऐप `localhost:3000` पर चल रहा है जबकि सर्वर API `localhost:5000` पर चल रहा है, फिर यह कैसे काम करता है [क्रॉस-ओरिजिन रिसोर्स शेयरिंग (CORS)](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 478,
    "chunk_index": 12,
    "total_chunks": 54
  },
  {
    "id": "8cd46b68addcd4ced35e87046869d935",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "सकते हैं: ```js account = result; navigate('/dashboard'); ``` ✅ क्या आप जानते हैं कि डिफ़ॉल्ट रूप से, आप केवल उसी *डोमेन और पोर्ट* से सर्वर API को कॉल कर सकते हैं जिस पर आप वेब पेज देख रहे हैंयह ब्राउज़र द्वारा लागू की गई सुरक्षा प्रणाली है। लेकिन रुको, हमारा वेब ऐप `localhost:3000` पर चल रहा है जबकि सर्वर API `localhost:5000` पर चल रहा है, फिर यह कैसे काम करता है [क्रॉस-ओरिजिन रिसोर्स शेयरिंग (CORS)](https://developer mozillaorg/docs/Web/HTTP/CORS) नामक तकनीक का उपयोग करके, यदि सर्वर प्रतिक्रिया में विशेष हेडर जोड़ता है, तो विशिष्ट डोमेन के लिए अपवादों की अनुमति देकर क्रॉस-ओरिजिन HTTP अनुरोध करना संभव है।\n> API के बारे में अधिक जानने के लिए यह [पाठ](https://docs",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 13,
    "total_chunks": 54
  },
  {
    "id": "fb64a825ca9fbecd02e2df66145e7d20",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "ब्राउज़र द्वारा लागू की गई सुरक्षा प्रणाली है। लेकिन रुको, हमारा वेब ऐप `localhost:3000` पर चल रहा है जबकि सर्वर API `localhost:5000` पर चल रहा है, फिर यह कैसे काम करता है [क्रॉस-ओरिजिन रिसोर्स शेयरिंग (CORS)](https://developer mozillaorg/docs/Web/HTTP/CORS) नामक तकनीक का उपयोग करके, यदि सर्वर प्रतिक्रिया में विशेष हेडर जोड़ता है, तो विशिष्ट डोमेन के लिए अपवादों की अनुमति देकर क्रॉस-ओरिजिन HTTP अनुरोध करना संभव है। > API के बारे में अधिक जानने के लिए यह [पाठ](https://docsmicrosoft com/learn/modules/use-apis-discover-museum-art/ WT",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 402,
    "chunk_index": 14,
    "total_chunks": 54
  },
  {
    "id": "9e1969922a4da0ad56ee37eae9355f43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "लागू की गई सुरक्षा प्रणाली है। लेकिन रुको, हमारा वेब ऐप `localhost:3000` पर चल रहा है जबकि सर्वर API `localhost:5000` पर चल रहा है, फिर यह कैसे काम करता है [क्रॉस-ओरिजिन रिसोर्स शेयरिंग (CORS)](https://developer mozillaorg/docs/Web/HTTP/CORS) नामक तकनीक का उपयोग करके, यदि सर्वर प्रतिक्रिया में विशेष हेडर जोड़ता है, तो विशिष्ट डोमेन के लिए अपवादों की अनुमति देकर क्रॉस-ओरिजिन HTTP अनुरोध करना संभव है। > API के बारे में अधिक जानने के लिए यह [पाठ](https://docsmicrosoft com/learn/modules/use-apis-discover-museum-art/ WTmc_id=academic-77807-sagibbon) लें।\n## डेटा प्रदर्शित करने के लिए HTML अपडेट करें\nअब जब हमारे पास उपयोगकर्ता डेटा है, तो हमें मौजूदा HTML को इसे प्रदर्शित करने के लिए अपडेट करना होगा। हम पहले ही देख चुके हैं कि DOM से किसी एलिमेंट को कैसे प्राप्त किया जाए, उदाहरण के लिए `document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 617,
    "chunk_index": 15,
    "total_chunks": 54
  },
  {
    "id": "a3c1ce4596e46e8222d484d04520377f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "डोमेन के लिए अपवादों की अनुमति देकर क्रॉस-ओरिजिन HTTP अनुरोध करना संभव है। > API के बारे में अधिक जानने के लिए यह [पाठ](https://docsmicrosoft com/learn/modules/use-apis-discover-museum-art/ WTmc_id=academic-77807-sagibbon) लें। ## डेटा प्रदर्शित करने के लिए HTML अपडेट करें अब जब हमारे पास उपयोगकर्ता डेटा है, तो हमें मौजूदा HTML को इसे प्रदर्शित करने के लिए अपडेट करना होगा। हम पहले ही देख चुके हैं कि DOM से किसी एलिमेंट को कैसे प्राप्त किया जाए, उदाहरण के लिए `documentgetElementById()` का उपयोग करके। एक बार जब आपके पास बेस एलिमेंट हो, तो यहां कुछ API हैं जिनका उपयोग आप इसे संशोधित करने या इसमें चाइल्ड एलिमेंट जोड़ने के लिए कर सकते हैं:\n- [`textContent`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 523,
    "chunk_index": 16,
    "total_chunks": 54
  },
  {
    "id": "9455d5e9d3305d2dbbfc2ebd689248f1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "अपडेट करें अब जब हमारे पास उपयोगकर्ता डेटा है, तो हमें मौजूदा HTML को इसे प्रदर्शित करने के लिए अपडेट करना होगा। हम पहले ही देख चुके हैं कि DOM से किसी एलिमेंट को कैसे प्राप्त किया जाए, उदाहरण के लिए `documentgetElementById()` का उपयोग करके। एक बार जब आपके पास बेस एलिमेंट हो, तो यहां कुछ API हैं जिनका उपयोग आप इसे संशोधित करने या इसमें चाइल्ड एलिमेंट जोड़ने के लिए कर सकते हैं: - [`textContent`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 353,
    "chunk_index": 17,
    "total_chunks": 54
  },
  {
    "id": "68efe53c7c6c5cc17bd68b0498728731",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "अपडेट करें अब जब हमारे पास उपयोगकर्ता डेटा है, तो हमें मौजूदा HTML को इसे प्रदर्शित करने के लिए अपडेट करना होगा। हम पहले ही देख चुके हैं कि DOM से किसी एलिमेंट को कैसे प्राप्त किया जाए, उदाहरण के लिए `documentgetElementById()` का उपयोग करके। एक बार जब आपके पास बेस एलिमेंट हो, तो यहां कुछ API हैं जिनका उपयोग आप इसे संशोधित करने या इसमें चाइल्ड एलिमेंट जोड़ने के लिए कर सकते हैं: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) प्रॉपर्टी का उपयोग करके आप किसी एलिमेंट के टेक्स्ट को बदल सकते हैं। ध्यान दें कि इस मान को बदलने से एलिमेंट के सभी चाइल्ड (यदि कोई हो) हटा दिए जाते हैं और इसे प्रदान किए गए टेक्स्ट से बदल दिया जाता है। इस प्रकार, यह किसी दिए गए एलिमेंट के सभी चाइल्ड को हटाने का एक कुशल तरीका भी है, इसे खाली स्ट्रिंग `''` असाइन करके।\n- [`document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 18,
    "total_chunks": 54
  },
  {
    "id": "14f4540b99f94fe22312dc5f8f903095",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "के लिए कर सकते हैं: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) प्रॉपर्टी का उपयोग करके आप किसी एलिमेंट के टेक्स्ट को बदल सकते हैं। ध्यान दें कि इस मान को बदलने से एलिमेंट के सभी चाइल्ड (यदि कोई हो) हटा दिए जाते हैं और इसे प्रदान किए गए टेक्स्ट से बदल दिया जाता है। इस प्रकार, यह किसी दिए गए एलिमेंट के सभी चाइल्ड को हटाने का एक कुशल तरीका भी है, इसे खाली स्ट्रिंग `''` असाइन करके। - [`documentcreateElement()`](https://developer mozilla org/docs/Web/API/Document/createElement) और [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) मेथड का उपयोग करके आप एक या अधिक नए चाइल्ड एलिमेंट बना सकते हैं और अटैच कर सकते हैं।\n✅ किसी एलिमेंट की [`innerHTML`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 19,
    "total_chunks": 54
  },
  {
    "id": "dbfa188a008576765b9786c054c14190",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "चाइल्ड (यदि कोई हो) हटा दिए जाते हैं और इसे प्रदान किए गए टेक्स्ट से बदल दिया जाता है। इस प्रकार, यह किसी दिए गए एलिमेंट के सभी चाइल्ड को हटाने का एक कुशल तरीका भी है, इसे खाली स्ट्रिंग `''` असाइन करके। - [`documentcreateElement()`](https://developer mozilla org/docs/Web/API/Document/createElement) और [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) मेथड का उपयोग करके आप एक या अधिक नए चाइल्ड एलिमेंट बना सकते हैं और अटैच कर सकते हैं। ✅ किसी एलिमेंट की [`innerHTML`](https://developer mozillaorg/docs/Web/API/Element/innerHTML) प्रॉपर्टी का उपयोग करके उसके HTML कंटेंट को बदलना भी संभव है, लेकिन इसे [क्रॉस-साइट स्क्रिप्टिंग (XSS)](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 460,
    "chunk_index": 20,
    "total_chunks": 54
  },
  {
    "id": "65ad3b3b52c60dbfdb63614c13a0da0d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "है। इस प्रकार, यह किसी दिए गए एलिमेंट के सभी चाइल्ड को हटाने का एक कुशल तरीका भी है, इसे खाली स्ट्रिंग `''` असाइन करके। - [`documentcreateElement()`](https://developer mozilla org/docs/Web/API/Document/createElement) और [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) मेथड का उपयोग करके आप एक या अधिक नए चाइल्ड एलिमेंट बना सकते हैं और अटैच कर सकते हैं। ✅ किसी एलिमेंट की [`innerHTML`](https://developer mozillaorg/docs/Web/API/Element/innerHTML) प्रॉपर्टी का उपयोग करके उसके HTML कंटेंट को बदलना भी संभव है, लेकिन इसे [क्रॉस-साइट स्क्रिप्टिंग (XSS)](https://developer mozillaorg/docs/Glossary/Cross-site_scripting) हमलों के प्रति संवेदनशील होने के कारण टाला जाना चाहिए।\n### कार्य\nडैशबोर्ड स्क्रीन पर जाने से पहले, हमें *लॉगिन* पेज पर एक और चीज़ करनी चाहिए। वर्तमान में, यदि आप किसी ऐसे उपयोगकर्ता नाम के साथ लॉगिन करने का प्रयास करते हैं जो मौजूद नहीं है, तो कंसोल में एक संदेश दिखाया जाता है, लेकिन एक सामान्य उपयोगकर्ता के लिए कुछ भी नहीं बदलता और यह समझ में नहीं आता कि क्या हो रहा है।\nआइए लॉगिन फॉर्म में एक प्लेसहोल्डर एलिमेंट जोड़ें जहां आवश्यकता होने पर हम एक त्रुटि संदेश प्रदर्शित कर सकें। एक अच्छा स्थान लॉगिन `` से ठीक पहले होगा:\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 907,
    "chunk_index": 21,
    "total_chunks": 54
  },
  {
    "id": "c8d10ffb71f11cfeeadb25c06a192c26",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "यदि आप किसी ऐसे उपयोगकर्ता नाम के साथ लॉगिन करने का प्रयास करते हैं जो मौजूद नहीं है, तो कंसोल में एक संदेश दिखाया जाता है, लेकिन एक सामान्य उपयोगकर्ता के लिए कुछ भी नहीं बदलता और यह समझ में नहीं आता कि क्या हो रहा है। आइए लॉगिन फॉर्म में एक प्लेसहोल्डर एलिमेंट जोड़ें जहां आवश्यकता होने पर हम एक त्रुटि संदेश प्रदर्शित कर सकें। एक अच्छा स्थान लॉगिन `` से ठीक पहले होगा: ```htmlLogin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 372,
    "chunk_index": 22,
    "total_chunks": 54
  },
  {
    "id": "e523d4f5598cd42e93567905c86f444a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "यदि आप किसी ऐसे उपयोगकर्ता नाम के साथ लॉगिन करने का प्रयास करते हैं जो मौजूद नहीं है, तो कंसोल में एक संदेश दिखाया जाता है, लेकिन एक सामान्य उपयोगकर्ता के लिए कुछ भी नहीं बदलता और यह समझ में नहीं आता कि क्या हो रहा है। आइए लॉगिन फॉर्म में एक प्लेसहोल्डर एलिमेंट जोड़ें जहां आवश्यकता होने पर हम एक त्रुटि संदेश प्रदर्शित कर सकें। एक अच्छा स्थान लॉगिन `` से ठीक पहले होगा: ```htmlLogin```\nयह `` एलिमेंट खाली है, जिसका अर्थ है कि जब तक हम इसमें कुछ सामग्री नहीं जोड़ते, स्क्रीन पर कुछ भी प्रदर्शित नहीं होगा। हम इसे एक `id` भी देते हैं ताकि इसे जावास्क्रिप्ट के साथ आसानी से प्राप्त किया जा सके।\n`app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 569,
    "chunk_index": 23,
    "total_chunks": 54
  },
  {
    "id": "413b5c7d20b5707ff4424d5755ac5769",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "क्या हो रहा है। आइए लॉगिन फॉर्म में एक प्लेसहोल्डर एलिमेंट जोड़ें जहां आवश्यकता होने पर हम एक त्रुटि संदेश प्रदर्शित कर सकें। एक अच्छा स्थान लॉगिन `` से ठीक पहले होगा: ```htmlLogin``` यह `` एलिमेंट खाली है, जिसका अर्थ है कि जब तक हम इसमें कुछ सामग्री नहीं जोड़ते, स्क्रीन पर कुछ भी प्रदर्शित नहीं होगा। हम इसे एक `id` भी देते हैं ताकि इसे जावास्क्रिप्ट के साथ आसानी से प्राप्त किया जा सके। `appjs` फ़ाइल पर वापस जाएं और एक नया हेल्पर फ़ंक्शन `updateElement` बनाएं:\n```js\nfunction updateElement(id, text) {\nconst element = document getElementById(id);\nelement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 445,
    "chunk_index": 24,
    "total_chunks": 54
  },
  {
    "id": "c64cc7698a12e20a2c3e94d9db632cbf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "सकें। एक अच्छा स्थान लॉगिन `` से ठीक पहले होगा: ```htmlLogin``` यह `` एलिमेंट खाली है, जिसका अर्थ है कि जब तक हम इसमें कुछ सामग्री नहीं जोड़ते, स्क्रीन पर कुछ भी प्रदर्शित नहीं होगा। हम इसे एक `id` भी देते हैं ताकि इसे जावास्क्रिप्ट के साथ आसानी से प्राप्त किया जा सके। `appjs` फ़ाइल पर वापस जाएं और एक नया हेल्पर फ़ंक्शन `updateElement` बनाएं: ```js function updateElement(id, text) { const element = document getElementById(id); elementtextContent = text;\n}\n```\nयह फ़ंक्शन काफी सरल है: दिए गए एलिमेंट *id* और *text* के आधार पर, यह DOM एलिमेंट के टेक्स्ट कंटेंट को अपडेट करेगा जिसका `id` मेल खाता है। आइए इस मेथड का उपयोग `login` फ़ंक्शन में पिछले त्रुटि संदेश के स्थान पर करें:\n```js\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 533,
    "chunk_index": 25,
    "total_chunks": 54
  },
  {
    "id": "b461e6ad65dfc8a6c449b5f5563e12d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "किया जा सके। `appjs` फ़ाइल पर वापस जाएं और एक नया हेल्पर फ़ंक्शन `updateElement` बनाएं: ```js function updateElement(id, text) { const element = document getElementById(id); elementtextContent = text; } ``` यह फ़ंक्शन काफी सरल है: दिए गए एलिमेंट *id* और *text* के आधार पर, यह DOM एलिमेंट के टेक्स्ट कंटेंट को अपडेट करेगा जिसका `id` मेल खाता है। आइए इस मेथड का उपयोग `login` फ़ंक्शन में पिछले त्रुटि संदेश के स्थान पर करें: ```js if (dataerror) {\nreturn updateElement('loginError', data error);\n}\n```\nअब यदि आप किसी अमान्य खाते के साथ लॉगिन करने का प्रयास करते हैं, तो आपको कुछ ऐसा दिखाई देगा: [लॉगिन के दौरान प्रदर्शित त्रुटि संदेश का स्क्रीनशॉट]( / / / /7-bank-project/3-data/images/login-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 26,
    "total_chunks": 54
  },
  {
    "id": "a5ad267bc4dfc45da1221783e5d4ae55",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "और *text* के आधार पर, यह DOM एलिमेंट के टेक्स्ट कंटेंट को अपडेट करेगा जिसका `id` मेल खाता है। आइए इस मेथड का उपयोग `login` फ़ंक्शन में पिछले त्रुटि संदेश के स्थान पर करें: ```js if (dataerror) { return updateElement('loginError', data error); } ``` अब यदि आप किसी अमान्य खाते के साथ लॉगिन करने का प्रयास करते हैं, तो आपको कुछ ऐसा दिखाई देगा: [लॉगिन के दौरान प्रदर्शित त्रुटि संदेश का स्क्रीनशॉट]( / / / /7-bank-project/3-data/images/login-errorpng)\nअब हमारे पास एक त्रुटि टेक्स्ट है जो दृश्य रूप से दिखाई देता है, लेकिन यदि आप इसे स्क्रीन रीडर के साथ आज़माते हैं, तो आप देखेंगे कि कुछ भी घोषित नहीं किया गया है। पेज पर डायनामिक रूप से जोड़ा गया टेक्स्ट स्क्रीन रीडर द्वारा घोषित किया जाए, इसके लिए इसे [लाइव रीजन](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 607,
    "chunk_index": 27,
    "total_chunks": 54
  },
  {
    "id": "042819680727e1141a7116657357e796",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "का प्रयास करते हैं, तो आपको कुछ ऐसा दिखाई देगा: [लॉगिन के दौरान प्रदर्शित त्रुटि संदेश का स्क्रीनशॉट]( / / / /7-bank-project/3-data/images/login-errorpng) अब हमारे पास एक त्रुटि टेक्स्ट है जो दृश्य रूप से दिखाई देता है, लेकिन यदि आप इसे स्क्रीन रीडर के साथ आज़माते हैं, तो आप देखेंगे कि कुछ भी घोषित नहीं किया गया है। पेज पर डायनामिक रूप से जोड़ा गया टेक्स्ट स्क्रीन रीडर द्वारा घोषित किया जाए, इसके लिए इसे [लाइव रीजन](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 389,
    "chunk_index": 28,
    "total_chunks": 54
  },
  {
    "id": "1d3c643a7d60763c3a3c513ffb9e083a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "का प्रयास करते हैं, तो आपको कुछ ऐसा दिखाई देगा: [लॉगिन के दौरान प्रदर्शित त्रुटि संदेश का स्क्रीनशॉट]( / / / /7-bank-project/3-data/images/login-errorpng) अब हमारे पास एक त्रुटि टेक्स्ट है जो दृश्य रूप से दिखाई देता है, लेकिन यदि आप इसे स्क्रीन रीडर के साथ आज़माते हैं, तो आप देखेंगे कि कुछ भी घोषित नहीं किया गया है। पेज पर डायनामिक रूप से जोड़ा गया टेक्स्ट स्क्रीन रीडर द्वारा घोषित किया जाए, इसके लिए इसे [लाइव रीजन](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) का उपयोग करना होगा। यहां हम एक विशेष प्रकार के लाइव रीजन का उपयोग करेंगे जिसे अलर्ट कहा जाता है:\n```html\n```\n`register` फ़ंक्शन त्रुटियों के लिए भी यही व्यवहार लागू करें (HTML को अपडेट करना न भूलें)।\n## डैशबोर्ड पर जानकारी प्रदर्शित करें\nउपरोक्त तकनीकों का उपयोग करके, हम डैशबोर्ड पेज पर खाता जानकारी प्रदर्शित करने का भी ध्यान रखेंगे।\nसर्वर से प्राप्त खाता ऑब्जेक्ट इस प्रकार दिखता है:\n```json\n{\n\"user\": \"test\",\n\"currency\": \"$\",\n\"description\": \"Test account\",\n\"balance\": 75,\n\"transactions\": [\n{ \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 },\n{ \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 },\n{ \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 }\n],\n}\n```\n> नोट: आपके लिए इसे आसान बनाने के लिए, आप पहले से मौजूद `test` खाते का उपयोग कर सकते हैं जिसमें डेटा पहले से भरा हुआ है।\n### कार्य\nआइए HTML में \"Balance\" सेक्शन को प्लेसहोल्डर एलिमेंट्स जोड़ने के लिए बदलें:\n```html\nBalance:\n```\nहम खाता विवरण प्रदर्शित करने के लिए इसके ठीक नीचे एक नया सेक्शन भी जोड़ेंगे:\n```html\n```\n✅ चूंकि खाता विवरण इसके नीचे की सामग्री के लिए एक शीर्षक के रूप में कार्य करता है, इसे सेमांटिक रूप से एक हेडिंग के रूप में चिह्नित किया गया है। जानें कि [हेडिंग संरचना](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1344,
    "chunk_index": 29,
    "total_chunks": 54
  },
  {
    "id": "b969c27b478c8647e671f9e0f4a8c300",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "जिसमें डेटा पहले से भरा हुआ है। ### कार्य आइए HTML में \"Balance\" सेक्शन को प्लेसहोल्डर एलिमेंट्स जोड़ने के लिए बदलें: ```html Balance: ``` हम खाता विवरण प्रदर्शित करने के लिए इसके ठीक नीचे एक नया सेक्शन भी जोड़ेंगे: ```html ``` ✅ चूंकि खाता विवरण इसके नीचे की सामग्री के लिए एक शीर्षक के रूप में कार्य करता है, इसे सेमांटिक रूप से एक हेडिंग के रूप में चिह्नित किया गया है। जानें कि [हेडिंग संरचना](https://wwwnomensa com/blog/2017/how-structure-headings-web-accessibility) एक्सेसिबिलिटी के लिए क्यों महत्वपूर्ण है, और पेज पर अन्य संभावित हेडिंग की पहचान करें।\nइसके बाद, हम `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 30,
    "total_chunks": 54
  },
  {
    "id": "9a8dd9887d99fb39de138d39f88870a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "बदलें: ```html Balance: ``` हम खाता विवरण प्रदर्शित करने के लिए इसके ठीक नीचे एक नया सेक्शन भी जोड़ेंगे: ```html ``` ✅ चूंकि खाता विवरण इसके नीचे की सामग्री के लिए एक शीर्षक के रूप में कार्य करता है, इसे सेमांटिक रूप से एक हेडिंग के रूप में चिह्नित किया गया है। जानें कि [हेडिंग संरचना](https://wwwnomensa com/blog/2017/how-structure-headings-web-accessibility) एक्सेसिबिलिटी के लिए क्यों महत्वपूर्ण है, और पेज पर अन्य संभावित हेडिंग की पहचान करें। इसके बाद, हम `appjs` में एक नया फ़ंक्शन बनाएंगे जो प्लेसहोल्डर को भर सके:\n```js\nfunction updateDashboard() {\nif ( account) {\nreturn navigate('/login');\n}\nupdateElement('description', account description);\nupdateElement('balance', account balance toFixed(2));\nupdateElement('currency', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 31,
    "total_chunks": 54
  },
  {
    "id": "20afabe2d1dfdd01fb6a626e9c6c8a88",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "लिए एक शीर्षक के रूप में कार्य करता है, इसे सेमांटिक रूप से एक हेडिंग के रूप में चिह्नित किया गया है। जानें कि [हेडिंग संरचना](https://wwwnomensa com/blog/2017/how-structure-headings-web-accessibility) एक्सेसिबिलिटी के लिए क्यों महत्वपूर्ण है, और पेज पर अन्य संभावित हेडिंग की पहचान करें। इसके बाद, हम `appjs` में एक नया फ़ंक्शन बनाएंगे जो प्लेसहोल्डर को भर सके: ```js function updateDashboard() { if ( account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency);\n}\n```\nसबसे पहले, हम यह जांचते हैं कि हमारे पास आवश्यक खाता डेटा है या नहीं। फिर हम पहले बनाए गए `updateElement()` फ़ंक्शन का उपयोग करके HTML को अपडेट करते हैं।\n> बैलेंस डिस्प्ले को सुंदर बनाने के लिए, हम [`toFixed(2)`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 527,
    "chunk_index": 32,
    "total_chunks": 54
  },
  {
    "id": "05f9c62b6763a705804b1c4520736791",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "इसके बाद, हम `appjs` में एक नया फ़ंक्शन बनाएंगे जो प्लेसहोल्डर को भर सके: ```js function updateDashboard() { if ( account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` सबसे पहले, हम यह जांचते हैं कि हमारे पास आवश्यक खाता डेटा है या नहीं। फिर हम पहले बनाए गए `updateElement()` फ़ंक्शन का उपयोग करके HTML को अपडेट करते हैं। > बैलेंस डिस्प्ले को सुंदर बनाने के लिए, हम [`toFixed(2)`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 303,
    "chunk_index": 33,
    "total_chunks": 54
  },
  {
    "id": "3498dc106021b43666d358e80d4e95d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "इसके बाद, हम `appjs` में एक नया फ़ंक्शन बनाएंगे जो प्लेसहोल्डर को भर सके: ```js function updateDashboard() { if ( account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` सबसे पहले, हम यह जांचते हैं कि हमारे पास आवश्यक खाता डेटा है या नहीं। फिर हम पहले बनाए गए `updateElement()` फ़ंक्शन का उपयोग करके HTML को अपडेट करते हैं। > बैलेंस डिस्प्ले को सुंदर बनाने के लिए, हम [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) मेथड का उपयोग करते हैं ताकि मान को दशमलव बिंदु के बाद 2 अंकों के साथ प्रदर्शित किया जा सके।\nअब हमें हर बार डैशबोर्ड लोड होने पर अपने `updateDashboard()` फ़ंक्शन को कॉल करना होगा। यदि आपने [पाठ 1 असाइनमेंट](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 34,
    "total_chunks": 54
  },
  {
    "id": "277bd0deed6dff745f0a03a4a293fcbf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "जांचते हैं कि हमारे पास आवश्यक खाता डेटा है या नहीं। फिर हम पहले बनाए गए `updateElement()` फ़ंक्शन का उपयोग करके HTML को अपडेट करते हैं। > बैलेंस डिस्प्ले को सुंदर बनाने के लिए, हम [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) मेथड का उपयोग करते हैं ताकि मान को दशमलव बिंदु के बाद 2 अंकों के साथ प्रदर्शित किया जा सके। अब हमें हर बार डैशबोर्ड लोड होने पर अपने `updateDashboard()` फ़ंक्शन को कॉल करना होगा। यदि आपने [पाठ 1 असाइनमेंट](/1-template-route/assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 382,
    "chunk_index": 35,
    "total_chunks": 54
  },
  {
    "id": "5241987fecc4cafc5c70bbcc5b765757",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "जांचते हैं कि हमारे पास आवश्यक खाता डेटा है या नहीं। फिर हम पहले बनाए गए `updateElement()` फ़ंक्शन का उपयोग करके HTML को अपडेट करते हैं। > बैलेंस डिस्प्ले को सुंदर बनाने के लिए, हम [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) मेथड का उपयोग करते हैं ताकि मान को दशमलव बिंदु के बाद 2 अंकों के साथ प्रदर्शित किया जा सके। अब हमें हर बार डैशबोर्ड लोड होने पर अपने `updateDashboard()` फ़ंक्शन को कॉल करना होगा। यदि आपने [पाठ 1 असाइनमेंट](/1-template-route/assignmentmd) पहले ही पूरा कर लिया है, तो यह सीधा होगा, अन्यथा आप निम्नलिखित कार्यान्वयन का उपयोग कर सकते हैं।\n`updateRoute()` फ़ंक्शन के अंत में यह कोड जोड़ें:\n```js\nif (typeof route",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 526,
    "chunk_index": 36,
    "total_chunks": 54
  },
  {
    "id": "337db61aba66e86b64be5373d6b44af4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "बनाने के लिए, हम [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) मेथड का उपयोग करते हैं ताकि मान को दशमलव बिंदु के बाद 2 अंकों के साथ प्रदर्शित किया जा सके। अब हमें हर बार डैशबोर्ड लोड होने पर अपने `updateDashboard()` फ़ंक्शन को कॉल करना होगा। यदि आपने [पाठ 1 असाइनमेंट](/1-template-route/assignmentmd) पहले ही पूरा कर लिया है, तो यह सीधा होगा, अन्यथा आप निम्नलिखित कार्यान्वयन का उपयोग कर सकते हैं। `updateRoute()` फ़ंक्शन के अंत में यह कोड जोड़ें: ```js if (typeof routeinit === 'function') {\nroute",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 385,
    "chunk_index": 37,
    "total_chunks": 54
  },
  {
    "id": "33c55274e76f6997bc9585eaed0d950f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) मेथड का उपयोग करते हैं ताकि मान को दशमलव बिंदु के बाद 2 अंकों के साथ प्रदर्शित किया जा सके। अब हमें हर बार डैशबोर्ड लोड होने पर अपने `updateDashboard()` फ़ंक्शन को कॉल करना होगा। यदि आपने [पाठ 1 असाइनमेंट](/1-template-route/assignmentmd) पहले ही पूरा कर लिया है, तो यह सीधा होगा, अन्यथा आप निम्नलिखित कार्यान्वयन का उपयोग कर सकते हैं। `updateRoute()` फ़ंक्शन के अंत में यह कोड जोड़ें: ```js if (typeof routeinit === 'function') { routeinit();\n}\n```\nऔर रूट्स परिभाषा को अपडेट करें:\n```js\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: updateDashboard }\n};\n```\nइस बदलाव के साथ, हर बार जब डैशबोर्ड पेज प्रदर्शित होता है, तो `updateDashboard()` फ़ंक्शन को कॉल किया जाता है। लॉगिन के बाद, आपको खाता बैलेंस, मुद्रा और विवरण देखना चाहिए।\n## HTML टेम्पलेट्स के साथ डायनामिक रूप से टेबल रो बनाएं\n[पहले पाठ](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 660,
    "chunk_index": 38,
    "total_chunks": 54
  },
  {
    "id": "4705d7db388b910ba60014e630d01bc4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "routeinit === 'function') { routeinit(); } ``` और रूट्स परिभाषा को अपडेट करें: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` इस बदलाव के साथ, हर बार जब डैशबोर्ड पेज प्रदर्शित होता है, तो `updateDashboard()` फ़ंक्शन को कॉल किया जाता है। लॉगिन के बाद, आपको खाता बैलेंस, मुद्रा और विवरण देखना चाहिए। ## HTML टेम्पलेट्स के साथ डायनामिक रूप से टेबल रो बनाएं [पहले पाठ](/1-template-route/README md) में हमने अपने ऐप में नेविगेशन को लागू करने के लिए HTML टेम्पलेट्स और [`appendChild()`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 369,
    "chunk_index": 39,
    "total_chunks": 54
  },
  {
    "id": "f63d80b291232fb394e869268947955f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "{ '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` इस बदलाव के साथ, हर बार जब डैशबोर्ड पेज प्रदर्शित होता है, तो `updateDashboard()` फ़ंक्शन को कॉल किया जाता है। लॉगिन के बाद, आपको खाता बैलेंस, मुद्रा और विवरण देखना चाहिए। ## HTML टेम्पलेट्स के साथ डायनामिक रूप से टेबल रो बनाएं [पहले पाठ](/1-template-route/README md) में हमने अपने ऐप में नेविगेशन को लागू करने के लिए HTML टेम्पलेट्स और [`appendChild()`](https://developer mozillaorg/docs/Web/API/Node/appendChild) मेथड का उपयोग किया था। टेम्पलेट्स छोटे भी हो सकते हैं और पेज के रिपिटिटिव हिस्सों को डायनामिक रूप से पॉप्युलेट करने के लिए उपयोग किए जा सकते हैं।\nहम HTML टेबल में लेन-देन की सूची प्रदर्शित करने के लिए इसी दृष्टिकोण का उपयोग करेंगे।\n### कार्य\nHTML `` में एक नया टेम्पलेट जोड़ें:\n```html\n```\nयह टेम्पलेट एक सिंगल टेबल रो का प्रतिनिधित्व करता है, जिसमें लेन-देन के *date*, *object* और *amount* के लिए 3 कॉलम हैं।\nफिर, टेबल के `` एलिमेंट में यह `id` प्रॉपर्टी जोड़ें ताकि इसे जावास्क्रिप्ट का उपयोग करके आसानी से ढूंढा जा सके:\n```html\n```\nहमारा HTML तैयार है, अब जावास्क्रिप्ट कोड पर स्विच करें और एक नया फ़ंक्शन `createTransactionRow` बनाएं:\n```js\nfunction createTransactionRow(transaction) {\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 908,
    "chunk_index": 40,
    "total_chunks": 54
  },
  {
    "id": "6882711d64e21e765db6cfdd31f160fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "में एक नया टेम्पलेट जोड़ें: ```html ``` यह टेम्पलेट एक सिंगल टेबल रो का प्रतिनिधित्व करता है, जिसमें लेन-देन के *date*, *object* और *amount* के लिए 3 कॉलम हैं। फिर, टेबल के `` एलिमेंट में यह `id` प्रॉपर्टी जोड़ें ताकि इसे जावास्क्रिप्ट का उपयोग करके आसानी से ढूंढा जा सके: ```html ``` हमारा HTML तैयार है, अब जावास्क्रिप्ट कोड पर स्विच करें और एक नया फ़ंक्शन `createTransactionRow` बनाएं: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction');\nconst transactionRow = template content cloneNode(true);\nconst tr = transactionRow querySelector('tr');\ntr children[0] textContent = transaction date;\ntr children[1] textContent = transaction object;\ntr children[2] textContent = transaction amount",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 395,
    "chunk_index": 41,
    "total_chunks": 54
  },
  {
    "id": "2e84ccdc1399211cfc7dd7f7a1242ec9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "फिर, टेबल के `` एलिमेंट में यह `id` प्रॉपर्टी जोड़ें ताकि इसे जावास्क्रिप्ट का उपयोग करके आसानी से ढूंढा जा सके: ```html ``` हमारा HTML तैयार है, अब जावास्क्रिप्ट कोड पर स्विच करें और एक नया फ़ंक्शन `createTransactionRow` बनाएं: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transaction amounttoFixed(2);\nreturn transactionRow;\n}\n```\nयह फ़ंक्शन वही करता है जो इसका नाम बताता है: पहले बनाए गए टेम्पलेट का उपयोग करके, यह एक नया टेबल रो बनाता है और लेन-देन डेटा का उपयोग करके इसकी सामग्री भरता है। हम अपने `updateDashboard()` फ़ंक्शन में इसको टेबल पॉप्युलेट करने के लिए उपयोग करेंगे:\n```js\nconst transactionsRows = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 514,
    "chunk_index": 42,
    "total_chunks": 54
  },
  {
    "id": "5ee764b76c3ac72d8b4569cb322881ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transaction amounttoFixed(2); return transactionRow; } ``` यह फ़ंक्शन वही करता है जो इसका नाम बताता है: पहले बनाए गए टेम्पलेट का उपयोग करके, यह एक नया टेबल रो बनाता है और लेन-देन डेटा का उपयोग करके इसकी सामग्री भरता है। हम अपने `updateDashboard()` फ़ंक्शन में इसको टेबल पॉप्युलेट करने के लिए उपयोग करेंगे: ```js const transactionsRows = documentcreateDocumentFragment();\nfor (const transaction of account transactions) {\nconst transactionRow = createTransactionRow(transaction);\ntransactionsRows appendChild(transactionRow);\n}\nupdateElement('transactions', transactionsRows);\n```\nयहां हम [`document createDocumentFragment()`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 346,
    "chunk_index": 43,
    "total_chunks": 54
  },
  {
    "id": "88f6f50f60063b67b331f18f0e00cb09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "} ``` यह फ़ंक्शन वही करता है जो इसका नाम बताता है: पहले बनाए गए टेम्पलेट का उपयोग करके, यह एक नया टेबल रो बनाता है और लेन-देन डेटा का उपयोग करके इसकी सामग्री भरता है। हम अपने `updateDashboard()` फ़ंक्शन में इसको टेबल पॉप्युलेट करने के लिए उपयोग करेंगे: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRows appendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` यहां हम [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment) मेथड का उपयोग करते हैं, जो एक नया DOM फ्रैगमेंट बनाता है जिस पर हम काम कर सकते हैं, और अंत में इसे अपनी HTML टेबल में अटैच कर सकते हैं।\nइस कोड को काम करने के लिए, हमें अपने `updateElement()` फ़ंक्शन को थोड़ा बदलना होगा, क्योंकि यह वर्तमान में केवल टेक्स्ट कंटेंट को सपोर्ट करता है। इसका कोड इस प्रकार बदलें:\n```js\nfunction updateElement(id, textOrNode) {\nconst element = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 604,
    "chunk_index": 44,
    "total_chunks": 54
  },
  {
    "id": "7e7a7ea29e59b68c3f1ea3346822a20c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "यहां हम [`document createDocumentFragment()`](https://developer mozillaorg/docs/Web/API/Document/createDocumentFragment) मेथड का उपयोग करते हैं, जो एक नया DOM फ्रैगमेंट बनाता है जिस पर हम काम कर सकते हैं, और अंत में इसे अपनी HTML टेबल में अटैच कर सकते हैं। इस कोड को काम करने के लिए, हमें अपने `updateElement()` फ़ंक्शन को थोड़ा बदलना होगा, क्योंकि यह वर्तमान में केवल टेक्स्ट कंटेंट को सपोर्ट करता है। इसका कोड इस प्रकार बदलें: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id);\nelement textContent = ''; // Removes all children\nelement append(textOrNode);\n}\n```\nहम [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) मेथड का उपयोग करते हैं क्योंकि यह पैरेंट एलिमेंट में टेक्स्ट या [DOM Nodes](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 437,
    "chunk_index": 45,
    "total_chunks": 54
  },
  {
    "id": "b0ffb79d82041c8f9cb0f24a53b07725",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "में अटैच कर सकते हैं। इस कोड को काम करने के लिए, हमें अपने `updateElement()` फ़ंक्शन को थोड़ा बदलना होगा, क्योंकि यह वर्तमान में केवल टेक्स्ट कंटेंट को सपोर्ट करता है। इसका कोड इस प्रकार बदलें: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` हम [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append) मेथड का उपयोग करते हैं क्योंकि यह पैरेंट एलिमेंट में टेक्स्ट या [DOM Nodes](https://developer mozillaorg/docs/Web/API/Node) दोनों को अटैच करने की अनुमति देता है, जो हमारे सभी उपयोग मामलों के लिए उपयुक्त है।\nयदि आप `test` अकाउंट का उपयोग करके लॉगिन करते हैं, तो अब आपको डैशबोर्ड पर लेन-देन की सूची दिखाई देनी चाहिए 🎉।\n---\n## 🚀 चुनौती\nमिलकर काम करें ताकि डैशबोर्ड पेज एक असली बैंकिंग ऐप जैसा दिखे। यदि आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 659,
    "chunk_index": 46,
    "total_chunks": 54
  },
  {
    "id": "9962682fedd5fa74473e5cfdd1521484",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "एलिमेंट में टेक्स्ट या [DOM Nodes](https://developer mozillaorg/docs/Web/API/Node) दोनों को अटैच करने की अनुमति देता है, जो हमारे सभी उपयोग मामलों के लिए उपयुक्त है। यदि आप `test` अकाउंट का उपयोग करके लॉगिन करते हैं, तो अब आपको डैशबोर्ड पर लेन-देन की सूची दिखाई देनी चाहिए 🎉। --- ## 🚀 चुनौती मिलकर काम करें ताकि डैशबोर्ड पेज एक असली बैंकिंग ऐप जैसा दिखे। यदि आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 438,
    "chunk_index": 47,
    "total_chunks": 54
  },
  {
    "id": "8e23c51fe5f220539672b094f5cc4956",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "दोनों को अटैच करने की अनुमति देता है, जो हमारे सभी उपयोग मामलों के लिए उपयुक्त है। यदि आप `test` अकाउंट का उपयोग करके लॉगिन करते हैं, तो अब आपको डैशबोर्ड पर लेन-देन की सूची दिखाई देनी चाहिए 🎉। --- ## 🚀 चुनौती मिलकर काम करें ताकि डैशबोर्ड पेज एक असली बैंकिंग ऐप जैसा दिखे। यदि आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) बनाने की कोशिश करें, जो डेस्कटॉप और मोबाइल दोनों डिवाइस पर अच्छे से काम करे।\nयहां एक स्टाइल किए गए डैशबोर्ड पेज का उदाहरण है:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 48,
    "total_chunks": 54
  },
  {
    "id": "65a04cb1b3b2f7bfeb0c8086c6c8f736",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "करते हैं, तो अब आपको डैशबोर्ड पर लेन-देन की सूची दिखाई देनी चाहिए 🎉। --- ## 🚀 चुनौती मिलकर काम करें ताकि डैशबोर्ड पेज एक असली बैंकिंग ऐप जैसा दिखे। यदि आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) बनाने की कोशिश करें, जो डेस्कटॉप और मोबाइल दोनों डिवाइस पर अच्छे से काम करे। यहां एक स्टाइल किए गए डैशबोर्ड पेज का उदाहरण है:[डैशबोर्ड के स्टाइलिंग के बाद का उदाहरण परिणाम का स्क्रीनशॉट]( / / / /7-bank-project/images/screen2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 49,
    "total_chunks": 54
  },
  {
    "id": "d70297f32cc0b3dfe097781b64754fc2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "🎉। --- ## 🚀 चुनौती मिलकर काम करें ताकि डैशबोर्ड पेज एक असली बैंकिंग ऐप जैसा दिखे। यदि आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) बनाने की कोशिश करें, जो डेस्कटॉप और मोबाइल दोनों डिवाइस पर अच्छे से काम करे। यहां एक स्टाइल किए गए डैशबोर्ड पेज का उदाहरण है:[डैशबोर्ड के स्टाइलिंग के बाद का उदाहरण परिणाम का स्क्रीनशॉट]( / / / /7-bank-project/images/screen2png)\n## पोस्ट-लेक्चर क्विज़\n[पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 482,
    "chunk_index": 50,
    "total_chunks": 54
  },
  {
    "id": "a24f47bb7a2483fa064f8cb4890826ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "करें ताकि डैशबोर्ड पेज एक असली बैंकिंग ऐप जैसा दिखे। यदि आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) बनाने की कोशिश करें, जो डेस्कटॉप और मोबाइल दोनों डिवाइस पर अच्छे से काम करे। यहां एक स्टाइल किए गए डैशबोर्ड पेज का उदाहरण है:[डैशबोर्ड के स्टाइलिंग के बाद का उदाहरण परिणाम का स्क्रीनशॉट]( / / / /7-bank-project/images/screen2png) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/46)\n## असाइनमेंट\n[अपने कोड को रिफैक्टर करें और उसमें कमेंट जोड़ें](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 526,
    "chunk_index": 51,
    "total_chunks": 54
  },
  {
    "id": "bb9304ec08ae8676feeeeff83ddc5c90",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "आपने पहले ही अपने ऐप को स्टाइल कर लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) बनाने की कोशिश करें, जो डेस्कटॉप और मोबाइल दोनों डिवाइस पर अच्छे से काम करे। यहां एक स्टाइल किए गए डैशबोर्ड पेज का उदाहरण है:[डैशबोर्ड के स्टाइलिंग के बाद का उदाहरण परिणाम का स्क्रीनशॉट]( / / / /7-bank-project/images/screen2png) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/46) ## असाइनमेंट [अपने कोड को रिफैक्टर करें और उसमें कमेंट जोड़ें](assignmentmd)\n**अस्वीकरण**:\nयह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 512,
    "chunk_index": 52,
    "total_chunks": 54
  },
  {
    "id": "2e93358df1b575b608a26b5858121ee2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 3: डेटा प्राप्त करने और उपयोग करने के तरीके",
    "content": "लिया है, तो [मीडिया क्वेरीज़](https://developermozilla org/docs/Web/CSS/Media_Queries) का उपयोग करके [रिस्पॉन्सिव डिज़ाइन](https://developer mozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) बनाने की कोशिश करें, जो डेस्कटॉप और मोबाइल दोनों डिवाइस पर अच्छे से काम करे। यहां एक स्टाइल किए गए डैशबोर्ड पेज का उदाहरण है:[डैशबोर्ड के स्टाइलिंग के बाद का उदाहरण परिणाम का स्क्रीनशॉट]( / / / /7-bank-project/images/screen2png) ## पोस्ट-लेक्चर क्विज़ [पोस्ट-लेक्चर क्विज़](https://ashy-river-0debb7803 1 azurestaticappsnet/quiz/46) ## असाइनमेंट [अपने कोड को रिफैक्टर करें और उसमें कमेंट जोड़ें](assignmentmd) **अस्वीकरण**: यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://githubcom/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 35409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 874,
    "chunk_index": 53,
    "total_chunks": 54
  },
  {
    "id": "d5da2aa3a935b970604f5799f2e97700",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\solution\\README.md",
    "source_type": "git_repo",
    "title": "बैंक ऐप",
    "content": "बैंक ऐप\nबैंक ऐप प्रोजेक्ट के लिए उदाहरण समाधान, जो वैनिला HTML5, CSS और JavaScript (कोई फ्रेमवर्क या लाइब्रेरी का उपयोग नहीं) के साथ बनाया गया है।\nऐप चलाना\nसबसे पहले सुनिश्चित करें कि आपके पास API सर्वर चालू है।\nऐप चलाने के लिए किसी भी वेब सर्वर का उपयोग किया जा सकता है, लेकिन चूंकि आपके पास Node js पहले से ही API चलाने के लिए इंस्टॉल होना चाहिए, आप ऐसा कर सकते हैं:\nइस रिपॉजिटरी को Git क्लोन करें।\nएक टर्मिनल खोलें, इस डायरेक्टरी पर जाएं, फिर npx lite-server",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 411,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "c6899d00baa1cbb3b735a554abe42ace",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\solution\\README.md",
    "source_type": "git_repo",
    "title": "बैंक ऐप",
    "content": "(कोई फ्रेमवर्क या लाइब्रेरी का उपयोग नहीं) के साथ बनाया गया है। ऐप चलाना सबसे पहले सुनिश्चित करें कि आपके पास API सर्वर चालू है। ऐप चलाने के लिए किसी भी वेब सर्वर का उपयोग किया जा सकता है, लेकिन चूंकि आपके पास Node js पहले से ही API चलाने के लिए इंस्टॉल होना चाहिए, आप ऐसा कर सकते हैं: इस रिपॉजिटरी को Git क्लोन करें। एक टर्मिनल खोलें, इस डायरेक्टरी पर जाएं, फिर npx lite-serverचलाएं। यह पोर्ट 3000 पर एक डेवलपमेंट वेब सर्वर शुरू करेगा।\nऐप चलाने के लिए ब्राउज़र में http://localhost:3000 खोलें।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 854,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "8ec04ecedf2e5ca0da5f0cda3e0c28af",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "बैंक API",
    "content": "बैंक API\nNode js + Express के साथ बनाया गया बैंक API।\nयह API पहले से ही बनाई गई है और यह अभ्यास का हिस्सा नहीं है।\nहालांकि, यदि आप इस तरह का API बनाना सीखने में रुचि रखते हैं, तो आप इस वीडियो श्रृंखला को देख सकते हैं: https://aka ms/NodeBeginner (वीडियो 17 से 21 तक इस API को कवर करते हैं)।\nआप इस इंटरएक्टिव ट्यूटोरियल को भी देख सकते हैं: https://aka ms/learn/express-api\nसर्वर चलाना\nसुनिश्चित करें कि आपके पास Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4953,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 339,
    "chunk_index": 0,
    "total_chunks": 3
  },
  {
    "id": "9e8f8f6ff078eaf5addae2ac80ec1688",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "बैंक API",
    "content": "Express के साथ बनाया गया बैंक API। यह API पहले से ही बनाई गई है और यह अभ्यास का हिस्सा नहीं है। हालांकि, यदि आप इस तरह का API बनाना सीखने में रुचि रखते हैं, तो आप इस वीडियो श्रृंखला को देख सकते हैं: https://aka ms/NodeBeginner (वीडियो 17 से 21 तक इस API को कवर करते हैं)। आप इस इंटरएक्टिव ट्यूटोरियल को भी देख सकते हैं: https://aka ms/learn/express-api सर्वर चलाना सुनिश्चित करें कि आपके पास Nodejs इंस्टॉल है।\nइस रिपॉजिटरी को क्लोन करें The Web-Dev-For-Beginners।\nअपना टर्मिनल खोलें और Web-Dev-For-Beginners/7-bank-project/api फोल्डर में जाएं।\nnpm install चलाएं और पैकेज इंस्टॉल होने का इंतजार करें (यह आपके इंटरनेट कनेक्शन की गुणवत्ता पर निर्भर करते हुए थोड़ा समय ले सकता है)।\nजब इंस्टॉलेशन पूरा हो जाए, तो npm start चलाएं और आप तैयार हैं।\nसर्वर पोर्ट 5000 पर सुनना शुरू कर देगा।\nयह सर्वर मुख्य बैंक ऐप सर्वर टर्मिनल (जो पोर्ट 3000 पर सुन रहा होगा) के साथ चल रहा होगा, इसे बंद न करें।\nनोट: सभी एंट्री इन-मेमोरी में स्टोर होती हैं और संरक्षित नहीं होती हैं, इसलिए जब सर्वर बंद हो जाता है तो सभी डेटा खो जाता है।\nAPI विवरण\nरूट                                         | विवरण\n---------------------------------------------|------------------------------------\nGET    /api/                                 | सर्वर जानकारी प्राप्त करें\nPOST   /api/accounts/                        | एक खाता बनाएं, उदाहरण: { user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 }\nGET    /api/accounts/:user                   | निर्दिष्ट खाते के लिए सभी डेटा प्राप्त करें\nDELETE /api/accounts/:user                   | निर्दिष्ट खाता हटाएं\nPOST   /api/accounts/:user/transactions      | एक लेन-देन जोड़ें, उदाहरण: { date: '2020-07-23T18:25:43",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4953,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1129,
    "chunk_index": 1,
    "total_chunks": 3
  },
  {
    "id": "bbad7fddfbf9ac7b9aa83439dd1b3b9d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "बैंक API",
    "content": "और संरक्षित नहीं होती हैं, इसलिए जब सर्वर बंद हो जाता है तो सभी डेटा खो जाता है। API विवरण रूट | विवरण ---------------------------------------------|------------------------------------ GET /api/ | सर्वर जानकारी प्राप्त करें POST /api/accounts/ | एक खाता बनाएं, उदाहरण: { user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 } GET /api/accounts/:user | निर्दिष्ट खाते के लिए सभी डेटा प्राप्त करें DELETE /api/accounts/:user | निर्दिष्ट खाता हटाएं POST /api/accounts/:user/transactions | एक लेन-देन जोड़ें, उदाहरण: { date: '2020-07-23T18:25:43511Z', object: 'Bought a book', amount: -20 }\nDELETE  /api/accounts/:user/transactions/:id | निर्दिष्ट लेन-देन हटाएं\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4953,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 792,
    "chunk_index": 2,
    "total_chunks": 3
  },
  {
    "id": "ed1c58efa17bd2c5b29490481f6dde1c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\assignment.md",
    "source_type": "git_repo",
    "title": "एक खेल का नमूना तैयार करें",
    "content": "एक खेल का नमूना तैयार करें\nनिर्देश\nपाठ में दिए गए कोड नमूनों का उपयोग करके, उस खेल का एक प्रतिनिधित्व लिखें जिसे आप पसंद करते हैं। यह एक साधारण खेल होना चाहिए, लेकिन लक्ष्य यह है कि या तो क्लास या कंपोज़िशन पैटर्न और पब/सब पैटर्न का उपयोग करके दिखाया जाए कि खेल कैसे शुरू हो सकता है। रचनात्मक बनें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3159,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 299,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "5cee045d1f8986d352dd66ddac416119",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\assignment.md",
    "source_type": "git_repo",
    "title": "एक खेल का नमूना तैयार करें",
    "content": "एक खेल का नमूना तैयार करें\nनिर्देश\nपाठ में दिए गए कोड नमूनों का उपयोग करके, उस खेल का एक प्रतिनिधित्व लिखें जिसे आप पसंद करते हैं। यह एक साधारण खेल होना चाहिए, लेकिन लक्ष्य यह है कि या तो क्लास या कंपोज़िशन पैटर्न और पब/सब पैटर्न का उपयोग करके दिखाया जाए कि खेल कैसे शुरू हो सकता है। रचनात्मक बनेंमूल्यांकन मानदंड\n| मानदंड | उत्कृष्टता                                               | पर्याप्तता                                              | सुधार की आवश्यकता                                   |\n| -------- | ------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------- |\n|          | तीन तत्व स्क्रीन पर रखे गए हैं और उन्हें संचालित किया गया है | दो तत्व स्क्रीन पर रखे गए हैं और उन्हें संचालित किया गया है | एक तत्व स्क्रीन पर रखा गया है और उसे संचालित किया गया है |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3159,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 984,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "5d4a5c350e4153e38afa8b43df67c532",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nजैसे-जैसे एक वेब एप्लिकेशन बढ़ता है, डेटा प्रवाह को ट्रैक करना चुनौतीपूर्ण हो जाता है। कौन सा कोड डेटा प्राप्त करता है, कौन सा पेज इसे उपयोग करता है, इसे कब और कहाँ अपडेट करने की आवश्यकता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 292,
    "chunk_index": 0,
    "total_chunks": 36
  },
  {
    "id": "7b26dfd1c850cdcd2845a6205190ba3f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nजैसे-जैसे एक वेब एप्लिकेशन बढ़ता है, डेटा प्रवाह को ट्रैक करना चुनौतीपूर्ण हो जाता है। कौन सा कोड डेटा प्राप्त करता है, कौन सा पेज इसे उपयोग करता है, इसे कब और कहाँ अपडेट करने की आवश्यकता हैयह आसानी से गड़बड़ कोड में बदल सकता है जिसे बनाए रखना मुश्किल है। यह विशेष रूप से तब सच है जब आपको अपने ऐप के विभिन्न पेजों के बीच डेटा साझा करने की आवश्यकता होती है, जैसे उपयोगकर्ता डेटा। स्टेट मैनेजमेंट की अवधारणा हमेशा सभी प्रकार के प्रोग्रामों में मौजूद रही है, लेकिन जैसे-जैसे वेब ऐप्स की जटिलता बढ़ती जा रही है, यह अब विकास के दौरान विचार करने का एक प्रमुख बिंदु बन गया है।\nइस अंतिम भाग में, हम उस ऐप पर विचार करेंगे जिसे हमने बनाया है ताकि स्टेट को बेहतर तरीके से प्रबंधित किया जा सके, जिससे ब्राउज़र को किसी भी समय रिफ्रेश करने का समर्थन मिले और उपयोगकर्ता सत्रों के बीच डेटा को बनाए रखा जा सके।\nपूर्वापेक्षा\nआपको इस पाठ के लिए वेब ऐप के डेटा फेचिंग भाग को पूरा करना होगा। आपको Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 975,
    "chunk_index": 1,
    "total_chunks": 36
  },
  {
    "id": "2d658f2f5b8707d25796f5e7d6a650c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "विकास के दौरान विचार करने का एक प्रमुख बिंदु बन गया है। इस अंतिम भाग में, हम उस ऐप पर विचार करेंगे जिसे हमने बनाया है ताकि स्टेट को बेहतर तरीके से प्रबंधित किया जा सके, जिससे ब्राउज़र को किसी भी समय रिफ्रेश करने का समर्थन मिले और उपयोगकर्ता सत्रों के बीच डेटा को बनाए रखा जा सके। पूर्वापेक्षा आपको इस पाठ के लिए वेब ऐप के डेटा फेचिंग भाग को पूरा करना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API को लोकल रूप से चलाना होगा ताकि आप अकाउंट डेटा प्रबंधित कर सकें।\nआप यह कमांड टर्मिनल में चलाकर जांच सकते हैं कि सर्वर सही तरीके से चल रहा है:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 2,
    "total_chunks": 36
  },
  {
    "id": "c082ce4f07365579183a16fd8c770bcf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "समर्थन मिले और उपयोगकर्ता सत्रों के बीच डेटा को बनाए रखा जा सके। पूर्वापेक्षा आपको इस पाठ के लिए वेब ऐप के डेटा फेचिंग भाग को पूरा करना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API को लोकल रूप से चलाना होगा ताकि आप अकाउंट डेटा प्रबंधित कर सकें। आप यह कमांड टर्मिनल में चलाकर जांच सकते हैं कि सर्वर सही तरीके से चल रहा है: ```sh curl http://localhost:5000/api -> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 324,
    "chunk_index": 3,
    "total_chunks": 36
  },
  {
    "id": "75a64a139c7c055f03d7dcb71f163b96",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "समर्थन मिले और उपयोगकर्ता सत्रों के बीच डेटा को बनाए रखा जा सके। पूर्वापेक्षा आपको इस पाठ के लिए वेब ऐप के डेटा फेचिंग भाग को पूरा करना होगा। आपको Nodejs इंस्टॉल करना होगा और सर्वर API को लोकल रूप से चलाना होगा ताकि आप अकाउंट डेटा प्रबंधित कर सकें। आप यह कमांड टर्मिनल में चलाकर जांच सकते हैं कि सर्वर सही तरीके से चल रहा है: ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result\n```\nस्टेट मैनेजमेंट पर पुनर्विचार\nपिछले पाठ में, हमने अपने ऐप में स्टेट की एक बुनियादी अवधारणा पेश की थी जिसमें account नामक एक ग्लोबल वेरिएबल था जो वर्तमान में लॉग इन किए गए उपयोगकर्ता के बैंक डेटा को संग्रहीत करता है। हालांकि, हमारे वर्तमान कार्यान्वयन में कुछ खामियां हैं। डैशबोर्ड पर रहते हुए पेज को रिफ्रेश करने का प्रयास करें। क्या होता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 4,
    "total_chunks": 36
  },
  {
    "id": "c7bdee9ba259364d228a2508ab5dbaba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` स्टेट मैनेजमेंट पर पुनर्विचार पिछले पाठ में, हमने अपने ऐप में स्टेट की एक बुनियादी अवधारणा पेश की थी जिसमें account नामक एक ग्लोबल वेरिएबल था जो वर्तमान में लॉग इन किए गए उपयोगकर्ता के बैंक डेटा को संग्रहीत करता है। हालांकि, हमारे वर्तमान कार्यान्वयन में कुछ खामियां हैं। डैशबोर्ड पर रहते हुए पेज को रिफ्रेश करने का प्रयास करें। क्या होता हैवर्तमान कोड में 3 समस्याएं हैं:\nस्टेट संरक्षित नहीं है, क्योंकि ब्राउज़र रिफ्रेश आपको लॉगिन पेज पर वापस ले जाता है।\nस्टेट को संशोधित करने वाले कई फंक्शन हैं। जैसे-जैसे ऐप बढ़ता है, यह परिवर्तनों को ट्रैक करना मुश्किल बना सकता है और एक को अपडेट करना भूलना आसान हो जाता है।\nस्टेट साफ नहीं किया गया है, इसलिए जब आप लॉगआउट पर क्लिक करते हैं तो अकाउंट डेटा अभी भी वहां होता है, भले ही आप लॉगिन पेज पर हों।\nहम इन समस्याओं को एक-एक करके हल करने के लिए अपने कोड को अपडेट कर सकते हैं, लेकिन इससे कोड का अधिक डुप्लीकेशन होगा और ऐप अधिक जटिल और बनाए रखने में कठिन हो जाएगा। या हम कुछ मिनटों के लिए रुक सकते हैं और अपनी रणनीति पर पुनर्विचार कर सकते हैं।\nहम वास्तव में यहां कौन सी समस्याओं को हल करने की कोशिश कर रहे हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1036,
    "chunk_index": 5,
    "total_chunks": 36
  },
  {
    "id": "b1599fadadf0d6581156930941a9ddbf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "होता है, भले ही आप लॉगिन पेज पर हों। हम इन समस्याओं को एक-एक करके हल करने के लिए अपने कोड को अपडेट कर सकते हैं, लेकिन इससे कोड का अधिक डुप्लीकेशन होगा और ऐप अधिक जटिल और बनाए रखने में कठिन हो जाएगा। या हम कुछ मिनटों के लिए रुक सकते हैं और अपनी रणनीति पर पुनर्विचार कर सकते हैं। हम वास्तव में यहां कौन सी समस्याओं को हल करने की कोशिश कर रहे हैंस्टेट मैनेजमेंट का उद्देश्य इन दो विशेष समस्याओं को हल करने के लिए एक अच्छा दृष्टिकोण खोजना है:\nऐप में डेटा प्रवाह को समझने योग्य कैसे रखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 463,
    "chunk_index": 6,
    "total_chunks": 36
  },
  {
    "id": "039a28191c17712dcd5d2ae4e33b8705",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "लेकिन इससे कोड का अधिक डुप्लीकेशन होगा और ऐप अधिक जटिल और बनाए रखने में कठिन हो जाएगा। या हम कुछ मिनटों के लिए रुक सकते हैं और अपनी रणनीति पर पुनर्विचार कर सकते हैं। हम वास्तव में यहां कौन सी समस्याओं को हल करने की कोशिश कर रहे हैंस्टेट मैनेजमेंट का उद्देश्य इन दो विशेष समस्याओं को हल करने के लिए एक अच्छा दृष्टिकोण खोजना है: ऐप में डेटा प्रवाह को समझने योग्य कैसे रखेंस्टेट डेटा को हमेशा उपयोगकर्ता इंटरफ़ेस के साथ (और इसके विपरीत) सिंक में कैसे रखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 7,
    "total_chunks": 36
  },
  {
    "id": "bf359468e5a62383a3f1ce5837590343",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "में कठिन हो जाएगा। या हम कुछ मिनटों के लिए रुक सकते हैं और अपनी रणनीति पर पुनर्विचार कर सकते हैं। हम वास्तव में यहां कौन सी समस्याओं को हल करने की कोशिश कर रहे हैंस्टेट मैनेजमेंट का उद्देश्य इन दो विशेष समस्याओं को हल करने के लिए एक अच्छा दृष्टिकोण खोजना है: ऐप में डेटा प्रवाह को समझने योग्य कैसे रखेंस्टेट डेटा को हमेशा उपयोगकर्ता इंटरफ़ेस के साथ (और इसके विपरीत) सिंक में कैसे रखेंएक बार जब आप इनका ध्यान रख लेते हैं, तो आपके पास जो अन्य समस्याएं हो सकती हैं, वे या तो पहले ही हल हो चुकी होंगी या उन्हें हल करना आसान हो गया होगा। इन समस्याओं को हल करने के लिए कई संभावित दृष्टिकोण हैं, लेकिन हम एक सामान्य समाधान के साथ जाएंगे जिसमें डेटा और इसे बदलने के तरीकों को केंद्रीकृत करना शामिल है। डेटा प्रवाह इस प्रकार होगा:\nहम यहां उस हिस्से को कवर नहीं करेंगे जहां डेटा स्वचालित रूप से व्यू अपडेट को ट्रिगर करता है, क्योंकि यह रिएक्टिव प्रोग्रामिंग की अधिक उन्नत अवधारणाओं से जुड़ा हुआ है। यदि आप गहराई से अध्ययन करने के इच्छुक हैं, तो यह एक अच्छा विषय है।\n✅ स्टेट मैनेजमेंट के लिए कई लाइब्रेरी उपलब्ध हैं, जिनमें Redux एक लोकप्रिय विकल्प है। इसके उपयोग किए गए अवधारणाओं और पैटर्न को देखें क्योंकि यह अक्सर यह समझने का एक अच्छा तरीका होता है कि बड़े वेब ऐप्स में आप किन संभावित समस्याओं का सामना कर सकते हैं और उन्हें कैसे हल किया जा सकता है।\nकार्य\nहम थोड़ा रिफैक्टरिंग से शुरुआत करेंगे। account डिक्लेरेशन को बदलें:\njs\nlet account = null;\nसे:\njs\nlet state = {\naccount: null\n};\nयह विचार हमारे ऐप डेटा को एक सिंगल स्टेट ऑब्जेक्ट में केंद्रीकृत करने का है। फिलहाल हमारे पास स्टेट में केवल account है, इसलिए यह ज्यादा नहीं बदलता है, लेकिन यह विकास के लिए एक रास्ता बनाता है।\nहमें इसका उपयोग करने वाले फंक्शन को भी अपडेट करना होगा। register() और login() फंक्शन में, account =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1556,
    "chunk_index": 8,
    "total_chunks": 36
  },
  {
    "id": "2e73a43c98a8cd2df3f1949022d7acb7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "शुरुआत करेंगे। account डिक्लेरेशन को बदलें: js let account = null; से: js let state = { account: null }; यह विचार हमारे ऐप डेटा को एक सिंगल स्टेट ऑब्जेक्ट में केंद्रीकृत करने का है। फिलहाल हमारे पास स्टेट में केवल account है, इसलिए यह ज्यादा नहीं बदलता है, लेकिन यह विकास के लिए एक रास्ता बनाता है। हमें इसका उपयोग करने वाले फंक्शन को भी अपडेट करना होगा। register() और login() फंक्शन में, account =को state account = से बदलें;\nupdateDashboard() फंक्शन के शीर्ष पर, यह लाइन जोड़ें:\njs\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 372,
    "chunk_index": 9,
    "total_chunks": 36
  },
  {
    "id": "6054581192c19142d18ada588d84a234",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "null }; यह विचार हमारे ऐप डेटा को एक सिंगल स्टेट ऑब्जेक्ट में केंद्रीकृत करने का है। फिलहाल हमारे पास स्टेट में केवल account है, इसलिए यह ज्यादा नहीं बदलता है, लेकिन यह विकास के लिए एक रास्ता बनाता है। हमें इसका उपयोग करने वाले फंक्शन को भी अपडेट करना होगा। register() और login() फंक्शन में, account =को state account = से बदलें; updateDashboard() फंक्शन के शीर्ष पर, यह लाइन जोड़ें: js const account = stateaccount;\nयह रिफैक्टरिंग अपने आप में बहुत सुधार नहीं लाती है, लेकिन विचार अगले परिवर्तनों के लिए नींव रखना था।\nडेटा परिवर्तनों को ट्रैक करें\nअब जब हमने अपना डेटा स्टोर करने के लिए state ऑब्जेक्ट स्थापित कर लिया है, तो अगला कदम अपडेट को केंद्रीकृत करना है। लक्ष्य यह है कि किसी भी परिवर्तन और उनके होने के समय को ट्रैक करना आसान हो जाए।\nstate ऑब्जेक्ट में परिवर्तन करने से बचने के लिए, इसे immutable मानना भी एक अच्छा अभ्यास है, जिसका अर्थ है कि इसे बिल्कुल भी संशोधित नहीं किया जा सकता। इसका मतलब यह भी है कि यदि आप इसमें कुछ भी बदलना चाहते हैं तो आपको एक नया स्टेट ऑब्जेक्ट बनाना होगा। ऐसा करके, आप संभावित अवांछित साइड इफेक्ट्स के बारे में सुरक्षा बनाते हैं और अपने ऐप में नई सुविधाओं को लागू करने जैसे कि undo/redo को सक्षम करने की संभावनाओं को खोलते हैं, साथ ही इसे डिबग करना आसान बनाते हैं। उदाहरण के लिए, आप स्टेट में किए गए हर बदलाव को लॉग कर सकते हैं और बग के स्रोत को समझने के लिए परिवर्तनों का इतिहास रख सकते हैं।\nजावास्क्रिप्ट में, आप Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1207,
    "chunk_index": 10,
    "total_chunks": 36
  },
  {
    "id": "f7ed3c61928f35cbec13d64aef36bf32",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "बनाना होगा। ऐसा करके, आप संभावित अवांछित साइड इफेक्ट्स के बारे में सुरक्षा बनाते हैं और अपने ऐप में नई सुविधाओं को लागू करने जैसे कि undo/redo को सक्षम करने की संभावनाओं को खोलते हैं, साथ ही इसे डिबग करना आसान बनाते हैं। उदाहरण के लिए, आप स्टेट में किए गए हर बदलाव को लॉग कर सकते हैं और बग के स्रोत को समझने के लिए परिवर्तनों का इतिहास रख सकते हैं। जावास्क्रिप्ट में, आप Objectfreeze() का उपयोग करके ऑब्जेक्ट का एक immutable संस्करण बना सकते हैं। यदि आप immutable ऑब्जेक्ट में परिवर्तन करने का प्रयास करते हैं, तो एक अपवाद उत्पन्न होगा।\n✅ क्या आप जानते हैं कि shallow और deep immutable ऑब्जेक्ट में क्या अंतर है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 11,
    "total_chunks": 36
  },
  {
    "id": "1f47038cdb48a4cc0b6268f779c4fe05",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "हैं। उदाहरण के लिए, आप स्टेट में किए गए हर बदलाव को लॉग कर सकते हैं और बग के स्रोत को समझने के लिए परिवर्तनों का इतिहास रख सकते हैं। जावास्क्रिप्ट में, आप Objectfreeze() का उपयोग करके ऑब्जेक्ट का एक immutable संस्करण बना सकते हैं। यदि आप immutable ऑब्जेक्ट में परिवर्तन करने का प्रयास करते हैं, तो एक अपवाद उत्पन्न होगा। ✅ क्या आप जानते हैं कि shallow और deep immutable ऑब्जेक्ट में क्या अंतर हैआप इसके बारे में यहां पढ़ सकते हैं।\nकार्य\nआइए एक नया updateState() फंक्शन बनाएं:\njs\nfunction updateState(property, newData) {\nstate = Object freeze({",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 422,
    "chunk_index": 12,
    "total_chunks": 36
  },
  {
    "id": "ad1f607cc2a2ecf1908cb2bd2c853a94",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "लिए परिवर्तनों का इतिहास रख सकते हैं। जावास्क्रिप्ट में, आप Objectfreeze() का उपयोग करके ऑब्जेक्ट का एक immutable संस्करण बना सकते हैं। यदि आप immutable ऑब्जेक्ट में परिवर्तन करने का प्रयास करते हैं, तो एक अपवाद उत्पन्न होगा। ✅ क्या आप जानते हैं कि shallow और deep immutable ऑब्जेक्ट में क्या अंतर हैआप इसके बारे में यहां पढ़ सकते हैं। कार्य आइए एक नया updateState() फंक्शन बनाएं: js function updateState(property, newData) { state = Object freeze({state,\n[property]: newData\n});\n}\nइस फंक्शन में, हम एक नया स्टेट ऑब्जेक्ट बना रहे हैं और पिछले स्टेट से डेटा को स्प्रेड (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 416,
    "chunk_index": 13,
    "total_chunks": 36
  },
  {
    "id": "f714cb4cbbc0931adaa3ac60e06b187c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "आप immutable ऑब्जेक्ट में परिवर्तन करने का प्रयास करते हैं, तो एक अपवाद उत्पन्न होगा। ✅ क्या आप जानते हैं कि shallow और deep immutable ऑब्जेक्ट में क्या अंतर हैआप इसके बारे में यहां पढ़ सकते हैं। कार्य आइए एक नया updateState() फंक्शन बनाएं: js function updateState(property, newData) { state = Object freeze({state, [property]: newData }); } इस फंक्शन में, हम एक नया स्टेट ऑब्जेक्ट बना रहे हैं और पिछले स्टेट से डेटा को स्प्रेड () ऑपरेटर का उपयोग करके कॉपी कर रहे हैं। फिर हम ब्रैकेट नोटेशन [property] का उपयोग करके स्टेट ऑब्जेक्ट की एक विशेष प्रॉपर्टी को नए डेटा के साथ ओवरराइड करते हैं। अंत में, हम Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 459,
    "chunk_index": 14,
    "total_chunks": 36
  },
  {
    "id": "b63c40ad10d00eb76dd4b6d6cfd45ff5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "पढ़ सकते हैं। कार्य आइए एक नया updateState() फंक्शन बनाएं: js function updateState(property, newData) { state = Object freeze({state, [property]: newData }); } इस फंक्शन में, हम एक नया स्टेट ऑब्जेक्ट बना रहे हैं और पिछले स्टेट से डेटा को स्प्रेड () ऑपरेटर का उपयोग करके कॉपी कर रहे हैं। फिर हम ब्रैकेट नोटेशन [property] का उपयोग करके स्टेट ऑब्जेक्ट की एक विशेष प्रॉपर्टी को नए डेटा के साथ ओवरराइड करते हैं। अंत में, हम Objectfreeze() का उपयोग करके ऑब्जेक्ट को लॉक कर देते हैं ताकि संशोधन रोके जा सकें। फिलहाल हमारे स्टेट में केवल account प्रॉपर्टी संग्रहीत है, लेकिन इस दृष्टिकोण के साथ आप स्टेट में जितनी चाहें उतनी प्रॉपर्टी जोड़ सकते हैं।\nहम यह सुनिश्चित करने के लिए state इनिशियलाइज़ेशन को भी अपडेट करेंगे कि प्रारंभिक स्टेट भी फ्रीज हो:\njs\nlet state = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 607,
    "chunk_index": 15,
    "total_chunks": 36
  },
  {
    "id": "32c356fbb1d2d40629b217a8b8d01581",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "एक विशेष प्रॉपर्टी को नए डेटा के साथ ओवरराइड करते हैं। अंत में, हम Objectfreeze() का उपयोग करके ऑब्जेक्ट को लॉक कर देते हैं ताकि संशोधन रोके जा सकें। फिलहाल हमारे स्टेट में केवल account प्रॉपर्टी संग्रहीत है, लेकिन इस दृष्टिकोण के साथ आप स्टेट में जितनी चाहें उतनी प्रॉपर्टी जोड़ सकते हैं। हम यह सुनिश्चित करने के लिए state इनिशियलाइज़ेशन को भी अपडेट करेंगे कि प्रारंभिक स्टेट भी फ्रीज हो: js let state = Objectfreeze({\naccount: null\n});\nइसके बाद, register फंक्शन को अपडेट करें और state account = result; असाइनमेंट को बदलें:\njs\nupdateState('account', result);\nlogin फंक्शन के साथ भी ऐसा ही करें, state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 16,
    "total_chunks": 36
  },
  {
    "id": "30c13ce6bed01ff299dec4a5fd3c3468",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "हमारे स्टेट में केवल account प्रॉपर्टी संग्रहीत है, लेकिन इस दृष्टिकोण के साथ आप स्टेट में जितनी चाहें उतनी प्रॉपर्टी जोड़ सकते हैं। हम यह सुनिश्चित करने के लिए state इनिशियलाइज़ेशन को भी अपडेट करेंगे कि प्रारंभिक स्टेट भी फ्रीज हो: js let state = Objectfreeze({ account: null }); इसके बाद, register फंक्शन को अपडेट करें और state account = result; असाइनमेंट को बदलें: js updateState('account', result); login फंक्शन के साथ भी ऐसा ही करें, stateaccount = data; को बदलें:\njs\nupdateState('account', data);\nअब हम उपयोगकर्ता द्वारा लॉगआउट पर क्लिक करने पर अकाउंट डेटा साफ न होने की समस्या को ठीक करने का अवसर लेंगे।\nएक नया फंक्शन logout() बनाएं:\njs\nfunction logout() {\nupdateState('account', null);\nnavigate('/login');\n}\nupdateDashboard() में, रीडायरेक्शन return navigate('/login'); को return logout(); से बदलें;\nएक नया अकाउंट रजिस्टर करें, लॉगआउट करें और फिर से लॉगिन करें यह जांचने के लिए कि सब कुछ अभी भी सही तरीके से काम कर रहा है।\nटिप: आप ब्राउज़र के डेवलपमेंट टूल्स में कंसोल खोलकर और updateState() के नीचे console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 17,
    "total_chunks": 36
  },
  {
    "id": "b70dbc6e744f598d5a4b28dd3b119fe3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "साफ न होने की समस्या को ठीक करने का अवसर लेंगे। एक नया फंक्शन logout() बनाएं: js function logout() { updateState('account', null); navigate('/login'); } updateDashboard() में, रीडायरेक्शन return navigate('/login'); को return logout(); से बदलें; एक नया अकाउंट रजिस्टर करें, लॉगआउट करें और फिर से लॉगिन करें यह जांचने के लिए कि सब कुछ अभी भी सही तरीके से काम कर रहा है। टिप: आप ब्राउज़र के डेवलपमेंट टूल्स में कंसोल खोलकर और updateState() के नीचे consolelog(state) जोड़कर सभी स्टेट परिवर्तनों को देख सकते हैं।\nस्टेट को संरक्षित करें\nअधिकांश वेब ऐप्स को सही तरीके से काम करने के लिए डेटा को संरक्षित करने की आवश्यकता होती है। सभी महत्वपूर्ण डेटा आमतौर पर डेटाबेस में संग्रहीत होते हैं और सर्वर API के माध्यम से एक्सेस किए जाते हैं, जैसे कि हमारे मामले में उपयोगकर्ता अकाउंट डेटा। लेकिन कभी-कभी, उपयोगकर्ता अनुभव को बेहतर बनाने या लोडिंग प्रदर्शन में सुधार करने के लिए ब्राउज़र में चल रहे क्लाइंट ऐप पर कुछ डेटा संरक्षित करना भी दिलचस्प होता है।\nजब आप अपने ब्राउज़र में डेटा संरक्षित करना चाहते हैं, तो कुछ महत्वपूर्ण प्रश्न हैं जिन्हें आपको खुद से पूछना चाहिए:\nक्या डेटा संवेदनशील है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 920,
    "chunk_index": 18,
    "total_chunks": 36
  },
  {
    "id": "3511a6fd905325c6e07981c07712eb9b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "संग्रहीत होते हैं और सर्वर API के माध्यम से एक्सेस किए जाते हैं, जैसे कि हमारे मामले में उपयोगकर्ता अकाउंट डेटा। लेकिन कभी-कभी, उपयोगकर्ता अनुभव को बेहतर बनाने या लोडिंग प्रदर्शन में सुधार करने के लिए ब्राउज़र में चल रहे क्लाइंट ऐप पर कुछ डेटा संरक्षित करना भी दिलचस्प होता है। जब आप अपने ब्राउज़र में डेटा संरक्षित करना चाहते हैं, तो कुछ महत्वपूर्ण प्रश्न हैं जिन्हें आपको खुद से पूछना चाहिए: क्या डेटा संवेदनशील हैआपको क्लाइंट पर कोई भी संवेदनशील डेटा संग्रहीत करने से बचना चाहिए, जैसे उपयोगकर्ता पासवर्ड।\nआपको इस डेटा को कितने समय तक रखना है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 538,
    "chunk_index": 19,
    "total_chunks": 36
  },
  {
    "id": "543c887abcd8e700bcbeae3dfc775b69",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "उपयोगकर्ता अनुभव को बेहतर बनाने या लोडिंग प्रदर्शन में सुधार करने के लिए ब्राउज़र में चल रहे क्लाइंट ऐप पर कुछ डेटा संरक्षित करना भी दिलचस्प होता है। जब आप अपने ब्राउज़र में डेटा संरक्षित करना चाहते हैं, तो कुछ महत्वपूर्ण प्रश्न हैं जिन्हें आपको खुद से पूछना चाहिए: क्या डेटा संवेदनशील हैआपको क्लाइंट पर कोई भी संवेदनशील डेटा संग्रहीत करने से बचना चाहिए, जैसे उपयोगकर्ता पासवर्ड। आपको इस डेटा को कितने समय तक रखना हैक्या आप इस डेटा को केवल वर्तमान सत्र के लिए एक्सेस करने की योजना बना रहे हैं या आप इसे हमेशा के लिए संग्रहीत करना चाहते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 530,
    "chunk_index": 20,
    "total_chunks": 36
  },
  {
    "id": "7b5c8ca441bd6660a55c3dabe788f4cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "होता है। जब आप अपने ब्राउज़र में डेटा संरक्षित करना चाहते हैं, तो कुछ महत्वपूर्ण प्रश्न हैं जिन्हें आपको खुद से पूछना चाहिए: क्या डेटा संवेदनशील हैआपको क्लाइंट पर कोई भी संवेदनशील डेटा संग्रहीत करने से बचना चाहिए, जैसे उपयोगकर्ता पासवर्ड। आपको इस डेटा को कितने समय तक रखना हैक्या आप इस डेटा को केवल वर्तमान सत्र के लिए एक्सेस करने की योजना बना रहे हैं या आप इसे हमेशा के लिए संग्रहीत करना चाहते हैंवेब ऐप के अंदर जानकारी संग्रहीत करने के कई तरीके हैं, इस पर निर्भर करता है कि आप क्या हासिल करना चाहते हैं। उदाहरण के लिए, आप एक सर्च क्वेरी को स्टोर करने के लिए URL का उपयोग कर सकते हैं और इसे उपयोगकर्ताओं के बीच साझा कर सकते हैं। यदि डेटा को सर्वर के साथ साझा करने की आवश्यकता है, जैसे प्रमाणीकरण जानकारी, तो आप HTTP कुकीज़ का उपयोग कर सकते हैं।\nएक अन्य विकल्प डेटा संग्रहीत करने के लिए ब्राउज़र API में से एक का उपयोग करना है। इनमें से दो विशेष रूप से दिलचस्प हैं:\nlocalStorage: एक Key/Value स्टोर जो विभिन्न सत्रों में वर्तमान वेबसाइट के लिए विशिष्ट डेटा को संरक्षित करने की अनुमति देता है। इसमें संग्रहीत डेटा कभी समाप्त नहीं होता।\nsessionStorage: यह localStorage की तरह ही काम करता है, सिवाय इसके कि इसमें संग्रहीत डेटा सत्र समाप्त होने पर (जब ब्राउज़र बंद हो जाता है) साफ हो जाता है।\nध्यान दें कि ये दोनों API केवल strings को संग्रहीत करने की अनुमति देते हैं। यदि आप जटिल ऑब्जेक्ट संग्रहीत करना चाहते हैं, तो आपको इसे JSON प्रारूप में सीरियलाइज़ करना होगा, JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1244,
    "chunk_index": 21,
    "total_chunks": 36
  },
  {
    "id": "2f980a812c6127fbc4710cb7758557e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "को संरक्षित करने की अनुमति देता है। इसमें संग्रहीत डेटा कभी समाप्त नहीं होता। sessionStorage: यह localStorage की तरह ही काम करता है, सिवाय इसके कि इसमें संग्रहीत डेटा सत्र समाप्त होने पर (जब ब्राउज़र बंद हो जाता है) साफ हो जाता है। ध्यान दें कि ये दोनों API केवल strings को संग्रहीत करने की अनुमति देते हैं। यदि आप जटिल ऑब्जेक्ट संग्रहीत करना चाहते हैं, तो आपको इसे JSON प्रारूप में सीरियलाइज़ करना होगा, JSONstringify() का उपयोग करके।\n✅ यदि आप एक वेब ऐप बनाना चाहते हैं जो सर्वर के साथ काम नहीं करता है, तो IndexedDB API का उपयोग करके क्लाइंट पर एक डेटाबेस बनाना भी संभव है। यह उन्नत उपयोग मामलों के लिए या यदि आपको महत्वपूर्ण मात्रा में डेटा संग्रहीत करने की आवश्यकता है, तो आरक्षित है, क्योंकि इसका उपयोग करना अधिक जटिल है।\nकार्य\nहम चाहते हैं कि हमारे उपयोगकर्ता तब तक लॉग इन रहें जब तक वे स्पष्ट रूप से लॉगआउट बटन पर क्लिक न करें, इसलिए हम localStorage का उपयोग करके अकाउंट डेटा को संग्रहीत करेंगे। सबसे पहले, आइए एक key को परिभाषित करें जिसका उपयोग हम अपने डेटा को संग्रहीत करने के लिए करेंगे।\njs\nconst storageKey = 'savedAccount';\nफिर updateState() फंक्शन के अंत में यह लाइन जोड़ें:\njs\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 955,
    "chunk_index": 22,
    "total_chunks": 36
  },
  {
    "id": "9e9906fd58a14c828dd7f3bbffb3948c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "इसका उपयोग करना अधिक जटिल है। कार्य हम चाहते हैं कि हमारे उपयोगकर्ता तब तक लॉग इन रहें जब तक वे स्पष्ट रूप से लॉगआउट बटन पर क्लिक न करें, इसलिए हम localStorage का उपयोग करके अकाउंट डेटा को संग्रहीत करेंगे। सबसे पहले, आइए एक key को परिभाषित करें जिसका उपयोग हम अपने डेटा को संग्रहीत करने के लिए करेंगे। js const storageKey = 'savedAccount'; फिर updateState() फंक्शन के अंत में यह लाइन जोड़ें: js localStoragesetItem(storageKey, JSON stringify(state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 354,
    "chunk_index": 23,
    "total_chunks": 36
  },
  {
    "id": "717246e64df22ba7ef05cbdd54f41952",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "करना अधिक जटिल है। कार्य हम चाहते हैं कि हमारे उपयोगकर्ता तब तक लॉग इन रहें जब तक वे स्पष्ट रूप से लॉगआउट बटन पर क्लिक न करें, इसलिए हम localStorage का उपयोग करके अकाउंट डेटा को संग्रहीत करेंगे। सबसे पहले, आइए एक key को परिभाषित करें जिसका उपयोग हम अपने डेटा को संग्रहीत करने के लिए करेंगे। js const storageKey = 'savedAccount'; फिर updateState() फंक्शन के अंत में यह लाइन जोड़ें: js localStoragesetItem(storageKey, JSON stringify(stateaccount));\nइसके साथ, उपयोगकर्ता अकाउंट डेटा संरक्षित रहेगा और हमेशा अपडेट रहेगा क्योंकि हमने पहले सभी स्टेट अपडेट को केंद्रीकृत किया था। यह वह जगह है जहां हम अपने पिछले रिफैक्टरिंग से लाभ उठाना शुरू करते हैं 🙂।\nजैसा कि डेटा संग्रहीत किया गया है, हमें इसे ऐप लोड होने पर पुनर्स्थापित करने का भी ध्यान रखना होगा। चूंकि अब हमारे पास अधिक इनिशियलाइज़ेशन कोड होने लगेगा, इसलिए app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 704,
    "chunk_index": 24,
    "total_chunks": 36
  },
  {
    "id": "91c7af826f4505e0774e07b243d9e41b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "में यह लाइन जोड़ें: js localStoragesetItem(storageKey, JSON stringify(stateaccount)); इसके साथ, उपयोगकर्ता अकाउंट डेटा संरक्षित रहेगा और हमेशा अपडेट रहेगा क्योंकि हमने पहले सभी स्टेट अपडेट को केंद्रीकृत किया था। यह वह जगह है जहां हम अपने पिछले रिफैक्टरिंग से लाभ उठाना शुरू करते हैं 🙂। जैसा कि डेटा संग्रहीत किया गया है, हमें इसे ऐप लोड होने पर पुनर्स्थापित करने का भी ध्यान रखना होगा। चूंकि अब हमारे पास अधिक इनिशियलाइज़ेशन कोड होने लगेगा, इसलिए appjs के नीचे हमारे पिछले कोड को भी शामिल करने के लिए एक नया init फंक्शन बनाना एक अच्छा विचार हो सकता है:\n```js\nfunction init() {\nconst savedAccount = localStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 25,
    "total_chunks": 36
  },
  {
    "id": "a103848dbc093b88e25ffedc6ad63d6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "वह जगह है जहां हम अपने पिछले रिफैक्टरिंग से लाभ उठाना शुरू करते हैं 🙂। जैसा कि डेटा संग्रहीत किया गया है, हमें इसे ऐप लोड होने पर पुनर्स्थापित करने का भी ध्यान रखना होगा। चूंकि अब हमारे पास अधिक इनिशियलाइज़ेशन कोड होने लगेगा, इसलिए appjs के नीचे हमारे पिछले कोड को भी शामिल करने के लिए एक नया init फंक्शन बनाना एक अच्छा विचार हो सकता है: ```js function init() { const savedAccount = localStoragegetItem(storageKey);\nif (savedAccount) {\nupdateState('account', JSON parse(savedAccount));\n}\n// Our previous initialization code\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 365,
    "chunk_index": 26,
    "total_chunks": 36
  },
  {
    "id": "eafde09ed8cbcc845a44cd5056a0dd46",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "हैं 🙂। जैसा कि डेटा संग्रहीत किया गया है, हमें इसे ऐप लोड होने पर पुनर्स्थापित करने का भी ध्यान रखना होगा। चूंकि अब हमारे पास अधिक इनिशियलाइज़ेशन कोड होने लगेगा, इसलिए appjs के नीचे हमारे पिछले कोड को भी शामिल करने के लिए एक नया init फंक्शन बनाना एक अच्छा विचार हो सकता है: ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSON parse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute();\nupdateRoute();\n}\ninit();\n```\nयहां हम संग्रहीत डेटा को पुनः प्राप्त करते हैं, और यदि कोई डेटा है तो हम स्टेट को तदनुसार अपडेट करते हैं। इसे रूट अपडेट करने से पहले करना महत्वपूर्ण है, क्योंकि पेज अपडेट के दौरान स्टेट पर निर्भर कोड हो सकता है।\nहम अपने एप्लिकेशन का डिफ़ॉल्ट पेज डैशबोर्ड पेज भी बना सकते हैं, क्योंकि अब हम अकाउंट डेटा को संरक्षित कर रहे हैं। यदि कोई डेटा नहीं मिलता है, तो डैशबोर्ड वैसे भी लॉगिन पेज पर रीडायरेक्ट करने का ध्यान रखता है। updateRoute() में, फॉलबैक return navigate('/login'); को return navigate('/dashboard'); से बदलें।\nअब ऐप में लॉगिन करें और पेज को रिफ्रेश करने का प्रयास करें। आपको डैशबोर्ड पर रहना चाहिए। इस अपडेट के साथ हमने अपनी सभी प्रारंभिक समस्याओं का ध्यान रखा है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 919,
    "chunk_index": 27,
    "total_chunks": 36
  },
  {
    "id": "4b68c6825c2a1cd6b6aa72d56bc296c2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "डैशबोर्ड पेज भी बना सकते हैं, क्योंकि अब हम अकाउंट डेटा को संरक्षित कर रहे हैं। यदि कोई डेटा नहीं मिलता है, तो डैशबोर्ड वैसे भी लॉगिन पेज पर रीडायरेक्ट करने का ध्यान रखता है। updateRoute() में, फॉलबैक return navigate('/login'); को return navigate('/dashboard'); से बदलें। अब ऐप में लॉगिन करें और पेज को रिफ्रेश करने का प्रयास करें। आपको डैशबोर्ड पर रहना चाहिए। इस अपडेट के साथ हमने अपनी सभी प्रारंभिक समस्याओं का ध्यान रखा हैडेटा को रिफ्रेश करें लेकिन हमने शायद एक नई समस्या भी पैदा कर दी है। ओह",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 436,
    "chunk_index": 28,
    "total_chunks": 36
  },
  {
    "id": "9b02552ee990c14bddcc64b61a099277",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "हैं। यदि कोई डेटा नहीं मिलता है, तो डैशबोर्ड वैसे भी लॉगिन पेज पर रीडायरेक्ट करने का ध्यान रखता है। updateRoute() में, फॉलबैक return navigate('/login'); को return navigate('/dashboard'); से बदलें। अब ऐप में लॉगिन करें और पेज को रिफ्रेश करने का प्रयास करें। आपको डैशबोर्ड पर रहना चाहिए। इस अपडेट के साथ हमने अपनी सभी प्रारंभिक समस्याओं का ध्यान रखा हैडेटा को रिफ्रेश करें लेकिन हमने शायद एक नई समस्या भी पैदा कर दी है। ओहtest अकाउंट का उपयोग करके डैशबोर्ड पर जाएं, फिर एक नया ट्रांजेक्शन बनाने के लिए टर्मिनल पर यह कमांड चलाएं:\nsh\ncurl --request POST \\\n--header \"Content-Type: application/json\" \\\n--data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\\nhttp://localhost:5000/api/accounts/test/transactions\nअब ब्राउज़र में डैशबोर्ड पेज को रिफ्रेश करने का प्रयास करें। क्या होता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 597,
    "chunk_index": 29,
    "total_chunks": 36
  },
  {
    "id": "44e76e4942455d62a0b834905805c7bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "सभी प्रारंभिक समस्याओं का ध्यान रखा हैडेटा को रिफ्रेश करें लेकिन हमने शायद एक नई समस्या भी पैदा कर दी है। ओहtest अकाउंट का उपयोग करके डैशबोर्ड पर जाएं, फिर एक नया ट्रांजेक्शन बनाने के लिए टर्मिनल पर यह कमांड चलाएं: sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions अब ब्राउज़र में डैशबोर्ड पेज को रिफ्रेश करने का प्रयास करें। क्या होता हैक्या आप नया ट्रांजेक्शन देख सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 374,
    "chunk_index": 30,
    "total_chunks": 36
  },
  {
    "id": "abbfb324819fe995af70b11fd9919416",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "हैडेटा को रिफ्रेश करें लेकिन हमने शायद एक नई समस्या भी पैदा कर दी है। ओहtest अकाउंट का उपयोग करके डैशबोर्ड पर जाएं, फिर एक नया ट्रांजेक्शन बनाने के लिए टर्मिनल पर यह कमांड चलाएं: sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions अब ब्राउज़र में डैशबोर्ड पेज को रिफ्रेश करने का प्रयास करें। क्या होता हैक्या आप नया ट्रांजेक्शन देख सकते हैंस्टेट localStorage के कारण अनिश्चित काल तक संरक्षित रहता है, लेकिन इसका मतलब यह भी है कि यह तब तक कभी अपडेट नहीं होता जब तक आप ऐप से लॉग आउट और फिर से लॉग इन नहीं करते",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 31,
    "total_chunks": 36
  },
  {
    "id": "43a987df344b90463035201eb1c4ba29",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "--request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions अब ब्राउज़र में डैशबोर्ड पेज को रिफ्रेश करने का प्रयास करें। क्या होता हैक्या आप नया ट्रांजेक्शन देख सकते हैंस्टेट localStorage के कारण अनिश्चित काल तक संरक्षित रहता है, लेकिन इसका मतलब यह भी है कि यह तब तक कभी अपडेट नहीं होता जब तक आप ऐप से लॉग आउट और फिर से लॉग इन नहीं करतेइस समस्या को ठीक करने की एक संभावित रणनीति यह है कि डैशबोर्ड लोड होने पर हर बार अकाउंट डेटा को रीलोड किया जाए, ताकि पुराना डेटा न रहे।\nकार्य\nएक नया फंक्शन updateAccountData बनाएं:\n```js\nasync function updateAccountData() {\nconst account = state account;\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 32,
    "total_chunks": 36
  },
  {
    "id": "6f8ddda634678b32a9846a3eeee33722",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "रहता है, लेकिन इसका मतलब यह भी है कि यह तब तक कभी अपडेट नहीं होता जब तक आप ऐप से लॉग आउट और फिर से लॉग इन नहीं करतेइस समस्या को ठीक करने की एक संभावित रणनीति यह है कि डैशबोर्ड लोड होने पर हर बार अकाउंट डेटा को रीलोड किया जाए, ताकि पुराना डेटा न रहे। कार्य एक नया फंक्शन updateAccountData बनाएं: ```js async function updateAccountData() { const account = state account; if (account) {\nreturn logout();\n}\nconst data = await getAccount(account user);\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 316,
    "chunk_index": 33,
    "total_chunks": 36
  },
  {
    "id": "138e20c98e87b6ff0ce474109b12166b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "कभी अपडेट नहीं होता जब तक आप ऐप से लॉग आउट और फिर से लॉग इन नहीं करतेइस समस्या को ठीक करने की एक संभावित रणनीति यह है कि डैशबोर्ड लोड होने पर हर बार अकाउंट डेटा को रीलोड किया जाए, ताकि पुराना डेटा न रहे। कार्य एक नया फंक्शन updateAccountData बनाएं: ```js async function updateAccountData() { const account = state account; if (account) { return logout(); } const data = await getAccount(account user); if (dataerror) {\nreturn logout();\n}\nupdateState('account', data);\n}\n```\nयह मेथड जांचता है कि हम वर्तमान में लॉग इन हैं और फिर सर्वर से अकाउंट डेटा को रीलोड करता है।\nrefresh नामक एक और फंक्शन बनाएं:\njs\nasync function refresh() {\nawait updateAccountData();\nupdateDashboard();\n}\nयह अकाउंट डेटा को अपडेट करता है, फिर डैशबोर्ड पेज के HTML को अपडेट करने का ध्यान रखता है। यह वही है जिसे हमें डैशबोर्ड रूट लोड होने पर कॉल करना है। रूट डिफिनिशन को अपडेट करें:\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: refresh }\n};\nअब डैशबोर्ड को रीलोड करने का प्रयास करें, यह अपडेटेड अकाउंट डेटा प्रदर्शित करना चाहिए।\n🚀 चुनौती\nअब जब हम हर बार डैशबोर्ड लोड होने पर अकाउंट डेटा को रीलोड करते हैं, तो क्या आपको लगता है कि हमें सभी अकाउंट डेटा को संरक्षित करने की आवश्यकता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 877,
    "chunk_index": 34,
    "total_chunks": 36
  },
  {
    "id": "61d51caf120b88d1f9c6976ec6cda37b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "बैंकिंग ऐप बनाएं भाग 4: स्टेट मैनेजमेंट की अवधारणाएँ",
    "content": "होने पर कॉल करना है। रूट डिफिनिशन को अपडेट करें: js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: refresh } }; अब डैशबोर्ड को रीलोड करने का प्रयास करें, यह अपडेटेड अकाउंट डेटा प्रदर्शित करना चाहिए। 🚀 चुनौती अब जब हम हर बार डैशबोर्ड लोड होने पर अकाउंट डेटा को रीलोड करते हैं, तो क्या आपको लगता है कि हमें सभी अकाउंट डेटा को संरक्षित करने की आवश्यकता हैएक साथ काम करके यह बदलने का प्रयास करें कि localStorage में क्या संग्रहीत और लोड किया गया है ताकि केवल वही शामिल हो जो ऐप को काम करने के लिए बिल्कुल आवश्यक है।\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nअसाइनमेंट\n\"Add transaction\" डायलॉग लागू करें\nअसाइनमेंट पूरा करने के बाद यहां एक उदाहरण परिणाम है:\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 33601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1004,
    "chunk_index": 35,
    "total_chunks": 36
  },
  {
    "id": "7c37285c79fda1c838253f77e27bf9b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\assignment.md",
    "source_type": "git_repo",
    "title": "कैनवास API के साथ खेलें",
    "content": "कैनवास API के साथ खेलें\nनिर्देश\nकैनवास API के किसी एक तत्व को चुनें और उसके चारों ओर कुछ दिलचस्प बनाएं। क्या आप बार-बार दोहराए जाने वाले सितारों की एक छोटी आकाशगंगा बना सकते हैं क्या आप रंगीन रेखाओं का एक दिलचस्प बनावट बना सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2959,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 226,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "f274527f6f692e101e92353da767253a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\assignment.md",
    "source_type": "git_repo",
    "title": "कैनवास API के साथ खेलें",
    "content": "कैनवास API के साथ खेलें\nनिर्देश\nकैनवास API के किसी एक तत्व को चुनें और उसके चारों ओर कुछ दिलचस्प बनाएं। क्या आप बार-बार दोहराए जाने वाले सितारों की एक छोटी आकाशगंगा बना सकते हैं क्या आप रंगीन रेखाओं का एक दिलचस्प बनावट बना सकते हैंप्रेरणा के लिए आप CodePen देख सकते हैं (लेकिन कॉपी न करें)।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                 | पर्याप्त                            | सुधार की आवश्यकता     |\n| ------- | --------------------------------------------------------- | ----------------------------------- | --------------------- |\n|         | कोड प्रस्तुत किया गया है जो एक दिलचस्प बनावट या आकार दिखाता है | कोड प्रस्तुत किया गया है, लेकिन चलता नहीं है | कोड प्रस्तुत नहीं किया गया है |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2959,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 928,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "eeac6b4c5f84a17e42a2697d1aeb788d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने कोड पर टिप्पणी करें",
    "content": "अपने कोड पर टिप्पणी करें\nनिर्देश\nअपने गेम फ़ोल्डर में मौजूद वर्तमान /app js फ़ाइल को देखें और उसमें टिप्पणी जोड़ने और उसे व्यवस्थित करने के तरीके खोजें। कोड को नियंत्रण से बाहर होना बहुत आसान है, और अभी आपके पास एक अच्छा मौका है कि आप टिप्पणियाँ जोड़ें ताकि आपका कोड पढ़ने योग्य हो और आप इसे बाद में उपयोग कर सकें।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                          | पर्याप्त                              | सुधार की आवश्यकता                                              |\n| ------- | ------------------------------------------------------------------ | ------------------------------------- | -------------------------------------------------------------- |\n|         | app js कोड पूरी तरह से टिप्पणी की गई है और तार्किक ब्लॉकों में व्यवस्थित है | app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3200,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 482,
    "chunk_index": 0,
    "total_chunks": 3
  },
  {
    "id": "54d65aa21c8a2c707950191ae03959b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने कोड पर टिप्पणी करें",
    "content": "को नियंत्रण से बाहर होना बहुत आसान है, और अभी आपके पास एक अच्छा मौका है कि आप टिप्पणियाँ जोड़ें ताकि आपका कोड पढ़ने योग्य हो और आप इसे बाद में उपयोग कर सकें। मूल्यांकन मानदंड | मानदंड | उत्कृष्ट | पर्याप्त | सुधार की आवश्यकता | | ------- | ------------------------------------------------------------------ | ------------------------------------- | -------------------------------------------------------------- | | | app js कोड पूरी तरह से टिप्पणी की गई है और तार्किक ब्लॉकों में व्यवस्थित है | appjs कोड पर्याप्त रूप से टिप्पणी की गई है | app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3200,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 356,
    "chunk_index": 1,
    "total_chunks": 3
  },
  {
    "id": "842d872ad1ac368cab3ff5be126d1a5f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने कोड पर टिप्पणी करें",
    "content": "आपके पास एक अच्छा मौका है कि आप टिप्पणियाँ जोड़ें ताकि आपका कोड पढ़ने योग्य हो और आप इसे बाद में उपयोग कर सकें। मूल्यांकन मानदंड | मानदंड | उत्कृष्ट | पर्याप्त | सुधार की आवश्यकता | | ------- | ------------------------------------------------------------------ | ------------------------------------- | -------------------------------------------------------------- | | | app js कोड पूरी तरह से टिप्पणी की गई है और तार्किक ब्लॉकों में व्यवस्थित है | appjs कोड पर्याप्त रूप से टिप्पणी की गई है | appjs कोड कुछ हद तक अव्यवस्थित है और अच्छी टिप्पणियों की कमी है |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3200,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 789,
    "chunk_index": 2,
    "total_chunks": 3
  },
  {
    "id": "af72d34e1867dbce622b6f873b7e5341",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nकैनवास\nकैनवास एक HTML एलिमेंट है जो डिफ़ॉल्ट रूप से खाली होता है; यह एक खाली स्लेट की तरह है। आपको इस पर ड्रॉ करके सामग्री जोड़नी होती है।\n✅ कैनवास API के बारे में अधिक पढ़ें MDN पर।\nयह आमतौर पर पेज के बॉडी के हिस्से के रूप में इस तरह घोषित किया जाता है:\n```html\n```\nऊपर हम id, width और height सेट कर रहे हैं।\nid: इसे सेट करें ताकि जब आपको इसके साथ इंटरैक्ट करना हो तो इसका रेफरेंस प्राप्त कर सकें।\nwidth: यह एलिमेंट की चौड़ाई है।\nheight: यह एलिमेंट की ऊंचाई है।\nसरल ज्यामिति ड्रॉ करना\nकैनवास चीजों को ड्रॉ करने के लिए एक कार्टेशियन कोऑर्डिनेट सिस्टम का उपयोग करता है। इसलिए यह x-अक्ष और y-अक्ष का उपयोग करता है यह व्यक्त करने के लिए कि कुछ कहाँ स्थित है। लोकेशन 0,0 टॉप लेफ्ट पोजिशन है और बॉटम राइट वह है जिसे आपने कैनवास की चौड़ाई और ऊंचाई के रूप में सेट किया है।\nछवि MDN से\nकैनवास एलिमेंट पर ड्रॉ करने के लिए आपको निम्नलिखित चरणों से गुजरना होगा:\nरेफरेंस प्राप्त करें कैनवास एलिमेंट का।\nरेफरेंस प्राप्त करें उस कॉन्टेक्स्ट एलिमेंट का जो कैनवास एलिमेंट पर बैठता है।\nड्रॉइंग ऑपरेशन करें कॉन्टेक्स्ट एलिमेंट का उपयोग करके।\nऊपर दिए गए चरणों के लिए कोड आमतौर पर इस तरह दिखता है:\n```javascript\n// draws a red rectangle\n//1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1156,
    "chunk_index": 0,
    "total_chunks": 17
  },
  {
    "id": "26c759722e21a97cf070ccddecfa3777",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "जिसे आपने कैनवास की चौड़ाई और ऊंचाई के रूप में सेट किया है। छवि MDN से कैनवास एलिमेंट पर ड्रॉ करने के लिए आपको निम्नलिखित चरणों से गुजरना होगा: रेफरेंस प्राप्त करें कैनवास एलिमेंट का। रेफरेंस प्राप्त करें उस कॉन्टेक्स्ट एलिमेंट का जो कैनवास एलिमेंट पर बैठता है। ड्रॉइंग ऑपरेशन करें कॉन्टेक्स्ट एलिमेंट का उपयोग करके। ऊपर दिए गए चरणों के लिए कोड आमतौर पर इस तरह दिखता है: ```javascript // draws a red rectangle //1get the canvas reference\ncanvas = document getElementById(\"myCanvas\");\n//2 set the context to 2D to draw basic shapes\nctx = canvas getContext(\"2d\");\n//3 fill it with the color red\nctx fillStyle = 'red';\n//4 and draw a rectangle with these parameters, setting location and size\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 453,
    "chunk_index": 1,
    "total_chunks": 17
  },
  {
    "id": "2bce343b12de170b84219aecd693f333",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "पर बैठता है। ड्रॉइंग ऑपरेशन करें कॉन्टेक्स्ट एलिमेंट का उपयोग करके। ऊपर दिए गए चरणों के लिए कोड आमतौर पर इस तरह दिखता है: ```javascript // draws a red rectangle //1get the canvas reference canvas = document getElementById(\"myCanvas\"); //2 set the context to 2D to draw basic shapes ctx = canvas getContext(\"2d\"); //3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height\n```\n✅ कैनवास API मुख्य रूप से 2D शेप्स पर केंद्रित है, लेकिन आप वेब साइट पर 3D एलिमेंट भी ड्रॉ कर सकते हैं; इसके लिए आप WebGL API का उपयोग कर सकते हैं।\nआप कैनवास API के साथ कई प्रकार की चीजें ड्रॉ कर सकते हैं जैसे:\nज्यामितीय आकृतियाँ, हमने पहले ही दिखाया है कि आयत कैसे ड्रॉ करें, लेकिन आप और भी बहुत कुछ ड्रॉ कर सकते हैं।\nटेक्स्ट, आप किसी भी फॉन्ट और रंग के साथ टेक्स्ट ड्रॉ कर सकते हैं।\nइमेजेस, आप किसी इमेज एसेट जैसे",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 616,
    "chunk_index": 2,
    "total_chunks": 17
  },
  {
    "id": "2b4535f6c8ff084bce7701a5e30558a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "वेब साइट पर 3D एलिमेंट भी ड्रॉ कर सकते हैं; इसके लिए आप WebGL API का उपयोग कर सकते हैं। आप कैनवास API के साथ कई प्रकार की चीजें ड्रॉ कर सकते हैं जैसे: ज्यामितीय आकृतियाँ, हमने पहले ही दिखाया है कि आयत कैसे ड्रॉ करें, लेकिन आप और भी बहुत कुछ ड्रॉ कर सकते हैं। टेक्स्ट, आप किसी भी फॉन्ट और रंग के साथ टेक्स्ट ड्रॉ कर सकते हैं। इमेजेस, आप किसी इमेज एसेट जैसेjpg या png के आधार पर इमेज ड्रॉ कर सकते हैं।\n✅ इसे आज़माएं आप जानते हैं कि आयत कैसे ड्रॉ करें, क्या आप पेज पर एक सर्कल ड्रॉ कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 458,
    "chunk_index": 3,
    "total_chunks": 17
  },
  {
    "id": "3f4403583f4331f4543697d9fc4ad383",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "सकते हैं जैसे: ज्यामितीय आकृतियाँ, हमने पहले ही दिखाया है कि आयत कैसे ड्रॉ करें, लेकिन आप और भी बहुत कुछ ड्रॉ कर सकते हैं। टेक्स्ट, आप किसी भी फॉन्ट और रंग के साथ टेक्स्ट ड्रॉ कर सकते हैं। इमेजेस, आप किसी इमेज एसेट जैसेjpg या png के आधार पर इमेज ड्रॉ कर सकते हैं। ✅ इसे आज़माएं आप जानते हैं कि आयत कैसे ड्रॉ करें, क्या आप पेज पर एक सर्कल ड्रॉ कर सकते हैंCodePen पर कुछ दिलचस्प कैनवास ड्रॉइंग्स देखें। यहाँ एक विशेष रूप से प्रभावशाली उदाहरण है।\nइमेज एसेट लोड और ड्रॉ करें\nआप एक इमेज एसेट को Image ऑब्जेक्ट बनाकर और उसकी src प्रॉपर्टी सेट करके लोड करते हैं। फिर आप load इवेंट को सुनते हैं ताकि यह जान सकें कि इसे उपयोग करने के लिए तैयार है। कोड इस तरह दिखता है:\nएसेट लोड करें\njavascript\nconst img = new Image();\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 658,
    "chunk_index": 4,
    "total_chunks": 17
  },
  {
    "id": "00444d03550a45c64db60564cd5d7ce5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "सर्कल ड्रॉ कर सकते हैंCodePen पर कुछ दिलचस्प कैनवास ड्रॉइंग्स देखें। यहाँ एक विशेष रूप से प्रभावशाली उदाहरण है। इमेज एसेट लोड और ड्रॉ करें आप एक इमेज एसेट को Image ऑब्जेक्ट बनाकर और उसकी src प्रॉपर्टी सेट करके लोड करते हैं। फिर आप load इवेंट को सुनते हैं ताकि यह जान सकें कि इसे उपयोग करने के लिए तैयार है। कोड इस तरह दिखता है: एसेट लोड करें javascript const img = new Image(); imgsrc = 'path/to/my/image png';\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 346,
    "chunk_index": 5,
    "total_chunks": 17
  },
  {
    "id": "6255a937fdcb7b7c23d1eefc9a1169d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "हैंCodePen पर कुछ दिलचस्प कैनवास ड्रॉइंग्स देखें। यहाँ एक विशेष रूप से प्रभावशाली उदाहरण है। इमेज एसेट लोड और ड्रॉ करें आप एक इमेज एसेट को Image ऑब्जेक्ट बनाकर और उसकी src प्रॉपर्टी सेट करके लोड करते हैं। फिर आप load इवेंट को सुनते हैं ताकि यह जान सकें कि इसे उपयोग करने के लिए तैयार है। कोड इस तरह दिखता है: एसेट लोड करें javascript const img = new Image(); imgsrc = 'path/to/my/image png'; imgonload = () => {\n// image loaded and ready to be used\n}\nएसेट लोड पैटर्न\nऊपर दिए गए को एक संरचना में लपेटने की सिफारिश की जाती है ताकि इसे उपयोग करना आसान हो और आप केवल तभी इसे संशोधित करने का प्रयास करें जब यह पूरी तरह से लोड हो जाए:\n```javascript\nfunction loadAsset(path) {\nreturn new Promise((resolve) => {\nconst img = new Image();\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 6,
    "total_chunks": 17
  },
  {
    "id": "85d4206403c22cb9dc1d8bf2fc6f56e7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "= new Image(); imgsrc = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } एसेट लोड पैटर्न ऊपर दिए गए को एक संरचना में लपेटने की सिफारिश की जाती है ताकि इसे उपयोग करना आसान हो और आप केवल तभी इसे संशोधित करने का प्रयास करें जब यह पूरी तरह से लोड हो जाए: ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path;\nimg onload = () => {\n// image loaded and ready to be used\nresolve(img);\n}\n})\n}\n// use like so\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster png')\n}\n```\nगेम एसेट्स को स्क्रीन पर ड्रॉ करने के लिए, आपका कोड इस तरह दिखेगा:\n```javascript\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster png')\ncanvas = document getElementById(\"myCanvas\");\nctx = canvas getContext(\"2d\");\nctx drawImage(heroImg, canvas width/2,canvas height/2);\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 411,
    "chunk_index": 7,
    "total_chunks": 17
  },
  {
    "id": "b9e55a7cc2b47c0b86b51376ec506c66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "and ready to be used resolve(img); } }) } // use like so async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') } ``` गेम एसेट्स को स्क्रीन पर ड्रॉ करने के लिए, आपका कोड इस तरह दिखेगा: ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0);\n}\n```\nअब समय है अपना गेम बनाना शुरू करने का\nक्या बनाना है\nआप एक वेब पेज बनाएंगे जिसमें एक कैनवास एलिमेंट होगा। इसे एक काले स्क्रीन 1024*768 पर रेंडर करना चाहिए। हमने आपको दो इमेजेस प्रदान की हैं:\nहीरो शिप\n5*5 मॉन्स्टर\nविकास शुरू करने के लिए अनुशंसित चरण\nउन फाइल्स को ढूंढें जो आपके लिए your-work सब फोल्डर में बनाई गई हैं। इसमें निम्नलिखित शामिल होना चाहिए:\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 533,
    "chunk_index": 8,
    "total_chunks": 17
  },
  {
    "id": "f9cb42878c1b64f172ab000565033853",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "0,0); } ``` अब समय है अपना गेम बनाना शुरू करने का क्या बनाना है आप एक वेब पेज बनाएंगे जिसमें एक कैनवास एलिमेंट होगा। इसे एक काले स्क्रीन 1024*768 पर रेंडर करना चाहिए। हमने आपको दो इमेजेस प्रदान की हैं: हीरो शिप 5*5 मॉन्स्टर विकास शुरू करने के लिए अनुशंसित चरण उन फाइल्स को ढूंढें जो आपके लिए your-work सब फोल्डर में बनाई गई हैं। इसमें निम्नलिखित शामिल होना चाहिए: bash -| assets -| enemyShippng\n-| player png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 372,
    "chunk_index": 9,
    "total_chunks": 17
  },
  {
    "id": "f0bd4fcecb302b8804bbffa651db564c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "का क्या बनाना है आप एक वेब पेज बनाएंगे जिसमें एक कैनवास एलिमेंट होगा। इसे एक काले स्क्रीन 1024*768 पर रेंडर करना चाहिए। हमने आपको दो इमेजेस प्रदान की हैं: हीरो शिप 5*5 मॉन्स्टर विकास शुरू करने के लिए अनुशंसित चरण उन फाइल्स को ढूंढें जो आपके लिए your-work सब फोल्डर में बनाई गई हैं। इसमें निम्नलिखित शामिल होना चाहिए: bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson\nइस फोल्डर की एक कॉपी को Visual Studio Code में खोलें। आपको एक स्थानीय विकास वातावरण सेटअप करना होगा, अधिमानतः Visual Studio Code के साथ जिसमें NPM और Node इंस्टॉल हो। यदि आपके कंप्यूटर पर npm सेटअप नहीं है, तो यहाँ बताया गया है कि इसे कैसे करें।\nअपने प्रोजेक्ट को your_work फोल्डर पर नेविगेट करके शुरू करें:\nbash\ncd your-work\nnpm start\nऊपर दिया गया आपके कंप्यूटर पर http://localhost:5000 एड्रेस पर एक HTTP सर्वर शुरू करेगा। एक ब्राउज़र खोलें और उस एड्रेस को इनपुट करें। यह अभी एक खाली पेज है, लेकिन यह बदल जाएगा।\nनोट: स्क्रीन पर बदलाव देखने के लिए, अपने ब्राउज़र को रिफ्रेश करें।\nकोड जोड़ें\nyour-work/app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 836,
    "chunk_index": 10,
    "total_chunks": 17
  },
  {
    "id": "1e331566ee3bdf10df6c6549c89a4677",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "npm सेटअप नहीं है, तो यहाँ बताया गया है कि इसे कैसे करें। अपने प्रोजेक्ट को your_work फोल्डर पर नेविगेट करके शुरू करें: bash cd your-work npm start ऊपर दिया गया आपके कंप्यूटर पर http://localhost:5000 एड्रेस पर एक HTTP सर्वर शुरू करेगा। एक ब्राउज़र खोलें और उस एड्रेस को इनपुट करें। यह अभी एक खाली पेज है, लेकिन यह बदल जाएगा। नोट: स्क्रीन पर बदलाव देखने के लिए, अपने ब्राउज़र को रिफ्रेश करें। कोड जोड़ें your-work/appjs में आवश्यक कोड जोड़ें ताकि नीचे दिए गए को हल किया जा सके:\nड्रॉ करें एक कैनवास काले बैकग्राउंड के साथ\nटिप: /app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 11,
    "total_chunks": 17
  },
  {
    "id": "8727e4863788e03667ea647ab2901f3b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "bash cd your-work npm start ऊपर दिया गया आपके कंप्यूटर पर http://localhost:5000 एड्रेस पर एक HTTP सर्वर शुरू करेगा। एक ब्राउज़र खोलें और उस एड्रेस को इनपुट करें। यह अभी एक खाली पेज है, लेकिन यह बदल जाएगा। नोट: स्क्रीन पर बदलाव देखने के लिए, अपने ब्राउज़र को रिफ्रेश करें। कोड जोड़ें your-work/appjs में आवश्यक कोड जोड़ें ताकि नीचे दिए गए को हल किया जा सके: ड्रॉ करें एक कैनवास काले बैकग्राउंड के साथ टिप: /appjs में उपयुक्त TODO के तहत दो लाइनें जोड़ें, ctx एलिमेंट को काला सेट करें और टॉप/लेफ्ट कोऑर्डिनेट्स को 0,0 पर सेट करें और कैनवास की ऊंचाई और चौड़ाई के बराबर करें।\nलोड करें टेक्सचर्स\nटिप: await loadTexture का उपयोग करके और इमेज पाथ पास करके प्लेयर और दुश्मन इमेजेस जोड़ें। आप उन्हें अभी स्क्रीन पर नहीं देखेंगे",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 642,
    "chunk_index": 12,
    "total_chunks": 17
  },
  {
    "id": "01a12e5dc3ff77b067f481a714b6fc0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "ताकि नीचे दिए गए को हल किया जा सके: ड्रॉ करें एक कैनवास काले बैकग्राउंड के साथ टिप: /appjs में उपयुक्त TODO के तहत दो लाइनें जोड़ें, ctx एलिमेंट को काला सेट करें और टॉप/लेफ्ट कोऑर्डिनेट्स को 0,0 पर सेट करें और कैनवास की ऊंचाई और चौड़ाई के बराबर करें। लोड करें टेक्सचर्स टिप: await loadTexture का उपयोग करके और इमेज पाथ पास करके प्लेयर और दुश्मन इमेजेस जोड़ें। आप उन्हें अभी स्क्रीन पर नहीं देखेंगेड्रॉ करें हीरो को स्क्रीन के सेंटर में नीचे के आधे हिस्से में\nटिप: drawImage API का उपयोग करके हीरो इमेज को स्क्रीन पर ड्रॉ करें, canvas width / 2 - 45 और canvas height - canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 13,
    "total_chunks": 17
  },
  {
    "id": "4b366d9461baf5c1d0e46aed7300b966",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "को 0,0 पर सेट करें और कैनवास की ऊंचाई और चौड़ाई के बराबर करें। लोड करें टेक्सचर्स टिप: await loadTexture का उपयोग करके और इमेज पाथ पास करके प्लेयर और दुश्मन इमेजेस जोड़ें। आप उन्हें अभी स्क्रीन पर नहीं देखेंगेड्रॉ करें हीरो को स्क्रीन के सेंटर में नीचे के आधे हिस्से में टिप: drawImage API का उपयोग करके हीरो इमेज को स्क्रीन पर ड्रॉ करें, canvas width / 2 - 45 और canvas height - canvasheight / 4) सेट करें।\nड्रॉ करें 5*5 मॉन्स्टर्स\nटिप: अब आप स्क्रीन पर दुश्मनों को ड्रॉ करने के लिए कोड को अनकमेंट कर सकते हैं। फिर, createEnemies फंक्शन पर जाएं और इसे बनाएं।\nपहले, कुछ कॉन्स्टेंट्स सेट करें:\n```javascript\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 525,
    "chunk_index": 14,
    "total_chunks": 17
  },
  {
    "id": "6ffd09d73988e8c8525e599f77483e10",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "drawImage API का उपयोग करके हीरो इमेज को स्क्रीन पर ड्रॉ करें, canvas width / 2 - 45 और canvas height - canvasheight / 4) सेट करें। ड्रॉ करें 5*5 मॉन्स्टर्स टिप: अब आप स्क्रीन पर दुश्मनों को ड्रॉ करने के लिए कोड को अनकमेंट कर सकते हैं। फिर, createEnemies फंक्शन पर जाएं और इसे बनाएं। पहले, कुछ कॉन्स्टेंट्स सेट करें: ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\n```\nफिर, मॉन्स्टर्स की एक एरे को स्क्रीन पर ड्रॉ करने के लिए एक लूप बनाएं:\n```javascript\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 401,
    "chunk_index": 15,
    "total_chunks": 17
  },
  {
    "id": "148efb61ec71a57d67c84023dfafb75d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 2: हीरो और मॉन्स्टर्स को कैनवास पर ड्रॉ करें",
    "content": "इसे बनाएं। पहले, कुछ कॉन्स्टेंट्स सेट करें: ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; ``` फिर, मॉन्स्टर्स की एक एरे को स्क्रीन पर ड्रॉ करने के लिए एक लूप बनाएं: ```javascript for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { ctxdrawImage(enemyImg, x, y);\n}\n}\n```\nपरिणाम\nअंतिम परिणाम इस तरह दिखना चाहिए:\nसमाधान\nकृपया पहले इसे स्वयं हल करने का प्रयास करें लेकिन यदि आप अटक जाते हैं, तो समाधान देखें।\n🚀 चुनौती\nआपने 2D-केंद्रित कैनवास API के साथ ड्रॉ करना सीखा है; WebGL API पर एक नज़र डालें, और 3D ऑब्जेक्ट ड्रॉ करने का प्रयास करें।\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nकैनवास API के बारे में अधिक जानने के लिए इसके बारे में पढ़ें।\nअसाइनमेंट\nकैनवास API के साथ खेलें\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15810,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1041,
    "chunk_index": 16,
    "total_chunks": 17
  },
  {
    "id": "f5a34fd7023a3d41f12cab1a989a59f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "स्पेस गेम बनाएं भाग 1: परिचय\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nगेम डेवलपमेंट में इनहेरिटेंस और कंपोज़िशन\nपिछले पाठों में, आपने जो ऐप्स बनाए थे, उनके डिज़ाइन आर्किटेक्चर के बारे में ज्यादा चिंता करने की ज़रूरत नहीं थी, क्योंकि प्रोजेक्ट्स का दायरा बहुत छोटा था। हालांकि, जब आपके एप्लिकेशन का आकार और दायरा बढ़ता है, तो आर्किटेक्चरल निर्णय अधिक महत्वपूर्ण हो जाते हैं। जावास्क्रिप्ट में बड़े एप्लिकेशन बनाने के दो प्रमुख तरीके हैं: कंपोज़िशन या इनहेरिटेंस। दोनों के अपने फायदे और नुकसान हैं, लेकिन आइए इन्हें एक गेम के संदर्भ में समझते हैं।\n✅ प्रोग्रामिंग की सबसे प्रसिद्ध किताबों में से एक डिज़ाइन पैटर्न्स के बारे में है।\nएक गेम में आपके पास गेम ऑब्जेक्ट्स होते हैं, जो स्क्रीन पर मौजूद ऑब्जेक्ट्स होते हैं। इसका मतलब है कि उनका स्थान एक कार्टेशियन कोऑर्डिनेट सिस्टम पर होता है, जिसे x और y कोऑर्डिनेट्स द्वारा दर्शाया जाता है। जब आप एक गेम विकसित करते हैं, तो आप देखेंगे कि आपके सभी गेम ऑब्जेक्ट्स में एक मानक प्रॉपर्टी होती है, जो हर गेम के लिए सामान्य होती है, जैसे:\nस्थान आधारित अधिकांश, यदि सभी नहीं, गेम एलिमेंट्स स्थान आधारित होते हैं। इसका मतलब है कि उनका एक स्थान होता है, x और y।\nचलने योग्य ये ऑब्जेक्ट्स ऐसे होते हैं जो एक नए स्थान पर जा सकते हैं। आमतौर पर यह एक हीरो, एक मॉन्स्टर या एक NPC (नॉन-प्लेयर कैरेक्टर) होता है, लेकिन उदाहरण के लिए, एक स्थिर ऑब्जेक्ट जैसे पेड़ नहीं।\nस्वयं-विनाशकारी ये ऑब्जेक्ट्स केवल एक निश्चित समय अवधि के लिए मौजूद होते हैं और फिर खुद को डिलीट करने के लिए तैयार कर लेते हैं। आमतौर पर इसे dead या destroyed बूलियन द्वारा दर्शाया जाता है, जो गेम इंजन को संकेत देता है कि इस ऑब्जेक्ट को अब रेंडर नहीं किया जाना चाहिए।\nकूल-डाउन 'कूल-डाउन' एक सामान्य प्रॉपर्टी है जो अल्पकालिक ऑब्जेक्ट्स में पाई जाती है। इसका एक सामान्य उदाहरण एक टेक्स्ट या ग्राफिकल इफेक्ट है, जैसे विस्फोट, जिसे केवल कुछ मिलीसेकंड के लिए देखा जाना चाहिए।\n✅ Pac-Man जैसे गेम के बारे में सोचें। क्या आप इस गेम में ऊपर बताए गए चार ऑब्जेक्ट प्रकारों की पहचान कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1847,
    "chunk_index": 0,
    "total_chunks": 14
  },
  {
    "id": "58f509cf4be8b90de63bbdc8c887ad44",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "है, जो गेम इंजन को संकेत देता है कि इस ऑब्जेक्ट को अब रेंडर नहीं किया जाना चाहिए। कूल-डाउन 'कूल-डाउन' एक सामान्य प्रॉपर्टी है जो अल्पकालिक ऑब्जेक्ट्स में पाई जाती है। इसका एक सामान्य उदाहरण एक टेक्स्ट या ग्राफिकल इफेक्ट है, जैसे विस्फोट, जिसे केवल कुछ मिलीसेकंड के लिए देखा जाना चाहिए। ✅ Pac-Man जैसे गेम के बारे में सोचें। क्या आप इस गेम में ऊपर बताए गए चार ऑब्जेक्ट प्रकारों की पहचान कर सकते हैंव्यवहार व्यक्त करना\nऊपर जो हमने वर्णन किया, वे सभी व्यवहार हैं जो गेम ऑब्जेक्ट्स में हो सकते हैं। तो हम उन्हें कैसे कोड करते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 515,
    "chunk_index": 1,
    "total_chunks": 14
  },
  {
    "id": "fb4f14ba1aa04b43b4115b49ed1333f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "अल्पकालिक ऑब्जेक्ट्स में पाई जाती है। इसका एक सामान्य उदाहरण एक टेक्स्ट या ग्राफिकल इफेक्ट है, जैसे विस्फोट, जिसे केवल कुछ मिलीसेकंड के लिए देखा जाना चाहिए। ✅ Pac-Man जैसे गेम के बारे में सोचें। क्या आप इस गेम में ऊपर बताए गए चार ऑब्जेक्ट प्रकारों की पहचान कर सकते हैंव्यवहार व्यक्त करना ऊपर जो हमने वर्णन किया, वे सभी व्यवहार हैं जो गेम ऑब्जेक्ट्स में हो सकते हैं। तो हम उन्हें कैसे कोड करते हैंहम इन व्यवहारों को क्लासेस या ऑब्जेक्ट्स से जुड़े मेथड्स के रूप में व्यक्त कर सकते हैं।\nक्लासेस\nआइडिया यह है कि क्लासेस का उपयोग इनहेरिटेंस के साथ किया जाए ताकि किसी क्लास में एक निश्चित व्यवहार जोड़ा जा सके।\n✅ इनहेरिटेंस एक महत्वपूर्ण अवधारणा है जिसे समझना चाहिए। MDN के इनहेरिटेंस पर लेख पर अधिक जानें।\nकोड के माध्यम से व्यक्त किया गया, एक गेम ऑब्जेक्ट आमतौर पर इस तरह दिख सकता है:\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 788,
    "chunk_index": 2,
    "total_chunks": 14
  },
  {
    "id": "97a0379e6be5d531ef15eb6490c5e759",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "में व्यक्त कर सकते हैं। क्लासेस आइडिया यह है कि क्लासेस का उपयोग इनहेरिटेंस के साथ किया जाए ताकि किसी क्लास में एक निश्चित व्यवहार जोड़ा जा सके। ✅ इनहेरिटेंस एक महत्वपूर्ण अवधारणा है जिसे समझना चाहिए। MDN के इनहेरिटेंस पर लेख पर अधिक जानें। कोड के माध्यम से व्यक्त किया गया, एक गेम ऑब्जेक्ट आमतौर पर इस तरह दिख सकता है: ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x;\nthis y = y;\nthis type = type;\n}\n}\n//this class will extend the GameObject's inherent class properties\nclass Movable extends GameObject {\nconstructor(x,y, type) {\nsuper(x,y, type)\n}\n//this movable object can be moved on the screen\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits\nclass Hero extends Movable {\nconstructor(x,y) {\nsuper(x,y, 'Hero')\n}\n}\n//this class, on the other hand, only inherits the GameObject properties\nclass Tree extends GameObject {\nconstructor(x,y) {\nsuper(x,y, 'Tree')\n}\n}\n//a hero can move",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 3,
    "total_chunks": 14
  },
  {
    "id": "f7e74158fa029c8b6c3caca09c2877b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "moved on the screen moveTo(x, y) { this x = x; this y = y; } } //this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits class Hero extends Movable { constructor(x,y) { super(x,y, 'Hero') } } //this class, on the other hand, only inherits the GameObject properties class Tree extends GameObject { constructor(x,y) { super(x,y, 'Tree') } } //a hero can moveconst hero = new Hero();\nhero moveTo(5,5);\n//but a tree cannot\nconst tree = new Tree();\n```\n✅ कुछ मिनट लें और Pac-Man के हीरो (जैसे Inky, Pinky या Blinky) को फिर से कल्पना करें और इसे जावास्क्रिप्ट में कैसे लिखा जाएगा।\nकंपोज़िशन\nऑब्जेक्ट इनहेरिटेंस को संभालने का एक अलग तरीका कंपोज़िशन का उपयोग करना है। फिर, ऑब्जेक्ट्स अपने व्यवहार को इस तरह व्यक्त करते हैं:\n```javascript\n//create a constant gameObject\nconst gameObject = {\nx: 0,\ny: 0,\ntype: ''\n};\n// and a constant movable\nconst movable = {\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//then the constant movableObject is composed of the gameObject and movable constants\nconst movableObject = { gameObject, movable};\n//then create a function to create a new Hero who inherits the movableObject properties\nfunction createHero(x, y) {\nreturn {",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 4,
    "total_chunks": 14
  },
  {
    "id": "1ebaf9350a20ed29c496370770e81336",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "```javascript //create a constant gameObject const gameObject = { x: 0, y: 0, type: '' }; // and a constant movable const movable = { moveTo(x, y) { this x = x; this y = y; } } //then the constant movableObject is composed of the gameObject and movable constants const movableObject = { gameObject, movable}; //then create a function to create a new Hero who inherits the movableObject properties function createHero(x, y) { return {movableObject,\nx,\ny,\ntype: 'Hero'\n}\n}\n// and a static object that inherits only the gameObject properties\nfunction createStatic(x, y, type) {\nreturn { gameObject\nx,\ny,\ntype\n}\n}\n//create the hero and move it\nconst hero = createHero(10,10);\nhero moveTo(5,5);\n//and create a static tree which only stands around\nconst tree = createStatic(0,0, 'Tree');\n```\nकौन सा पैटर्न उपयोग करना चाहिए",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 232,
    "chunk_index": 5,
    "total_chunks": 14
  },
  {
    "id": "5e735ed886a52fb9f58380dac0195d4e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "new Hero who inherits the movableObject properties function createHero(x, y) { return {movableObject, x, y, type: 'Hero' } } // and a static object that inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); hero moveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` कौन सा पैटर्न उपयोग करना चाहिएयह आप पर निर्भर करता है कि आप कौन सा पैटर्न चुनते हैं। जावास्क्रिप्ट दोनों पैटर्न का समर्थन करता है।\n--\nगेम डेवलपमेंट में एक और सामान्य पैटर्न गेम के उपयोगकर्ता अनुभव और प्रदर्शन को संभालने की समस्या को संबोधित करता है।\nपब/सब पैटर्न\n✅ Pub/Sub का मतलब है 'पब्लिश-सब्सक्राइब'\nयह पैटर्न इस विचार को संबोधित करता है कि आपके एप्लिकेशन के विभिन्न हिस्सों को एक-दूसरे के बारे में नहीं जानना चाहिए। ऐसा क्यों",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 532,
    "chunk_index": 6,
    "total_chunks": 14
  },
  {
    "id": "c4e0856290e3d054647b8a1ae2105314",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "उपयोग करना चाहिएयह आप पर निर्भर करता है कि आप कौन सा पैटर्न चुनते हैं। जावास्क्रिप्ट दोनों पैटर्न का समर्थन करता है। -- गेम डेवलपमेंट में एक और सामान्य पैटर्न गेम के उपयोगकर्ता अनुभव और प्रदर्शन को संभालने की समस्या को संबोधित करता है। पब/सब पैटर्न ✅ Pub/Sub का मतलब है 'पब्लिश-सब्सक्राइब' यह पैटर्न इस विचार को संबोधित करता है कि आपके एप्लिकेशन के विभिन्न हिस्सों को एक-दूसरे के बारे में नहीं जानना चाहिए। ऐसा क्योंयदि विभिन्न हिस्से अलग-अलग हों, तो यह सामान्य रूप से यह देखना बहुत आसान बनाता है कि क्या हो रहा है। यह अचानक व्यवहार बदलने को भी आसान बनाता है यदि आपको इसकी आवश्यकता हो। हम इसे कैसे प्राप्त करते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 603,
    "chunk_index": 7,
    "total_chunks": 14
  },
  {
    "id": "5c9ca3a020a3ae278b239c428eeaae3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "को संबोधित करता है। पब/सब पैटर्न ✅ Pub/Sub का मतलब है 'पब्लिश-सब्सक्राइब' यह पैटर्न इस विचार को संबोधित करता है कि आपके एप्लिकेशन के विभिन्न हिस्सों को एक-दूसरे के बारे में नहीं जानना चाहिए। ऐसा क्योंयदि विभिन्न हिस्से अलग-अलग हों, तो यह सामान्य रूप से यह देखना बहुत आसान बनाता है कि क्या हो रहा है। यह अचानक व्यवहार बदलने को भी आसान बनाता है यदि आपको इसकी आवश्यकता हो। हम इसे कैसे प्राप्त करते हैंहम कुछ अवधारणाओं को स्थापित करके ऐसा करते हैं:\nसंदेश: एक संदेश आमतौर पर एक टेक्स्ट स्ट्रिंग होता है जिसके साथ एक वैकल्पिक पेलोड (डेटा का एक टुकड़ा जो संदेश के बारे में स्पष्ट करता है) होता है। गेम में एक सामान्य संदेश हो सकता है KEY_PRESSED_ENTER।\nपब्लिशर: यह एलिमेंट एक संदेश पब्लिश करता है और इसे सभी सब्सक्राइबर्स को भेजता है।\nसब्सक्राइबर: यह एलिमेंट विशिष्ट संदेशों को सुनता है और इस संदेश को प्राप्त करने के परिणामस्वरूप कुछ कार्य करता है, जैसे लेज़र फायर करना।\nइसका कार्यान्वयन आकार में बहुत छोटा है लेकिन यह एक बहुत ही शक्तिशाली पैटर्न है। इसे इस तरह लागू किया जा सकता है:\n```javascript\n//set up an EventEmitter class that contains listeners\nclass EventEmitter {\nconstructor() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 966,
    "chunk_index": 8,
    "total_chunks": 14
  },
  {
    "id": "5b5a591357ca9e650d0bcab53815000f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "यह एलिमेंट एक संदेश पब्लिश करता है और इसे सभी सब्सक्राइबर्स को भेजता है। सब्सक्राइबर: यह एलिमेंट विशिष्ट संदेशों को सुनता है और इस संदेश को प्राप्त करने के परिणामस्वरूप कुछ कार्य करता है, जैसे लेज़र फायर करना। इसका कार्यान्वयन आकार में बहुत छोटा है लेकिन यह एक बहुत ही शक्तिशाली पैटर्न है। इसे इस तरह लागू किया जा सकता है: ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {};\n}\n//when a message is received, let the listener to handle its payload\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\n//when a message is sent, send it to a listener with some payload\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 422,
    "chunk_index": 9,
    "total_chunks": 14
  },
  {
    "id": "6e49b2b800652395e5bc8dbe6dfdc00b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "लागू किया जा सकता है: ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if ( this listeners[message]) { this listeners[message] = []; } this listeners[message] push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (this listeners[message]) { this listeners[message]forEach(l => l(message, payload))\n}\n}\n}\n```\nऊपर दिए गए कोड का उपयोग करने के लिए हम एक बहुत छोटा कार्यान्वयन बना सकते हैं:\n```javascript\n//set up a message structure\nconst Messages = {\nHERO_MOVE_LEFT: 'HERO_MOVE_LEFT'\n};\n//invoke the eventEmitter you set up above\nconst eventEmitter = new EventEmitter();\n//set up a hero\nconst hero = createHero(0,0);\n//let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero move(5,0);\n});\n//set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left\nwindow addEventListener('keyup', (evt) => {\nif (evt key === 'ArrowLeft') {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 368,
    "chunk_index": 10,
    "total_chunks": 14
  },
  {
    "id": "68aca192a04ae1bacbae015515f717e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "= new EventEmitter(); //set up a hero const hero = createHero(0,0); //let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it eventEmitter on(Messages HERO_MOVE_LEFT, () => { hero move(5,0); }); //set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left window addEventListener('keyup', (evt) => { if (evt key === 'ArrowLeft') { eventEmitter emit(MessagesHERO_MOVE_LEFT)\n}\n});\n```\nऊपर हमने एक कीबोर्ड इवेंट, ArrowLeft को कनेक्ट किया और HERO_MOVE_LEFT संदेश भेजा। हम उस संदेश को सुनते हैं और परिणामस्वरूप हीरो को मूव करते हैं। इस पैटर्न की ताकत यह है कि इवेंट लिसनर और हीरो एक-दूसरे के बारे में नहीं जानते। आप ArrowLeft को A कुंजी पर रीमैप कर सकते हैं। इसके अलावा, यह संभव होगा कि ArrowLeft पर कुछ पूरी तरह से अलग किया जाए, इवेंटEmitter के on फ़ंक्शन में कुछ संपादन करके:\njavascript\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 11,
    "total_chunks": 14
  },
  {
    "id": "2d4f1737b107bf3f449b3bd239d5a365",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "किया और HERO_MOVE_LEFT संदेश भेजा। हम उस संदेश को सुनते हैं और परिणामस्वरूप हीरो को मूव करते हैं। इस पैटर्न की ताकत यह है कि इवेंट लिसनर और हीरो एक-दूसरे के बारे में नहीं जानते। आप ArrowLeft को A कुंजी पर रीमैप कर सकते हैं। इसके अलावा, यह संभव होगा कि ArrowLeft पर कुछ पूरी तरह से अलग किया जाए, इवेंटEmitter के on फ़ंक्शन में कुछ संपादन करके: javascript eventEmitter on(Messages HERO_MOVE_LEFT, () => { heromove(5,0);\n});\nजैसे-जैसे आपका गेम बढ़ता है और चीजें अधिक जटिल होती जाती हैं, यह पैटर्न जटिलता में समान रहता है और आपका कोड साफ रहता है। इस पैटर्न को अपनाने की सिफारिश की जाती है।\n🚀 चुनौती\nसोचें कि पब-सब पैटर्न गेम को कैसे बेहतर बना सकता है। कौन से हिस्से इवेंट्स को एमिट करें, और गेम को उन पर कैसे प्रतिक्रिया देनी चाहिए",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 12,
    "total_chunks": 14
  },
  {
    "id": "b464bf3b7c22c58cc61401507c25f187",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 1: परिचय",
    "content": "में कुछ संपादन करके: javascript eventEmitter on(Messages HERO_MOVE_LEFT, () => { heromove(5,0); }); जैसे-जैसे आपका गेम बढ़ता है और चीजें अधिक जटिल होती जाती हैं, यह पैटर्न जटिलता में समान रहता है और आपका कोड साफ रहता है। इस पैटर्न को अपनाने की सिफारिश की जाती है। 🚀 चुनौती सोचें कि पब-सब पैटर्न गेम को कैसे बेहतर बना सकता है। कौन से हिस्से इवेंट्स को एमिट करें, और गेम को उन पर कैसे प्रतिक्रिया देनी चाहिएअब आपके पास एक नया गेम सोचने और इसके हिस्सों के व्यवहार की कल्पना करने का मौका है।\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nपब/सब के बारे में अधिक जानें इसके बारे में पढ़कर।\nअसाइनमेंट\nएक गेम का मॉकअप बनाएं\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17734,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1003,
    "chunk_index": 13,
    "total_chunks": 14
  },
  {
    "id": "9c8e19efcb5da8906d53adfc7c3128cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\assignment.md",
    "source_type": "git_repo",
    "title": "टकरावों का अन्वेषण करें",
    "content": "टकरावों का अन्वेषण करें\nनिर्देश\nटकराव कैसे काम करते हैं, इसे बेहतर समझने के लिए, कुछ वस्तुओं के साथ एक बहुत छोटा खेल बनाएं जो टकराते हैं। उन्हें कुंजी दबाने या माउस क्लिक के माध्यम से हिलाएं, और जब किसी वस्तु से टकराव हो, तो कुछ ऐसा करें जिससे किसी एक वस्तु पर प्रभाव पड़े। यह कुछ ऐसा हो सकता है जैसे उल्का पृथ्वी से टकरा रहा हो, या बम्पर-कार्स। रचनात्मक बनें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3408,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 349,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "0c6950f69a60b1bcbc4c59c68f894ccc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\assignment.md",
    "source_type": "git_repo",
    "title": "टकरावों का अन्वेषण करें",
    "content": "टकरावों का अन्वेषण करें\nनिर्देश\nटकराव कैसे काम करते हैं, इसे बेहतर समझने के लिए, कुछ वस्तुओं के साथ एक बहुत छोटा खेल बनाएं जो टकराते हैं। उन्हें कुंजी दबाने या माउस क्लिक के माध्यम से हिलाएं, और जब किसी वस्तु से टकराव हो, तो कुछ ऐसा करें जिससे किसी एक वस्तु पर प्रभाव पड़े। यह कुछ ऐसा हो सकता है जैसे उल्का पृथ्वी से टकरा रहा हो, या बम्पर-कार्स। रचनात्मक बनेंमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                                                                                | पर्याप्त                       | सुधार की आवश्यकता |\n| -------- | ------------------------------------------------------------------------------------------------------------------------ | ------------------------------ | ----------------- |\n|          | पूरा कार्यशील कोड नमूना तैयार किया गया है, जिसमें वस्तुएं कैनवास पर खींची गई हैं, बुनियादी टकराव हो रहा है, और प्रतिक्रियाएं हो रही हैं | कोड किसी न किसी रूप में अधूरा है | कोड सही से काम नहीं करता |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3408,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1057,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "ce2d2d7646cc5f044d105e1fb5458ac1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\assignment.md",
    "source_type": "git_repo",
    "title": "स्कोरिंग गेम बनाएं",
    "content": "स्कोरिंग गेम बनाएं\nनिर्देश\nएक ऐसा गेम बनाएं जिसमें आप जीवन और अंकों को रचनात्मक तरीके से प्रदर्शित करें। एक सुझाव है कि जीवन को दिलों के रूप में दिखाएं और अंकों को स्क्रीन के निचले केंद्र भाग में एक बड़े नंबर के रूप में प्रदर्शित करें। मुफ्त गेम संसाधन यहां देखें।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                | पर्याप्त                   | सुधार की आवश्यकता         |\n| ------- | ---------------------- | -------------------------- | -------------------------- |\n|         | पूरा गेम प्रस्तुत किया गया है | गेम आंशिक रूप से प्रस्तुत है | आंशिक गेम में बग हैं       |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2682,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 844,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "1c6e9c1607d1a8c844d962b0272a3ab9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "स्पेस गेम बनाएं भाग 3: गति जोड़ना\nप्री-लेक्चर क्विज\nप्री-लेक्चर क्विज\nगेम्स तब तक मज़ेदार नहीं होते जब तक स्क्रीन पर एलियंस इधर-उधर घूमते नज़र न आएं इस गेम में, हम दो प्रकार की मूवमेंट का उपयोग करेंगे:\nकीबोर्ड/माउस मूवमेंट: जब उपयोगकर्ता कीबोर्ड या माउस के माध्यम से स्क्रीन पर किसी ऑब्जेक्ट को हिलाता है।\nगेम द्वारा प्रेरित मूवमेंट: जब गेम किसी ऑब्जेक्ट को एक निश्चित समय अंतराल पर हिलाता है।\nतो स्क्रीन पर चीजों को कैसे हिलाया जाए",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 429,
    "chunk_index": 0,
    "total_chunks": 27
  },
  {
    "id": "8342d48c8233056b02ecd932a67646df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "भाग 3: गति जोड़ना प्री-लेक्चर क्विज प्री-लेक्चर क्विज गेम्स तब तक मज़ेदार नहीं होते जब तक स्क्रीन पर एलियंस इधर-उधर घूमते नज़र न आएं इस गेम में, हम दो प्रकार की मूवमेंट का उपयोग करेंगे: कीबोर्ड/माउस मूवमेंट: जब उपयोगकर्ता कीबोर्ड या माउस के माध्यम से स्क्रीन पर किसी ऑब्जेक्ट को हिलाता है। गेम द्वारा प्रेरित मूवमेंट: जब गेम किसी ऑब्जेक्ट को एक निश्चित समय अंतराल पर हिलाता है। तो स्क्रीन पर चीजों को कैसे हिलाया जाएयह सब कार्टेशियन कोऑर्डिनेट्स के बारे में है: हम ऑब्जेक्ट के स्थान (x, y) को बदलते हैं और फिर स्क्रीन को फिर से ड्रॉ करते हैं।\nआमतौर पर स्क्रीन पर मूवमेंट को पूरा करने के लिए आपको निम्नलिखित चरणों की आवश्यकता होती है:\nनया स्थान सेट करें किसी ऑब्जेक्ट के लिए; यह आवश्यक है ताकि ऑब्जेक्ट को हिलते हुए देखा जा सके।\nस्क्रीन साफ करें, ड्रॉ के बीच स्क्रीन को साफ करना आवश्यक है। हम इसे बैकग्राउंड रंग से भरे हुए एक आयत को ड्रॉ करके साफ कर सकते हैं।\nऑब्जेक्ट को नए स्थान पर फिर से ड्रॉ करें। ऐसा करके हम अंततः ऑब्जेक्ट को एक स्थान से दूसरे स्थान पर ले जाने में सफल होते हैं।\nकोड में यह कुछ इस तरह दिख सकता है:\njavascript\n//set the hero's location\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 993,
    "chunk_index": 1,
    "total_chunks": 27
  },
  {
    "id": "945cf5192e93911b82e7a852f94f0be3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "को हिलते हुए देखा जा सके। स्क्रीन साफ करें, ड्रॉ के बीच स्क्रीन को साफ करना आवश्यक है। हम इसे बैकग्राउंड रंग से भरे हुए एक आयत को ड्रॉ करके साफ कर सकते हैं। ऑब्जेक्ट को नए स्थान पर फिर से ड्रॉ करें। ऐसा करके हम अंततः ऑब्जेक्ट को एक स्थान से दूसरे स्थान पर ले जाने में सफल होते हैं। कोड में यह कुछ इस तरह दिख सकता है: javascript //set the hero's location herox += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx fillRect(0, 0, canvas width, canvas height)\nctx fillStyle = \"black\";\nctx drawImage(heroImg, hero x, hero y);\n✅ क्या आप सोच सकते हैं कि आपके हीरो को प्रति सेकंड कई फ्रेम्स पर फिर से ड्रॉ करने से प्रदर्शन लागत क्यों बढ़ सकती है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 2,
    "total_chunks": 27
  },
  {
    "id": "4a6d3e99444ed39c27f19b1051af656f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "दिख सकता है: javascript //set the hero's location herox += 5; // clear the rectangle that hosts the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctx fillRect(0, 0, canvas width, canvas height) ctx fillStyle = \"black\"; ctx drawImage(heroImg, hero x, hero y); ✅ क्या आप सोच सकते हैं कि आपके हीरो को प्रति सेकंड कई फ्रेम्स पर फिर से ड्रॉ करने से प्रदर्शन लागत क्यों बढ़ सकती हैइस पैटर्न के विकल्पों के बारे में पढ़ें।\nकीबोर्ड इवेंट्स को हैंडल करें\nआप इवेंट्स को कोड से जोड़कर हैंडल करते हैं। कीबोर्ड इवेंट्स पूरे विंडो पर ट्रिगर होते हैं जबकि माउस इवेंट्स जैसे क्लिक को किसी विशेष एलिमेंट पर क्लिक करने से जोड़ा जा सकता है। हम इस प्रोजेक्ट में कीबोर्ड इवेंट्स का उपयोग करेंगे।\nइवेंट को हैंडल करने के लिए आपको विंडो के addEventListener() मेथड का उपयोग करना होगा और इसे दो इनपुट पैरामीटर प्रदान करने होंगे। पहला पैरामीटर इवेंट का नाम है, जैसे keyup। दूसरा पैरामीटर वह फंक्शन है जिसे इवेंट होने पर इनवोक किया जाना चाहिए।\nयहां एक उदाहरण है:\njavascript\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 753,
    "chunk_index": 3,
    "total_chunks": 27
  },
  {
    "id": "9cf05f29c1f77560c5de08606bd370eb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "जबकि माउस इवेंट्स जैसे क्लिक को किसी विशेष एलिमेंट पर क्लिक करने से जोड़ा जा सकता है। हम इस प्रोजेक्ट में कीबोर्ड इवेंट्स का उपयोग करेंगे। इवेंट को हैंडल करने के लिए आपको विंडो के addEventListener() मेथड का उपयोग करना होगा और इसे दो इनपुट पैरामीटर प्रदान करने होंगे। पहला पैरामीटर इवेंट का नाम है, जैसे keyup। दूसरा पैरामीटर वह फंक्शन है जिसे इवेंट होने पर इनवोक किया जाना चाहिए। यहां एक उदाहरण है: javascript windowaddEventListener('keyup', (evt) => {\n// `evt key` = string representation of the key\nif (evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 414,
    "chunk_index": 4,
    "total_chunks": 27
  },
  {
    "id": "20def23523d7c86f856e5fe3f86636c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "जा सकता है। हम इस प्रोजेक्ट में कीबोर्ड इवेंट्स का उपयोग करेंगे। इवेंट को हैंडल करने के लिए आपको विंडो के addEventListener() मेथड का उपयोग करना होगा और इसे दो इनपुट पैरामीटर प्रदान करने होंगे। पहला पैरामीटर इवेंट का नाम है, जैसे keyup। दूसरा पैरामीटर वह फंक्शन है जिसे इवेंट होने पर इनवोक किया जाना चाहिए। यहां एक उदाहरण है: javascript windowaddEventListener('keyup', (evt) => { // `evt key` = string representation of the key if (evtkey === 'ArrowUp') {\n// do something\n}\n})\nकी इवेंट्स के लिए इवेंट पर दो प्रॉपर्टीज होती हैं जिनका उपयोग यह देखने के लिए किया जा सकता है कि कौन सी कुंजी दबाई गई थी:\nkey, यह दबाई गई कुंजी का स्ट्रिंग रिप्रेजेंटेशन है, जैसे ArrowUp\nkeyCode, यह एक नंबर रिप्रेजेंटेशन है, जैसे 37, जो ArrowLeft के अनुरूप है।\n✅ की इवेंट मैनिपुलेशन गेम डेवलपमेंट के बाहर भी उपयोगी है। इस तकनीक के अन्य उपयोगों के बारे में आप क्या सोच सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 711,
    "chunk_index": 5,
    "total_chunks": 27
  },
  {
    "id": "775c41c31b8b77586804f2e7def692c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "}) की इवेंट्स के लिए इवेंट पर दो प्रॉपर्टीज होती हैं जिनका उपयोग यह देखने के लिए किया जा सकता है कि कौन सी कुंजी दबाई गई थी: key, यह दबाई गई कुंजी का स्ट्रिंग रिप्रेजेंटेशन है, जैसे ArrowUp keyCode, यह एक नंबर रिप्रेजेंटेशन है, जैसे 37, जो ArrowLeft के अनुरूप है। ✅ की इवेंट मैनिपुलेशन गेम डेवलपमेंट के बाहर भी उपयोगी है। इस तकनीक के अन्य उपयोगों के बारे में आप क्या सोच सकते हैंविशेष कुंजियाँ: एक चेतावनी\nकुछ विशेष कुंजियाँ विंडो को प्रभावित करती हैं। इसका मतलब है कि यदि आप keyup इवेंट को सुन रहे हैं और इन विशेष कुंजियों का उपयोग अपने हीरो को हिलाने के लिए करते हैं तो यह क्षैतिज स्क्रॉलिंग भी करेगा। इस कारण से आप अपने गेम को बनाते समय इस बिल्ट-इन ब्राउज़र व्यवहार को बंद करना चाह सकते हैं। इसके लिए आपको ऐसा कोड चाहिए:\n```javascript\nlet onKeyDown = function (e) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 706,
    "chunk_index": 6,
    "total_chunks": 27
  },
  {
    "id": "dbadf8bc50e9de90de985b76c6186e06",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "कुंजियाँ: एक चेतावनी कुछ विशेष कुंजियाँ विंडो को प्रभावित करती हैं। इसका मतलब है कि यदि आप keyup इवेंट को सुन रहे हैं और इन विशेष कुंजियों का उपयोग अपने हीरो को हिलाने के लिए करते हैं तो यह क्षैतिज स्क्रॉलिंग भी करेगा। इस कारण से आप अपने गेम को बनाते समय इस बिल्ट-इन ब्राउज़र व्यवहार को बंद करना चाह सकते हैं। इसके लिए आपको ऐसा कोड चाहिए: ```javascript let onKeyDown = function (e) { consolelog(e keyCode);\nswitch (e keyCode) {\ncase 37:\ncase 39:\ncase 38:\ncase 40: // Arrow keys\ncase 32:\ne preventDefault();\nbreak; // Space\ndefault:\nbreak; // do not block other keys\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 398,
    "chunk_index": 7,
    "total_chunks": 27
  },
  {
    "id": "ed146b31c2dc662ffc17b9e73b227124",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "लिए करते हैं तो यह क्षैतिज स्क्रॉलिंग भी करेगा। इस कारण से आप अपने गेम को बनाते समय इस बिल्ट-इन ब्राउज़र व्यवहार को बंद करना चाह सकते हैं। इसके लिए आपको ऐसा कोड चाहिए: ```javascript let onKeyDown = function (e) { consolelog(e keyCode); switch (e keyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: e preventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown);\n```\nऊपर दिया गया कोड सुनिश्चित करेगा कि एरो-कुंजियाँ और स्पेस कुंजी का डिफ़ॉल्ट व्यवहार बंद हो जाए। बंद करने की प्रक्रिया तब होती है जब हम e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 372,
    "chunk_index": 8,
    "total_chunks": 27
  },
  {
    "id": "e69e1a6a3fe604bc7c81468321fc7392",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "लिए आपको ऐसा कोड चाहिए: ```javascript let onKeyDown = function (e) { consolelog(e keyCode); switch (e keyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: e preventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` ऊपर दिया गया कोड सुनिश्चित करेगा कि एरो-कुंजियाँ और स्पेस कुंजी का डिफ़ॉल्ट व्यवहार बंद हो जाए। बंद करने की प्रक्रिया तब होती है जब हम epreventDefault() को कॉल करते हैं।\nगेम द्वारा प्रेरित मूवमेंट\nहम टाइमर जैसे setTimeout() या setInterval() फंक्शन का उपयोग करके चीजों को खुद से हिलने के लिए बना सकते हैं जो प्रत्येक टिक या समय अंतराल पर ऑब्जेक्ट के स्थान को अपडेट करता है। यह कुछ इस तरह दिख सकता है:\njavascript\nlet id = setInterval(() => {\n//move the enemy on the y axis\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 467,
    "chunk_index": 9,
    "total_chunks": 27
  },
  {
    "id": "b59032d913fc5a64b93d8dd4e649dfea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "हो जाए। बंद करने की प्रक्रिया तब होती है जब हम epreventDefault() को कॉल करते हैं। गेम द्वारा प्रेरित मूवमेंट हम टाइमर जैसे setTimeout() या setInterval() फंक्शन का उपयोग करके चीजों को खुद से हिलने के लिए बना सकते हैं जो प्रत्येक टिक या समय अंतराल पर ऑब्जेक्ट के स्थान को अपडेट करता है। यह कुछ इस तरह दिख सकता है: javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10;\n})\nगेम लूप\nगेम लूप एक अवधारणा है जो मूल रूप से एक फंक्शन है जिसे नियमित अंतराल पर इनवोक किया जाता है। इसे गेम लूप कहा जाता है क्योंकि जो कुछ भी उपयोगकर्ता को दिखाई देना चाहिए वह लूप में ड्रॉ किया जाता है। गेम लूप गेम के सभी ऑब्जेक्ट्स का उपयोग करता है जो गेम का हिस्सा हैं, उन सभी को ड्रॉ करता है जब तक कि किसी कारण से वे अब गेम का हिस्सा नहीं होते। उदाहरण के लिए, यदि कोई ऑब्जेक्ट एक दुश्मन है जिसे लेजर से मारा गया और वह फट गया, तो वह अब वर्तमान गेम लूप का हिस्सा नहीं है (आप इसके बारे में अधिक अगले पाठों में सीखेंगे)।\nगेम लूप आमतौर पर कोड में इस तरह दिख सकता है:\njavascript\nlet gameLoopId = setInterval(() =>\nfunction gameLoop() {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 871,
    "chunk_index": 10,
    "total_chunks": 27
  },
  {
    "id": "b52fbad1c4d4ecd10601e25bdfbcb761",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "सभी को ड्रॉ करता है जब तक कि किसी कारण से वे अब गेम का हिस्सा नहीं होते। उदाहरण के लिए, यदि कोई ऑब्जेक्ट एक दुश्मन है जिसे लेजर से मारा गया और वह फट गया, तो वह अब वर्तमान गेम लूप का हिस्सा नहीं है (आप इसके बारे में अधिक अगले पाठों में सीखेंगे)। गेम लूप आमतौर पर कोड में इस तरह दिख सकता है: javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 339,
    "chunk_index": 11,
    "total_chunks": 27
  },
  {
    "id": "6e4bfd5a9c60a24c27443f1d5b6db1a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "हिस्सा नहीं होते। उदाहरण के लिए, यदि कोई ऑब्जेक्ट एक दुश्मन है जिसे लेजर से मारा गया और वह फट गया, तो वह अब वर्तमान गेम लूप का हिस्सा नहीं है (आप इसके बारे में अधिक अगले पाठों में सीखेंगे)। गेम लूप आमतौर पर कोड में इस तरह दिख सकता है: javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight);\ndrawHero();\ndrawEnemies();\ndrawStaticObjects();\n}, 200);\nऊपर दिया गया लूप हर 200 मिलीसेकंड में कैनवास को फिर से ड्रॉ करने के लिए इनवोक किया जाता है। आपके पास अपने गेम के लिए सबसे अच्छा अंतराल चुनने की क्षमता है।\nस्पेस गेम जारी रखना\nआप मौजूदा कोड को लेंगे और इसे बढ़ाएंगे। या तो उस कोड से शुरू करें जिसे आपने भाग I के दौरान पूरा किया था या भाग II- स्टार्टर में कोड का उपयोग करें।\nहीरो को हिलाना: आप कोड जोड़ेंगे ताकि आप एरो कुंजियों का उपयोग करके हीरो को हिला सकें।\nदुश्मनों को हिलाना: आपको यह सुनिश्चित करने के लिए कोड भी जोड़ना होगा कि दुश्मन एक निश्चित दर पर ऊपर से नीचे की ओर हिलें।\nअनुशंसित चरण\nyour-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए:\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 925,
    "chunk_index": 12,
    "total_chunks": 27
  },
  {
    "id": "ec1cddb2889cb738b78ac5f1d20c4808",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "के दौरान पूरा किया था या भाग II- स्टार्टर में कोड का उपयोग करें। हीरो को हिलाना: आप कोड जोड़ेंगे ताकि आप एरो कुंजियों का उपयोग करके हीरो को हिला सकें। दुश्मनों को हिलाना: आपको यह सुनिश्चित करने के लिए कोड भी जोड़ना होगा कि दुश्मन एक निश्चित दर पर ऊपर से नीचे की ओर हिलें। अनुशंसित चरण your-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए: bash -| assets -| enemyShippng\n-| player png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 377,
    "chunk_index": 13,
    "total_chunks": 27
  },
  {
    "id": "435467efb3895998db4f78d5d823c1c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "का उपयोग करें। हीरो को हिलाना: आप कोड जोड़ेंगे ताकि आप एरो कुंजियों का उपयोग करके हीरो को हिला सकें। दुश्मनों को हिलाना: आपको यह सुनिश्चित करने के लिए कोड भी जोड़ना होगा कि दुश्मन एक निश्चित दर पर ऊपर से नीचे की ओर हिलें। अनुशंसित चरण your-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए: bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson\nआप अपने प्रोजेक्ट को your_work फोल्डर में शुरू करते हैं:\nbash\ncd your-work\nnpm start\nऊपर दिया गया HTTP सर्वर http://localhost:5000 पते पर शुरू करेगा। ब्राउज़र खोलें और उस पते को इनपुट करें, अभी यह हीरो और सभी दुश्मनों को रेंडर करना चाहिए; कुछ भी हिल नहीं रहा है - अभी तक",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 548,
    "chunk_index": 14,
    "total_chunks": 27
  },
  {
    "id": "664c2e37f76d86e3f31264cb6d19a446",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए: bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson आप अपने प्रोजेक्ट को your_work फोल्डर में शुरू करते हैं: bash cd your-work npm start ऊपर दिया गया HTTP सर्वर http://localhost:5000 पते पर शुरू करेगा। ब्राउज़र खोलें और उस पते को इनपुट करें, अभी यह हीरो और सभी दुश्मनों को रेंडर करना चाहिए; कुछ भी हिल नहीं रहा है - अभी तककोड जोड़ें\nहीरो, दुश्मन, और गेम ऑब्जेक्ट के लिए समर्पित ऑब्जेक्ट्स जोड़ें, उनके पास x और y प्रॉपर्टीज होनी चाहिए। (इनहेरिटेंस या कंपोजिशन के हिस्से को याद रखें)।\nसंकेत: गेम ऑब्जेक्ट वह होना चाहिए जिसमें x और y हों और खुद को कैनवास पर ड्रॉ करने की क्षमता हो।\nटिप: नीचे दिए गए कंस्ट्रक्टर के साथ एक नया GameObject क्लास जोड़ें और फिर इसे कैनवास पर ड्रॉ करें:\n```javascript\nclass GameObject {\nconstructor(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 648,
    "chunk_index": 15,
    "total_chunks": 27
  },
  {
    "id": "9d7f49c95076d1bcd0fe3a62a504cfb2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "तककोड जोड़ें हीरो, दुश्मन, और गेम ऑब्जेक्ट के लिए समर्पित ऑब्जेक्ट्स जोड़ें, उनके पास x और y प्रॉपर्टीज होनी चाहिए। (इनहेरिटेंस या कंपोजिशन के हिस्से को याद रखें)। संकेत: गेम ऑब्जेक्ट वह होना चाहिए जिसमें x और y हों और खुद को कैनवास पर ड्रॉ करने की क्षमता हो। टिप: नीचे दिए गए कंस्ट्रक्टर के साथ एक नया GameObject क्लास जोड़ें और फिर इसे कैनवास पर ड्रॉ करें: ```javascript class GameObject { constructor(x, y) { thisx = x;\nthis y = y;\nthis dead = false;\nthis type = \"\";\nthis width = 0;\nthis height = 0;\nthis img = undefined;\n}\ndraw(ctx) {\nctx drawImage(this img, this x, this y, this width, this height);\n}\n}\n```\nअब, इस GameObject को बढ़ाकर हीरो और दुश्मन बनाएं।\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 16,
    "total_chunks": 27
  },
  {
    "id": "73da6836aa80948d7c4fb3afa536abf7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "और फिर इसे कैनवास पर ड्रॉ करें: ```javascript class GameObject { constructor(x, y) { thisx = x; this y = y; this dead = false; this type = \"\"; this width = 0; this height = 0; this img = undefined; } draw(ctx) { ctx drawImage(this img, this x, this y, this width, this height); } } ``` अब, इस GameObject को बढ़ाकर हीरो और दुश्मन बनाएं। ```javascript class Hero extends GameObject { constructor(x, y) {it needs an x, y, type, and speed\n}\n}\n```\n```javascript\nclass Enemy extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 98), (this height = 50);\nthis type = \"Enemy\";\nlet id = setInterval(() => {\nif (this y < canvas height - this height) {\nthis y += 5;\n} else {\nconsole log('Stopped at', this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 249,
    "chunk_index": 17,
    "total_chunks": 27
  },
  {
    "id": "30cee9f5e5633603827d2b09545238fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "GameObject को बढ़ाकर हीरो और दुश्मन बनाएं। ```javascript class Hero extends GameObject { constructor(x, y) {it needs an x, y, type, and speed } } ``` ```javascript class Enemy extends GameObject { constructor(x, y) { super(x, y); (this width = 98), (this height = 50); this type = \"Enemy\"; let id = setInterval(() => { if (this y < canvas height - this height) { this y += 5; } else { console log('Stopped at', thisy)\nclearInterval(id);\n}\n}, 300)\n}\n}\n```\nकी-इवेंट हैंडलर्स जोड़ें ताकि हीरो को ऊपर/नीचे, बाएं/दाएं हिलाया जा सके।\nयाद रखें: यह एक कार्टेशियन सिस्टम है, टॉप-लेफ्ट 0,0 है। डिफ़ॉल्ट व्यवहार को रोकने के लिए कोड जोड़ना भी याद रखें।\nटिप: अपना onKeyDown फंक्शन बनाएं और इसे विंडो से जोड़ें:\n```javascript\nlet onKeyDown = function (e) {\nconsole log(e keyCode); add the code from the lesson above to stop default behavior\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 429,
    "chunk_index": 18,
    "total_chunks": 27
  },
  {
    "id": "e4f22f23b7f7b544f7293219d2faaa64",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "log('Stopped at', thisy) clearInterval(id); } }, 300) } } ``` की-इवेंट हैंडलर्स जोड़ें ताकि हीरो को ऊपर/नीचे, बाएं/दाएं हिलाया जा सके। याद रखें: यह एक कार्टेशियन सिस्टम है, टॉप-लेफ्ट 0,0 है। डिफ़ॉल्ट व्यवहार को रोकने के लिए कोड जोड़ना भी याद रखें। टिप: अपना onKeyDown फंक्शन बनाएं और इसे विंडो से जोड़ें: ```javascript let onKeyDown = function (e) { console log(e keyCode); add the code from the lesson above to stop default behavior } }; windowaddEventListener(\"keydown\", onKeyDown);\n```\nइस बिंदु पर अपने ब्राउज़र कंसोल की जांच करें, और कीस्ट्रोक्स को लॉग होते हुए देखें।\nपब सब पैटर्न लागू करें, यह आपके कोड को साफ रखेगा क्योंकि आप शेष भागों का पालन करते हैं।\nऐसा करने के लिए, आप:\nविंडो पर एक इवेंट लिसनर जोड़ें:\njavascript\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 19,
    "total_chunks": 27
  },
  {
    "id": "2ee22609cf2ea49852a1ddca89206327",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "से जोड़ें: ```javascript let onKeyDown = function (e) { console log(e keyCode); add the code from the lesson above to stop default behavior } }; windowaddEventListener(\"keydown\", onKeyDown); ``` इस बिंदु पर अपने ब्राउज़र कंसोल की जांच करें, और कीस्ट्रोक्स को लॉग होते हुए देखें। पब सब पैटर्न लागू करें, यह आपके कोड को साफ रखेगा क्योंकि आप शेष भागों का पालन करते हैं। ऐसा करने के लिए, आप: विंडो पर एक इवेंट लिसनर जोड़ें: javascript windowaddEventListener(\"keyup\", (evt) => {\nif (evt key === \"ArrowUp\") {\neventEmitter emit(Messages KEY_EVENT_UP);\n} else if (evt key === \"ArrowDown\") {\neventEmitter emit(Messages KEY_EVENT_DOWN);\n} else if (evt key === \"ArrowLeft\") {\neventEmitter emit(Messages KEY_EVENT_LEFT);\n} else if (evt key === \"ArrowRight\") {\neventEmitter emit(Messages KEY_EVENT_RIGHT);\n}\n});\nएक EventEmitter क्लास बनाएं ताकि संदेशों को प्रकाशित और सब्सक्राइब किया जा सके:\n```javascript\nclass EventEmitter {\nconstructor() {\nthis listeners = {};\n}\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 20,
    "total_chunks": 27
  },
  {
    "id": "9133eb6ddb419d2aff13752feafc0164",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "} else if (evt key === \"ArrowLeft\") { eventEmitter emit(Messages KEY_EVENT_LEFT); } else if (evt key === \"ArrowRight\") { eventEmitter emit(Messages KEY_EVENT_RIGHT); } }); एक EventEmitter क्लास बनाएं ताकि संदेशों को प्रकाशित और सब्सक्राइब किया जा सके: ```javascript class EventEmitter { constructor() { this listeners = {}; } on(message, listener) { if ( this listeners[message]) { this listeners[message] = []; } this listeners[message] push(listener); } emit(message, payload = null) { if (this listeners[message]) { this listeners[message]forEach((l) => l(message, payload));\n}\n}\n}\n```\nकॉन्स्टेंट्स जोड़ें और EventEmitter सेट करें:\n```javascript\nconst Messages = {\nKEY_EVENT_UP: \"KEY_EVENT_UP\",\nKEY_EVENT_DOWN: \"KEY_EVENT_DOWN\",\nKEY_EVENT_LEFT: \"KEY_EVENT_LEFT\",\nKEY_EVENT_RIGHT: \"KEY_EVENT_RIGHT\",\n};\nlet heroImg,\nenemyImg,\nlaserImg,\ncanvas, ctx,\ngameObjects = [],\nhero,\neventEmitter = new EventEmitter();\n```\nगेम को इनिशियलाइज़ करें\n```javascript\nfunction initGame() {\ngameObjects = [];\ncreateEnemies();\ncreateHero();\neventEmitter on(Messages KEY_EVENT_UP, () => {\nhero y -=5 ;\n})\neventEmitter on(Messages KEY_EVENT_DOWN, () => {\nhero y += 5;\n});\neventEmitter on(Messages KEY_EVENT_LEFT, () => {\nhero x -= 5;\n});\neventEmitter on(Messages KEY_EVENT_RIGHT, () => {\nhero x += 5;\n});\n}\n```\nगेम लूप सेट करें\nविंडो",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 433,
    "chunk_index": 21,
    "total_chunks": 27
  },
  {
    "id": "0e02c6173422ffc2bb9004bdbe533284",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "laserImg, canvas, ctx, gameObjects = [], hero, eventEmitter = new EventEmitter(); ``` गेम को इनिशियलाइज़ करें ```javascript function initGame() { gameObjects = []; createEnemies(); createHero(); eventEmitter on(Messages KEY_EVENT_UP, () => { hero y -=5 ; }) eventEmitter on(Messages KEY_EVENT_DOWN, () => { hero y += 5; }); eventEmitter on(Messages KEY_EVENT_LEFT, () => { hero x -= 5; }); eventEmitter on(Messages KEY_EVENT_RIGHT, () => { hero x += 5; }); } ``` गेम लूप सेट करें विंडोonload फंक्शन को रिफैक्टर करें ताकि गेम को इनिशियलाइज़ किया जा सके और एक अच्छे अंतराल पर गेम लूप सेट किया जा सके। आप एक लेजर बीम भी जोड़ेंगे:\n```javascript\nwindow onload = async () => {\ncanvas = document getElementById(\"canvas\");\nctx = canvas getContext(\"2d\");\nheroImg = await loadTexture(\"assets/player png\");\nenemyImg = await loadTexture(\"assets/enemyShip png\");\nlaserImg = await loadTexture(\"assets/laserRed png\");\ninitGame();\nlet gameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 406,
    "chunk_index": 22,
    "total_chunks": 27
  },
  {
    "id": "2c9ff60a7301ba9cd1d645ed3e273161",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "इनिशियलाइज़ किया जा सके और एक अच्छे अंतराल पर गेम लूप सेट किया जा सके। आप एक लेजर बीम भी जोड़ेंगे: ```javascript window onload = async () => { canvas = document getElementById(\"canvas\"); ctx = canvas getContext(\"2d\"); heroImg = await loadTexture(\"assets/player png\"); enemyImg = await loadTexture(\"assets/enemyShip png\"); laserImg = await loadTexture(\"assets/laserRed png\"); initGame(); let gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight);\ndrawGameObjects(ctx);\n}, 100)\n};\n```\nकोड जोड़ें ताकि दुश्मन एक निश्चित अंतराल पर हिलें\ncreateEnemies() फंक्शन को रिफैक्टर करें ताकि दुश्मनों को बनाया जा सके और उन्हें नए gameObjects क्लास में पुश किया जा सके:\n```javascript\nfunction createEnemies() {\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas width - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nconst enemy = new Enemy(x, y);\nenemy img = enemyImg;\ngameObjects",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 483,
    "chunk_index": 23,
    "total_chunks": 27
  },
  {
    "id": "48a7556ef70d8ba38dd5079f4eaa4d8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "और उन्हें नए gameObjects क्लास में पुश किया जा सके: ```javascript function createEnemies() { const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvas width - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { const enemy = new Enemy(x, y); enemy img = enemyImg; gameObjectspush(enemy);\n}\n}\n}\n```\nऔर हीरो के लिए समान प्रक्रिया करने के लिए एक createHero() फंक्शन जोड़ें।\njavascript\nfunction createHero() {\nhero = new Hero(\ncanvas width / 2 - 45,\ncanvas height - canvas height / 4\n);\nhero img = heroImg;\ngameObjects push(hero);\n}\nऔर अंत में, एक drawGameObjects() फंक्शन जोड़ें ताकि ड्रॉ शुरू हो सके:\njavascript\nfunction drawGameObjects(ctx) {\ngameObjects forEach(go => go draw(ctx));\n}\nआपके दुश्मन आपके हीरो स्पेसशिप पर आगे बढ़ना शुरू कर देंगे",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 397,
    "chunk_index": 24,
    "total_chunks": 27
  },
  {
    "id": "41f11c5110b27a24d9648b36acee8d95",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "``` और हीरो के लिए समान प्रक्रिया करने के लिए एक createHero() फंक्शन जोड़ें। javascript function createHero() { hero = new Hero( canvas width / 2 - 45, canvas height - canvas height / 4 ); hero img = heroImg; gameObjects push(hero); } और अंत में, एक drawGameObjects() फंक्शन जोड़ें ताकि ड्रॉ शुरू हो सके: javascript function drawGameObjects(ctx) { gameObjects forEach(go => go draw(ctx)); } आपके दुश्मन आपके हीरो स्पेसशिप पर आगे बढ़ना शुरू कर देंगे🚀 चुनौती\nजैसा कि आप देख सकते हैं, जब आप फंक्शन्स, वेरिएबल्स और क्लासेस जोड़ना शुरू करते हैं तो आपका कोड 'स्पेगेटी कोड' में बदल सकता है। आप अपने कोड को अधिक पठनीय बनाने के लिए इसे बेहतर तरीके से कैसे व्यवस्थित कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 458,
    "chunk_index": 25,
    "total_chunks": 27
  },
  {
    "id": "b4d3f37fb5603fd09878026d284fd617",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 3: गति जोड़ना",
    "content": "अंत में, एक drawGameObjects() फंक्शन जोड़ें ताकि ड्रॉ शुरू हो सके: javascript function drawGameObjects(ctx) { gameObjects forEach(go => go draw(ctx)); } आपके दुश्मन आपके हीरो स्पेसशिप पर आगे बढ़ना शुरू कर देंगे🚀 चुनौती जैसा कि आप देख सकते हैं, जब आप फंक्शन्स, वेरिएबल्स और क्लासेस जोड़ना शुरू करते हैं तो आपका कोड 'स्पेगेटी कोड' में बदल सकता है। आप अपने कोड को अधिक पठनीय बनाने के लिए इसे बेहतर तरीके से कैसे व्यवस्थित कर सकते हैंएक सिस्टम का स्केच बनाएं ताकि आपका कोड व्यवस्थित हो, भले ही वह अभी भी एक ही फाइल में हो।\nपोस्ट-लेक्चर क्विज\nपोस्ट-लेक्चर क्विज\nसमीक्षा और स्व-अध्ययन\nहालांकि हम अपने गेम को फ्रेमवर्क्स का उपयोग किए बिना लिख रहे हैं, गेम डेवलपमेंट के लिए कई जावास्क्रिप्ट-आधारित कैनवास फ्रेमवर्क हैं। इनके बारे में पढ़ने के लिए समय निकालें।\nअसाइनमेंट\nअपने कोड पर टिप्पणी करें\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 24487,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1125,
    "chunk_index": 26,
    "total_chunks": 27
  },
  {
    "id": "40a2b29dd36b9620655f243d07ef058f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\assignment.md",
    "source_type": "git_repo",
    "title": "एक नमूना गेम बनाएं",
    "content": "एक नमूना गेम बनाएं\nनिर्देश\nऐसा एक छोटा गेम बनाने की कोशिश करें जिसमें आप विभिन्न अंत परिस्थितियों का अभ्यास कर सकें। जैसे कि कुछ अंकों को प्राप्त करना, हीरो की सभी ज़िंदगियाँ खत्म हो जाना, या सभी राक्षसों का पराजित हो जाना। कुछ सरल बनाएं, जैसे कि एक कंसोल आधारित एडवेंचर गेम। नीचे दिए गए गेम फ्लो को प्रेरणा के रूप में उपयोग करें:\nHero> Strikes with broadsword - orc takes 3p damage\nOrc> Hits with club - hero takes 2p damage\nHero> Kicks - orc takes 1p damage\nGame> Orc is defeated - Hero collects 2 coins\nGame> ****No more monsters, you have conquered the evil fortress****\nमूल्यांकन मानदंड\n| मानदंड   | उत्कृष्ट                | पर्याप्त                     | सुधार की आवश्यकता          |\n| -------- | ---------------------- | --------------------------- | -------------------------- |\n|          | पूरा गेम प्रस्तुत है    | गेम आंशिक रूप से प्रस्तुत है | आंशिक गेम में बग्स हैं     |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3074,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 973,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "941437462e7f02c4bf43f99060921930",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nइस पाठ में, आप सीखेंगे कि गेम में स्कोरिंग कैसे जोड़ें और जीवन की गणना कैसे करें।\nस्क्रीन पर टेक्स्ट प्रदर्शित करें\nगेम स्कोर को स्क्रीन पर प्रदर्शित करने के लिए, आपको यह जानना होगा कि स्क्रीन पर टेक्स्ट कैसे रखा जाए। इसका उत्तर है fillText() मेथड का उपयोग करना, जो कैनवास ऑब्जेक्ट पर उपलब्ध है। आप अन्य पहलुओं को भी नियंत्रित कर सकते हैं जैसे कि कौन सा फॉन्ट उपयोग करना है, टेक्स्ट का रंग और यहां तक कि उसका संरेखण (बाएं, दाएं, केंद्र)। नीचे दिया गया कोड स्क्रीन पर टेक्स्ट प्रदर्शित करता है।\njavascript\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 551,
    "chunk_index": 0,
    "total_chunks": 17
  },
  {
    "id": "68d78f8113c738c661bb6562361f8208",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "करें गेम स्कोर को स्क्रीन पर प्रदर्शित करने के लिए, आपको यह जानना होगा कि स्क्रीन पर टेक्स्ट कैसे रखा जाए। इसका उत्तर है fillText() मेथड का उपयोग करना, जो कैनवास ऑब्जेक्ट पर उपलब्ध है। आप अन्य पहलुओं को भी नियंत्रित कर सकते हैं जैसे कि कौन सा फॉन्ट उपयोग करना है, टेक्स्ट का रंग और यहां तक कि उसका संरेखण (बाएं, दाएं, केंद्र)। नीचे दिया गया कोड स्क्रीन पर टेक्स्ट प्रदर्शित करता है। javascript ctxfont = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 384,
    "chunk_index": 1,
    "total_chunks": 17
  },
  {
    "id": "633bc082f67faec53e7a60d73edc8c31",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "जानना होगा कि स्क्रीन पर टेक्स्ट कैसे रखा जाए। इसका उत्तर है fillText() मेथड का उपयोग करना, जो कैनवास ऑब्जेक्ट पर उपलब्ध है। आप अन्य पहलुओं को भी नियंत्रित कर सकते हैं जैसे कि कौन सा फॉन्ट उपयोग करना है, टेक्स्ट का रंग और यहां तक कि उसका संरेखण (बाएं, दाएं, केंद्र)। नीचे दिया गया कोड स्क्रीन पर टेक्स्ट प्रदर्शित करता है। javascript ctxfont = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0);\n✅ कैसे कैनवास पर टेक्स्ट जोड़ें के बारे में अधिक पढ़ें, और इसे और आकर्षक बनाने के लिए स्वतंत्र महसूस करें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 2,
    "total_chunks": 17
  },
  {
    "id": "f72c516b454a9c0c0ab13bbb81025a9b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "भी नियंत्रित कर सकते हैं जैसे कि कौन सा फॉन्ट उपयोग करना है, टेक्स्ट का रंग और यहां तक कि उसका संरेखण (बाएं, दाएं, केंद्र)। नीचे दिया गया कोड स्क्रीन पर टेक्स्ट प्रदर्शित करता है। javascript ctxfont = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ कैसे कैनवास पर टेक्स्ट जोड़ें के बारे में अधिक पढ़ें, और इसे और आकर्षक बनाने के लिए स्वतंत्र महसूस करेंजीवन, एक गेम अवधारणा के रूप में\nगेम में जीवन की अवधारणा केवल एक संख्या है। स्पेस गेम के संदर्भ में, यह आम है कि एक सेट संख्या में जीवन दिया जाए, जो आपके जहाज को नुकसान होने पर एक-एक करके घटता है। यदि आप इसे ग्राफिकल रूप में दिखा सकें, जैसे मिनीशिप्स या दिल, तो यह संख्या की तुलना में अधिक आकर्षक लगता है।\nक्या बनाना है\nअपने गेम में निम्नलिखित जोड़ें:\nगेम स्कोर: हर दुश्मन जहाज को नष्ट करने पर, हीरो को कुछ अंक दिए जाने चाहिए। हम सुझाव देते हैं कि प्रति जहाज 100 अंक दिए जाएं। गेम स्कोर को नीचे बाईं ओर दिखाया जाना चाहिए।\nजीवन: आपके जहाज के पास तीन जीवन हैं। हर बार जब कोई दुश्मन जहाज आपसे टकराता है, तो आप एक जीवन खो देते हैं। जीवन स्कोर को नीचे दाईं ओर प्रदर्शित किया जाना चाहिए और इसे निम्न ग्राफिक से बनाया जाना चाहिए ।\nअनुशंसित कदम\nyour-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित शामिल होना चाहिए:\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1140,
    "chunk_index": 3,
    "total_chunks": 17
  },
  {
    "id": "5ec3cdca2463bbfb63d367545c05450d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "अंक दिए जाएं। गेम स्कोर को नीचे बाईं ओर दिखाया जाना चाहिए। जीवन: आपके जहाज के पास तीन जीवन हैं। हर बार जब कोई दुश्मन जहाज आपसे टकराता है, तो आप एक जीवन खो देते हैं। जीवन स्कोर को नीचे दाईं ओर प्रदर्शित किया जाना चाहिए और इसे निम्न ग्राफिक से बनाया जाना चाहिए । अनुशंसित कदम your-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित शामिल होना चाहिए: bash -| assets -| enemyShippng\n-| player png\n-| laserRed png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 390,
    "chunk_index": 4,
    "total_chunks": 17
  },
  {
    "id": "7233535a71a4c01bdd0a6ddf3dc8d4a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "जहाज के पास तीन जीवन हैं। हर बार जब कोई दुश्मन जहाज आपसे टकराता है, तो आप एक जीवन खो देते हैं। जीवन स्कोर को नीचे दाईं ओर प्रदर्शित किया जाना चाहिए और इसे निम्न ग्राफिक से बनाया जाना चाहिए । अनुशंसित कदम your-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित शामिल होना चाहिए: bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson\nआप अपने प्रोजेक्ट को your_work फोल्डर में निम्नलिखित टाइप करके शुरू करें:\nbash\ncd your-work\nnpm start\nऊपर दिया गया कमांड HTTP सर्वर को http://localhost:5000 पते पर शुरू करेगा। ब्राउज़र खोलें और उस पते को दर्ज करें। अभी, यह हीरो और सभी दुश्मनों को रेंडर करेगा, और जब आप अपने बाएं और दाएं तीर दबाएंगे, तो हीरो हिल सकता है और दुश्मनों को शूट कर सकता है।\nकोड जोड़ें\nआवश्यक एसेट्स कॉपी करें। solution/assets/ फोल्डर से your-work फोल्डर में आवश्यक एसेट्स कॉपी करें; इसमें life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 712,
    "chunk_index": 5,
    "total_chunks": 17
  },
  {
    "id": "29e33dfc9c626aa857da84f37dcb6fb1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "करके शुरू करें: bash cd your-work npm start ऊपर दिया गया कमांड HTTP सर्वर को http://localhost:5000 पते पर शुरू करेगा। ब्राउज़र खोलें और उस पते को दर्ज करें। अभी, यह हीरो और सभी दुश्मनों को रेंडर करेगा, और जब आप अपने बाएं और दाएं तीर दबाएंगे, तो हीरो हिल सकता है और दुश्मनों को शूट कर सकता है। कोड जोड़ें आवश्यक एसेट्स कॉपी करें। solution/assets/ फोल्डर से your-work फोल्डर में आवश्यक एसेट्स कॉपी करें; इसमें lifepng एसेट जोड़ें। window onload फंक्शन में lifeImg जोड़ें:\njavascript\nlifeImg = await loadTexture(\"assets/life png\");\nएसेट्स की सूची में lifeImg जोड़ें:\njavascript\nlet heroImg, lifeImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 440,
    "chunk_index": 6,
    "total_chunks": 17
  },
  {
    "id": "1c48a951ffb3cf8e8e1fe4c6ed0162c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "पते को दर्ज करें। अभी, यह हीरो और सभी दुश्मनों को रेंडर करेगा, और जब आप अपने बाएं और दाएं तीर दबाएंगे, तो हीरो हिल सकता है और दुश्मनों को शूट कर सकता है। कोड जोड़ें आवश्यक एसेट्स कॉपी करें। solution/assets/ फोल्डर से your-work फोल्डर में आवश्यक एसेट्स कॉपी करें; इसमें lifepng एसेट जोड़ें। window onload फंक्शन में lifeImg जोड़ें: javascript lifeImg = await loadTexture(\"assets/life png\"); एसेट्स की सूची में lifeImg जोड़ें: javascript let heroImg, lifeImg,eventEmitter = new EventEmitter();\nवेरिएबल्स जोड़ें। अपने कुल स्कोर (0) और बचे हुए जीवन (3) का प्रतिनिधित्व करने वाले कोड को जोड़ें, और इन स्कोर को स्क्रीन पर प्रदर्शित करें।\nupdateGameObjects() फंक्शन को विस्तारित करें। दुश्मन के टकराव को संभालने के लिए updateGameObjects() फंक्शन को विस्तारित करें:\njavascript\nenemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 7,
    "total_chunks": 17
  },
  {
    "id": "bffb516fccaaaf048e3237c8071f0f8d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "कॉपी करें; इसमें lifepng एसेट जोड़ें। window onload फंक्शन में lifeImg जोड़ें: javascript lifeImg = await loadTexture(\"assets/life png\"); एसेट्स की सूची में lifeImg जोड़ें: javascript let heroImg, lifeImg,eventEmitter = new EventEmitter(); वेरिएबल्स जोड़ें। अपने कुल स्कोर (0) और बचे हुए जीवन (3) का प्रतिनिधित्व करने वाले कोड को जोड़ें, और इन स्कोर को स्क्रीन पर प्रदर्शित करें। updateGameObjects() फंक्शन को विस्तारित करें। दुश्मन के टकराव को संभालने के लिए updateGameObjects() फंक्शन को विस्तारित करें: javascript enemiesforEach(enemy => {\nconst heroRect = hero rectFromGameObject();\nif (intersectRect(heroRect, enemy rectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy });\n}\n})\nजीवन और अंक जोड़ें।\nवेरिएबल्स इनिशियलाइज़ करें। Hero क्लास में this cooldown = 0 के तहत जीवन और अंक सेट करें:\n```javascript\nthis life = 3;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 8,
    "total_chunks": 17
  },
  {
    "id": "73641ae9c70b9a799602dae2a02816f9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "को जोड़ें, और इन स्कोर को स्क्रीन पर प्रदर्शित करें। updateGameObjects() फंक्शन को विस्तारित करें। दुश्मन के टकराव को संभालने के लिए updateGameObjects() फंक्शन को विस्तारित करें: javascript enemiesforEach(enemy => { const heroRect = hero rectFromGameObject(); if (intersectRect(heroRect, enemy rectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) जीवन और अंक जोड़ें। वेरिएबल्स इनिशियलाइज़ करें। Hero क्लास में this cooldown = 0 के तहत जीवन और अंक सेट करें: ```javascript this life = 3; thispoints = 0;\n```\nस्क्रीन पर वेरिएबल्स ड्रॉ करें। इन मानों को स्क्रीन पर ड्रॉ करें:\n```javascript\nfunction drawLife() {\n// TODO, 35, 27\nconst START_POS = canvas width - 180;\nfor(let i=0; i < hero life; i++ ) {\nctx drawImage(\nlifeImg,\nSTART_POS + (45 * (i+1) ),\ncanvas height - 37);\n}\n}\nfunction drawPoints() {\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"left\";\ndrawText(\"Points: \" + hero points, 10, canvas height-20);\n}\nfunction drawText(message, x, y) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 476,
    "chunk_index": 9,
    "total_chunks": 17
  },
  {
    "id": "6dc7438a446155ad575eff77ee1e90f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "मानों को स्क्रीन पर ड्रॉ करें: ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvas width - 180; for(let i=0; i < hero life; i++ ) { ctx drawImage( lifeImg, START_POS + (45 * (i+1) ), canvas height - 37); } } function drawPoints() { ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"left\"; drawText(\"Points: \" + hero points, 10, canvas height-20); } function drawText(message, x, y) { ctxfillText(message, x, y);\n}\n```\nगेम लूप में मेथड्स जोड़ें। सुनिश्चित करें कि आप इन फंक्शन्स को window onload फंक्शन में updateGameObjects() के तहत जोड़ें:\n```javascript\ndrawPoints();\ndrawLife();\n```\nगेम नियम लागू करें। निम्नलिखित गेम नियम लागू करें:\nहर हीरो और दुश्मन टकराव के लिए, एक जीवन घटाएं।\nHero क्लास को इस घटाव को संभालने के लिए विस्तारित करें:\n```javascript\ndecrementLife() {\nthis life--;\nif (this life === 0) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 434,
    "chunk_index": 10,
    "total_chunks": 17
  },
  {
    "id": "da00ca7276c313399e5f9ba7606cb33d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "function drawText(message, x, y) { ctxfillText(message, x, y); } ``` गेम लूप में मेथड्स जोड़ें। सुनिश्चित करें कि आप इन फंक्शन्स को window onload फंक्शन में updateGameObjects() के तहत जोड़ें: ```javascript drawPoints(); drawLife(); ``` गेम नियम लागू करें। निम्नलिखित गेम नियम लागू करें: हर हीरो और दुश्मन टकराव के लिए, एक जीवन घटाएं। Hero क्लास को इस घटाव को संभालने के लिए विस्तारित करें: ```javascript decrementLife() { this life--; if (this life === 0) { thisdead = true;\n}\n}\n```\nहर लेजर जो दुश्मन को हिट करता है, गेम स्कोर में 100 अंक जोड़ें।\nHero क्लास को इस वृद्धि को संभालने के लिए विस्तारित करें:\n```javascript\nincrementPoints() {\nthis points += 100;\n}\n```\nइन फंक्शन्स को अपने टकराव इवेंट एमिटर्स में जोड़ें:\n```javascript\neventEmitter on(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 11,
    "total_chunks": 17
  },
  {
    "id": "ad0f9ec44d76080d3b9159fef5a4e4a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "जीवन घटाएं। Hero क्लास को इस घटाव को संभालने के लिए विस्तारित करें: ```javascript decrementLife() { this life--; if (this life === 0) { thisdead = true; } } ``` हर लेजर जो दुश्मन को हिट करता है, गेम स्कोर में 100 अंक जोड़ें। Hero क्लास को इस वृद्धि को संभालने के लिए विस्तारित करें: ```javascript incrementPoints() { this points += 100; } ``` इन फंक्शन्स को अपने टकराव इवेंट एमिटर्स में जोड़ें: ```javascript eventEmitter on(MessagesCOLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\n})\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero decrementLife();\n});\n```\n✅ थोड़ा शोध करें और पता लगाएं कि जावास्क्रिप्ट/कैनवास का उपयोग करके बनाए गए अन्य गेम कौन-कौन से हैं। उनके सामान्य लक्षण क्या हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 467,
    "chunk_index": 12,
    "total_chunks": 17
  },
  {
    "id": "bb4fdee5d3196125da97f0fc191a611b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "points += 100; } ``` इन फंक्शन्स को अपने टकराव इवेंट एमिटर्स में जोड़ें: ```javascript eventEmitter on(MessagesCOLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); }) eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); }); ``` ✅ थोड़ा शोध करें और पता लगाएं कि जावास्क्रिप्ट/कैनवास का उपयोग करके बनाए गए अन्य गेम कौन-कौन से हैं। उनके सामान्य लक्षण क्या हैंइस काम के अंत तक, आपको नीचे दाईं ओर छोटे 'जीवन' जहाज, नीचे बाईं ओर अंक, और दुश्मनों से टकराने पर जीवन की गिनती घटती हुई और दुश्मनों को शूट करने पर अंक बढ़ते हुए दिखाई देंगे। बहुत अच्छा",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 13,
    "total_chunks": 17
  },
  {
    "id": "785a967aa0e2be6368e21730f8899184",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "(_, { enemy }) => { enemy dead = true; hero decrementLife(); }); ``` ✅ थोड़ा शोध करें और पता लगाएं कि जावास्क्रिप्ट/कैनवास का उपयोग करके बनाए गए अन्य गेम कौन-कौन से हैं। उनके सामान्य लक्षण क्या हैंइस काम के अंत तक, आपको नीचे दाईं ओर छोटे 'जीवन' जहाज, नीचे बाईं ओर अंक, और दुश्मनों से टकराने पर जीवन की गिनती घटती हुई और दुश्मनों को शूट करने पर अंक बढ़ते हुए दिखाई देंगे। बहुत अच्छाआपका गेम लगभग पूरा हो गया है।\n🚀 चुनौती\nआपका कोड लगभग पूरा हो गया है। क्या आप अपने अगले कदमों की कल्पना कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 463,
    "chunk_index": 14,
    "total_chunks": 17
  },
  {
    "id": "35f2f9896cb0f9f11f474443a8395741",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "करके बनाए गए अन्य गेम कौन-कौन से हैं। उनके सामान्य लक्षण क्या हैंइस काम के अंत तक, आपको नीचे दाईं ओर छोटे 'जीवन' जहाज, नीचे बाईं ओर अंक, और दुश्मनों से टकराने पर जीवन की गिनती घटती हुई और दुश्मनों को शूट करने पर अंक बढ़ते हुए दिखाई देंगे। बहुत अच्छाआपका गेम लगभग पूरा हो गया है। 🚀 चुनौती आपका कोड लगभग पूरा हो गया है। क्या आप अपने अगले कदमों की कल्पना कर सकते हैंपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nकुछ तरीकों पर शोध करें जिनसे आप गेम स्कोर और जीवन को बढ़ा और घटा सकते हैं। PlayFab जैसे कुछ दिलचस्प गेम इंजन हैं। इनका उपयोग आपके गेम को कैसे बेहतर बना सकता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 15,
    "total_chunks": 17
  },
  {
    "id": "249fc83252e037dac2fdef7bd2f5ff2a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 5: स्कोरिंग और जीवन",
    "content": "को शूट करने पर अंक बढ़ते हुए दिखाई देंगे। बहुत अच्छाआपका गेम लगभग पूरा हो गया है। 🚀 चुनौती आपका कोड लगभग पूरा हो गया है। क्या आप अपने अगले कदमों की कल्पना कर सकते हैंपोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन कुछ तरीकों पर शोध करें जिनसे आप गेम स्कोर और जीवन को बढ़ा और घटा सकते हैं। PlayFab जैसे कुछ दिलचस्प गेम इंजन हैं। इनका उपयोग आपके गेम को कैसे बेहतर बना सकता हैअसाइनमेंट\nस्कोरिंग गेम बनाएं\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13278,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 844,
    "chunk_index": 16,
    "total_chunks": 17
  },
  {
    "id": "144ef77c906e6728d37c802c2d610284",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1571,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "734c4328e129417942871239b6c84294",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1549,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "55d4a6307dee2df38f0a938cce2ba9c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1588,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "39d50fa35386ff5dea91f4d76b1c8f59",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1587,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "31b4f6702d29e628436275ff0db8dda9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1588,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\5-keeping-score\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "56fbc03c0ba17f2dadaff18fcdd1b27e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1593,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "da85c8bac7f682671e176e12236b5bbe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1594,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b041ea68cf4e735d887b2cdd5e1e8541",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने एक्सटेंशन को नया रूप दें",
    "content": "अपने एक्सटेंशन को नया रूप दें\nनिर्देश\nइस एक्सटेंशन के कोडबेस में पहले से ही स्टाइल्स शामिल हैं, लेकिन आपको इन्हें उपयोग करने की ज़रूरत नहीं है; इसे अपना बनाने के लिए इसके CSS फाइल को एडिट करके इसे नया रूप दें।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                    | पर्याप्त              | सुधार की आवश्यकता |\n| ------- | ------------------------------------------ | --------------------- | ------------------ |\n|         | कोड नए और कार्यशील स्टाइल्स के साथ सबमिट किया गया है | स्टाइलिंग अधूरी है | स्टाइल्स में गड़बड़ी है |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 827,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0aa18c1355e42b7672f86cf987f015d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nइस पाठ में आप सीखेंगे कि जावास्क्रिप्ट के साथ लेज़र कैसे शूट करें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 159,
    "chunk_index": 0,
    "total_chunks": 24
  },
  {
    "id": "d6fb7262c2a8f0c0538ace57c3af3870",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nइस पाठ में आप सीखेंगे कि जावास्क्रिप्ट के साथ लेज़र कैसे शूट करेंहम अपने गेम में दो चीजें जोड़ेंगे:\nएक लेज़र: यह लेज़र आपके हीरो के जहाज से ऊपर की ओर शूट होता है।\nटकराव का पता लगाना, शूटिंग की क्षमता को लागू करने के हिस्से के रूप में हम कुछ अच्छे गेम नियम भी जोड़ेंगे:\nलेज़र दुश्मन को हिट करता है: लेज़र से हिट होने पर दुश्मन मर जाता है।\nलेज़र स्क्रीन के शीर्ष को हिट करता है: स्क्रीन के शीर्ष भाग को हिट करने पर लेज़र नष्ट हो जाता है।\nदुश्मन और हीरो का टकराव: यदि दुश्मन और हीरो एक-दूसरे से टकराते हैं तो दोनों नष्ट हो जाते हैं।\nदुश्मन स्क्रीन के नीचे पहुंचता है: यदि दुश्मन स्क्रीन के नीचे पहुंचता है तो दुश्मन और हीरो दोनों नष्ट हो जाते हैं।\nसंक्षेप में, आप -- हीरो -- को सभी दुश्मनों को लेज़र से हिट करना होगा इससे पहले कि वे स्क्रीन के नीचे पहुंच जाएं।\n✅ सबसे पहले लिखे गए कंप्यूटर गेम के बारे में थोड़ा शोध करें। इसकी कार्यक्षमता क्या थी",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 919,
    "chunk_index": 1,
    "total_chunks": 24
  },
  {
    "id": "6a2d7327a1f0b96d4e66b9c3e70facb4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "दुश्मन और हीरो एक-दूसरे से टकराते हैं तो दोनों नष्ट हो जाते हैं। दुश्मन स्क्रीन के नीचे पहुंचता है: यदि दुश्मन स्क्रीन के नीचे पहुंचता है तो दुश्मन और हीरो दोनों नष्ट हो जाते हैं। संक्षेप में, आप -- हीरो -- को सभी दुश्मनों को लेज़र से हिट करना होगा इससे पहले कि वे स्क्रीन के नीचे पहुंच जाएं। ✅ सबसे पहले लिखे गए कंप्यूटर गेम के बारे में थोड़ा शोध करें। इसकी कार्यक्षमता क्या थीआइए साथ मिलकर हीरो बनें टकराव का पता लगाना\nहम टकराव का पता कैसे लगाते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 439,
    "chunk_index": 2,
    "total_chunks": 24
  },
  {
    "id": "47d3da33696a43e68f5399e56cb05d68",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "के नीचे पहुंचता है: यदि दुश्मन स्क्रीन के नीचे पहुंचता है तो दुश्मन और हीरो दोनों नष्ट हो जाते हैं। संक्षेप में, आप -- हीरो -- को सभी दुश्मनों को लेज़र से हिट करना होगा इससे पहले कि वे स्क्रीन के नीचे पहुंच जाएं। ✅ सबसे पहले लिखे गए कंप्यूटर गेम के बारे में थोड़ा शोध करें। इसकी कार्यक्षमता क्या थीआइए साथ मिलकर हीरो बनें टकराव का पता लगाना हम टकराव का पता कैसे लगाते हैंहमें अपने गेम ऑब्जेक्ट्स को आयतों के रूप में सोचना होगा जो इधर-उधर घूमते हैं। आप पूछ सकते हैं कि ऐसा क्यों",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 3,
    "total_chunks": 24
  },
  {
    "id": "d63c2a2cd733dcd723d2ead94e5edfa9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "में, आप -- हीरो -- को सभी दुश्मनों को लेज़र से हिट करना होगा इससे पहले कि वे स्क्रीन के नीचे पहुंच जाएं। ✅ सबसे पहले लिखे गए कंप्यूटर गेम के बारे में थोड़ा शोध करें। इसकी कार्यक्षमता क्या थीआइए साथ मिलकर हीरो बनें टकराव का पता लगाना हम टकराव का पता कैसे लगाते हैंहमें अपने गेम ऑब्जेक्ट्स को आयतों के रूप में सोचना होगा जो इधर-उधर घूमते हैं। आप पूछ सकते हैं कि ऐसा क्योंखैर, गेम ऑब्जेक्ट को ड्रॉ करने के लिए उपयोग की गई छवि एक आयत है: इसमें x, y, width और height होता है।\nयदि दो आयतें, यानी हीरो और दुश्मन इंटरसेक्ट करते हैं, तो टकराव होता है। इसके बाद क्या होना चाहिए यह गेम के नियमों पर निर्भर करता है। टकराव का पता लगाने के लिए आपको निम्नलिखित की आवश्यकता होगी:\nगेम ऑब्जेक्ट का आयत प्रतिनिधित्व प्राप्त करने का एक तरीका, कुछ इस तरह:\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 719,
    "chunk_index": 4,
    "total_chunks": 24
  },
  {
    "id": "cdd5f0f56da080173921cf5330befe46",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "करने के लिए उपयोग की गई छवि एक आयत है: इसमें x, y, width और height होता है। यदि दो आयतें, यानी हीरो और दुश्मन इंटरसेक्ट करते हैं, तो टकराव होता है। इसके बाद क्या होना चाहिए यह गेम के नियमों पर निर्भर करता है। टकराव का पता लगाने के लिए आपको निम्नलिखित की आवश्यकता होगी: गेम ऑब्जेक्ट का आयत प्रतिनिधित्व प्राप्त करने का एक तरीका, कुछ इस तरह: javascript rectFromGameObject() { return { top: thisy,\nleft: this x,\nbottom: this y + this height,\nright: this x + this width\n}\n}\nतुलना करने का एक फ़ंक्शन, यह फ़ंक्शन कुछ इस तरह दिख सकता है:\njavascript\nfunction intersectRect(r1, r2) {\nreturn (r2 left > r1 right ||\nr2 right < r1 left ||\nr2 top > r1 bottom ||\nr2 bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 460,
    "chunk_index": 5,
    "total_chunks": 24
  },
  {
    "id": "8ecfcbac7e29ceda1fd3eb96b834d144",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "का आयत प्रतिनिधित्व प्राप्त करने का एक तरीका, कुछ इस तरह: javascript rectFromGameObject() { return { top: thisy, left: this x, bottom: this y + this height, right: this x + this width } } तुलना करने का एक फ़ंक्शन, यह फ़ंक्शन कुछ इस तरह दिख सकता है: javascript function intersectRect(r1, r2) { return (r2 left > r1 right || r2 right < r1 left || r2 top > r1 bottom || r2 bottom < r1top);\n}\nचीजों को नष्ट कैसे करें\nगेम में चीजों को नष्ट करने के लिए आपको गेम को यह बताना होगा कि इसे अब गेम लूप में पेंट नहीं करना चाहिए जो एक निश्चित अंतराल पर ट्रिगर होता है। ऐसा करने का एक तरीका यह है कि जब कुछ होता है तो गेम ऑब्जेक्ट को डेड के रूप में चिह्नित करें, जैसे:\njavascript\n// collision happened\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 457,
    "chunk_index": 6,
    "total_chunks": 24
  },
  {
    "id": "574708992af6e7807fe762ab2d5a3805",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "r2 top > r1 bottom || r2 bottom < r1top); } चीजों को नष्ट कैसे करें गेम में चीजों को नष्ट करने के लिए आपको गेम को यह बताना होगा कि इसे अब गेम लूप में पेंट नहीं करना चाहिए जो एक निश्चित अंतराल पर ट्रिगर होता है। ऐसा करने का एक तरीका यह है कि जब कुछ होता है तो गेम ऑब्जेक्ट को डेड के रूप में चिह्नित करें, जैसे: javascript // collision happened enemydead = true\nफिर आप स्क्रीन को फिर से पेंट करने से पहले डेड ऑब्जेक्ट्स को हटा सकते हैं, जैसे:\njavascript\ngameObjects = gameObject filter(go => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 366,
    "chunk_index": 7,
    "total_chunks": 24
  },
  {
    "id": "7c81f4284351f0d65e5f9a30d87e9576",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "को यह बताना होगा कि इसे अब गेम लूप में पेंट नहीं करना चाहिए जो एक निश्चित अंतराल पर ट्रिगर होता है। ऐसा करने का एक तरीका यह है कि जब कुछ होता है तो गेम ऑब्जेक्ट को डेड के रूप में चिह्नित करें, जैसे: javascript // collision happened enemydead = true फिर आप स्क्रीन को फिर से पेंट करने से पहले डेड ऑब्जेक्ट्स को हटा सकते हैं, जैसे: javascript gameObjects = gameObject filter(go => godead);\nलेज़र कैसे फायर करें\nलेज़र फायर करना एक की-इवेंट पर प्रतिक्रिया देने और एक ऑब्जेक्ट बनाने का अनुवाद करता है जो एक निश्चित दिशा में चलता है। इसलिए हमें निम्नलिखित कदम उठाने होंगे:\nलेज़र ऑब्जेक्ट बनाएं: हमारे हीरो के जहाज के शीर्ष से, जो बनते ही स्क्रीन के शीर्ष की ओर ऊपर की ओर बढ़ना शुरू कर देता है।\nकोड को की-इवेंट से जोड़ें: हमें कीबोर्ड पर एक कुंजी चुननी होगी जो खिलाड़ी द्वारा लेज़र शूट करने का प्रतिनिधित्व करती है।\nएक गेम ऑब्जेक्ट बनाएं जो लेज़र जैसा दिखता है जब कुंजी दबाई जाती है।\nहमारे लेज़र पर कूलडाउन\nलेज़र को हर बार फायर करना चाहिए जब आप एक कुंजी दबाते हैं, जैसे स्पेस। गेम को बहुत कम समय में बहुत सारे लेज़र उत्पन्न करने से रोकने के लिए हमें इसे ठीक करना होगा। इसे ठीक करने का तरीका कूलडाउन लागू करना है, एक टाइमर, जो सुनिश्चित करता है कि लेज़र केवल एक निश्चित समय में फायर किया जा सकता है। आप इसे निम्नलिखित तरीके से लागू कर सकते हैं:\n```javascript\nclass Cooldown {\nconstructor(time) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1130,
    "chunk_index": 8,
    "total_chunks": 24
  },
  {
    "id": "be2dc5a4572590032f71fec1d2f1e5ae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "हर बार फायर करना चाहिए जब आप एक कुंजी दबाते हैं, जैसे स्पेस। गेम को बहुत कम समय में बहुत सारे लेज़र उत्पन्न करने से रोकने के लिए हमें इसे ठीक करना होगा। इसे ठीक करने का तरीका कूलडाउन लागू करना है, एक टाइमर, जो सुनिश्चित करता है कि लेज़र केवल एक निश्चित समय में फायर किया जा सकता है। आप इसे निम्नलिखित तरीके से लागू कर सकते हैं: ```javascript class Cooldown { constructor(time) { thiscool = false;\nsetTimeout(() => {\nthis cool = true;\n}, time)\n}\n}\nclass Weapon {\nconstructor {\n}\nfire() {\nif ( this cooldown || this cooldown cool) {\n// produce a laser\nthis cooldown = new Cooldown(500);\n} else {\n// do nothing - it hasn't cooled down yet",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 389,
    "chunk_index": 9,
    "total_chunks": 24
  },
  {
    "id": "15c70642decdaa5b94b4028b24524e43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "एक निश्चित समय में फायर किया जा सकता है। आप इसे निम्नलिखित तरीके से लागू कर सकते हैं: ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { this cool = true; }, time) } } class Weapon { constructor { } fire() { if ( this cooldown || this cooldown cool) { // produce a laser this cooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet}\n}\n}\n```\n✅ स्पेस गेम श्रृंखला के पाठ 1 को देखें ताकि कूलडाउन के बारे में याद दिलाया जा सके।\nक्या बनाना है\nआप पिछले पाठ से मौजूदा कोड (जिसे आपने साफ और पुनर्गठित किया होना चाहिए) लेंगे और इसे बढ़ाएंगे। या तो भाग II से कोड शुरू करें या भाग III- स्टार्टर पर कोड का उपयोग करें।\nटिप: जिस लेज़र के साथ आप काम करेंगे वह पहले से ही आपके एसेट्स फोल्डर में है और आपके कोड द्वारा संदर्भित है।\nटकराव का पता लगाना जोड़ें, जब लेज़र किसी चीज़ से टकराता है तो निम्नलिखित नियम लागू होने चाहिए:\nलेज़र दुश्मन को हिट करता है: लेज़र से हिट होने पर दुश्मन मर जाता है।\nलेज़र स्क्रीन के शीर्ष को हिट करता है: स्क्रीन के शीर्ष भाग को हिट करने पर लेज़र नष्ट हो जाता है।\nदुश्मन और हीरो का टकराव: यदि दुश्मन और हीरो एक-दूसरे से टकराते हैं तो दोनों नष्ट हो जाते हैं।\nदुश्मन स्क्रीन के नीचे पहुंचता है: यदि दुश्मन स्क्रीन के नीचे पहुंचता है तो दुश्मन और हीरो दोनों नष्ट हो जाते हैं।\nअनुशंसित कदम\nyour-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए:\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1086,
    "chunk_index": 10,
    "total_chunks": 24
  },
  {
    "id": "c04ca6e91e7abeab222f62ebf05dfc2d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "करता है: स्क्रीन के शीर्ष भाग को हिट करने पर लेज़र नष्ट हो जाता है। दुश्मन और हीरो का टकराव: यदि दुश्मन और हीरो एक-दूसरे से टकराते हैं तो दोनों नष्ट हो जाते हैं। दुश्मन स्क्रीन के नीचे पहुंचता है: यदि दुश्मन स्क्रीन के नीचे पहुंचता है तो दुश्मन और हीरो दोनों नष्ट हो जाते हैं। अनुशंसित कदम your-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए: bash -| assets -| enemyShippng\n-| player png\n-| laserRed png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 394,
    "chunk_index": 11,
    "total_chunks": 24
  },
  {
    "id": "a05b729786f958e70ac2b674ccc787d0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "है। दुश्मन और हीरो का टकराव: यदि दुश्मन और हीरो एक-दूसरे से टकराते हैं तो दोनों नष्ट हो जाते हैं। दुश्मन स्क्रीन के नीचे पहुंचता है: यदि दुश्मन स्क्रीन के नीचे पहुंचता है तो दुश्मन और हीरो दोनों नष्ट हो जाते हैं। अनुशंसित कदम your-work सब फोल्डर में बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित होना चाहिए: bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson\nआप अपने प्रोजेक्ट को your_work फोल्डर में निम्नलिखित टाइप करके शुरू करें:\nbash\ncd your-work\nnpm start\nऊपर दिया गया HTTP सर्वर को http://localhost:5000 पते पर शुरू करेगा। एक ब्राउज़र खोलें और उस पते को इनपुट करें, अभी यह हीरो और सभी दुश्मनों को रेंडर करना चाहिए, लेकिन कुछ भी मूव नहीं हो रहा है - अभी तक :)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 584,
    "chunk_index": 12,
    "total_chunks": 24
  },
  {
    "id": "0a6bcfbcf399aadff7620abae1626d93",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson आप अपने प्रोजेक्ट को your_work फोल्डर में निम्नलिखित टाइप करके शुरू करें: bash cd your-work npm start ऊपर दिया गया HTTP सर्वर को http://localhost:5000 पते पर शुरू करेगा। एक ब्राउज़र खोलें और उस पते को इनपुट करें, अभी यह हीरो और सभी दुश्मनों को रेंडर करना चाहिए, लेकिन कुछ भी मूव नहीं हो रहा है - अभी तक :)कोड जोड़ें\nअपने गेम ऑब्जेक्ट का आयत प्रतिनिधित्व सेटअप करें, टकराव को संभालने के लिए नीचे दिया गया कोड आपको GameObject का आयत प्रतिनिधित्व प्राप्त करने की अनुमति देता है। अपने GameObject क्लास को इसे बढ़ाने के लिए संपादित करें:\njavascript\nrectFromGameObject() {\nreturn {\ntop: this y,\nleft: this x,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 13,
    "total_chunks": 24
  },
  {
    "id": "1a1c1989a88fd5ca58ce30995af1faed",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "इनपुट करें, अभी यह हीरो और सभी दुश्मनों को रेंडर करना चाहिए, लेकिन कुछ भी मूव नहीं हो रहा है - अभी तक :)कोड जोड़ें अपने गेम ऑब्जेक्ट का आयत प्रतिनिधित्व सेटअप करें, टकराव को संभालने के लिए नीचे दिया गया कोड आपको GameObject का आयत प्रतिनिधित्व प्राप्त करने की अनुमति देता है। अपने GameObject क्लास को इसे बढ़ाने के लिए संपादित करें: javascript rectFromGameObject() { return { top: this y, left: this x, bottom: thisy + this height,\nright: this x + this width,\n};\n}\nटकराव की जांच करने वाला कोड जोड़ें यह एक नया फ़ंक्शन होगा जो परीक्षण करता है कि क्या दो आयतें इंटरसेक्ट करती हैं:\njavascript\nfunction intersectRect(r1, r2) {\nreturn (\nr2 left > r1 right ||\nr2 right < r1 left ||\nr2 top > r1 bottom ||\nr2 bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 14,
    "total_chunks": 24
  },
  {
    "id": "2cf3dae7ed2e197f4b36229e6ec74dd8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "javascript rectFromGameObject() { return { top: this y, left: this x, bottom: thisy + this height, right: this x + this width, }; } टकराव की जांच करने वाला कोड जोड़ें यह एक नया फ़ंक्शन होगा जो परीक्षण करता है कि क्या दो आयतें इंटरसेक्ट करती हैं: javascript function intersectRect(r1, r2) { return ( r2 left > r1 right || r2 right < r1 left || r2 top > r1 bottom || r2 bottom < r1top\n);\n}\nलेज़र फायर करने की क्षमता जोड़ें\nकी-इवेंट संदेश जोड़ें। स्पेस कुंजी को हीरो जहाज के ठीक ऊपर एक लेज़र बनाना चाहिए। Messages ऑब्जेक्ट में तीन कॉन्स्टेंट्स जोड़ें:\njavascript\nKEY_EVENT_SPACE: \"KEY_EVENT_SPACE\",\nCOLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\",\nCOLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\",\nस्पेस कुंजी को संभालें। window addEventListener के keyup फ़ंक्शन को स्पेस को संभालने के लिए संपादित करें:\njavascript\n} else if(evt keyCode === 32) {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 15,
    "total_chunks": 24
  },
  {
    "id": "9105539fca871bee0a13d420489ff654",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "r1 left || r2 top > r1 bottom || r2 bottom < r1top ); } लेज़र फायर करने की क्षमता जोड़ें की-इवेंट संदेश जोड़ें। स्पेस कुंजी को हीरो जहाज के ठीक ऊपर एक लेज़र बनाना चाहिए। Messages ऑब्जेक्ट में तीन कॉन्स्टेंट्स जोड़ें: javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", स्पेस कुंजी को संभालें। window addEventListener के keyup फ़ंक्शन को स्पेस को संभालने के लिए संपादित करें: javascript } else if(evt keyCode === 32) { eventEmitter emit(MessagesKEY_EVENT_SPACE);\n}\nलिसनर्स जोड़ें। सुनिश्चित करें कि जब स्पेस बार दबाया जाए तो हीरो फायर कर सके, इसके लिए initGame() फ़ंक्शन को संपादित करें:\njavascript\neventEmitter on(Messages KEY_EVENT_SPACE, () => {\nif (hero canFire()) {\nhero fire();\n}\nऔर एक नया eventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 465,
    "chunk_index": 16,
    "total_chunks": 24
  },
  {
    "id": "a28c95c823fd839cb31821534138e3e7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "जोड़ें: javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", स्पेस कुंजी को संभालें। window addEventListener के keyup फ़ंक्शन को स्पेस को संभालने के लिए संपादित करें: javascript } else if(evt keyCode === 32) { eventEmitter emit(MessagesKEY_EVENT_SPACE); } लिसनर्स जोड़ें। सुनिश्चित करें कि जब स्पेस बार दबाया जाए तो हीरो फायर कर सके, इसके लिए initGame() फ़ंक्शन को संपादित करें: javascript eventEmitter on(Messages KEY_EVENT_SPACE, () => { if (hero canFire()) { hero fire(); } और एक नया eventEmitteron() फ़ंक्शन जोड़ें ताकि जब दुश्मन लेज़र से टकराए तो व्यवहार सुनिश्चित हो सके:\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 403,
    "chunk_index": 17,
    "total_chunks": 24
  },
  {
    "id": "117f34267f6e1d6da313907a0d2c155a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "keyCode === 32) { eventEmitter emit(MessagesKEY_EVENT_SPACE); } लिसनर्स जोड़ें। सुनिश्चित करें कि जब स्पेस बार दबाया जाए तो हीरो फायर कर सके, इसके लिए initGame() फ़ंक्शन को संपादित करें: javascript eventEmitter on(Messages KEY_EVENT_SPACE, () => { if (hero canFire()) { hero fire(); } और एक नया eventEmitteron() फ़ंक्शन जोड़ें ताकि जब दुश्मन लेज़र से टकराए तो व्यवहार सुनिश्चित हो सके: ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; seconddead = true;\n})\n```\nऑब्जेक्ट को मूव करें, सुनिश्चित करें कि लेज़र धीरे-धीरे स्क्रीन के शीर्ष तक मूव करे। आप एक नया Laser क्लास बनाएंगे जो GameObject को बढ़ाता है, जैसा आपने पहले किया था:\njavascript\nclass Laser extends GameObject {\nconstructor(x, y) {\nsuper(x,y);\n(this width = 9), (this height = 33);\nthis type = 'Laser';\nthis img = laserImg;\nlet id = setInterval(() => {\nif (this y > 0) {\nthis y -= 15;\n} else {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 18,
    "total_chunks": 24
  },
  {
    "id": "cfcf3f511c5a4206c570bdf6ed2ecd4f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "को मूव करें, सुनिश्चित करें कि लेज़र धीरे-धीरे स्क्रीन के शीर्ष तक मूव करे। आप एक नया Laser क्लास बनाएंगे जो GameObject को बढ़ाता है, जैसा आपने पहले किया था: javascript class Laser extends GameObject { constructor(x, y) { super(x,y); (this width = 9), (this height = 33); this type = 'Laser'; this img = laserImg; let id = setInterval(() => { if (this y > 0) { this y -= 15; } else { thisdead = true;\nclearInterval(id);\n}\n}, 100)\n}\n}\nटकराव को संभालें, लेज़र के लिए टकराव नियम लागू करें। एक updateGameObjects() फ़ंक्शन जोड़ें जो हिट के लिए टकराने वाले ऑब्जेक्ट्स का परीक्षण करता है:\n```javascript\nfunction updateGameObjects() {\nconst enemies = gameObjects filter(go => go type === 'Enemy');\nconst lasers = gameObjects filter((go) => go type === \"Laser\");\n// laser hit something\nlasers forEach((l) => {\nenemies forEach((m) => {\nif (intersectRect(l rectFromGameObject(), m rectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_LASER, {\nfirst: l,\nsecond: m,\n});\n}\n});\n});\ngameObjects = gameObjects filter(go => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 19,
    "total_chunks": 24
  },
  {
    "id": "e1fc3a01baff3a0a2b149edb55720b22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "करें। एक updateGameObjects() फ़ंक्शन जोड़ें जो हिट के लिए टकराने वाले ऑब्जेक्ट्स का परीक्षण करता है: ```javascript function updateGameObjects() { const enemies = gameObjects filter(go => go type === 'Enemy'); const lasers = gameObjects filter((go) => go type === \"Laser\"); // laser hit something lasers forEach((l) => { enemies forEach((m) => { if (intersectRect(l rectFromGameObject(), m rectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_LASER, { first: l, second: m, }); } }); }); gameObjects = gameObjects filter(go => godead);\n}\n```\nसुनिश्चित करें कि updateGameObjects() को अपने गेम लूप में window onload में जोड़ें।\nलेज़र पर कूलडाउन लागू करें, ताकि इसे केवल एक निश्चित समय में फायर किया जा सके।\nअंत में, Hero क्लास को संपादित करें ताकि यह कूलडाउन कर सके:\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 99), (this height = 75);\nthis type = \"Hero\";\nthis speed = { x: 0, y: 0 };\nthis cooldown = 0;\n}\nfire() {\ngameObjects push(new Laser(this x + 45, this y - 10));\nthis cooldown = 500;\nlet id = setInterval(() => {\nif (this cooldown > 0) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 20,
    "total_chunks": 24
  },
  {
    "id": "2a4bf4f6418aa68f77daaeedffdbf4fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "Hero क्लास को संपादित करें ताकि यह कूलडाउन कर सके: ```javascript class Hero extends GameObject { constructor(x, y) { super(x, y); (this width = 99), (this height = 75); this type = \"Hero\"; this speed = { x: 0, y: 0 }; this cooldown = 0; } fire() { gameObjects push(new Laser(this x + 45, this y - 10)); this cooldown = 500; let id = setInterval(() => { if (this cooldown > 0) { thiscooldown -= 100;\n} else {\nclearInterval(id);\n}\n}, 200);\n}\ncanFire() {\nreturn this cooldown === 0;\n}\n}\n```\nइस बिंदु पर, आपके गेम में कुछ कार्यक्षमता है आप अपने एरो कीज़ के साथ नेविगेट कर सकते हैं, अपने स्पेस बार के साथ लेज़र फायर कर सकते हैं, और जब आप दुश्मनों को हिट करते हैं तो वे गायब हो जाते हैं। बहुत अच्छा 🚀 चुनौती\nएक विस्फोट जोड़ें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 407,
    "chunk_index": 21,
    "total_chunks": 24
  },
  {
    "id": "1d4246bd70ead36df2805cc402d829be",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "(this cooldown > 0) { thiscooldown -= 100; } else { clearInterval(id); } }, 200); } canFire() { return this cooldown === 0; } } ``` इस बिंदु पर, आपके गेम में कुछ कार्यक्षमता है आप अपने एरो कीज़ के साथ नेविगेट कर सकते हैं, अपने स्पेस बार के साथ लेज़र फायर कर सकते हैं, और जब आप दुश्मनों को हिट करते हैं तो वे गायब हो जाते हैं। बहुत अच्छा 🚀 चुनौती एक विस्फोट जोड़ेंस्पेस आर्ट रिपो में गेम एसेट्स पर एक नज़र डालें और जब लेज़र एलियन को हिट करे तो विस्फोट जोड़ने का प्रयास करें।\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nअब तक आपके गेम में अंतराल के साथ प्रयोग करें। जब आप उन्हें बदलते हैं तो क्या होता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 526,
    "chunk_index": 22,
    "total_chunks": 24
  },
  {
    "id": "404da06a3f7bea0fa267719bef192126",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 4: लेज़र जोड़ें और टकराव का पता लगाएं",
    "content": "के साथ लेज़र फायर कर सकते हैं, और जब आप दुश्मनों को हिट करते हैं तो वे गायब हो जाते हैं। बहुत अच्छा 🚀 चुनौती एक विस्फोट जोड़ेंस्पेस आर्ट रिपो में गेम एसेट्स पर एक नज़र डालें और जब लेज़र एलियन को हिट करे तो विस्फोट जोड़ने का प्रयास करें। पोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन अब तक आपके गेम में अंतराल के साथ प्रयोग करें। जब आप उन्हें बदलते हैं तो क्या होता हैजावास्क्रिप्ट टाइमिंग इवेंट्स के बारे में अधिक पढ़ें।\nअसाइनमेंट\nटकराव का अन्वेषण करें\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 891,
    "chunk_index": 23,
    "total_chunks": 24
  },
  {
    "id": "4b0fc12d4f959e2aecf0840f3ced903f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nकिसी गेम में समाप्ति की स्थिति व्यक्त करने के कई तरीके होते हैं। यह गेम के निर्माता के रूप में आप पर निर्भर करता है कि आप तय करें कि गेम क्यों समाप्त हुआ। यदि हम अब तक बनाए गए स्पेस गेम की बात करें, तो यहां कुछ संभावित कारण दिए गए हैं:\nN दुश्मन जहाज नष्ट हो गए हैं: यह काफी सामान्य है, खासकर यदि आप गेम को विभिन्न स्तरों में विभाजित करते हैं, तो आपको एक स्तर पूरा करने के लिए N दुश्मन जहाजों को नष्ट करना होगा।\nआपका जहाज नष्ट हो गया है: ऐसे कई गेम होते हैं जहां आपका जहाज नष्ट होने पर आप गेम हार जाते हैं। एक और सामान्य तरीका यह है कि गेम में \"लाइव्स\" की अवधारणा हो। हर बार जब आपका जहाज नष्ट होता है, तो एक जीवन कम हो जाता है। जब सभी जीवन समाप्त हो जाते हैं, तो आप गेम हार जाते हैं।\nआपने N अंक एकत्र किए हैं: एक और सामान्य समाप्ति की स्थिति यह है कि आप अंक एकत्र करें। अंक कैसे प्राप्त किए जाते हैं, यह आप पर निर्भर करता है, लेकिन आमतौर पर दुश्मन जहाज को नष्ट करने या उन वस्तुओं को एकत्र करने पर अंक दिए जाते हैं जो नष्ट होने पर गिरती हैं।\nएक स्तर पूरा करें: इसमें कई स्थितियां शामिल हो सकती हैं, जैसे X दुश्मन जहाज नष्ट करना, Y अंक एकत्र करना, या शायद कोई विशेष वस्तु एकत्र करना।\nपुनः प्रारंभ करना\nयदि लोग आपके गेम का आनंद लेते हैं, तो वे इसे फिर से खेलना चाहेंगे। किसी भी कारण से गेम समाप्त होने के बाद, आपको इसे पुनः प्रारंभ करने का विकल्प देना चाहिए।\n✅ सोचें कि किन स्थितियों में आपको लगता है कि कोई गेम समाप्त होता है, और फिर आपको इसे पुनः प्रारंभ करने के लिए कैसे प्रेरित किया जाता है।\nक्या बनाना है\nआपको अपने गेम में ये नियम जोड़ने होंगे:\nगेम जीतना। जब सभी दुश्मन जहाज नष्ट हो जाते हैं, तो आप गेम जीत जाते हैं। इसके अतिरिक्त, किसी प्रकार का विजय संदेश प्रदर्शित करें।\nपुनः प्रारंभ। जब आपके सभी जीवन समाप्त हो जाते हैं या गेम जीत लिया जाता है, तो आपको गेम को पुनः प्रारंभ करने का विकल्प देना चाहिए। याद रखें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1738,
    "chunk_index": 0,
    "total_chunks": 14
  },
  {
    "id": "8010c76b2f67103cbaebe4231d50a6e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "इसे पुनः प्रारंभ करने के लिए कैसे प्रेरित किया जाता है। क्या बनाना है आपको अपने गेम में ये नियम जोड़ने होंगे: गेम जीतना। जब सभी दुश्मन जहाज नष्ट हो जाते हैं, तो आप गेम जीत जाते हैं। इसके अतिरिक्त, किसी प्रकार का विजय संदेश प्रदर्शित करें। पुनः प्रारंभ। जब आपके सभी जीवन समाप्त हो जाते हैं या गेम जीत लिया जाता है, तो आपको गेम को पुनः प्रारंभ करने का विकल्प देना चाहिए। याद रखेंआपको गेम को फिर से प्रारंभ करना होगा और पिछले गेम की स्थिति को साफ़ करना होगा।\nअनुशंसित चरण\nyour-work सब फोल्डर में आपके लिए बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित फाइल्स होनी चाहिए:\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 557,
    "chunk_index": 1,
    "total_chunks": 14
  },
  {
    "id": "3ba8f7ed88b4f962ec96b267afd8b28d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "अतिरिक्त, किसी प्रकार का विजय संदेश प्रदर्शित करें। पुनः प्रारंभ। जब आपके सभी जीवन समाप्त हो जाते हैं या गेम जीत लिया जाता है, तो आपको गेम को पुनः प्रारंभ करने का विकल्प देना चाहिए। याद रखेंआपको गेम को फिर से प्रारंभ करना होगा और पिछले गेम की स्थिति को साफ़ करना होगा। अनुशंसित चरण your-work सब फोल्डर में आपके लिए बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित फाइल्स होनी चाहिए: bash -| assets -| enemyShippng\n-| player png\n-| laserRed png\n-| life png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 399,
    "chunk_index": 2,
    "total_chunks": 14
  },
  {
    "id": "55d65ef4ddae41f243b54881f639231d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "हैं या गेम जीत लिया जाता है, तो आपको गेम को पुनः प्रारंभ करने का विकल्प देना चाहिए। याद रखेंआपको गेम को फिर से प्रारंभ करना होगा और पिछले गेम की स्थिति को साफ़ करना होगा। अनुशंसित चरण your-work सब फोल्डर में आपके लिए बनाए गए फाइल्स को ढूंढें। इसमें निम्नलिखित फाइल्स होनी चाहिए: bash -| assets -| enemyShippng -| player png -| laserRed png -| life png -| index html -| app js -| packagejson\nआप अपने प्रोजेक्ट को your_work फोल्डर में इस कमांड से शुरू करें:\nbash\ncd your-work\nnpm start\nउपरोक्त कमांड एक HTTP सर्वर को http://localhost:5000 पते पर शुरू करेगा। एक ब्राउज़र खोलें और इस पते को दर्ज करें। आपका गेम खेलने योग्य स्थिति में होना चाहिए।\nटिप: Visual Studio Code में चेतावनियों से बचने के लिए, window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 3,
    "total_chunks": 14
  },
  {
    "id": "0553b0b7533806d84d3528cc52091830",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "assets -| enemyShippng -| player png -| laserRed png -| life png -| index html -| app js -| packagejson आप अपने प्रोजेक्ट को your_work फोल्डर में इस कमांड से शुरू करें: bash cd your-work npm start उपरोक्त कमांड एक HTTP सर्वर को http://localhost:5000 पते पर शुरू करेगा। एक ब्राउज़र खोलें और इस पते को दर्ज करें। आपका गेम खेलने योग्य स्थिति में होना चाहिए। टिप: Visual Studio Code में चेतावनियों से बचने के लिए, windowonload फ़ंक्शन को gameLoopId को वैसे ही कॉल करने के लिए संपादित करें (बिना let के), और फ़ाइल के शीर्ष पर स्वतंत्र रूप से let gameLoopId; घोषित करें।\nकोड जोड़ें\nसमाप्ति की स्थिति को ट्रैक करें। कोड जोड़ें जो दुश्मनों की संख्या को ट्रैक करता है, या यदि हीरो जहाज नष्ट हो गया है, तो इन दो फ़ंक्शन्स को जोड़ें:\n```javascript\nfunction isHeroDead() {\nreturn hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 548,
    "chunk_index": 4,
    "total_chunks": 14
  },
  {
    "id": "bcba5659b37df101ad01b8828b9e0301",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "टिप: Visual Studio Code में चेतावनियों से बचने के लिए, windowonload फ़ंक्शन को gameLoopId को वैसे ही कॉल करने के लिए संपादित करें (बिना let के), और फ़ाइल के शीर्ष पर स्वतंत्र रूप से let gameLoopId; घोषित करें। कोड जोड़ें समाप्ति की स्थिति को ट्रैक करें। कोड जोड़ें जो दुश्मनों की संख्या को ट्रैक करता है, या यदि हीरो जहाज नष्ट हो गया है, तो इन दो फ़ंक्शन्स को जोड़ें: ```javascript function isHeroDead() { return herolife <= 0;\n}\nfunction isEnemiesDead() {\nconst enemies = gameObjects filter((go) => go type === \"Enemy\" && go dead);\nreturn enemies length === 0;\n}\n```\nसंदेश हैंडलर्स में लॉजिक जोड़ें। eventEmitter को संपादित करें ताकि ये स्थितियां संभाली जा सकें:\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\nif (isEnemiesDead()) {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 5,
    "total_chunks": 14
  },
  {
    "id": "34d176710c0c89ce453c60dc5fb76b18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "फ़ंक्शन्स को जोड़ें: ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjects filter((go) => go type === \"Enemy\" && go dead); return enemies length === 0; } ``` संदेश हैंडलर्स में लॉजिक जोड़ें। eventEmitter को संपादित करें ताकि ये स्थितियां संभाली जा सकें: ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(MessagesGAME_END_WIN);\n}\n});\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero decrementLife();\nif (isHeroDead())  {\neventEmitter emit(Messages GAME_END_LOSS);\nreturn; // loss before victory\n}\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages GAME_END_WIN, () => {\nendGame(true);\n});\neventEmitter on(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 301,
    "chunk_index": 6,
    "total_chunks": 14
  },
  {
    "id": "4a4bccda0acd4cd98ff2471522e311de",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "संभाली जा सकें: ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(MessagesGAME_END_WIN); } }); eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(Messages GAME_END_LOSS); return; // loss before victory } if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages GAME_END_WIN, () => { endGame(true); }); eventEmitter on(MessagesGAME_END_LOSS, () => {\nendGame(false);\n});\n```\nनए संदेश प्रकार जोड़ें। इन संदेशों को constants ऑब्जेक्ट में जोड़ें:\njavascript\nGAME_END_LOSS: \"GAME_END_LOSS\",\nGAME_END_WIN: \"GAME_END_WIN\",\nपुनः प्रारंभ कोड जोड़ें। एक चयनित बटन दबाने पर गेम को पुनः प्रारंभ करने का कोड जोड़ें।\nकुंजी दबाव Enter सुनें। अपने विंडो के eventListener को इस दबाव को सुनने के लिए संपादित करें:\njavascript\nelse if(evt key === \"Enter\") {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 431,
    "chunk_index": 7,
    "total_chunks": 14
  },
  {
    "id": "753f864fdd2a7124bf0bcea00aded8c1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "}); eventEmitter on(Messages GAME_END_WIN, () => { endGame(true); }); eventEmitter on(MessagesGAME_END_LOSS, () => { endGame(false); }); ``` नए संदेश प्रकार जोड़ें। इन संदेशों को constants ऑब्जेक्ट में जोड़ें: javascript GAME_END_LOSS: \"GAME_END_LOSS\", GAME_END_WIN: \"GAME_END_WIN\", पुनः प्रारंभ कोड जोड़ें। एक चयनित बटन दबाने पर गेम को पुनः प्रारंभ करने का कोड जोड़ें। कुंजी दबाव Enter सुनें। अपने विंडो के eventListener को इस दबाव को सुनने के लिए संपादित करें: javascript else if(evt key === \"Enter\") { eventEmitter emit(MessagesKEY_EVENT_ENTER);\n}\nपुनः प्रारंभ संदेश जोड़ें। इस संदेश को अपने Messages constant में जोड़ें:\n```javascript\nKEY_EVENT_ENTER: \"KEY_EVENT_ENTER\",\n```\nगेम नियम लागू करें। निम्नलिखित गेम नियम लागू करें:\nप्लेयर जीतने की स्थिति। जब सभी दुश्मन जहाज नष्ट हो जाते हैं, तो एक विजय संदेश प्रदर्शित करें।\nपहले, एक displayMessage() फ़ंक्शन बनाएं:\njavascript\nfunction displayMessage(message, color = \"red\") {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 562,
    "chunk_index": 8,
    "total_chunks": 14
  },
  {
    "id": "038ce87b43d06f4d2fef9323bf74e469",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "eventListener को इस दबाव को सुनने के लिए संपादित करें: javascript else if(evt key === \"Enter\") { eventEmitter emit(MessagesKEY_EVENT_ENTER); } पुनः प्रारंभ संदेश जोड़ें। इस संदेश को अपने Messages constant में जोड़ें: ```javascript KEY_EVENT_ENTER: \"KEY_EVENT_ENTER\", ``` गेम नियम लागू करें। निम्नलिखित गेम नियम लागू करें: प्लेयर जीतने की स्थिति। जब सभी दुश्मन जहाज नष्ट हो जाते हैं, तो एक विजय संदेश प्रदर्शित करें। पहले, एक displayMessage() फ़ंक्शन बनाएं: javascript function displayMessage(message, color = \"red\") { ctxfont = \"30px Arial\";\nctx fillStyle = color;\nctx textAlign = \"center\";\nctx fillText(message, canvas width / 2, canvas height / 2);\n}\nएक endGame() फ़ंक्शन बनाएं:\n```javascript\nfunction endGame(win) {\nclearInterval(gameLoopId);\n// set a delay so we are sure any paints have finished\nsetTimeout(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\nif (win) {\ndisplayMessage(\n\"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\",\n\"green\"\n);\n} else {\ndisplayMessage(\n\"You died",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 482,
    "chunk_index": 9,
    "total_chunks": 14
  },
  {
    "id": "7ae7973adf75808c3a5efd0b3130410d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "width / 2, canvas height / 2); } एक endGame() फ़ंक्शन बनाएं: ```javascript function endGame(win) { clearInterval(gameLoopId); // set a delay so we are sure any paints have finished setTimeout(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvas height); if (win) { displayMessage( \"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\", \"green\" ); } else { displayMessage( \"You diedPress [Enter] to start a new game Captain Pew Pew\"\n);\n}\n}, 200)\n}\n```\nपुनः प्रारंभ लॉजिक। जब सभी जीवन समाप्त हो जाते हैं या खिलाड़ी गेम जीत जाता है, तो प्रदर्शित करें कि गेम को पुनः प्रारंभ किया जा सकता है। इसके अतिरिक्त, जब पुनः प्रारंभ कुंजी दबाई जाती है, तो गेम को पुनः प्रारंभ करें (आप तय कर सकते हैं कि कौन सी कुंजी पुनः प्रारंभ के लिए मैप की जाए)।\nresetGame() फ़ंक्शन बनाएं:\njavascript\nfunction resetGame() {\nif (gameLoopId) {\nclearInterval(gameLoopId);\neventEmitter clear();\ninitGame();\ngameLoopId = setInterval(() => {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 492,
    "chunk_index": 10,
    "total_chunks": 14
  },
  {
    "id": "29fc14f333a06d4ef5a33196a59a5282",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "जब सभी जीवन समाप्त हो जाते हैं या खिलाड़ी गेम जीत जाता है, तो प्रदर्शित करें कि गेम को पुनः प्रारंभ किया जा सकता है। इसके अतिरिक्त, जब पुनः प्रारंभ कुंजी दबाई जाती है, तो गेम को पुनः प्रारंभ करें (आप तय कर सकते हैं कि कौन सी कुंजी पुनः प्रारंभ के लिए मैप की जाए)। resetGame() फ़ंक्शन बनाएं: javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctxclearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\ndrawPoints();\ndrawLife();\nupdateGameObjects();\ndrawGameObjects(ctx);\n}, 100);\n}\n}\ninitGame() में गेम को रीसेट करने के लिए eventEmitter को कॉल जोड़ें:\njavascript\neventEmitter on(Messages KEY_EVENT_ENTER, () => {\nresetGame();\n});\nEventEmitter में एक clear() फ़ंक्शन जोड़ें:\njavascript\nclear() {\nthis listeners = {};\n}\n👽 💥 🚀 बधाई हो, कप्तान",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 11,
    "total_chunks": 14
  },
  {
    "id": "a4bca5db7187a5cc436eafb44a498217",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "{ clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctxclearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvas height); drawPoints(); drawLife(); updateGameObjects(); drawGameObjects(ctx); }, 100); } } initGame() में गेम को रीसेट करने के लिए eventEmitter को कॉल जोड़ें: javascript eventEmitter on(Messages KEY_EVENT_ENTER, () => { resetGame(); }); EventEmitter में एक clear() फ़ंक्शन जोड़ें: javascript clear() { this listeners = {}; } 👽 💥 🚀 बधाई हो, कप्तानआपका गेम पूरा हो गया है बहुत अच्छा काम किया 🚀 💥 👽\n🚀 चुनौती\nएक ध्वनि जोड़ें क्या आप अपने गेम में ध्वनि जोड़ सकते हैं ताकि गेमप्ले को और बेहतर बनाया जा सके, जैसे लेज़र हिट होने पर, या हीरो के मरने या जीतने पर",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 405,
    "chunk_index": 12,
    "total_chunks": 14
  },
  {
    "id": "4b58bd7b5d3b3afdb9253646ca37320f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "स्पेस गेम बनाएं भाग 6: समाप्ति और पुनः प्रारंभ",
    "content": "जोड़ें: javascript eventEmitter on(Messages KEY_EVENT_ENTER, () => { resetGame(); }); EventEmitter में एक clear() फ़ंक्शन जोड़ें: javascript clear() { this listeners = {}; } 👽 💥 🚀 बधाई हो, कप्तानआपका गेम पूरा हो गया है बहुत अच्छा काम किया 🚀 💥 👽 🚀 चुनौती एक ध्वनि जोड़ें क्या आप अपने गेम में ध्वनि जोड़ सकते हैं ताकि गेमप्ले को और बेहतर बनाया जा सके, जैसे लेज़र हिट होने पर, या हीरो के मरने या जीतने परयह जानने के लिए कि जावास्क्रिप्ट का उपयोग करके ध्वनि कैसे चलाई जाती है, इस सैंडबॉक्स को देखें।\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nआपका असाइनमेंट एक नया सैंपल गेम बनाना है, इसलिए वहां मौजूद कुछ दिलचस्प गेम्स का पता लगाएं ताकि आप देख सकें कि आप किस प्रकार का गेम बना सकते हैं।\nअसाइनमेंट\nसैंपल गेम बनाएं\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15813,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1037,
    "chunk_index": 13,
    "total_chunks": 14
  },
  {
    "id": "5cdc0b4b42866c1359eac1b1106c2024",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
    "source_type": "git_repo",
    "title": "API अपनाएं",
    "content": "API अपनाएं\nनिर्देश\nAPIs के साथ काम करना बहुत मजेदार हो सकता है। यहाँ कई मुफ्त APIs की सूची दी गई है। एक API चुनें और एक ब्राउज़र एक्सटेंशन बनाएं जो किसी समस्या का समाधान करे। यह समस्या इतनी छोटी हो सकती है कि आपके पास पर्याप्त पालतू जानवरों की तस्वीरें नहीं हैं (तो, dog CEO API आज़माएं) या कुछ बड़ा हो सकता है - मज़े करें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3236,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 293,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "c867b3085db7e66fe54aa9c26ba75484",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
    "source_type": "git_repo",
    "title": "API अपनाएं",
    "content": "API अपनाएं\nनिर्देश\nAPIs के साथ काम करना बहुत मजेदार हो सकता है। यहाँ कई मुफ्त APIs की सूची दी गई है। एक API चुनें और एक ब्राउज़र एक्सटेंशन बनाएं जो किसी समस्या का समाधान करे। यह समस्या इतनी छोटी हो सकती है कि आपके पास पर्याप्त पालतू जानवरों की तस्वीरें नहीं हैं (तो, dog CEO API आज़माएं) या कुछ बड़ा हो सकता है - मज़े करेंमूल्यांकन मानदंड\n| मानदंड | उत्कृष्टता                                                                  | पर्याप्तता                                 | सुधार की आवश्यकता       |\n| -------- | -------------------------------------------------------------------------- | ---------------------------------------- | ----------------------- |\n|          | ऊपर दी गई सूची में से किसी API का उपयोग करके एक पूर्ण ब्राउज़र एक्सटेंशन जमा किया गया है | एक आंशिक ब्राउज़र एक्सटेंशन जमा किया गया है | जमा किए गए प्रोजेक्ट में बग्स हैं |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3236,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 983,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "28685ca3c044b2d98dd873d9c1cf5451",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
    "source_type": "git_repo",
    "title": "साइट के प्रदर्शन का विश्लेषण करें",
    "content": "साइट के प्रदर्शन का विश्लेषण करें\nएक वेबसाइट की विस्तृत रिपोर्ट प्रदान करें, जिसमें उन क्षेत्रों को दिखाया जाए जहां प्रदर्शन में समस्या है। विश्लेषण करें कि साइट धीमी क्यों है और इसे तेज करने के लिए आप क्या कर सकते हैं। केवल ब्राउज़र टूल्स पर निर्भर न रहें, बल्कि अन्य टूल्स पर भी शोध करें जो आपकी रिपोर्ट में मदद कर सकते हैं।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                                                                  | पर्याप्त                    | सुधार की आवश्यकता             |\n| -------- | ---------------------------------------------------------------------------------------------------------- | --------------------------- | ----------------------------- |\n|          | एक रिपोर्ट प्रस्तुत की गई है जिसमें न केवल ब्राउज़र टूल्स बल्कि उपलब्ध होने पर तृतीय-पक्ष टूल्स से भी विवरण शामिल हैं | एक बुनियादी रिपोर्ट प्रस्तुत की गई है | एक न्यूनतम रिपोर्ट प्रस्तुत की गई है |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3305,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1011,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "9c5bf5eb7c4b7f712f2d39ea93b37f73",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ\nस्केच नोट वसीम चेघम द्वारा\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nब्राउज़र एक्सटेंशन ब्राउज़र में अतिरिक्त कार्यक्षमता जोड़ते हैं। लेकिन इसे बनाने से पहले, आपको यह समझना चाहिए कि ब्राउज़र कैसे काम करते हैं।\nब्राउज़र के बारे में\nइस पाठ श्रृंखला में, आप एक ऐसा ब्राउज़र एक्सटेंशन बनाना सीखेंगे जो Chrome, Firefox और Edge ब्राउज़र्स पर काम करेगा। इस भाग में, आप जानेंगे कि ब्राउज़र कैसे काम करते हैं और ब्राउज़र एक्सटेंशन के तत्वों को तैयार करेंगे।\nलेकिन ब्राउज़र वास्तव में है क्या",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 0,
    "total_chunks": 17
  },
  {
    "id": "0709ef1cc9586ebe9a2c80718ffe71a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "क्विज़ प्री-लेक्चर क्विज़ परिचय ब्राउज़र एक्सटेंशन ब्राउज़र में अतिरिक्त कार्यक्षमता जोड़ते हैं। लेकिन इसे बनाने से पहले, आपको यह समझना चाहिए कि ब्राउज़र कैसे काम करते हैं। ब्राउज़र के बारे में इस पाठ श्रृंखला में, आप एक ऐसा ब्राउज़र एक्सटेंशन बनाना सीखेंगे जो Chrome, Firefox और Edge ब्राउज़र्स पर काम करेगा। इस भाग में, आप जानेंगे कि ब्राउज़र कैसे काम करते हैं और ब्राउज़र एक्सटेंशन के तत्वों को तैयार करेंगे। लेकिन ब्राउज़र वास्तव में है क्यायह एक सॉफ़्टवेयर एप्लिकेशन है जो उपयोगकर्ता को सर्वर से सामग्री एक्सेस करने और उसे वेब पेजों पर प्रदर्शित करने की अनुमति देता है।\n✅ थोड़ा इतिहास: पहला ब्राउज़र 'WorldWideWeb' था, जिसे सर टिमोथी बर्नर्स-ली ने 1990 में बनाया था।\nकुछ प्रारंभिक ब्राउज़र, करेन मैकग्रेन के माध्यम से\nजब कोई उपयोगकर्ता URL (Uniform Resource Locator) पते का उपयोग करके इंटरनेट से जुड़ता है, आमतौर पर Hypertext Transfer Protocol के माध्यम से http या https पते का उपयोग करते हुए, तो ब्राउज़र वेब सर्वर से संपर्क करता है और एक वेब पेज प्राप्त करता है।\nइस बिंदु पर, ब्राउज़र का रेंडरिंग इंजन इसे उपयोगकर्ता के डिवाइस पर प्रदर्शित करता है, जो मोबाइल फोन, डेस्कटॉप या लैपटॉप हो सकता है।\nब्राउज़र में सामग्री को कैश करने की क्षमता भी होती है ताकि हर बार इसे सर्वर से पुनः प्राप्त न करना पड़े। वे उपयोगकर्ता की ब्राउज़िंग गतिविधि का इतिहास रिकॉर्ड कर सकते हैं, 'कुकीज़' स्टोर कर सकते हैं, जो छोटे डेटा के टुकड़े होते हैं और उपयोगकर्ता की गतिविधि को संग्रहीत करने के लिए उपयोग किए जाते हैं, और भी बहुत कुछ।\nएक महत्वपूर्ण बात जो याद रखनी चाहिए वह यह है कि सभी ब्राउज़र एक जैसे नहीं होते",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1405,
    "chunk_index": 1,
    "total_chunks": 17
  },
  {
    "id": "69ae5bada459ebe674ae7f6a37fc6b7e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "को कैश करने की क्षमता भी होती है ताकि हर बार इसे सर्वर से पुनः प्राप्त न करना पड़े। वे उपयोगकर्ता की ब्राउज़िंग गतिविधि का इतिहास रिकॉर्ड कर सकते हैं, 'कुकीज़' स्टोर कर सकते हैं, जो छोटे डेटा के टुकड़े होते हैं और उपयोगकर्ता की गतिविधि को संग्रहीत करने के लिए उपयोग किए जाते हैं, और भी बहुत कुछ। एक महत्वपूर्ण बात जो याद रखनी चाहिए वह यह है कि सभी ब्राउज़र एक जैसे नहीं होतेप्रत्येक ब्राउज़र की अपनी ताकत और कमजोरियां होती हैं, और एक पेशेवर वेब डेवलपर को यह समझना चाहिए कि वेब पेजों को क्रॉस-ब्राउज़र परफॉर्मेंस के लिए कैसे अनुकूलित किया जाए। इसमें छोटे व्यूपोर्ट्स जैसे मोबाइल फोन के लिए अनुकूलन और ऑफलाइन उपयोगकर्ता को संभालना शामिल है।\nएक बहुत उपयोगी वेबसाइट जिसे आपको अपने पसंदीदा ब्राउज़र में बुकमार्क करना चाहिए, वह है caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 2,
    "total_chunks": 17
  },
  {
    "id": "6c2891fb48365a646df2b93ece24baba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "बात जो याद रखनी चाहिए वह यह है कि सभी ब्राउज़र एक जैसे नहीं होतेप्रत्येक ब्राउज़र की अपनी ताकत और कमजोरियां होती हैं, और एक पेशेवर वेब डेवलपर को यह समझना चाहिए कि वेब पेजों को क्रॉस-ब्राउज़र परफॉर्मेंस के लिए कैसे अनुकूलित किया जाए। इसमें छोटे व्यूपोर्ट्स जैसे मोबाइल फोन के लिए अनुकूलन और ऑफलाइन उपयोगकर्ता को संभालना शामिल है। एक बहुत उपयोगी वेबसाइट जिसे आपको अपने पसंदीदा ब्राउज़र में बुकमार्क करना चाहिए, वह है caniusecom। जब आप वेब पेज बना रहे हों, तो उपयोगकर्ताओं को सर्वोत्तम समर्थन देने के लिए caniuse की समर्थित तकनीकों की सूची का उपयोग करना बहुत सहायक होता है।\n✅ आप यह कैसे पता लगा सकते हैं कि आपके वेब साइट के उपयोगकर्ता आधार में कौन से ब्राउज़र सबसे लोकप्रिय हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 662,
    "chunk_index": 3,
    "total_chunks": 17
  },
  {
    "id": "0067f7b0c670133f37e8984bce8c09a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "के लिए अनुकूलन और ऑफलाइन उपयोगकर्ता को संभालना शामिल है। एक बहुत उपयोगी वेबसाइट जिसे आपको अपने पसंदीदा ब्राउज़र में बुकमार्क करना चाहिए, वह है caniusecom। जब आप वेब पेज बना रहे हों, तो उपयोगकर्ताओं को सर्वोत्तम समर्थन देने के लिए caniuse की समर्थित तकनीकों की सूची का उपयोग करना बहुत सहायक होता है। ✅ आप यह कैसे पता लगा सकते हैं कि आपके वेब साइट के उपयोगकर्ता आधार में कौन से ब्राउज़र सबसे लोकप्रिय हैंअपने एनालिटिक्स की जांच करें - आप अपने वेब विकास प्रक्रिया के हिस्से के रूप में विभिन्न एनालिटिक्स पैकेज इंस्टॉल कर सकते हैं, और वे आपको बताएंगे कि कौन से ब्राउज़र सबसे अधिक उपयोग किए जा रहे हैं।\nब्राउज़र एक्सटेंशन\nआप ब्राउज़र एक्सटेंशन क्यों बनाना चाहेंगे",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 649,
    "chunk_index": 4,
    "total_chunks": 17
  },
  {
    "id": "de0ed9a438a297bfca5cd3ffcb872ec2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "की सूची का उपयोग करना बहुत सहायक होता है। ✅ आप यह कैसे पता लगा सकते हैं कि आपके वेब साइट के उपयोगकर्ता आधार में कौन से ब्राउज़र सबसे लोकप्रिय हैंअपने एनालिटिक्स की जांच करें - आप अपने वेब विकास प्रक्रिया के हिस्से के रूप में विभिन्न एनालिटिक्स पैकेज इंस्टॉल कर सकते हैं, और वे आपको बताएंगे कि कौन से ब्राउज़र सबसे अधिक उपयोग किए जा रहे हैं। ब्राउज़र एक्सटेंशन आप ब्राउज़र एक्सटेंशन क्यों बनाना चाहेंगेयह आपके ब्राउज़र से जोड़ने के लिए एक उपयोगी उपकरण है जब आपको बार-बार किए जाने वाले कार्यों तक त्वरित पहुंच की आवश्यकता होती है। उदाहरण के लिए, यदि आपको उन विभिन्न वेब पेजों पर रंग जांचने की आवश्यकता होती है जिनके साथ आप इंटरैक्ट करते हैं, तो आप एक कलर-पिकर ब्राउज़र एक्सटेंशन इंस्टॉल कर सकते हैं। यदि आपको पासवर्ड याद रखने में परेशानी होती है, तो आप एक पासवर्ड-प्रबंधन ब्राउज़र एक्सटेंशन का उपयोग कर सकते हैं।\nब्राउज़र एक्सटेंशन बनाना मजेदार भी होता है। वे आमतौर पर सीमित संख्या में कार्यों को प्रबंधित करते हैं और उन्हें अच्छी तरह से निष्पादित करते हैं।\n✅ आपके पसंदीदा ब्राउज़र एक्सटेंशन कौन से हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1014,
    "chunk_index": 5,
    "total_chunks": 17
  },
  {
    "id": "8c22baad6301794d2eca14ddc38d89eb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "रंग जांचने की आवश्यकता होती है जिनके साथ आप इंटरैक्ट करते हैं, तो आप एक कलर-पिकर ब्राउज़र एक्सटेंशन इंस्टॉल कर सकते हैं। यदि आपको पासवर्ड याद रखने में परेशानी होती है, तो आप एक पासवर्ड-प्रबंधन ब्राउज़र एक्सटेंशन का उपयोग कर सकते हैं। ब्राउज़र एक्सटेंशन बनाना मजेदार भी होता है। वे आमतौर पर सीमित संख्या में कार्यों को प्रबंधित करते हैं और उन्हें अच्छी तरह से निष्पादित करते हैं। ✅ आपके पसंदीदा ब्राउज़र एक्सटेंशन कौन से हैंवे कौन से कार्य करते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 453,
    "chunk_index": 6,
    "total_chunks": 17
  },
  {
    "id": "077b26da06f63363726a65585bacc02d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "है जिनके साथ आप इंटरैक्ट करते हैं, तो आप एक कलर-पिकर ब्राउज़र एक्सटेंशन इंस्टॉल कर सकते हैं। यदि आपको पासवर्ड याद रखने में परेशानी होती है, तो आप एक पासवर्ड-प्रबंधन ब्राउज़र एक्सटेंशन का उपयोग कर सकते हैं। ब्राउज़र एक्सटेंशन बनाना मजेदार भी होता है। वे आमतौर पर सीमित संख्या में कार्यों को प्रबंधित करते हैं और उन्हें अच्छी तरह से निष्पादित करते हैं। ✅ आपके पसंदीदा ब्राउज़र एक्सटेंशन कौन से हैंवे कौन से कार्य करते हैंएक्सटेंशन इंस्टॉल करना\nबनाने से पहले, ब्राउज़र एक्सटेंशन बनाने और तैनात करने की प्रक्रिया पर एक नज़र डालें। हालांकि प्रत्येक ब्राउज़र इस कार्य को प्रबंधित करने में थोड़ा भिन्न होता है, Chrome और Firefox पर प्रक्रिया Edge के इस उदाहरण के समान है:\nनोट: सुनिश्चित करें कि डेवलपर मोड चालू है और अन्य स्टोर्स से एक्सटेंशन की अनुमति दी गई है।\nमूल रूप से, प्रक्रिया इस प्रकार होगी:\nnpm run build का उपयोग करके अपना एक्सटेंशन बनाएं\nब्राउज़र में \"सेटिंग्स और अधिक\" बटन (ऊपरी दाएं कोने में",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 866,
    "chunk_index": 7,
    "total_chunks": 17
  },
  {
    "id": "49ca78daa319882d6388b5451de52c73",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "करने की प्रक्रिया पर एक नज़र डालें। हालांकि प्रत्येक ब्राउज़र इस कार्य को प्रबंधित करने में थोड़ा भिन्न होता है, Chrome और Firefox पर प्रक्रिया Edge के इस उदाहरण के समान है: नोट: सुनिश्चित करें कि डेवलपर मोड चालू है और अन्य स्टोर्स से एक्सटेंशन की अनुमति दी गई है। मूल रूप से, प्रक्रिया इस प्रकार होगी: npm run build का उपयोग करके अपना एक्सटेंशन बनाएं ब्राउज़र में \"सेटिंग्स और अधिक\" बटन (ऊपरी दाएं कोने मेंआइकन) का उपयोग करके एक्सटेंशन पैन पर नेविगेट करें\nयदि यह एक नई स्थापना है, तो load unpacked चुनें और बिल्ड फ़ोल्डर (हमारे मामले में /dist) से एक नया एक्सटेंशन अपलोड करें\nया, यदि आप पहले से इंस्टॉल किए गए एक्सटेंशन को फिर से लोड कर रहे हैं, तो reload पर क्लिक करें\n✅ ये निर्देश उन एक्सटेंशनों पर लागू होते हैं जिन्हें आप स्वयं बनाते हैं; उन एक्सटेंशनों को इंस्टॉल करने के लिए जो प्रत्येक ब्राउज़र से जुड़े ब्राउज़र एक्सटेंशन स्टोर में जारी किए गए हैं, आपको उन स्टोर्स पर नेविगेट करना चाहिए और अपनी पसंद का एक्सटेंशन इंस्टॉल करना चाहिए।\nशुरू करें\nआप एक ब्राउज़र एक्सटेंशन बनाने जा रहे हैं जो आपके क्षेत्र के कार्बन फुटप्रिंट को प्रदर्शित करेगा, आपके क्षेत्र की ऊर्जा खपत और ऊर्जा के स्रोत को दिखाएगा। एक्सटेंशन में एक फॉर्म होगा जो API कुंजी एकत्र करेगा ताकि आप CO2 Signal की API तक पहुंच सकें।\nआपको चाहिए:\nएक API कुंजी; इस पेज पर अपना ईमेल दर्ज करें और आपको एक कुंजी भेजी जाएगी\nआपके क्षेत्र का कोड जो Electricity Map से मेल खाता है (उदाहरण के लिए, बोस्टन में, मैं 'US-NEISO' का उपयोग करता हूं)।\nस्टार्टर कोड। start फ़ोल्डर डाउनलोड करें; आप इस फ़ोल्डर में कोड पूरा करेंगे।\nNPM - NPM एक पैकेज प्रबंधन उपकरण है; इसे स्थानीय रूप से इंस्टॉल करें और आपके package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1443,
    "chunk_index": 8,
    "total_chunks": 17
  },
  {
    "id": "0c13cefb0ea1487ef982c3ecef728370",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "Signal की API तक पहुंच सकें। आपको चाहिए: एक API कुंजी; इस पेज पर अपना ईमेल दर्ज करें और आपको एक कुंजी भेजी जाएगी आपके क्षेत्र का कोड जो Electricity Map से मेल खाता है (उदाहरण के लिए, बोस्टन में, मैं 'US-NEISO' का उपयोग करता हूं)। स्टार्टर कोड। start फ़ोल्डर डाउनलोड करें; आप इस फ़ोल्डर में कोड पूरा करेंगे। NPM - NPM एक पैकेज प्रबंधन उपकरण है; इसे स्थानीय रूप से इंस्टॉल करें और आपके packagejson फ़ाइल में सूचीबद्ध पैकेज आपके वेब एसेट द्वारा उपयोग के लिए इंस्टॉल हो जाएंगे।\n✅ पैकेज प्रबंधन के बारे में अधिक जानें इस उत्कृष्ट Learn मॉड्यूल में\nकोडबेस को देखने के लिए एक मिनट लें:\ndist\n-|manifest",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 534,
    "chunk_index": 9,
    "total_chunks": 17
  },
  {
    "id": "ccc36d25c1d95a4ffe248153a4aab427",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "लिए, बोस्टन में, मैं 'US-NEISO' का उपयोग करता हूं)। स्टार्टर कोड। start फ़ोल्डर डाउनलोड करें; आप इस फ़ोल्डर में कोड पूरा करेंगे। NPM - NPM एक पैकेज प्रबंधन उपकरण है; इसे स्थानीय रूप से इंस्टॉल करें और आपके packagejson फ़ाइल में सूचीबद्ध पैकेज आपके वेब एसेट द्वारा उपयोग के लिए इंस्टॉल हो जाएंगे। ✅ पैकेज प्रबंधन के बारे में अधिक जानें इस उत्कृष्ट Learn मॉड्यूल में कोडबेस को देखने के लिए एक मिनट लें: dist -|manifestjson (डिफ़ॉल्ट सेटिंग्स यहां)\n-|index html (फ्रंट-एंड HTML मार्कअप यहां)\n-|background js (बैकग्राउंड JS यहां)\n-|main js (बंडल किया गया JS)\nsrc\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 10,
    "total_chunks": 17
  },
  {
    "id": "ffc969cdda0e240f3dcf360011de776f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "NPM - NPM एक पैकेज प्रबंधन उपकरण है; इसे स्थानीय रूप से इंस्टॉल करें और आपके packagejson फ़ाइल में सूचीबद्ध पैकेज आपके वेब एसेट द्वारा उपयोग के लिए इंस्टॉल हो जाएंगे। ✅ पैकेज प्रबंधन के बारे में अधिक जानें इस उत्कृष्ट Learn मॉड्यूल में कोडबेस को देखने के लिए एक मिनट लें: dist -|manifestjson (डिफ़ॉल्ट सेटिंग्स यहां) -|index html (फ्रंट-एंड HTML मार्कअप यहां) -|background js (बैकग्राउंड JS यहां) -|main js (बंडल किया गया JS) src -|indexjs (आपका JS कोड यहां जाएगा)\n✅ एक बार जब आपके पास अपनी API कुंजी और क्षेत्र कोड तैयार हो जाए, तो उन्हें भविष्य में उपयोग के लिए कहीं नोट में सहेज लें।\nएक्सटेंशन के लिए HTML बनाएं\nइस एक्सटेंशन में दो दृश्य हैं। एक API कुंजी और क्षेत्र कोड एकत्र करने के लिए:\nऔर दूसरा क्षेत्र के कार्बन उपयोग को प्रदर्शित करने के लिए:\nआइए फॉर्म के लिए HTML बनाकर और इसे CSS के साथ स्टाइल करके शुरू करें।\n/dist फ़ोल्डर में, आप एक फॉर्म और एक परिणाम क्षेत्र बनाएंगे। index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 793,
    "chunk_index": 11,
    "total_chunks": 17
  },
  {
    "id": "7f878f6e2c2c0cb9246c39da1b09b678",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "क्षेत्र कोड तैयार हो जाए, तो उन्हें भविष्य में उपयोग के लिए कहीं नोट में सहेज लें। एक्सटेंशन के लिए HTML बनाएं इस एक्सटेंशन में दो दृश्य हैं। एक API कुंजी और क्षेत्र कोड एकत्र करने के लिए: और दूसरा क्षेत्र के कार्बन उपयोग को प्रदर्शित करने के लिए: आइए फॉर्म के लिए HTML बनाकर और इसे CSS के साथ स्टाइल करके शुरू करें। /dist फ़ोल्डर में, आप एक फॉर्म और एक परिणाम क्षेत्र बनाएंगे। indexhtml फ़ाइल में, निर्दिष्ट फॉर्म क्षेत्र को भरें:\n```HTML\nNew",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 402,
    "chunk_index": 12,
    "total_chunks": 17
  },
  {
    "id": "de0f3ac4da3825d0ca5d8b7ec024fff9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "उपयोग के लिए कहीं नोट में सहेज लें। एक्सटेंशन के लिए HTML बनाएं इस एक्सटेंशन में दो दृश्य हैं। एक API कुंजी और क्षेत्र कोड एकत्र करने के लिए: और दूसरा क्षेत्र के कार्बन उपयोग को प्रदर्शित करने के लिए: आइए फॉर्म के लिए HTML बनाकर और इसे CSS के साथ स्टाइल करके शुरू करें। /dist फ़ोल्डर में, आप एक फॉर्म और एक परिणाम क्षेत्र बनाएंगे। indexhtml फ़ाइल में, निर्दिष्ट फॉर्म क्षेत्र को भरें: ```HTML NewAdd your Information\nRegion Name\nYour API Key from tmrow\nSubmit\n```\nयह वह फॉर्म है जहां आपकी सहेजी गई जानकारी इनपुट की जाएगी और लोकल स्टोरेज में सहेजी जाएगी।\nइसके बाद, परिणाम क्षेत्र बनाएं; अंतिम फॉर्म टैग के नीचे कुछ divs जोड़ें:\n```HTML\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 541,
    "chunk_index": 13,
    "total_chunks": 17
  },
  {
    "id": "c90f71fd167a41899a74b69f8ec98014",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "HTML बनाकर और इसे CSS के साथ स्टाइल करके शुरू करें। /dist फ़ोल्डर में, आप एक फॉर्म और एक परिणाम क्षेत्र बनाएंगे। indexhtml फ़ाइल में, निर्दिष्ट फॉर्म क्षेत्र को भरें: ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` यह वह फॉर्म है जहां आपकी सहेजी गई जानकारी इनपुट की जाएगी और लोकल स्टोरेज में सहेजी जाएगी। इसके बाद, परिणाम क्षेत्र बनाएं; अंतिम फॉर्म टैग के नीचे कुछ divs जोड़ें: ```HTML loadingRegion:\nCarbon Usage:\nFossil Fuel Percentage:\nChange region\n```\nइस बिंदु पर, आप एक बिल्ड आज़मा सकते हैं। सुनिश्चित करें कि इस एक्सटेंशन के पैकेज डिपेंडेंसीज़ इंस्टॉल करें:\nnpm install\nयह कमांड npm, Node Package Manager, का उपयोग आपके एक्सटेंशन की बिल्ड प्रक्रिया के लिए webpack इंस्टॉल करने के लिए करेगा। आप इस प्रक्रिया के आउटपुट को /dist/main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 14,
    "total_chunks": 17
  },
  {
    "id": "8654a3723eec98e3fcb304c5c06745d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "स्टोरेज में सहेजी जाएगी। इसके बाद, परिणाम क्षेत्र बनाएं; अंतिम फॉर्म टैग के नीचे कुछ divs जोड़ें: ```HTML loadingRegion: Carbon Usage: Fossil Fuel Percentage: Change region ``` इस बिंदु पर, आप एक बिल्ड आज़मा सकते हैं। सुनिश्चित करें कि इस एक्सटेंशन के पैकेज डिपेंडेंसीज़ इंस्टॉल करें: npm install यह कमांड npm, Node Package Manager, का उपयोग आपके एक्सटेंशन की बिल्ड प्रक्रिया के लिए webpack इंस्टॉल करने के लिए करेगा। आप इस प्रक्रिया के आउटपुट को /dist/mainjs में देख सकते हैं - आप देखेंगे कि कोड बंडल किया गया है।\nफिलहाल, एक्सटेंशन को बिल्ड करना चाहिए और यदि आप इसे Edge में एक एक्सटेंशन के रूप में तैनात करते हैं, तो आपको एक फॉर्म साफ-सुथरे तरीके से प्रदर्शित होता दिखाई देगा।\nबधाई हो, आपने ब्राउज़र एक्सटेंशन बनाने की दिशा में पहला कदम उठाया है। अगले पाठों में, आप इसे और अधिक कार्यात्मक और उपयोगी बनाएंगे।\n🚀 चुनौती\nकिसी ब्राउज़र एक्सटेंशन स्टोर पर एक नज़र डालें और अपने ब्राउज़र में एक एक्सटेंशन इंस्टॉल करें। आप इसके फाइलों को दिलचस्प तरीकों से जांच सकते हैं। आप क्या खोजते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 880,
    "chunk_index": 15,
    "total_chunks": 17
  },
  {
    "id": "6129142d35330f9bd4fa3dc4709269a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 1: ब्राउज़र्स के बारे में सब कुछ",
    "content": "में एक एक्सटेंशन के रूप में तैनात करते हैं, तो आपको एक फॉर्म साफ-सुथरे तरीके से प्रदर्शित होता दिखाई देगा। बधाई हो, आपने ब्राउज़र एक्सटेंशन बनाने की दिशा में पहला कदम उठाया है। अगले पाठों में, आप इसे और अधिक कार्यात्मक और उपयोगी बनाएंगे। 🚀 चुनौती किसी ब्राउज़र एक्सटेंशन स्टोर पर एक नज़र डालें और अपने ब्राउज़र में एक एक्सटेंशन इंस्टॉल करें। आप इसके फाइलों को दिलचस्प तरीकों से जांच सकते हैं। आप क्या खोजते हैंपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nइस पाठ में आपने वेब ब्राउज़र के इतिहास के बारे में थोड़ा सीखा; इस अवसर का उपयोग यह जानने के लिए करें कि वर्ल्ड वाइड वेब के आविष्कारकों ने इसके उपयोग की कल्पना कैसे की थी। इसके इतिहास के बारे में अधिक पढ़ने के लिए कुछ उपयोगी साइटें हैं:\nवेब ब्राउज़रों का इतिहास\nवेब का इतिहास\nटिम बर्नर्स-ली के साथ एक साक्षात्कार\nअसाइनमेंट\nअपने एक्सटेंशन को फिर से स्टाइल करें\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को आधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1271,
    "chunk_index": 16,
    "total_chunks": 17
  },
  {
    "id": "1920b95602d75f6d5a36c0d1208b7abf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\README.md",
    "source_type": "git_repo",
    "title": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: पूर्ण कोड",
    "content": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: पूर्ण कोड\ntmrow के C02 Signal API का उपयोग करके बिजली की खपत को ट्रैक करें और एक ब्राउज़र एक्सटेंशन बनाएं ताकि आपके ब्राउज़र में यह याद दिलाने वाला फीचर हो कि आपके क्षेत्र में बिजली की खपत कितनी भारी है। इस एक्सटेंशन का अस्थायी उपयोग आपको इस जानकारी के आधार पर अपनी गतिविधियों के बारे में निर्णय लेने में मदद करेगा।\nशुरुआत करें\nआपको npm इंस्टॉल करना होगा। इस कोड की एक कॉपी अपने कंप्यूटर पर एक फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें:\nnpm install\nवेबपैक से एक्सटेंशन बनाएं:\nnpm run build\nEdge पर इंस्टॉल करने के लिए, ब्राउज़र के ऊपर दाईं ओर 'तीन डॉट' मेनू का उपयोग करें और एक्सटेंशन पैनल ढूंढें। वहां से 'लोड अनपैक्ड' चुनें ताकि नया एक्सटेंशन लोड किया जा सके। प्रॉम्प्ट पर 'dist' फोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसे उपयोग करने के लिए, आपको CO2 Signal के API के लिए एक API key की आवश्यकता होगी (यहां ईमेल के माध्यम से प्राप्त करें - इस पेज पर बॉक्स में अपना ईमेल डालें) और Electricity Map के अनुसार आपके क्षेत्र का कोड (उदाहरण के लिए, बोस्टन में मैं 'US-NEISO' का उपयोग करता हूं)।\nएक बार जब API key और क्षेत्र का कोड एक्सटेंशन इंटरफेस में डाल दिया जाए, तो ब्राउज़र एक्सटेंशन बार में रंगीन डॉट आपके क्षेत्र की ऊर्जा खपत को दर्शाने के लिए बदल जाना चाहिए और आपको यह संकेत देगा कि कौन सी ऊर्जा-गहन गतिविधियां आपके लिए उपयुक्त होंगी। इस 'डॉट' सिस्टम की अवधारणा मुझे Energy Lollipop एक्सटेंशन से मिली थी, जो कैलिफोर्निया के उत्सर्जन के लिए बनाया गया है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5283,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1737,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f71abe7853672008db50a002999a0bfc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\start\\README.md",
    "source_type": "git_repo",
    "title": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: स्टार्टर कोड",
    "content": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: स्टार्टर कोड\ntmrow के C02 Signal API का उपयोग करके बिजली की खपत को ट्रैक करें और एक ब्राउज़र एक्सटेंशन बनाएं ताकि आपके ब्राउज़र में यह याद दिलाने वाला फीचर हो कि आपके क्षेत्र में बिजली की खपत कितनी भारी है। इस एक्सटेंशन का उपयोग करके आप अपनी गतिविधियों के बारे में इस जानकारी के आधार पर निर्णय ले सकते हैं।\nशुरुआत कैसे करें\nआपको npm इंस्टॉल करना होगा। इस कोड की एक कॉपी अपने कंप्यूटर पर एक फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें:\nnpm install\nवेबपैक से एक्सटेंशन बनाएं:\nnpm run build\nEdge पर इंस्टॉल करने के लिए, ब्राउज़र के ऊपर दाईं ओर 'तीन डॉट' मेनू का उपयोग करें और एक्सटेंशन पैनल ढूंढें। वहां से 'लोड अनपैक्ड' चुनें ताकि नया एक्सटेंशन लोड किया जा सके। प्रॉम्प्ट पर 'dist' फोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसे उपयोग करने के लिए, आपको CO2 Signal के API के लिए एक API कुंजी की आवश्यकता होगी (यहां ईमेल के माध्यम से प्राप्त करें - इस पेज पर बॉक्स में अपना ईमेल डालें) और Electricity Map के अनुसार आपके क्षेत्र का कोड (उदाहरण के लिए, बोस्टन में मैं 'US-NEISO' का उपयोग करता हूं)।\nएक बार जब API कुंजी और क्षेत्र का कोड एक्सटेंशन इंटरफेस में डाल दिया जाए, तो ब्राउज़र एक्सटेंशन बार में रंगीन डॉट आपके क्षेत्र की ऊर्जा खपत को दर्शाने के लिए बदल जाएगा और आपको यह संकेत देगा कि कौन सी ऊर्जा-गहन गतिविधियां आपके लिए उपयुक्त होंगी। इस 'डॉट' सिस्टम का विचार मुझे Energy Lollipop एक्सटेंशन से मिला, जो कैलिफोर्निया के उत्सर्जन के लिए बनाया गया है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5266,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\start\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1729,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c3c125514380ac950e902f48f83ce5dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.es.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger ब्राउज़र एक्सटेंशन: पूरा कोड",
    "content": "Carbon Trigger ब्राउज़र एक्सटेंशन: पूरा कोड\ntmrow की CO2 Signal API का उपयोग करके बिजली की खपत को ट्रैक करें और एक ब्राउज़र एक्सटेंशन बनाएं ताकि आप अपनी क्षेत्रीय बिजली खपत की जानकारी सीधे अपने ब्राउज़र में देख सकें। इस ऐड-हॉक एक्सटेंशन का उपयोग आपको अपनी गतिविधियों के बारे में निर्णय लेने में मदद करेगा, जो इस जानकारी पर आधारित होंगे।\nशुरुआत करें\nआपको npm इंस्टॉल करना होगा। इस कोड की एक कॉपी अपने कंप्यूटर की किसी फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें:\nnpm install\nवेबपैक से एक्सटेंशन बनाएं:\nnpm run build\nEdge में इंस्टॉल करने के लिए, ब्राउज़र के ऊपरी दाएं कोने में 'तीन बिंदु' वाले मेनू का उपयोग करें और एक्सटेंशन पैनल ढूंढें। वहां से 'अनपैक्ड लोड करें' चुनें ताकि नया एक्सटेंशन लोड किया जा सके। जब पूछा जाए, तो 'dist' फोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसका उपयोग करने के लिए, आपको CO2 Signal API के लिए एक API कुंजी की आवश्यकता होगी (यहां ईमेल के माध्यम से प्राप्त करें - इस पेज पर अपना ईमेल दर्ज करें) और Electricity Map के अनुसार अपनी क्षेत्रीय कोड की आवश्यकता होगी (यहां देखें)। उदाहरण के लिए, Boston में मैं 'US-NEISO' का उपयोग करता हूं।\nएक बार जब API कुंजी और क्षेत्र को एक्सटेंशन इंटरफेस में दर्ज किया जाता है, तो ब्राउज़र एक्सटेंशन बार में रंगीन बिंदु आपकी क्षेत्रीय ऊर्जा खपत को दर्शाने के लिए बदल जाएगा और आपको उच्च ऊर्जा खपत वाली गतिविधियों के लिए एक संकेत देगा जो आपके लिए उपयुक्त हो सकती हैं। इस \"पॉइंट\" सिस्टम का विचार मुझे Energy Lollipop एक्सटेंशन से मिला, जो कैलिफोर्निया की उत्सर्जन जानकारी प्रदान करता है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5345,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.es.md",
      "source_type": "git_repo"
    },
    "token_count": 1769,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f4252f7b5fb570169036a7843abb41c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.fr.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger ब्राउज़र एक्सटेंशन: पूर्ण कोड",
    "content": "Carbon Trigger ब्राउज़र एक्सटेंशन: पूर्ण कोड\ntmrow की C02 Signal API का उपयोग करके बिजली की खपत को ट्रैक करें और एक ब्राउज़र एक्सटेंशन बनाएं ताकि आप अपने क्षेत्र की बिजली खपत के बारे में सीधे अपने ब्राउज़र में एक रिमाइंडर प्राप्त कर सकें। इस एक्सटेंशन का उपयोग आपको इन जानकारियों के आधार पर अपनी गतिविधियों का मूल्यांकन करने में मदद करेगा।\nशुरुआत करें\nआपको npm इंस्टॉल करना होगा। इस कोड की एक कॉपी अपने कंप्यूटर के किसी फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें:\nnpm install\nवेबपैक से एक्सटेंशन को बिल्ड करें:\nnpm run build\nEdge पर इंस्टॉल करने के लिए, ब्राउज़र के ऊपरी दाएं कोने में 'तीन बिंदु' वाले मेनू का उपयोग करें और एक्सटेंशन पैनल खोजें। वहां से, 'डिकम्प्रेस्ड एक्सटेंशन लोड करें' चुनें ताकि नया एक्सटेंशन लोड किया जा सके। प्रॉम्प्ट पर 'dist' फोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसका उपयोग करने के लिए, आपको CO2 Signal API के लिए एक API कुंजी की आवश्यकता होगी (यहां ईमेल के माध्यम से प्राप्त करें - इस पेज पर दिए गए बॉक्स में अपना ईमेल डालें) और आपके क्षेत्र का कोड जो Electricity Map से मेल खाता हो (उदाहरण के लिए, Boston में मैं 'US-NEISO' का उपयोग करता हूं)।\nएक बार जब API कुंजी और क्षेत्र को एक्सटेंशन इंटरफेस में दर्ज कर दिया जाए, तो ब्राउज़र के एक्सटेंशन बार में रंगीन बिंदु आपके क्षेत्र की ऊर्जा खपत को दर्शाने के लिए बदल जाएगा और आपको यह संकेत देगा कि कौन सी ऊर्जा-गहन गतिविधियां करना उपयुक्त होगा। इस 'बिंदु' प्रणाली का विचार मुझे Energy Lollipop एक्सटेंशन से मिला, जो कैलिफोर्निया की उत्सर्जन जानकारी प्रदान करता है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5376,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.fr.md",
      "source_type": "git_repo"
    },
    "token_count": 1743,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3b55195f1f05aaed1eed59a1274655e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nइस पाठ में, आप अपने ब्राउज़र एक्सटेंशन के फॉर्म को सबमिट करके एक API कॉल करेंगे और परिणामों को ब्राउज़र एक्सटेंशन में प्रदर्शित करेंगे। इसके अलावा, आप सीखेंगे कि ब्राउज़र के लोकल स्टोरेज में डेटा को भविष्य के संदर्भ और उपयोग के लिए कैसे संग्रहीत किया जा सकता है।\n✅ उपयुक्त फाइलों में क्रमांकित खंडों का पालन करें ताकि आप जान सकें कि कोड को कहां रखना है।\nएक्सटेंशन में उपयोग करने के लिए तत्व सेट करें:\nअब तक आपने अपने ब्राउज़र एक्सटेंशन के लिए फॉर्म और परिणाम <div> के लिए HTML बना लिया है। अब से, आपको /src/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 0,
    "total_chunks": 28
  },
  {
    "id": "bb8373be2805b2e57ae73ef24d1f11c0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "करेंगे। इसके अलावा, आप सीखेंगे कि ब्राउज़र के लोकल स्टोरेज में डेटा को भविष्य के संदर्भ और उपयोग के लिए कैसे संग्रहीत किया जा सकता है। ✅ उपयुक्त फाइलों में क्रमांकित खंडों का पालन करें ताकि आप जान सकें कि कोड को कहां रखना है। एक्सटेंशन में उपयोग करने के लिए तत्व सेट करें: अब तक आपने अपने ब्राउज़र एक्सटेंशन के लिए फॉर्म और परिणाम <div> के लिए HTML बना लिया है। अब से, आपको /src/indexjs फाइल में काम करना होगा और अपने एक्सटेंशन को धीरे-धीरे बनाना होगा। पिछले पाठ का संदर्भ लें ताकि आप अपने प्रोजेक्ट को सेट अप और बिल्ड प्रक्रिया को समझ सकें।\nअपने index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 516,
    "chunk_index": 1,
    "total_chunks": 28
  },
  {
    "id": "afbcf956d4261f54e30e5f3108a2b791",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "का पालन करें ताकि आप जान सकें कि कोड को कहां रखना है। एक्सटेंशन में उपयोग करने के लिए तत्व सेट करें: अब तक आपने अपने ब्राउज़र एक्सटेंशन के लिए फॉर्म और परिणाम <div> के लिए HTML बना लिया है। अब से, आपको /src/indexjs फाइल में काम करना होगा और अपने एक्सटेंशन को धीरे-धीरे बनाना होगा। पिछले पाठ का संदर्भ लें ताकि आप अपने प्रोजेक्ट को सेट अप और बिल्ड प्रक्रिया को समझ सकें। अपने indexjs फाइल में काम करते हुए, शुरुआत करें कुछ const वेरिएबल्स बनाने से जो विभिन्न फील्ड्स से जुड़े मानों को पकड़ते हैं:\n```JavaScript\n// form fields\nconst form = document querySelector(' form-data');\nconst region = document querySelector(' region-name');\nconst apiKey = document querySelector(' api-key');\n// results\nconst errors = document querySelector('",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 2,
    "total_chunks": 28
  },
  {
    "id": "adaf0215ce4645f117546cc099e874f7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "अपने एक्सटेंशन को धीरे-धीरे बनाना होगा। पिछले पाठ का संदर्भ लें ताकि आप अपने प्रोजेक्ट को सेट अप और बिल्ड प्रक्रिया को समझ सकें। अपने indexjs फाइल में काम करते हुए, शुरुआत करें कुछ const वेरिएबल्स बनाने से जो विभिन्न फील्ड्स से जुड़े मानों को पकड़ते हैं: ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector('errors');\nconst loading = document querySelector(' loading');\nconst results = document querySelector(' result-container');\nconst usage = document querySelector(' carbon-usage');\nconst fossilfuel = document querySelector(' fossil-fuel');\nconst myregion = document querySelector(' my-region');\nconst clearBtn = document querySelector('",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 341,
    "chunk_index": 3,
    "total_chunks": 28
  },
  {
    "id": "9877c2bac8b4758e43b8fffb1d2788f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "वेरिएबल्स बनाने से जो विभिन्न फील्ड्स से जुड़े मानों को पकड़ते हैं: ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector('errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn');\n```\nइन सभी फील्ड्स को उनके CSS क्लास द्वारा संदर्भित किया गया है, जैसा कि आपने पिछले पाठ में HTML में सेट किया था।\nलिसनर्स जोड़ें\nअब, फॉर्म और क्लियर बटन पर इवेंट लिसनर्स जोड़ें जो फॉर्म को रीसेट करता है, ताकि जब उपयोगकर्ता फॉर्म सबमिट करे या रीसेट बटन पर क्लिक करे, तो कुछ कार्रवाई हो। इसके अलावा, फाइल के नीचे ऐप को इनिशियलाइज़ करने के लिए कॉल जोड़ें:\nJavaScript\nform",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 527,
    "chunk_index": 4,
    "total_chunks": 28
  },
  {
    "id": "eca15c5426aa27cf0587397e49cae77e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "clearBtn = document querySelector('clear-btn'); ``` इन सभी फील्ड्स को उनके CSS क्लास द्वारा संदर्भित किया गया है, जैसा कि आपने पिछले पाठ में HTML में सेट किया था। लिसनर्स जोड़ें अब, फॉर्म और क्लियर बटन पर इवेंट लिसनर्स जोड़ें जो फॉर्म को रीसेट करता है, ताकि जब उपयोगकर्ता फॉर्म सबमिट करे या रीसेट बटन पर क्लिक करे, तो कुछ कार्रवाई हो। इसके अलावा, फाइल के नीचे ऐप को इनिशियलाइज़ करने के लिए कॉल जोड़ें: JavaScript formaddEventListener('submit', (e) => handleSubmit(e));\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 369,
    "chunk_index": 5,
    "total_chunks": 28
  },
  {
    "id": "fb3977a0e472734965e1c742ae97fbdb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "``` इन सभी फील्ड्स को उनके CSS क्लास द्वारा संदर्भित किया गया है, जैसा कि आपने पिछले पाठ में HTML में सेट किया था। लिसनर्स जोड़ें अब, फॉर्म और क्लियर बटन पर इवेंट लिसनर्स जोड़ें जो फॉर्म को रीसेट करता है, ताकि जब उपयोगकर्ता फॉर्म सबमिट करे या रीसेट बटन पर क्लिक करे, तो कुछ कार्रवाई हो। इसके अलावा, फाइल के नीचे ऐप को इनिशियलाइज़ करने के लिए कॉल जोड़ें: JavaScript formaddEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e));\ninit();\n✅ ध्यान दें कि सबमिट या क्लिक इवेंट को सुनने के लिए शॉर्टहैंड का उपयोग किया गया है, और कैसे इवेंट को handleSubmit या reset फंक्शन में पास किया गया है। क्या आप इस शॉर्टहैंड का लंबा संस्करण लिख सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 558,
    "chunk_index": 6,
    "total_chunks": 28
  },
  {
    "id": "55c14fd9b9cfbb5aa50599c06b52a467",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "सबमिट करे या रीसेट बटन पर क्लिक करे, तो कुछ कार्रवाई हो। इसके अलावा, फाइल के नीचे ऐप को इनिशियलाइज़ करने के लिए कॉल जोड़ें: JavaScript formaddEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e)); init(); ✅ ध्यान दें कि सबमिट या क्लिक इवेंट को सुनने के लिए शॉर्टहैंड का उपयोग किया गया है, और कैसे इवेंट को handleSubmit या reset फंक्शन में पास किया गया है। क्या आप इस शॉर्टहैंड का लंबा संस्करण लिख सकते हैंआपको कौन सा तरीका पसंद है init() और reset() फंक्शन बनाएं:\nअब आप उस फंक्शन को बनाएंगे जो एक्सटेंशन को इनिशियलाइज़ करता है, जिसे init() कहा जाता है:\n```JavaScript\nfunction init() {\n//if anything is in localStorage, pick it up\nconst storedApiKey = localStorage getItem('apiKey');\nconst storedRegion = localStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 7,
    "total_chunks": 28
  },
  {
    "id": "9adaba53b2cb7bb3548370f264b29a52",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "का उपयोग किया गया है, और कैसे इवेंट को handleSubmit या reset फंक्शन में पास किया गया है। क्या आप इस शॉर्टहैंड का लंबा संस्करण लिख सकते हैंआपको कौन सा तरीका पसंद है init() और reset() फंक्शन बनाएं: अब आप उस फंक्शन को बनाएंगे जो एक्सटेंशन को इनिशियलाइज़ करता है, जिसे init() कहा जाता है: ```JavaScript function init() { //if anything is in localStorage, pick it up const storedApiKey = localStorage getItem('apiKey'); const storedRegion = localStoragegetItem('regionName');\n//set icon to be generic green\n//todo\nif (storedApiKey === null || storedRegion === null) {\n//if we don't have the keys, show the form\nform style display = 'block';\nresults style display = 'none';\nloading style display = 'none';\nclearBtn style display = 'none';\nerrors textContent = '';\n} else {\n//if we have saved keys/regions in localStorage, show results when they load\ndisplayCarbonUsage(storedApiKey, storedRegion);\nresults style display = 'none';\nform style display = 'none';\nclearBtn style display = 'block';\n}\n};\nfunction reset(e) {\ne preventDefault();\n//clear local storage for region only\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 434,
    "chunk_index": 8,
    "total_chunks": 28
  },
  {
    "id": "3113346562cb90071a3ac413366ea8e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "have the keys, show the form form style display = 'block'; results style display = 'none'; loading style display = 'none'; clearBtn style display = 'none'; errors textContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName');\ninit();\n}\n```\nइस फंक्शन में कुछ दिलचस्प लॉजिक है। इसे पढ़ते हुए, क्या आप देख सकते हैं कि क्या हो रहा है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 215,
    "chunk_index": 9,
    "total_chunks": 28
  },
  {
    "id": "97722d78854180372fa7c6ebc7b4ae05",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "display = 'none'; errors textContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` इस फंक्शन में कुछ दिलचस्प लॉजिक है। इसे पढ़ते हुए, क्या आप देख सकते हैं कि क्या हो रहा हैदो const सेट किए गए हैं ताकि यह जांचा जा सके कि उपयोगकर्ता ने लोकल स्टोरेज में APIKey और क्षेत्र कोड संग्रहीत किया है या नहीं।\nयदि इनमें से कोई भी null है, तो फॉर्म को 'block' के रूप में प्रदर्शित करने के लिए इसकी शैली बदलकर दिखाएं।\nपरिणाम, लोडिंग, और clearBtn को छिपाएं और किसी भी त्रुटि पाठ को खाली स्ट्रिंग में सेट करें।\nयदि कोई key और region मौजूद है, तो एक रूटीन शुरू करें:\nAPI को कॉल करें ताकि कार्बन उपयोग डेटा प्राप्त किया जा सके।\nपरिणाम क्षेत्र को छिपाएं।\nफॉर्म को छिपाएं।\nरीसेट बटन दिखाएं।\nआगे बढ़ने से पहले, ब्राउज़रों में उपलब्ध एक बहुत ही महत्वपूर्ण अवधारणा के बारे में जानना उपयोगी है: LocalStorage। LocalStorage ब्राउज़र में key-value जोड़ी के रूप में स्ट्रिंग्स को संग्रहीत करने का एक उपयोगी तरीका है। इस प्रकार के वेब स्टोरेज को जावास्क्रिप्ट द्वारा ब्राउज़र में डेटा प्रबंधित करने के लिए नियंत्रित किया जा सकता है। LocalStorage समाप्त नहीं होता है, जबकि SessionStorage, वेब स्टोरेज का एक अन्य प्रकार, ब्राउज़र बंद होने पर साफ हो जाता है। विभिन्न प्रकार के स्टोरेज के उपयोग के अपने फायदे और नुकसान हैं।\nनोट - आपके ब्राउज़र एक्सटेंशन का अपना लोकल स्टोरेज है; मुख्य ब्राउज़र विंडो एक अलग इंस्टेंस है और अलग तरीके से व्यवहार करती है।\nआप अपने APIKey को एक स्ट्रिंग मान के रूप में सेट करते हैं, उदाहरण के लिए, और आप देख सकते हैं कि इसे Edge पर कैसे सेट किया गया है, \"वेब पेज का निरीक्षण\" करके (आप ब्राउज़र पर राइट-क्लिक करके निरीक्षण कर सकते हैं) और स्टोरेज देखने के लिए एप्लिकेशन टैब पर जाकर।\n✅ उन स्थितियों के बारे में सोचें जहां आप लोकल स्टोरेज में कुछ डेटा संग्रहीत नहीं करना चाहेंगे। सामान्य तौर पर, लोकल स्टोरेज में API Keys रखना एक बुरा विचार है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1610,
    "chunk_index": 10,
    "total_chunks": 28
  },
  {
    "id": "06ff240a3cfd4921154cb769ecf664cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "रूप में सेट करते हैं, उदाहरण के लिए, और आप देख सकते हैं कि इसे Edge पर कैसे सेट किया गया है, \"वेब पेज का निरीक्षण\" करके (आप ब्राउज़र पर राइट-क्लिक करके निरीक्षण कर सकते हैं) और स्टोरेज देखने के लिए एप्लिकेशन टैब पर जाकर। ✅ उन स्थितियों के बारे में सोचें जहां आप लोकल स्टोरेज में कुछ डेटा संग्रहीत नहीं करना चाहेंगे। सामान्य तौर पर, लोकल स्टोरेज में API Keys रखना एक बुरा विचार हैक्या आप देख सकते हैं क्यों",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 377,
    "chunk_index": 11,
    "total_chunks": 28
  },
  {
    "id": "8f2ee3a5ef11651591b5afc52ab2591a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "उदाहरण के लिए, और आप देख सकते हैं कि इसे Edge पर कैसे सेट किया गया है, \"वेब पेज का निरीक्षण\" करके (आप ब्राउज़र पर राइट-क्लिक करके निरीक्षण कर सकते हैं) और स्टोरेज देखने के लिए एप्लिकेशन टैब पर जाकर। ✅ उन स्थितियों के बारे में सोचें जहां आप लोकल स्टोरेज में कुछ डेटा संग्रहीत नहीं करना चाहेंगे। सामान्य तौर पर, लोकल स्टोरेज में API Keys रखना एक बुरा विचार हैक्या आप देख सकते हैं क्योंहमारे मामले में, चूंकि हमारा ऐप केवल सीखने के लिए है और इसे ऐप स्टोर में तैनात नहीं किया जाएगा, हम इस विधि का उपयोग करेंगे।\nध्यान दें कि आप लोकल स्टोरेज को नियंत्रित करने के लिए वेब API का उपयोग करते हैं, या तो getItem(), setItem(), या removeItem() का उपयोग करके। यह ब्राउज़रों में व्यापक रूप से समर्थित है।\ndisplayCarbonUsage() फंक्शन बनाने से पहले, जो init() में कॉल किया गया है, आइए प्रारंभिक फॉर्म सबमिशन को संभालने की कार्यक्षमता बनाएं।\nफॉर्म सबमिशन को संभालें\nएक फंक्शन बनाएं जिसे handleSubmit कहा जाता है, जो एक इवेंट तर्क (e) स्वीकार करता है। इवेंट को फैलने से रोकें (इस मामले में, हम ब्राउज़र को रिफ्रेश होने से रोकना चाहते हैं) और एक नए फंक्शन setUpUser को कॉल करें, जिसमें apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 955,
    "chunk_index": 12,
    "total_chunks": 28
  },
  {
    "id": "abb957cf51ac35d0ab3ce0fbbb6b2a8d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "यह ब्राउज़रों में व्यापक रूप से समर्थित है। displayCarbonUsage() फंक्शन बनाने से पहले, जो init() में कॉल किया गया है, आइए प्रारंभिक फॉर्म सबमिशन को संभालने की कार्यक्षमता बनाएं। फॉर्म सबमिशन को संभालें एक फंक्शन बनाएं जिसे handleSubmit कहा जाता है, जो एक इवेंट तर्क (e) स्वीकार करता है। इवेंट को फैलने से रोकें (इस मामले में, हम ब्राउज़र को रिफ्रेश होने से रोकना चाहते हैं) और एक नए फंक्शन setUpUser को कॉल करें, जिसमें apiKeyvalue और region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 374,
    "chunk_index": 13,
    "total_chunks": 28
  },
  {
    "id": "446ea79fd5ae88051d820d94735bd726",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "में व्यापक रूप से समर्थित है। displayCarbonUsage() फंक्शन बनाने से पहले, जो init() में कॉल किया गया है, आइए प्रारंभिक फॉर्म सबमिशन को संभालने की कार्यक्षमता बनाएं। फॉर्म सबमिशन को संभालें एक फंक्शन बनाएं जिसे handleSubmit कहा जाता है, जो एक इवेंट तर्क (e) स्वीकार करता है। इवेंट को फैलने से रोकें (इस मामले में, हम ब्राउज़र को रिफ्रेश होने से रोकना चाहते हैं) और एक नए फंक्शन setUpUser को कॉल करें, जिसमें apiKeyvalue और regionvalue तर्क पास करें। इस तरह, आप प्रारंभिक फॉर्म के माध्यम से लाए गए दो मानों का उपयोग करते हैं जब उपयुक्त फील्ड्स भरे जाते हैं।\nJavaScript\nfunction handleSubmit(e) {\ne preventDefault();\nsetUpUser(apiKey value, region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 14,
    "total_chunks": 28
  },
  {
    "id": "b5d73860a6c2f559dc29c5dd9c9f327d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "जिसे handleSubmit कहा जाता है, जो एक इवेंट तर्क (e) स्वीकार करता है। इवेंट को फैलने से रोकें (इस मामले में, हम ब्राउज़र को रिफ्रेश होने से रोकना चाहते हैं) और एक नए फंक्शन setUpUser को कॉल करें, जिसमें apiKeyvalue और regionvalue तर्क पास करें। इस तरह, आप प्रारंभिक फॉर्म के माध्यम से लाए गए दो मानों का उपयोग करते हैं जब उपयुक्त फील्ड्स भरे जाते हैं। JavaScript function handleSubmit(e) { e preventDefault(); setUpUser(apiKey value, regionvalue);\n}\n✅ अपनी याददाश्त ताज़ा करें - पिछले पाठ में सेट किए गए HTML में दो इनपुट फील्ड्स हैं जिनके values को आपने फाइल के शीर्ष पर सेट किए गए const के माध्यम से कैप्चर किया है, और वे दोनों required हैं ताकि ब्राउज़र उपयोगकर्ताओं को null मान इनपुट करने से रोक सके।\nउपयोगकर्ता सेट करें\nsetUpUser फंक्शन पर आगे बढ़ते हुए, यहां आप लोकल स्टोरेज मानों को apiKey और regionName के लिए सेट करते हैं। एक नया फंक्शन जोड़ें:\nJavaScript\nfunction setUpUser(apiKey, regionName) {\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 680,
    "chunk_index": 15,
    "total_chunks": 28
  },
  {
    "id": "59e9ffcd59265680c3a98af13a93d8b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "सेट किए गए HTML में दो इनपुट फील्ड्स हैं जिनके values को आपने फाइल के शीर्ष पर सेट किए गए const के माध्यम से कैप्चर किया है, और वे दोनों required हैं ताकि ब्राउज़र उपयोगकर्ताओं को null मान इनपुट करने से रोक सके। उपयोगकर्ता सेट करें setUpUser फंक्शन पर आगे बढ़ते हुए, यहां आप लोकल स्टोरेज मानों को apiKey और regionName के लिए सेट करते हैं। एक नया फंक्शन जोड़ें: JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey);\nlocalStorage setItem('regionName', regionName);\nloading style display = 'block';\nerrors textContent = '';\nclearBtn style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 349,
    "chunk_index": 16,
    "total_chunks": 28
  },
  {
    "id": "3da6412647740cf8640a91ebe17fe9ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "शीर्ष पर सेट किए गए const के माध्यम से कैप्चर किया है, और वे दोनों required हैं ताकि ब्राउज़र उपयोगकर्ताओं को null मान इनपुट करने से रोक सके। उपयोगकर्ता सेट करें setUpUser फंक्शन पर आगे बढ़ते हुए, यहां आप लोकल स्टोरेज मानों को apiKey और regionName के लिए सेट करते हैं। एक नया फंक्शन जोड़ें: JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStorage setItem('regionName', regionName); loading style display = 'block'; errors textContent = ''; clearBtn styledisplay = 'block';\n//make initial call\ndisplayCarbonUsage(apiKey, regionName);\n}\nयह फंक्शन API को कॉल करते समय एक लोडिंग संदेश दिखाने के लिए सेट करता है। इस बिंदु पर, आप इस ब्राउज़र एक्सटेंशन के सबसे महत्वपूर्ण फंक्शन को बनाने के लिए पहुंच गए हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 17,
    "total_chunks": 28
  },
  {
    "id": "c03297000af19c78eb5d4085c5e562d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "को apiKey और regionName के लिए सेट करते हैं। एक नया फंक्शन जोड़ें: JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStorage setItem('regionName', regionName); loading style display = 'block'; errors textContent = ''; clearBtn styledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } यह फंक्शन API को कॉल करते समय एक लोडिंग संदेश दिखाने के लिए सेट करता है। इस बिंदु पर, आप इस ब्राउज़र एक्सटेंशन के सबसे महत्वपूर्ण फंक्शन को बनाने के लिए पहुंच गए हैंकार्बन उपयोग प्रदर्शित करें\nअंत में, API को क्वेरी करने का समय आ गया है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 345,
    "chunk_index": 18,
    "total_chunks": 28
  },
  {
    "id": "a4a146ded9242e0f23e6434781b0e62b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStorage setItem('regionName', regionName); loading style display = 'block'; errors textContent = ''; clearBtn styledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } यह फंक्शन API को कॉल करते समय एक लोडिंग संदेश दिखाने के लिए सेट करता है। इस बिंदु पर, आप इस ब्राउज़र एक्सटेंशन के सबसे महत्वपूर्ण फंक्शन को बनाने के लिए पहुंच गए हैंकार्बन उपयोग प्रदर्शित करें अंत में, API को क्वेरी करने का समय आ गया हैआगे बढ़ने से पहले, हमें APIs पर चर्चा करनी चाहिए। APIs, या एप्लिकेशन प्रोग्रामिंग इंटरफेस, वेब डेवलपर के टूलबॉक्स का एक महत्वपूर्ण तत्व हैं। वे प्रोग्राम्स को एक-दूसरे के साथ इंटरफेस और इंटरैक्ट करने के लिए मानक तरीके प्रदान करते हैं। उदाहरण के लिए, यदि आप एक वेबसाइट बना रहे हैं जिसे डेटाबेस को क्वेरी करने की आवश्यकता है, तो किसी ने आपके उपयोग के लिए एक API बनाया हो सकता है। जबकि APIs के कई प्रकार हैं, उनमें से एक सबसे लोकप्रिय है REST API।\n✅ 'REST' शब्द का मतलब 'Representational State Transfer' है और इसमें विभिन्न प्रकार के URL का उपयोग करके डेटा को प्राप्त करना शामिल है। डेवलपर्स के लिए उपलब्ध विभिन्न प्रकार के APIs पर थोड़ा शोध करें। आपको कौन सा प्रारूप पसंद आता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 895,
    "chunk_index": 19,
    "total_chunks": 28
  },
  {
    "id": "78352e07d107c57948d33bf67a41dde2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "को क्वेरी करने की आवश्यकता है, तो किसी ने आपके उपयोग के लिए एक API बनाया हो सकता है। जबकि APIs के कई प्रकार हैं, उनमें से एक सबसे लोकप्रिय है REST API। ✅ 'REST' शब्द का मतलब 'Representational State Transfer' है और इसमें विभिन्न प्रकार के URL का उपयोग करके डेटा को प्राप्त करना शामिल है। डेवलपर्स के लिए उपलब्ध विभिन्न प्रकार के APIs पर थोड़ा शोध करें। आपको कौन सा प्रारूप पसंद आता हैइस फंक्शन के बारे में महत्वपूर्ण बातें नोट करें। सबसे पहले, async कीवर्ड पर ध्यान दें। अपने फंक्शन को इस तरह से लिखना कि वे असिंक्रोनस रूप से चलें, इसका मतलब है कि वे किसी क्रिया, जैसे डेटा लौटने, के पूरा होने की प्रतीक्षा करते हैं, इससे पहले कि वे आगे बढ़ें।\nयहां async पर एक त्वरित वीडियो है:\n🎥 ऊपर दी गई छवि पर क्लिक करें async/await के बारे में वीडियो देखने के लिए।\nC02Signal API को क्वेरी करने के लिए एक नया फंक्शन बनाएं:\n```JavaScript\nimport axios from '",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 20,
    "total_chunks": 28
  },
  {
    "id": "842dc4ad005589292cf22fc49465d54e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "दें। अपने फंक्शन को इस तरह से लिखना कि वे असिंक्रोनस रूप से चलें, इसका मतलब है कि वे किसी क्रिया, जैसे डेटा लौटने, के पूरा होने की प्रतीक्षा करते हैं, इससे पहले कि वे आगे बढ़ें। यहां async पर एक त्वरित वीडियो है: 🎥 ऊपर दी गई छवि पर क्लिक करें async/await के बारे में वीडियो देखने के लिए। C02Signal API को क्वेरी करने के लिए एक नया फंक्शन बनाएं: ```JavaScript import axios from '/node_modules/axios';\nasync function displayCarbonUsage(apiKey, region) {\ntry {\nawait axios get('https://api co2signal com/v1/latest', {\nparams: {\ncountryCode: region,\n},\nheaders: {\n'auth-token': apiKey,\n},\n}) then((response) => {\nlet CO2 = Math floor(response data data carbonIntensity);\n//calculateColor(CO2);\nloading style display = 'none';\nform style display = 'none';\nmyregion textContent = region;\nusage textContent =\nMath round(response data data carbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)';\nfossilfuel textContent =\nresponse data data fossilFuelPercentage toFixed(2) +\n'% (percentage of fossil fuels used to generate electricity)';\nresults style display = 'block';\n});\n} catch (error) {\nconsole log(error);\nloading style display = 'none';\nresults style display = 'none';\nerrors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 503,
    "chunk_index": 21,
    "total_chunks": 28
  },
  {
    "id": "0d823b47a19678284034fe83260dd607",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "data data carbonIntensity); //calculateColor(CO2); loading style display = 'none'; form style display = 'none'; myregion textContent = region; usage textContent = Math round(response data data carbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfuel textContent = response data data fossilFuelPercentage toFixed(2) + '% (percentage of fossil fuels used to generate electricity)'; results style display = 'block'; }); } catch (error) { console log(error); loading style display = 'none'; results style display = 'none'; errorstextContent = 'Sorry, we have no data for the region you have requested ';\n}\n}\n```\nयह एक बड़ा फंक्शन है। यहां क्या हो रहा है सर्वोत्तम प्रथाओं का पालन करते हुए, आप इस फंक्शन को असिंक्रोनस रूप से व्यवहार करने के लिए async कीवर्ड का उपयोग करते हैं। फंक्शन में एक try/catch ब्लॉक होता है क्योंकि यह API से डेटा लौटने पर एक प्रॉमिस लौटाएगा। चूंकि आपके पास API के प्रतिक्रिया देने की गति पर नियंत्रण नहीं है (यह प्रतिक्रिया नहीं भी दे सकता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 22,
    "total_chunks": 28
  },
  {
    "id": "d095013ae773d082b3f6dade7f751f2d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "have requested '; } } ``` यह एक बड़ा फंक्शन है। यहां क्या हो रहा है सर्वोत्तम प्रथाओं का पालन करते हुए, आप इस फंक्शन को असिंक्रोनस रूप से व्यवहार करने के लिए async कीवर्ड का उपयोग करते हैं। फंक्शन में एक try/catch ब्लॉक होता है क्योंकि यह API से डेटा लौटने पर एक प्रॉमिस लौटाएगा। चूंकि आपके पास API के प्रतिक्रिया देने की गति पर नियंत्रण नहीं है (यह प्रतिक्रिया नहीं भी दे सकता है), आपको इस अनिश्चितता को असिंक्रोनस रूप से कॉल करके संभालने की आवश्यकता है।\nआप co2signal API को क्वेरी कर रहे हैं ताकि अपने क्षेत्र का डेटा प्राप्त किया जा सके, अपने API Key का उपयोग करके। उस key का उपयोग करने के लिए, आपको अपने हेडर पैरामीटर्स में एक प्रकार का ऑथेंटिकेशन उपयोग करना होगा।\nएक बार जब API प्रतिक्रिया देता है, तो आप इसकी प्रतिक्रिया डेटा के विभिन्न तत्वों को अपनी स्क्रीन के उन हिस्सों में असाइन करते हैं जिन्हें आपने इस डेटा को दिखाने के लिए सेट किया है।\nयदि कोई त्रुटि है, या कोई परिणाम नहीं है, तो आप एक त्रुटि संदेश दिखाते हैं।\n✅ असिंक्रोनस प्रोग्रामिंग पैटर्न का उपयोग करना आपके टूलबॉक्स में एक और बहुत उपयोगी उपकरण है। विभिन्न तरीकों के बारे में पढ़ें जिनसे आप इस प्रकार के कोड को कॉन्फ़िगर कर सकते हैं।\nबधाई हो",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1016,
    "chunk_index": 23,
    "total_chunks": 28
  },
  {
    "id": "83996dba9410400c795180fe4639c13e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "डेटा के विभिन्न तत्वों को अपनी स्क्रीन के उन हिस्सों में असाइन करते हैं जिन्हें आपने इस डेटा को दिखाने के लिए सेट किया है। यदि कोई त्रुटि है, या कोई परिणाम नहीं है, तो आप एक त्रुटि संदेश दिखाते हैं। ✅ असिंक्रोनस प्रोग्रामिंग पैटर्न का उपयोग करना आपके टूलबॉक्स में एक और बहुत उपयोगी उपकरण है। विभिन्न तरीकों के बारे में पढ़ें जिनसे आप इस प्रकार के कोड को कॉन्फ़िगर कर सकते हैं। बधाई होयदि आप अपने एक्सटेंशन को बिल्ड करते हैं (npm run build) और इसे अपने एक्सटेंशन पैन में रिफ्रेश करते हैं, तो आपके पास एक कार्यशील एक्सटेंशन है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 24,
    "total_chunks": 28
  },
  {
    "id": "5e2808dc3a1a33cdd2f43e1e8122288e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "कोई त्रुटि है, या कोई परिणाम नहीं है, तो आप एक त्रुटि संदेश दिखाते हैं। ✅ असिंक्रोनस प्रोग्रामिंग पैटर्न का उपयोग करना आपके टूलबॉक्स में एक और बहुत उपयोगी उपकरण है। विभिन्न तरीकों के बारे में पढ़ें जिनसे आप इस प्रकार के कोड को कॉन्फ़िगर कर सकते हैं। बधाई होयदि आप अपने एक्सटेंशन को बिल्ड करते हैं (npm run build) और इसे अपने एक्सटेंशन पैन में रिफ्रेश करते हैं, तो आपके पास एक कार्यशील एक्सटेंशन हैकेवल एक चीज जो काम नहीं कर रही है वह है आइकन, और आप इसे अगले पाठ में ठीक करेंगे।\n🚀 चुनौती\nहमने इन पाठों में अब तक कई प्रकार के API पर चर्चा की है। एक वेब API चुनें और गहराई से शोध करें कि यह क्या प्रदान करता है। उदाहरण के लिए, ब्राउज़रों में उपलब्ध APIs जैसे HTML Drag and Drop API को देखें। आपके विचार में एक अच्छा API क्या बनाता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 25,
    "total_chunks": 28
  },
  {
    "id": "16ca2330cbc62684c083f3e2e0d358d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "एक्सटेंशन हैकेवल एक चीज जो काम नहीं कर रही है वह है आइकन, और आप इसे अगले पाठ में ठीक करेंगे। 🚀 चुनौती हमने इन पाठों में अब तक कई प्रकार के API पर चर्चा की है। एक वेब API चुनें और गहराई से शोध करें कि यह क्या प्रदान करता है। उदाहरण के लिए, ब्राउज़रों में उपलब्ध APIs जैसे HTML Drag and Drop API को देखें। आपके विचार में एक अच्छा API क्या बनाता हैपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nआपने इस पाठ में LocalStorage और APIs के बारे में सीखा, जो पेशेवर वेब डेवलपर के लिए बहुत उपयोगी हैं। क्या आप सोच सकते हैं कि ये दोनों चीजें एक साथ कैसे काम करती हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 516,
    "chunk_index": 26,
    "total_chunks": 28
  },
  {
    "id": "6ea8d882a72ef234e4bcdc3fd22508c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 2: API कॉल करें, लोकल स्टोरेज का उपयोग करें",
    "content": "और गहराई से शोध करें कि यह क्या प्रदान करता है। उदाहरण के लिए, ब्राउज़रों में उपलब्ध APIs जैसे HTML Drag and Drop API को देखें। आपके विचार में एक अच्छा API क्या बनाता हैपोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन आपने इस पाठ में LocalStorage और APIs के बारे में सीखा, जो पेशेवर वेब डेवलपर के लिए बहुत उपयोगी हैं। क्या आप सोच सकते हैं कि ये दोनों चीजें एक साथ कैसे काम करती हैंएक वेबसाइट को आर्किटेक्ट करने के बारे में सोचें जो API द्वारा उपयोग किए जाने वाले आइटम को संग्रहीत करेगी।\nअसाइनमेंट\nएक API अपनाएं\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 25045,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 886,
    "chunk_index": 27,
    "total_chunks": 28
  },
  {
    "id": "53099ea6f81a6dbe973f62bc20d60d66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.hi.md",
    "source_type": "git_repo",
    "title": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: पूरा किया हुआ कोड",
    "content": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: पूरा किया हुआ कोड\nबिजली के उपयोग को ट्रैक करने के लिए tmrow के C02 सिग्नल एपीआई का उपयोग करते हुए, एक ब्राउज़र एक्सटेंशन का निर्माण किया गया है जो आपके ब्राउज़र में आपके क्षेत्र की बिजली के उपयोग की तीव्रता के बारे में आपको रिमाइंडर देता है। इस एक्सटेंशन का उपयोग करके, आप इस जानकारी के आधार पर अपनी गतिविधियों के बारे में बेहतर निर्णय ले सकते हैं।\nशुरू करना\nआपको npm इंस्टॉल करना होगा। अपने कंप्यूटर पर एक फ़ोल्डर में इस कोड की एक प्रति डाउनलोड करें।\nसभी आवश्यक पैकेज स्थापित करें:\nnpm install\nवेबपैक से एक्सटेंशन बनाएं:\nnpm run build\nएज पर स्थापित करने के लिए, ब्राउज़र के ऊपरी दाएं कोने पर 'तीन डॉट' मेनू का उपयोग करें और एक्सटेंशन पैनल को खोजें। वहां से, एक नया एक्सटेंशन लोड करने के लिए 'लोड अनपैक्ड' चुनें। प्रॉम्प्ट पर 'dist' फ़ोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसका उपयोग करने के लिए, आपको CO2 सिग्नल की एपीआई (ईमेल के माध्यम से यहां प्राप्त करें के लिए एक एपीआई कुंजी की आवश्यकता होगी - इस पृष्ठ पर बॉक्स में अपना ईमेल दर्ज करें) और अपने क्षेत्र के लिए कोड विद्युत मानचित्र (उदाहरण के लिए, बोस्टन में, मैं 'US-NEISO' का उपयोग करता हूं)।\nएक बार एपीआई कुंजी और क्षेत्र एक्सटेंशन इंटरफ़ेस में इनपुट हो जाने के बाद, ब्राउज़र एक्सटेंशन बार में रंगीन डॉट आपके क्षेत्र की ऊर्जा के उपयोग को प्रतिबिंबित करने के लिए बदल जाएगा और आपको यह संकेत देगा कि ऊर्जा-गहन गतिविधियां आपके प्रदर्शन के लिए उपयुक्त हैं या नहीं। इस 'डॉट' प्रणाली की अवधारणा मुझे कैलिफ़ोर्निया उत्सर्जन के लिए एनर्जी लॉलीपॉप एक्सटेंशन से प्रेरित हुई थी।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5509,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.hi.md",
      "source_type": "git_repo"
    },
    "token_count": 1844,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3a9c2dfd23005fc3707893be5fc5b30c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.it.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger ब्राउज़र एक्सटेंशन: शुरुआत के लिए कोड",
    "content": "Carbon Trigger ब्राउज़र एक्सटेंशन: शुरुआत के लिए कोड\nआप tmrow की Signal C02 API का उपयोग करके बिजली की खपत की निगरानी करेंगे ताकि एक ब्राउज़र एक्सटेंशन बनाया जा सके। यह एक्सटेंशन आपके ब्राउज़र में सीधे यह याद दिलाने का काम करेगा कि आपके क्षेत्र में बिजली की खपत कितनी भारी है। इस विशेष एक्सटेंशन का उपयोग आपको इन जानकारियों के आधार पर अपनी गतिविधियों का मूल्यांकन करने में मदद करेगा।\nशुरुआत करने के लिए\nयह आवश्यक है कि npm इंस्टॉल हो। इस कोड की एक कॉपी अपने कंप्यूटर की किसी फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें:\nnpm install\nWebpack से एक्सटेंशन बनाएं:\nnpm run build\nEdge पर इंस्टॉल करने के लिए, ब्राउज़र के ऊपर दाईं ओर \"तीन बिंदु\" वाले मेनू का उपयोग करें और एक्सटेंशन पैनल ढूंढें। यदि यह पहले से सक्रिय नहीं है, तो डेवलपर मोड (नीचे बाईं ओर) को सक्रिय करें। \"अनपैक्ड लोड करें\" चुनें ताकि नया एक्सटेंशन लोड किया जा सके। प्रॉम्प्ट पर \"dist\" फोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसका उपयोग करने के लिए, आपको CO2 Signal API के लिए एक API कुंजी की आवश्यकता होगी (आप इसे यहां ईमेल के माध्यम से प्राप्त कर सकते हैं - इस पेज पर अपना ईमेल बॉक्स में डालें) और अपनी क्षेत्र का कोड जो इलेक्ट्रिसिटी मैप से मेल खाता हो (उदाहरण के लिए, बोस्टन में \"US-NEISO\")।\nएक बार जब API कुंजी और क्षेत्र को एक्सटेंशन इंटरफेस में डाल दिया जाए, तो ब्राउज़र एक्सटेंशन बार में रंगीन बिंदु क्षेत्र की ऊर्जा खपत को दर्शाने के लिए बदल जाएगा और यह संकेत देगा कि कौन सी उच्च ऊर्जा खपत वाली गतिविधियां उपयुक्त होंगी। इस \"पॉइंट\" सिस्टम का विचार Energy Lollipop एक्सटेंशन से लिया गया है, जो कैलिफोर्निया की उत्सर्जन जानकारी प्रदान करता है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5575,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.it.md",
      "source_type": "git_repo"
    },
    "token_count": 1830,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "96ecce12321d7e21e13b482a2d8dae75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.ja.md",
    "source_type": "git_repo",
    "title": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: तैयार कोड",
    "content": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: तैयार कोड\ntmrow के C02 सिग्नल API का उपयोग करके बिजली की खपत को ट्रैक करने के लिए, आपके क्षेत्र में बिजली की खपत कितनी अधिक है, इसे ब्राउज़र पर एक रिमाइंडर के रूप में दिखाने के लिए एक ब्राउज़र एक्सटेंशन बनाएं। इस एक्सटेंशन का उपयोग करके, आप इस जानकारी के आधार पर अपनी गतिविधियों का निर्णय ले सकते हैं।\nशुरुआत करें\nnpm इंस्टॉल होना चाहिए। इस कोड की एक कॉपी अपने कंप्यूटर पर किसी फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें।\nnpm install\nwebpack का उपयोग करके एक्सटेंशन को बिल्ड करें।\nnpm run build\nEdge में इंस्टॉल करने के लिए, ब्राउज़र के ऊपर दाईं ओर \"तीन डॉट्स\" मेनू से \"Extensions\" पैनल खोजें। वहां से \"Load Unpacked\" चुनें और नया एक्सटेंशन लोड करें। प्रॉम्प्ट में \"dist\" फोल्डर खोलें, और एक्सटेंशन लोड हो जाएगा। इसका उपयोग करने के लिए, CO2 सिग्नल API का API की (यहां ईमेल के जरिए प्राप्त करें - इस पेज के बॉक्स में अपना ईमेल डालें) और Electricity Map के लिए आपके क्षेत्र का कोड चाहिए (उदाहरण के लिए, बोस्टन में 'US-NEISO' का उपयोग किया जाता है)।\nAPI की और क्षेत्र को एक्सटेंशन इंटरफेस में दर्ज करें। इसके बाद, ब्राउज़र के एक्सटेंशन बार में दिखने वाला रंगीन डॉट आपके क्षेत्र की ऊर्जा खपत को दर्शाएगा और यह बताएगा कि किस प्रकार की ऊर्जा-आधारित गतिविधियां करना उपयुक्त होगा। इस \"डॉट\" सिस्टम का विचार मुझे कैलिफोर्निया के उत्सर्जन के लिए Energy Lollipop extension से मिला।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 4942,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.ja.md",
      "source_type": "git_repo"
    },
    "token_count": 1608,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "4564ac23099729f92e21d2dd971290e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nपरिचय\nइस मॉड्यूल के पिछले दो पाठों में, आपने एक फॉर्म और डेटा को प्रदर्शित करने के लिए एक क्षेत्र बनाना सीखा, जिसे API से प्राप्त किया गया था। यह वेब पर एक वेब उपस्थिति बनाने का एक बहुत ही सामान्य तरीका है। आपने डेटा को असिंक्रोनस रूप से प्राप्त करने का प्रबंधन करना भी सीखा। आपका ब्राउज़र एक्सटेंशन लगभग पूरा हो चुका है।\nअब बैकग्राउंड टास्क को प्रबंधित करना बाकी है, जिसमें एक्सटेंशन के आइकन का रंग रिफ्रेश करना शामिल है। यह एक अच्छा समय है यह समझने का कि ब्राउज़र इस प्रकार के कार्यों को कैसे प्रबंधित करता है। आइए इन ब्राउज़र कार्यों को आपके वेब एसेट्स के प्रदर्शन के संदर्भ में समझें जब आप उन्हें बनाते हैं।\nवेब परफॉर्मेंस के मूल सिद्धांत\n\"वेबसाइट परफॉर्मेंस दो चीज़ों के बारे में है: पेज कितनी जल्दी लोड होता है, और उस पर कोड कितनी जल्दी चलता है।\" -- ज़ैक ग्रॉसबार्ट\nआपकी वेबसाइट को सभी प्रकार के डिवाइसों, उपयोगकर्ताओं और परिस्थितियों में तेज़ बनाने के विषय पर चर्चा करना स्वाभाविक रूप से बहुत व्यापक है। यहां कुछ बिंदु दिए गए हैं जिन्हें आपको एक सामान्य वेब प्रोजेक्ट या ब्राउज़र एक्सटेंशन बनाते समय ध्यान में रखना चाहिए।\nसबसे पहली चीज़ जो आपको यह सुनिश्चित करने के लिए करनी चाहिए कि आपकी साइट कुशलता से चल रही है, वह है इसके प्रदर्शन के बारे में डेटा एकत्र करना। इसका पहला स्थान आपके वेब ब्राउज़र के डेवलपर टूल्स में है। Edge में, आप \"सेटिंग्स और अधिक\" बटन (ब्राउज़र के शीर्ष दाएं कोने में तीन डॉट्स आइकन) का चयन कर सकते हैं, फिर More Tools > Developer Tools पर नेविगेट करें और Performance टैब खोलें। आप Windows पर Ctrl + Shift + I या Mac पर Option + Command + I कीबोर्ड शॉर्टकट का उपयोग करके भी डेवलपर टूल्स खोल सकते हैं।\nPerformance टैब में एक प्रोफाइलिंग टूल होता है। एक वेबसाइट खोलें (उदाहरण के लिए, https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1635,
    "chunk_index": 0,
    "total_chunks": 18
  },
  {
    "id": "8854e06ac9e524643710224a9e436686",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "Edge में, आप \"सेटिंग्स और अधिक\" बटन (ब्राउज़र के शीर्ष दाएं कोने में तीन डॉट्स आइकन) का चयन कर सकते हैं, फिर More Tools > Developer Tools पर नेविगेट करें और Performance टैब खोलें। आप Windows पर Ctrl + Shift + I या Mac पर Option + Command + I कीबोर्ड शॉर्टकट का उपयोग करके भी डेवलपर टूल्स खोल सकते हैं। Performance टैब में एक प्रोफाइलिंग टूल होता है। एक वेबसाइट खोलें (उदाहरण के लिए, https://wwwmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 306,
    "chunk_index": 1,
    "total_chunks": 18
  },
  {
    "id": "a25f4132eec81874c42b7ac5374c9042",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "Edge में, आप \"सेटिंग्स और अधिक\" बटन (ब्राउज़र के शीर्ष दाएं कोने में तीन डॉट्स आइकन) का चयन कर सकते हैं, फिर More Tools > Developer Tools पर नेविगेट करें और Performance टैब खोलें। आप Windows पर Ctrl + Shift + I या Mac पर Option + Command + I कीबोर्ड शॉर्टकट का उपयोग करके भी डेवलपर टूल्स खोल सकते हैं। Performance टैब में एक प्रोफाइलिंग टूल होता है। एक वेबसाइट खोलें (उदाहरण के लिए, https://wwwmicrosoftcom) और 'Record' बटन पर क्लिक करें, फिर साइट को रिफ्रेश करें। किसी भी समय रिकॉर्डिंग रोकें, और आप उन रूटीन को देख पाएंगे जो साइट को 'स्क्रिप्ट', 'रेंडर', और 'पेंट' करने के लिए उत्पन्न होते हैं:\n✅ Microsoft डाक्यूमेंटेशन पर Edge के Performance पैनल के बारे में जानें।\nटिप: अपनी वेबसाइट के स्टार्टअप समय का सटीक रीडिंग प्राप्त करने के लिए, अपने ब्राउज़र का कैश साफ़ करें।\nप्रोफाइल टाइमलाइन के तत्वों का चयन करें ताकि आप उन घटनाओं को ज़ूम कर सकें जो आपके पेज लोड होने के दौरान होती हैं।\nप्रोफाइल टाइमलाइन के एक हिस्से का चयन करके और सारांश पैन को देखकर अपने पेज के प्रदर्शन का स्नैपशॉट प्राप्त करें:\nइवेंट लॉग पैन की जांच करें कि क्या कोई इवेंट 15 मिलीसेकंड से अधिक समय ले रहा है:\n✅ अपने प्रोफाइलर को जानें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 954,
    "chunk_index": 2,
    "total_chunks": 18
  },
  {
    "id": "f19c48cd3bcdd34ea5258c4b64275ee4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "के लिए, अपने ब्राउज़र का कैश साफ़ करें। प्रोफाइल टाइमलाइन के तत्वों का चयन करें ताकि आप उन घटनाओं को ज़ूम कर सकें जो आपके पेज लोड होने के दौरान होती हैं। प्रोफाइल टाइमलाइन के एक हिस्से का चयन करके और सारांश पैन को देखकर अपने पेज के प्रदर्शन का स्नैपशॉट प्राप्त करें: इवेंट लॉग पैन की जांच करें कि क्या कोई इवेंट 15 मिलीसेकंड से अधिक समय ले रहा है: ✅ अपने प्रोफाइलर को जानेंइस साइट पर डेवलपर टूल्स खोलें और देखें कि क्या कोई बाधा है। सबसे धीमी लोडिंग एसेट कौन सा है सबसे तेज़ कौन सा है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 3,
    "total_chunks": 18
  },
  {
    "id": "3a2852890314cfaa565ea4d218888f1e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "आपके पेज लोड होने के दौरान होती हैं। प्रोफाइल टाइमलाइन के एक हिस्से का चयन करके और सारांश पैन को देखकर अपने पेज के प्रदर्शन का स्नैपशॉट प्राप्त करें: इवेंट लॉग पैन की जांच करें कि क्या कोई इवेंट 15 मिलीसेकंड से अधिक समय ले रहा है: ✅ अपने प्रोफाइलर को जानेंइस साइट पर डेवलपर टूल्स खोलें और देखें कि क्या कोई बाधा है। सबसे धीमी लोडिंग एसेट कौन सा है सबसे तेज़ कौन सा हैप्रोफाइलिंग चेक्स\nसामान्य तौर पर, कुछ \"समस्या क्षेत्र\" होते हैं जिन पर हर वेब डेवलपर को साइट बनाते समय ध्यान देना चाहिए ताकि प्रोडक्शन में तैनाती के समय अप्रिय आश्चर्य से बचा जा सके।\nएसेट साइज़: पिछले कुछ वर्षों में वेब 'भारी' और इस प्रकार धीमा हो गया है। इस वजन का कुछ हिस्सा छवियों के उपयोग से संबंधित है।\n✅ इंटरनेट आर्काइव पर पेज वेट का ऐतिहासिक दृश्य और अधिक जानकारी देखें।\nएक अच्छा अभ्यास यह सुनिश्चित करना है कि आपकी छवियां अनुकूलित हैं और आपके उपयोगकर्ताओं के लिए सही आकार और रिज़ॉल्यूशन में वितरित की गई हैं।\nDOM ट्रैवर्सल्स: ब्राउज़र को आपके द्वारा लिखे गए कोड के आधार पर अपना Document Object Model बनाना होता है, इसलिए अच्छे पेज प्रदर्शन के लिए अपने टैग्स को न्यूनतम रखना महत्वपूर्ण है। केवल वही उपयोग करें और स्टाइल करें जो पेज को चाहिए। इस बिंदु पर, पेज से जुड़े अतिरिक्त CSS को अनुकूलित किया जा सकता है; उदाहरण के लिए, जो स्टाइल केवल एक पेज पर उपयोग किए जाने हैं, उन्हें मुख्य स्टाइल शीट में शामिल करने की आवश्यकता नहीं है।\nजावास्क्रिप्ट: हर जावास्क्रिप्ट डेवलपर को 'रेंडर-ब्लॉकिंग' स्क्रिप्ट्स पर ध्यान देना चाहिए, जिन्हें DOM को ट्रैवर्स और ब्राउज़र में पेंट करने से पहले लोड करना आवश्यक है। अपने इनलाइन स्क्रिप्ट्स के साथ defer का उपयोग करने पर विचार करें (जैसा कि Terrarium मॉड्यूल में किया गया है)।\n✅ साइट परफॉर्मेंस निर्धारित करने के लिए किए गए सामान्य चेक्स के बारे में अधिक जानने के लिए साइट स्पीड टेस्ट वेबसाइट पर कुछ साइट्स आज़माएं।\nअब जब आपको यह समझ आ गया है कि ब्राउज़र आपके द्वारा भेजे गए एसेट्स को कैसे रेंडर करता है, तो आइए उन अंतिम कुछ चीज़ों को देखें जो आपको अपने एक्सटेंशन को पूरा करने के लिए करने की आवश्यकता है:\nरंग की गणना करने के लिए एक फ़ंक्शन बनाएं\n/src/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1903,
    "chunk_index": 4,
    "total_chunks": 18
  },
  {
    "id": "87cd6eb8d415fd5035e094f0b73d9e62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "साइट परफॉर्मेंस निर्धारित करने के लिए किए गए सामान्य चेक्स के बारे में अधिक जानने के लिए साइट स्पीड टेस्ट वेबसाइट पर कुछ साइट्स आज़माएं। अब जब आपको यह समझ आ गया है कि ब्राउज़र आपके द्वारा भेजे गए एसेट्स को कैसे रेंडर करता है, तो आइए उन अंतिम कुछ चीज़ों को देखें जो आपको अपने एक्सटेंशन को पूरा करने के लिए करने की आवश्यकता है: रंग की गणना करने के लिए एक फ़ंक्शन बनाएं /src/indexjs में काम करते हुए, calculateColor() नामक एक फ़ंक्शन जोड़ें, जिसे आपने DOM तक पहुंच प्राप्त करने के लिए सेट किए गए const वेरिएबल्स की श्रृंखला के बाद लिखा है:\n```JavaScript\nfunction calculateColor(value) {\nlet co2Scale = [0, 150, 600, 750, 800];\nlet colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02'];\nlet closestNum = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 572,
    "chunk_index": 5,
    "total_chunks": 18
  },
  {
    "id": "bc3c64ff76db6b40a1d21d424db6a202",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "जो आपको अपने एक्सटेंशन को पूरा करने के लिए करने की आवश्यकता है: रंग की गणना करने के लिए एक फ़ंक्शन बनाएं /src/indexjs में काम करते हुए, calculateColor() नामक एक फ़ंक्शन जोड़ें, जिसे आपने DOM तक पहुंच प्राप्त करने के लिए सेट किए गए const वेरिएबल्स की श्रृंखला के बाद लिखा है: ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => {\nreturn Math abs(a - value) - Math abs(b - value);\n})[0];\nconsole log(value + ' is closest to ' + closestNum);\nlet num = (element) => element > closestNum;\nlet scaleIndex = co2Scale findIndex(num);\nlet closestColor = colors[scaleIndex];\nconsole log(scaleIndex, closestColor);\nchrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } });\n}\n```\nयहां क्या हो रहा है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 424,
    "chunk_index": 6,
    "total_chunks": 18
  },
  {
    "id": "7330bcbd08a38e4855e69984cb7e87f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Math abs(a - value) - Math abs(b - value); })[0]; console log(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2Scale findIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` यहां क्या हो रहा हैआप एक मान (कार्बन इंटेंसिटी) पास करते हैं, जो आपने पिछले पाठ में पूरी की गई API कॉल से प्राप्त किया था, और फिर आप इसकी वैल्यू को रंगों की सूची में प्रस्तुत इंडेक्स के करीब गणना करते हैं। फिर आप उस निकटतम रंग मान को क्रोम रनटाइम पर भेजते हैं।\nchrome runtime में एक API है जो सभी प्रकार के बैकग्राउंड टास्क को संभालता है, और आपका एक्सटेंशन इसका लाभ उठा रहा है:\n\"chrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 7,
    "total_chunks": 18
  },
  {
    "id": "80cad319e82ec99d6e1021a14a1a5f3c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "रहा हैआप एक मान (कार्बन इंटेंसिटी) पास करते हैं, जो आपने पिछले पाठ में पूरी की गई API कॉल से प्राप्त किया था, और फिर आप इसकी वैल्यू को रंगों की सूची में प्रस्तुत इंडेक्स के करीब गणना करते हैं। फिर आप उस निकटतम रंग मान को क्रोम रनटाइम पर भेजते हैं। chrome runtime में एक API है जो सभी प्रकार के बैकग्राउंड टास्क को संभालता है, और आपका एक्सटेंशन इसका लाभ उठा रहा है: \"chromeruntime API का उपयोग बैकग्राउंड पेज को पुनः प्राप्त करने, मैनिफेस्ट के बारे में विवरण लौटाने, और ऐप या एक्सटेंशन लाइफसाइकल में घटनाओं के लिए सुनने और प्रतिक्रिया देने के लिए करें। आप इस API का उपयोग URL के सापेक्ष पथ को पूर्ण-योग्य URL में बदलने के लिए भी कर सकते हैं।\"\n✅ यदि आप इस ब्राउज़र एक्सटेंशन को Edge के लिए विकसित कर रहे हैं, तो यह आपको आश्चर्यचकित कर सकता है कि आप एक क्रोम API का उपयोग कर रहे हैं। नए Edge ब्राउज़र संस्करण क्रोमियम ब्राउज़र इंजन पर चलते हैं, इसलिए आप इन टूल्स का लाभ उठा सकते हैं।\nध्यान दें, यदि आप किसी ब्राउज़र एक्सटेंशन को प्रोफाइल करना चाहते हैं, तो इसे एक्सटेंशन के भीतर से लॉन्च करें, क्योंकि यह अपना अलग ब्राउज़र इंस्टेंस है।\nडिफ़ॉल्ट आइकन रंग सेट करें\nअब, init() फ़ंक्शन में, आइकन को शुरू में सामान्य हरे रंग में सेट करें, फिर से क्रोम के updateIcon एक्शन को कॉल करके:\nJavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1095,
    "chunk_index": 8,
    "total_chunks": 18
  },
  {
    "id": "451b6d265ef3de2d8f40b2d5b49167f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "नए Edge ब्राउज़र संस्करण क्रोमियम ब्राउज़र इंजन पर चलते हैं, इसलिए आप इन टूल्स का लाभ उठा सकते हैं। ध्यान दें, यदि आप किसी ब्राउज़र एक्सटेंशन को प्रोफाइल करना चाहते हैं, तो इसे एक्सटेंशन के भीतर से लॉन्च करें, क्योंकि यह अपना अलग ब्राउज़र इंस्टेंस है। डिफ़ॉल्ट आइकन रंग सेट करें अब, init() फ़ंक्शन में, आइकन को शुरू में सामान्य हरे रंग में सेट करें, फिर से क्रोम के updateIcon एक्शन को कॉल करके: JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 378,
    "chunk_index": 9,
    "total_chunks": 18
  },
  {
    "id": "7414824dfe806195b2383cd7b91666a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "नए Edge ब्राउज़र संस्करण क्रोमियम ब्राउज़र इंजन पर चलते हैं, इसलिए आप इन टूल्स का लाभ उठा सकते हैं। ध्यान दें, यदि आप किसी ब्राउज़र एक्सटेंशन को प्रोफाइल करना चाहते हैं, तो इसे एक्सटेंशन के भीतर से लॉन्च करें, क्योंकि यह अपना अलग ब्राउज़र इंस्टेंस है। डिफ़ॉल्ट आइकन रंग सेट करें अब, init() फ़ंक्शन में, आइकन को शुरू में सामान्य हरे रंग में सेट करें, फिर से क्रोम के updateIcon एक्शन को कॉल करके: JavaScript chromeruntimesendMessage({\naction: 'updateIcon',\nvalue: {\ncolor: 'green',\n},\n});\nफ़ंक्शन को कॉल करें, कॉल को निष्पादित करें\nअगले चरण में, आपने जो फ़ंक्शन बनाया है उसे C02Signal API द्वारा लौटाए गए प्रॉमिस में जोड़कर कॉल करें:\nJavaScript\n//let CO2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 541,
    "chunk_index": 10,
    "total_chunks": 18
  },
  {
    "id": "372bea11d2a6517422e98b8dd9d2323b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "करें, क्योंकि यह अपना अलग ब्राउज़र इंस्टेंस है। डिफ़ॉल्ट आइकन रंग सेट करें अब, init() फ़ंक्शन में, आइकन को शुरू में सामान्य हरे रंग में सेट करें, फिर से क्रोम के updateIcon एक्शन को कॉल करके: JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); फ़ंक्शन को कॉल करें, कॉल को निष्पादित करें अगले चरण में, आपने जो फ़ंक्शन बनाया है उसे C02Signal API द्वारा लौटाए गए प्रॉमिस में जोड़कर कॉल करें: JavaScript //let CO2calculateColor(CO2);\nऔर अंत में, /dist/background js में, इन बैकग्राउंड एक्शन कॉल्स के लिए लिसनर जोड़ें:\n```JavaScript\nchrome runtime onMessage addListener(function (msg, sender, sendResponse) {\nif (msg action === 'updateIcon') {\nchrome browserAction setIcon({ imageData: drawIcon(msg value) });\n}\n});\n//borrowed from energy lollipop extension, nice feature function drawIcon(value) {\nlet canvas = document createElement('canvas');\nlet context = canvas getContext('2d');\ncontext beginPath();\ncontext fillStyle = value",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 11,
    "total_chunks": 18
  },
  {
    "id": "939103da6e5b8530f3f692c9e6544077",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "API द्वारा लौटाए गए प्रॉमिस में जोड़कर कॉल करें: JavaScript //let CO2calculateColor(CO2); और अंत में, /dist/background js में, इन बैकग्राउंड एक्शन कॉल्स के लिए लिसनर जोड़ें: ```JavaScript chrome runtime onMessage addListener(function (msg, sender, sendResponse) { if (msg action === 'updateIcon') { chrome browserAction setIcon({ imageData: drawIcon(msg value) }); } }); //borrowed from energy lollipop extension, nice feature function drawIcon(value) { let canvas = document createElement('canvas'); let context = canvas getContext('2d'); context beginPath(); context fillStyle = valuecolor;\ncontext arc(100, 100, 50, 0, 2 * Math PI);\ncontext fill();\nreturn context",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 242,
    "chunk_index": 12,
    "total_chunks": 18
  },
  {
    "id": "ef7cc75a2f9eb1eb4ffeb28ab04ad977",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "अंत में, /dist/background js में, इन बैकग्राउंड एक्शन कॉल्स के लिए लिसनर जोड़ें: ```JavaScript chrome runtime onMessage addListener(function (msg, sender, sendResponse) { if (msg action === 'updateIcon') { chrome browserAction setIcon({ imageData: drawIcon(msg value) }); } }); //borrowed from energy lollipop extension, nice feature function drawIcon(value) { let canvas = document createElement('canvas'); let context = canvas getContext('2d'); context beginPath(); context fillStyle = valuecolor; context arc(100, 100, 50, 0, 2 * Math PI); context fill(); return contextgetImageData(50, 50, 100, 100);\n}\n```\nइस कोड में, आप बैकएंड टास्क मैनेजर पर आने वाले किसी भी संदेश के लिए एक लिसनर जोड़ रहे हैं। यदि इसे 'updateIcon' कहा जाता है, तो अगला कोड सही रंग का आइकन बनाने के लिए Canvas API का उपयोग करता है।\n✅ आप स्पेस गेम पाठों में Canvas API के बारे में और जानेंगे।\nअब, अपने एक्सटेंशन को फिर से बनाएं (npm run build), रिफ्रेश करें और अपना एक्सटेंशन लॉन्च करें, और रंग बदलते हुए देखें। क्या यह कोई काम करने या बर्तन धोने का अच्छा समय है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 586,
    "chunk_index": 13,
    "total_chunks": 18
  },
  {
    "id": "7a93e68bc9271187dd8687d588bb6c4d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "के लिए एक लिसनर जोड़ रहे हैं। यदि इसे 'updateIcon' कहा जाता है, तो अगला कोड सही रंग का आइकन बनाने के लिए Canvas API का उपयोग करता है। ✅ आप स्पेस गेम पाठों में Canvas API के बारे में और जानेंगे। अब, अपने एक्सटेंशन को फिर से बनाएं (npm run build), रिफ्रेश करें और अपना एक्सटेंशन लॉन्च करें, और रंग बदलते हुए देखें। क्या यह कोई काम करने या बर्तन धोने का अच्छा समय हैअब आप जानते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 343,
    "chunk_index": 14,
    "total_chunks": 18
  },
  {
    "id": "e7319957bb9d85d93cdbbe5b6028f0c2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "लिसनर जोड़ रहे हैं। यदि इसे 'updateIcon' कहा जाता है, तो अगला कोड सही रंग का आइकन बनाने के लिए Canvas API का उपयोग करता है। ✅ आप स्पेस गेम पाठों में Canvas API के बारे में और जानेंगे। अब, अपने एक्सटेंशन को फिर से बनाएं (npm run build), रिफ्रेश करें और अपना एक्सटेंशन लॉन्च करें, और रंग बदलते हुए देखें। क्या यह कोई काम करने या बर्तन धोने का अच्छा समय हैअब आप जानते हैंबधाई हो, आपने एक उपयोगी ब्राउज़र एक्सटेंशन बनाया है और यह भी सीखा है कि ब्राउज़र कैसे काम करता है और इसकी परफॉर्मेंस को कैसे प्रोफाइल किया जाता है।\n🚀 चुनौती\nकुछ ओपन सोर्स वेबसाइटों की जांच करें जो लंबे समय से मौजूद हैं, और उनके GitHub इतिहास के आधार पर देखें कि क्या उन्हें प्रदर्शन के लिए अनुकूलित किया गया था। सबसे आम समस्या क्षेत्र क्या है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 671,
    "chunk_index": 15,
    "total_chunks": 18
  },
  {
    "id": "dde95e2607ed88b6aad5a65e96ff20e7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "बर्तन धोने का अच्छा समय हैअब आप जानते हैंबधाई हो, आपने एक उपयोगी ब्राउज़र एक्सटेंशन बनाया है और यह भी सीखा है कि ब्राउज़र कैसे काम करता है और इसकी परफॉर्मेंस को कैसे प्रोफाइल किया जाता है। 🚀 चुनौती कुछ ओपन सोर्स वेबसाइटों की जांच करें जो लंबे समय से मौजूद हैं, और उनके GitHub इतिहास के आधार पर देखें कि क्या उन्हें प्रदर्शन के लिए अनुकूलित किया गया था। सबसे आम समस्या क्षेत्र क्या हैपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nपरफॉर्मेंस न्यूज़लेटर के लिए साइन अप करने पर विचार करें।\nब्राउज़र वेब परफॉर्मेंस को मापने के लिए किन तरीकों का उपयोग करते हैं, यह जानने के लिए उनके वेब टूल्स के परफॉर्मेंस टैब्स की जांच करें। क्या आपको कोई बड़ा अंतर दिखाई देता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 676,
    "chunk_index": 16,
    "total_chunks": 18
  },
  {
    "id": "87a0a58e381498b3fa4b7a2c6d755f0e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ब्राउज़र एक्सटेंशन प्रोजेक्ट भाग 3: बैकग्राउंड टास्क और परफॉर्मेंस के बारे में जानें",
    "content": "मौजूद हैं, और उनके GitHub इतिहास के आधार पर देखें कि क्या उन्हें प्रदर्शन के लिए अनुकूलित किया गया था। सबसे आम समस्या क्षेत्र क्या हैपोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन परफॉर्मेंस न्यूज़लेटर के लिए साइन अप करने पर विचार करें। ब्राउज़र वेब परफॉर्मेंस को मापने के लिए किन तरीकों का उपयोग करते हैं, यह जानने के लिए उनके वेब टूल्स के परफॉर्मेंस टैब्स की जांच करें। क्या आपको कोई बड़ा अंतर दिखाई देता हैअसाइनमेंट\nसाइट का प्रदर्शन विश्लेषण करें\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21041,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 873,
    "chunk_index": 17,
    "total_chunks": 18
  },
  {
    "id": "ea9b316e4f249e09fda782ce591b4164",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.ms.md",
    "source_type": "git_repo",
    "title": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: पूरा कोड",
    "content": "कार्बन ट्रिगर ब्राउज़र एक्सटेंशन: पूरा कोड\nC02 सिग्नल tmrow API का उपयोग करके बिजली की खपत का पता लगाएं और एक ब्राउज़र एक्सटेंशन बनाएं, ताकि आप अपने क्षेत्र की बिजली खपत की स्थिति के बारे में ब्राउज़र में अलर्ट प्राप्त कर सकें। इस एक्सटेंशन का उपयोग विशेष रूप से आपको अपनी गतिविधियों के बारे में सूचित निर्णय लेने में मदद करेगा।\nयहां से शुरू करें\nआपको npm इंस्टॉल करना होगा। इस कोड की एक कॉपी अपने कंप्यूटर पर किसी फोल्डर में डाउनलोड करें।\nसभी आवश्यक पैकेज इंस्टॉल करें:\nnpm install\nWebpack से एक्सटेंशन बनाएं:\nnpm run build\nEdge में इंस्टॉल करने के लिए, ब्राउज़र के ऊपर दाईं ओर 'तीन डॉट्स' वाले मेनू का उपयोग करें और एक्सटेंशन पैनल खोजें। वहां से, 'Load Unpacked' चुनें और नया एक्सटेंशन लोड करें। अनुरोध पर 'dist' फोल्डर खोलें और एक्सटेंशन लोड हो जाएगा। इसे उपयोग करने के लिए, आपको CO2 सिग्नल API के लिए एक API कुंजी की आवश्यकता होगी (इसे यहां ईमेल के माध्यम से प्राप्त करें - इस पेज पर दिए गए बॉक्स में अपना ईमेल डालें) और अपने क्षेत्र का कोड जो इलेक्ट्रिसिटी मैप से मेल खाता हो (उदाहरण के लिए, बोस्टन में, मैंने 'US-NEISO' का उपयोग किया)।\nएक बार जब आप API कुंजी और क्षेत्र को एक्सटेंशन इंटरफेस में दर्ज कर लेते हैं, तो ब्राउज़र एक्सटेंशन बार में रंगीन डॉट आपके क्षेत्र की ऊर्जा खपत को दर्शाने के लिए बदल जाएगा और आपको यह सुझाव देगा कि कौन सी भारी गतिविधियां आपके लिए उपयुक्त हैं। इस 'डॉट' सिस्टम का विचार मुझे एनर्जी लॉलीपॉप ब्राउज़र एक्सटेंशन से मिला, जो कैलिफोर्निया के लिए बनाया गया है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 5330,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\5-browser-extension\\solution\\translation\\README.ms.md",
      "source_type": "git_repo"
    },
    "token_count": 1737,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e48c5602284b38e8fd1cce272aa0ec8b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "यह एक प्लेसहोल्डर है, जिसे जानबूझकर खाली छोड़ा गया है।\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1575,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "54ce3f5cad3bf726408e500cde6ff09b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\assignment.md",
    "source_type": "git_repo",
    "title": "एक नया कीबोर्ड गेम बनाएं",
    "content": "एक नया कीबोर्ड गेम बनाएं\nनिर्देश\nएक छोटा गेम बनाएं जो कीबोर्ड इवेंट्स का उपयोग करके कार्य करता हो। यह एक अलग प्रकार का टाइपिंग गेम हो सकता है, या एक कला प्रकार का गेम हो सकता है जो कीस्ट्रोक्स पर स्क्रीन पर पिक्सल्स को पेंट करता है। रचनात्मक बनें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2682,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 234,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "2ae67787108e7aa5b17e5918e1067b4d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\assignment.md",
    "source_type": "git_repo",
    "title": "एक नया कीबोर्ड गेम बनाएं",
    "content": "एक नया कीबोर्ड गेम बनाएं\nनिर्देश\nएक छोटा गेम बनाएं जो कीबोर्ड इवेंट्स का उपयोग करके कार्य करता हो। यह एक अलग प्रकार का टाइपिंग गेम हो सकता है, या एक कला प्रकार का गेम हो सकता है जो कीस्ट्रोक्स पर स्क्रीन पर पिक्सल्स को पेंट करता है। रचनात्मक बनेंमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                 | पर्याप्त                 | सुधार की आवश्यकता |\n| ------- | ------------------------ | ------------------------ | ----------------- |\n|         | एक पूरा गेम प्रस्तुत किया गया है | गेम बहुत ही साधारण है | गेम में बग्स हैं |\n|         |                          |                          |                   |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2682,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 828,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "94bf16a3f18865bfd9c00b62e0002658",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\assignment.md",
    "source_type": "git_repo",
    "title": "अपने HTML का अभ्यास करें: एक ब्लॉग मॉकअप बनाएं",
    "content": "अपने HTML का अभ्यास करें: एक ब्लॉग मॉकअप बनाएं\nनिर्देश\nकल्पना करें कि आप अपनी व्यक्तिगत वेबसाइट डिज़ाइन कर रहे हैं या उसे फिर से डिज़ाइन कर रहे हैं। अपनी साइट का एक ग्राफिकल मॉकअप बनाएं, और फिर उन विभिन्न तत्वों को बनाने के लिए उपयोग किए जाने वाले HTML मार्कअप को लिखें। आप इसे कागज पर बना सकते हैं और स्कैन कर सकते हैं, या अपनी पसंद के सॉफ़्टवेयर का उपयोग कर सकते हैं, बस यह सुनिश्चित करें कि HTML मार्कअप को हाथ से कोड करें।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्टता                                                                           | पर्याप्त                                                                         | सुधार की आवश्यकता                                                                 |\n| -------- | ----------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |\n|          | एक ब्लॉग लेआउट को दृश्य रूप में प्रदर्शित किया गया है जिसमें कम से कम 10 मार्कअप तत्व दिखाए गए हैं | एक ब्लॉग लेआउट को दृश्य रूप में प्रदर्शित किया गया है जिसमें लगभग 5 मार्कअप तत्व दिखाए गए हैं | एक ब्लॉग लेआउट को दृश्य रूप में प्रदर्शित किया गया है जिसमें अधिकतम 3 मार्कअप तत्व दिखाए गए हैं |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3916,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1220,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "4310568d188e5289c9eacd1ab536beda",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\2-intro-to-css\\assignment.md",
    "source_type": "git_repo",
    "title": "सीएसएस रिफैक्टरिंग",
    "content": "सीएसएस रिफैक्टरिंग\nनिर्देश\nटेरारियम को फिर से स्टाइल करें, इसके लिए Flexbox या CSS Grid का उपयोग करें, और यह दिखाने के लिए स्क्रीनशॉट लें कि आपने इसे कई ब्राउज़रों पर परीक्षण किया है। आपको मार्कअप बदलने की आवश्यकता हो सकती है, इसलिए अपने रिफैक्टर के लिए ऐप का एक नया संस्करण बनाएं जिसमें कला को सही जगह पर रखा गया हो। फिलहाल, तत्वों को ड्रैग करने योग्य बनाने की चिंता न करें; केवल HTML और CSS को रिफैक्टर करें।\nमूल्यांकन मानदंड\n| मानदंड | उत्कृष्ट                                                         | पर्याप्त                      | सुधार की आवश्यकता                    |\n| -------- | ----------------------------------------------------------------- | ----------------------------- | ------------------------------------ |\n|          | Flexbox या CSS Grid का उपयोग करके पूरी तरह से स्टाइल किया गया टेरारियम प्रस्तुत करें | कुछ तत्वों को फिर से स्टाइल करें | टेरारियम को बिल्कुल भी फिर से स्टाइल करने में विफल |\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3299,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\2-intro-to-css\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 1035,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "06914ae4d888994c6990cbe645b894f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "टेरारियम प्रोजेक्ट भाग 1: HTML का परिचय\nस्केच नोट टोमोमी इमुरा द्वारा\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nवीडियो देखें\nपरिचय\nHTML, या हाइपरटेक्स्ट मार्कअप लैंग्वेज, वेब का 'कंकाल' है। अगर CSS आपके HTML को 'सजाती' है और JavaScript इसे जीवन देती है, तो HTML आपके वेब एप्लिकेशन का शरीर है। HTML की सिंटैक्स भी इस विचार को दर्शाती है, क्योंकि इसमें \"head\", \"body\", और \"footer\" टैग शामिल हैं।\nइस पाठ में, हम HTML का उपयोग करके हमारे वर्चुअल टेरारियम के इंटरफेस का 'कंकाल' बनाएंगे। इसमें एक शीर्षक और तीन कॉलम होंगे: एक दायां और एक बायां कॉलम जहां खींचने योग्य पौधे होंगे, और एक केंद्र क्षेत्र जो असल में कांच जैसा टेरारियम होगा। इस पाठ के अंत तक, आप कॉलम में पौधों को देख पाएंगे, लेकिन इंटरफेस थोड़ा अजीब लगेगा; चिंता न करें, अगले भाग में आप CSS स्टाइल्स जोड़कर इसे बेहतर बनाएंगे।\nकार्य\nअपने कंप्यूटर पर 'terrarium' नाम का एक फ़ोल्डर बनाएं और उसके अंदर 'index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 800,
    "chunk_index": 0,
    "total_chunks": 16
  },
  {
    "id": "823eab31d0ae94b16a7ce2a40ecd3395",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "का 'कंकाल' बनाएंगे। इसमें एक शीर्षक और तीन कॉलम होंगे: एक दायां और एक बायां कॉलम जहां खींचने योग्य पौधे होंगे, और एक केंद्र क्षेत्र जो असल में कांच जैसा टेरारियम होगा। इस पाठ के अंत तक, आप कॉलम में पौधों को देख पाएंगे, लेकिन इंटरफेस थोड़ा अजीब लगेगा; चिंता न करें, अगले भाग में आप CSS स्टाइल्स जोड़कर इसे बेहतर बनाएंगे। कार्य अपने कंप्यूटर पर 'terrarium' नाम का एक फ़ोल्डर बनाएं और उसके अंदर 'indexhtml' नाम की एक फाइल बनाएं। आप यह Visual Studio Code में कर सकते हैं। अपने टेरारियम फ़ोल्डर को खोलने के बाद, एक नया VS Code विंडो खोलें, 'open folder' पर क्लिक करें, और अपने नए फ़ोल्डर पर जाएं। Explorer पैन में छोटे 'file' बटन पर क्लिक करें और नई फाइल बनाएं:\nया\nGit Bash में इन कमांड्स का उपयोग करें:\n* mkdir terrarium\n* cd terrarium\n* touch index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 1,
    "total_chunks": 16
  },
  {
    "id": "3e5ede229d11de0c2fcb6489245b9ed4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "एक फ़ोल्डर बनाएं और उसके अंदर 'indexhtml' नाम की एक फाइल बनाएं। आप यह Visual Studio Code में कर सकते हैं। अपने टेरारियम फ़ोल्डर को खोलने के बाद, एक नया VS Code विंडो खोलें, 'open folder' पर क्लिक करें, और अपने नए फ़ोल्डर पर जाएं। Explorer पैन में छोटे 'file' बटन पर क्लिक करें और नई फाइल बनाएं: या Git Bash में इन कमांड्स का उपयोग करें: * mkdir terrarium * cd terrarium * touch indexhtml\n* code index html या nano index html\nindex html फाइलें ब्राउज़र को यह संकेत देती हैं कि यह फ़ोल्डर की डिफ़ॉल्ट फाइल है; जैसे URLs https://anysite com/test एक फ़ोल्डर संरचना का उपयोग कर सकते हैं जिसमें test नाम का फ़ोल्डर और उसके अंदर index html हो; URL में index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 2,
    "total_chunks": 16
  },
  {
    "id": "e1ab67109ef6a8374d7fe648315ac6aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "बटन पर क्लिक करें और नई फाइल बनाएं: या Git Bash में इन कमांड्स का उपयोग करें: * mkdir terrarium * cd terrarium * touch indexhtml * code index html या nano index html index html फाइलें ब्राउज़र को यह संकेत देती हैं कि यह फ़ोल्डर की डिफ़ॉल्ट फाइल है; जैसे URLs https://anysite com/test एक फ़ोल्डर संरचना का उपयोग कर सकते हैं जिसमें test नाम का फ़ोल्डर और उसके अंदर index html हो; URL में indexhtml दिखाना आवश्यक नहीं है।\nDocType और html टैग्स\nHTML फाइल की पहली लाइन उसका DocType होती है। यह थोड़ा अजीब लग सकता है कि यह लाइन फाइल के सबसे ऊपर होनी चाहिए, लेकिन यह पुराने ब्राउज़रों को बताती है कि पेज को वर्तमान HTML स्पेसिफिकेशन के अनुसार स्टैंडर्ड मोड में रेंडर करना है।\nटिप: VS Code में, आप किसी टैग पर होवर कर सकते हैं और उसके उपयोग के बारे में जानकारी MDN Reference गाइड्स से प्राप्त कर सकते हैं।\nदूसरी लाइन <html> टैग की ओपनिंग टैग होनी चाहिए, और उसके तुरंत बाद उसकी क्लोजिंग टैग </html> होनी चाहिए। ये टैग्स आपके इंटरफेस के रूट एलिमेंट्स हैं।\nकार्य\nअपने index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 790,
    "chunk_index": 3,
    "total_chunks": 16
  },
  {
    "id": "6f08eb63aeefbaa6f299c61fb1a5e887",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "पुराने ब्राउज़रों को बताती है कि पेज को वर्तमान HTML स्पेसिफिकेशन के अनुसार स्टैंडर्ड मोड में रेंडर करना है। टिप: VS Code में, आप किसी टैग पर होवर कर सकते हैं और उसके उपयोग के बारे में जानकारी MDN Reference गाइड्स से प्राप्त कर सकते हैं। दूसरी लाइन <html> टैग की ओपनिंग टैग होनी चाहिए, और उसके तुरंत बाद उसकी क्लोजिंग टैग </html> होनी चाहिए। ये टैग्स आपके इंटरफेस के रूट एलिमेंट्स हैं। कार्य अपने indexhtml फाइल के शीर्ष पर ये लाइनें जोड़ें:\n```HTML\n```\n✅ DocType को एक क्वेरी स्ट्रिंग के साथ सेट करके कुछ अलग मोड्स निर्धारित किए जा सकते हैं: Quirks Mode और Standards Mode। ये मोड्स पुराने ब्राउज़रों (जैसे Netscape Navigator 4 और Internet Explorer 5) को सपोर्ट करने के लिए उपयोग किए जाते थे, जो अब आमतौर पर उपयोग नहीं होते। आप स्टैंडर्ड DocType डिक्लेरेशन का उपयोग कर सकते हैं।\nडॉक्यूमेंट का 'head'\nHTML डॉक्यूमेंट का 'head' क्षेत्र आपके वेब पेज की महत्वपूर्ण जानकारी, जिसे मेटाडेटा भी कहा जाता है, शामिल करता है। हमारे मामले में, हम वेब सर्वर को, जिसे यह पेज रेंडर करने के लिए भेजा जाएगा, ये चार चीजें बताएंगे:\nपेज का शीर्षक\nपेज मेटाडेटा जिसमें शामिल हैं:\n'कैरेक्टर सेट', जो बताता है कि पेज में कौन सा कैरेक्टर एन्कोडिंग उपयोग किया गया है\nब्राउज़र जानकारी, जिसमें x-ua-compatible शामिल है जो इंगित करता है कि IE=edge ब्राउज़र समर्थित है\nजानकारी कि व्यूपोर्ट को लोड होने पर कैसे व्यवहार करना चाहिए। व्यूपोर्ट को 1 की प्रारंभिक स्केल पर सेट करना पेज के पहले लोड होने पर ज़ूम स्तर को नियंत्रित करता है।\nकार्य\nअपने डॉक्यूमेंट में <html> टैग्स के बीच एक 'head' ब्लॉक जोड़ें।\nhtml\n<head>\n<title>Welcome to my Virtual Terrarium</title>\n<meta charset=\"utf-8\" />\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n</head>\n✅ क्या होगा अगर आप व्यूपोर्ट मेटा टैग को इस तरह सेट करें: <meta name=\"viewport\" content=\"width=600\">",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1435,
    "chunk_index": 4,
    "total_chunks": 16
  },
  {
    "id": "8c7ea8ad24c3b1098112a538e98db613",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "लोड होने पर कैसे व्यवहार करना चाहिए। व्यूपोर्ट को 1 की प्रारंभिक स्केल पर सेट करना पेज के पहले लोड होने पर ज़ूम स्तर को नियंत्रित करता है। कार्य अपने डॉक्यूमेंट में <html> टैग्स के बीच एक 'head' ब्लॉक जोड़ें। html <head> <title>Welcome to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ क्या होगा अगर आप व्यूपोर्ट मेटा टैग को इस तरह सेट करें: <meta name=\"viewport\" content=\"width=600\">Viewport के बारे में और पढ़ें।\nडॉक्यूमेंट का body\nHTML टैग्स\nHTML में, आप अपने",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 390,
    "chunk_index": 5,
    "total_chunks": 16
  },
  {
    "id": "b80f90c8bd1895350cb8350761a8b099",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "सेट करना पेज के पहले लोड होने पर ज़ूम स्तर को नियंत्रित करता है। कार्य अपने डॉक्यूमेंट में <html> टैग्स के बीच एक 'head' ब्लॉक जोड़ें। html <head> <title>Welcome to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ क्या होगा अगर आप व्यूपोर्ट मेटा टैग को इस तरह सेट करें: <meta name=\"viewport\" content=\"width=600\">Viewport के बारे में और पढ़ें। डॉक्यूमेंट का body HTML टैग्स HTML में, आप अपनेhtml फाइल में टैग्स जोड़कर वेब पेज के एलिमेंट्स बनाते हैं। प्रत्येक टैग में आमतौर पर एक ओपनिंग और क्लोजिंग टैग होती है, जैसे: <p>hello</p> पैराग्राफ को इंगित करने के लिए। अपने इंटरफेस का बॉडी बनाने के लिए <html> टैग्स के अंदर <body> टैग्स का एक सेट जोड़ें; अब आपका मार्कअप इस तरह दिखेगा:\nकार्य\n```html\nWelcome to my Virtual Terrarium\n```\nअब, आप अपने पेज को बनाना शुरू कर सकते हैं। आमतौर पर, आप पेज में अलग-अलग एलिमेंट्स बनाने के लिए <div> टैग्स का उपयोग करते हैं। हम <div> एलिमेंट्स की एक श्रृंखला बनाएंगे जो इमेजेस को समाहित करेंगे।\nइमेजेस\nएक HTML टैग जिसे क्लोजिंग टैग की आवश्यकता नहीं होती, वह <img> टैग है, क्योंकि इसमें एक src एलिमेंट होता है जो पेज को आइटम को रेंडर करने के लिए आवश्यक सभी जानकारी प्रदान करता है।\nअपने ऐप में images नाम का एक फ़ोल्डर बनाएं और उसमें स्रोत कोड फ़ोल्डर की सभी इमेजेस जोड़ें; (पौधों की 14 इमेजेस हैं)।\nकार्य\nइन पौधों की इमेजेस को <body></body> टैग्स के बीच दो कॉलम में जोड़ें:\n```html\n```\nनोट: स्पैन बनाम डिव। डिव्स को 'ब्लॉक' एलिमेंट्स माना जाता है, और स्पैन्स 'इनलाइन'। क्या होगा अगर आप इन डिव्स को स्पैन्स में बदल दें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1311,
    "chunk_index": 6,
    "total_chunks": 16
  },
  {
    "id": "d2ecec8d7b624878c5cf4ba9a28bd174",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "आइटम को रेंडर करने के लिए आवश्यक सभी जानकारी प्रदान करता है। अपने ऐप में images नाम का एक फ़ोल्डर बनाएं और उसमें स्रोत कोड फ़ोल्डर की सभी इमेजेस जोड़ें; (पौधों की 14 इमेजेस हैं)। कार्य इन पौधों की इमेजेस को <body></body> टैग्स के बीच दो कॉलम में जोड़ें: ```html ``` नोट: स्पैन बनाम डिव। डिव्स को 'ब्लॉक' एलिमेंट्स माना जाता है, और स्पैन्स 'इनलाइन'। क्या होगा अगर आप इन डिव्स को स्पैन्स में बदल देंइस मार्कअप के साथ, पौधे अब स्क्रीन पर दिखाई देंगे। यह थोड़ा खराब दिखता है, क्योंकि अभी तक इसे CSS का उपयोग करके स्टाइल नहीं किया गया है, और हम इसे अगले पाठ में करेंगे।\nप्रत्येक इमेज में alt टेक्स्ट होता है जो तब दिखाई देगा जब आप इमेज को देख या रेंडर नहीं कर सकते। यह एक महत्वपूर्ण एट्रिब्यूट है जिसे एक्सेसिबिलिटी के लिए शामिल करना चाहिए। भविष्य के पाठों में एक्सेसिबिलिटी के बारे में और जानें; फिलहाल, याद रखें कि alt एट्रिब्यूट इमेज के लिए वैकल्पिक जानकारी प्रदान करता है अगर किसी कारणवश उपयोगकर्ता इसे नहीं देख सकता (धीमा कनेक्शन, src एट्रिब्यूट में त्रुटि, या अगर उपयोगकर्ता स्क्रीन रीडर का उपयोग करता है)।\n✅ क्या आपने देखा कि प्रत्येक इमेज का alt टैग समान है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1023,
    "chunk_index": 7,
    "total_chunks": 16
  },
  {
    "id": "9b2e90611f29bed9489c67b0f4e14fbe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "या रेंडर नहीं कर सकते। यह एक महत्वपूर्ण एट्रिब्यूट है जिसे एक्सेसिबिलिटी के लिए शामिल करना चाहिए। भविष्य के पाठों में एक्सेसिबिलिटी के बारे में और जानें; फिलहाल, याद रखें कि alt एट्रिब्यूट इमेज के लिए वैकल्पिक जानकारी प्रदान करता है अगर किसी कारणवश उपयोगकर्ता इसे नहीं देख सकता (धीमा कनेक्शन, src एट्रिब्यूट में त्रुटि, या अगर उपयोगकर्ता स्क्रीन रीडर का उपयोग करता है)। ✅ क्या आपने देखा कि प्रत्येक इमेज का alt टैग समान हैक्या यह अच्छी प्रैक्टिस है क्यों या क्यों नहीं क्या आप इस कोड को बेहतर बना सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 8,
    "total_chunks": 16
  },
  {
    "id": "0c2663fdfede7037c9f45a36272a2708",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "भविष्य के पाठों में एक्सेसिबिलिटी के बारे में और जानें; फिलहाल, याद रखें कि alt एट्रिब्यूट इमेज के लिए वैकल्पिक जानकारी प्रदान करता है अगर किसी कारणवश उपयोगकर्ता इसे नहीं देख सकता (धीमा कनेक्शन, src एट्रिब्यूट में त्रुटि, या अगर उपयोगकर्ता स्क्रीन रीडर का उपयोग करता है)। ✅ क्या आपने देखा कि प्रत्येक इमेज का alt टैग समान हैक्या यह अच्छी प्रैक्टिस है क्यों या क्यों नहीं क्या आप इस कोड को बेहतर बना सकते हैंसेमांटिक मार्कअप\nसामान्यतः, HTML लिखते समय अर्थपूर्ण 'सेमांटिक्स' का उपयोग करना बेहतर होता है। इसका क्या मतलब है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 502,
    "chunk_index": 9,
    "total_chunks": 16
  },
  {
    "id": "2ad66fecdbc53018261edc0b4dc9fc80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "के लिए वैकल्पिक जानकारी प्रदान करता है अगर किसी कारणवश उपयोगकर्ता इसे नहीं देख सकता (धीमा कनेक्शन, src एट्रिब्यूट में त्रुटि, या अगर उपयोगकर्ता स्क्रीन रीडर का उपयोग करता है)। ✅ क्या आपने देखा कि प्रत्येक इमेज का alt टैग समान हैक्या यह अच्छी प्रैक्टिस है क्यों या क्यों नहीं क्या आप इस कोड को बेहतर बना सकते हैंसेमांटिक मार्कअप सामान्यतः, HTML लिखते समय अर्थपूर्ण 'सेमांटिक्स' का उपयोग करना बेहतर होता है। इसका क्या मतलब हैइसका मतलब है कि आप HTML टैग्स का उपयोग उस प्रकार के डेटा या इंटरैक्शन को दर्शाने के लिए करते हैं जिसके लिए उन्हें डिज़ाइन किया गया था। उदाहरण के लिए, पेज के मुख्य शीर्षक टेक्स्ट को <h1> टैग का उपयोग करना चाहिए।\nअपने ओपनिंग <body> टैग के ठीक नीचे निम्न पंक्ति जोड़ें:\n```html\nMy Terrarium\n```\nसेमांटिक मार्कअप का उपयोग करना, जैसे कि हेडर्स को <h1> और अनऑर्डर्ड लिस्ट्स को <ul> के रूप में रेंडर करना, स्क्रीन रीडर्स को पेज के माध्यम से नेविगेट करने में मदद करता है। सामान्यतः, बटन को <button> के रूप में लिखा जाना चाहिए और लिस्ट्स को <li> के रूप में। हालांकि यह संभव है कि विशेष रूप से स्टाइल किए गए <span> एलिमेंट्स के साथ क्लिक हैंडलर्स का उपयोग करके बटन की नकल की जाए, लेकिन विकलांग उपयोगकर्ताओं के लिए यह बेहतर है कि वे टेक्नोलॉजी का उपयोग करके पेज पर बटन का पता लगाएं और इसके साथ इंटरैक्ट करें, अगर एलिमेंट बटन के रूप में दिखाई देता है। इसी कारण, जितना संभव हो सेमांटिक मार्कअप का उपयोग करने का प्रयास करें।\n✅ एक स्क्रीन रीडर और यह कैसे वेब पेज के साथ इंटरैक्ट करता है देखें। क्या आप देख सकते हैं कि गैर-सेमांटिक मार्कअप उपयोगकर्ता को क्यों निराश कर सकता है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1420,
    "chunk_index": 10,
    "total_chunks": 16
  },
  {
    "id": "5c8a6e2d54df15a4559c5a6957182a53",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "विकलांग उपयोगकर्ताओं के लिए यह बेहतर है कि वे टेक्नोलॉजी का उपयोग करके पेज पर बटन का पता लगाएं और इसके साथ इंटरैक्ट करें, अगर एलिमेंट बटन के रूप में दिखाई देता है। इसी कारण, जितना संभव हो सेमांटिक मार्कअप का उपयोग करने का प्रयास करें। ✅ एक स्क्रीन रीडर और यह कैसे वेब पेज के साथ इंटरैक्ट करता है देखें। क्या आप देख सकते हैं कि गैर-सेमांटिक मार्कअप उपयोगकर्ता को क्यों निराश कर सकता हैटेरारियम\nइस इंटरफेस का अंतिम भाग मार्कअप बनाना है जिसे स्टाइल किया जाएगा ताकि यह टेरारियम जैसा दिखे।\nकार्य:\nअंतिम </div> टैग के ऊपर यह मार्कअप जोड़ें:\n```html\n```\n✅ आपने यह मार्कअप स्क्रीन पर जोड़ा, लेकिन कुछ भी रेंडर नहीं हुआ। क्यों",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 611,
    "chunk_index": 11,
    "total_chunks": 16
  },
  {
    "id": "990989789b53b9aaec52f2de1f762f66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "करने का प्रयास करें। ✅ एक स्क्रीन रीडर और यह कैसे वेब पेज के साथ इंटरैक्ट करता है देखें। क्या आप देख सकते हैं कि गैर-सेमांटिक मार्कअप उपयोगकर्ता को क्यों निराश कर सकता हैटेरारियम इस इंटरफेस का अंतिम भाग मार्कअप बनाना है जिसे स्टाइल किया जाएगा ताकि यह टेरारियम जैसा दिखे। कार्य: अंतिम </div> टैग के ऊपर यह मार्कअप जोड़ें: ```html ``` ✅ आपने यह मार्कअप स्क्रीन पर जोड़ा, लेकिन कुछ भी रेंडर नहीं हुआ। क्यों🚀चुनौती\nHTML में कुछ पुराने 'वाइल्ड' टैग्स हैं जो अभी भी मज़ेदार हैं, हालांकि आपको इन टैग्स जैसे डिप्रिकेटेड टैग्स का उपयोग अपने मार्कअप में नहीं करना चाहिए। फिर भी, क्या आप पुराने <marquee> टैग का उपयोग करके h1 शीर्षक को क्षैतिज रूप से स्क्रॉल कर सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 640,
    "chunk_index": 12,
    "total_chunks": 16
  },
  {
    "id": "2d302ba885f688b40cb5a8d0658fe282",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "यह टेरारियम जैसा दिखे। कार्य: अंतिम </div> टैग के ऊपर यह मार्कअप जोड़ें: ```html ``` ✅ आपने यह मार्कअप स्क्रीन पर जोड़ा, लेकिन कुछ भी रेंडर नहीं हुआ। क्यों🚀चुनौती HTML में कुछ पुराने 'वाइल्ड' टैग्स हैं जो अभी भी मज़ेदार हैं, हालांकि आपको इन टैग्स जैसे डिप्रिकेटेड टैग्स का उपयोग अपने मार्कअप में नहीं करना चाहिए। फिर भी, क्या आप पुराने <marquee> टैग का उपयोग करके h1 शीर्षक को क्षैतिज रूप से स्क्रॉल कर सकते हैं(अगर आप ऐसा करते हैं, तो इसे बाद में हटा देना न भूलें)\nपोस्ट-लेक्चर क्विज़\nपोस्ट-लेक्चर क्विज़\nसमीक्षा और स्व-अध्ययन\nHTML वह 'परीक्षित और प्रमाणित' बिल्डिंग ब्लॉक सिस्टम है जिसने वेब को आज के रूप में विकसित करने में मदद की है। इसके इतिहास के बारे में थोड़ा जानें और कुछ पुराने और नए टैग्स का अध्ययन करें। क्या आप यह पता लगा सकते हैं कि कुछ टैग्स को डिप्रिकेट क्यों किया गया और कुछ को जोड़ा गया",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 787,
    "chunk_index": 13,
    "total_chunks": 16
  },
  {
    "id": "9e075eb7da1c68ba18fd09c5a1d9c843",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "ऐसा करते हैं, तो इसे बाद में हटा देना न भूलें) पोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन HTML वह 'परीक्षित और प्रमाणित' बिल्डिंग ब्लॉक सिस्टम है जिसने वेब को आज के रूप में विकसित करने में मदद की है। इसके इतिहास के बारे में थोड़ा जानें और कुछ पुराने और नए टैग्स का अध्ययन करें। क्या आप यह पता लगा सकते हैं कि कुछ टैग्स को डिप्रिकेट क्यों किया गया और कुछ को जोड़ा गयाभविष्य में कौन से टैग्स पेश किए जा सकते हैं",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 418,
    "chunk_index": 14,
    "total_chunks": 16
  },
  {
    "id": "15f5d6e9b7c166041f39bac725e610b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "न भूलें) पोस्ट-लेक्चर क्विज़ पोस्ट-लेक्चर क्विज़ समीक्षा और स्व-अध्ययन HTML वह 'परीक्षित और प्रमाणित' बिल्डिंग ब्लॉक सिस्टम है जिसने वेब को आज के रूप में विकसित करने में मदद की है। इसके इतिहास के बारे में थोड़ा जानें और कुछ पुराने और नए टैग्स का अध्ययन करें। क्या आप यह पता लगा सकते हैं कि कुछ टैग्स को डिप्रिकेट क्यों किया गया और कुछ को जोड़ा गयाभविष्य में कौन से टैग्स पेश किए जा सकते हैंवेब और मोबाइल डिवाइस के लिए साइट्स बनाने के बारे में और जानें Microsoft Learn पर।\nअसाइनमेंट\nअपना HTML अभ्यास करें: एक ब्लॉग मॉकअप बनाएं\nअस्वीकरण:\nयह दस्तावेज़ AI अनुवाद सेवा Co-op Translator का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22840,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 918,
    "chunk_index": 15,
    "total_chunks": 16
  },
  {
    "id": "b7cc1950510372fd579d93d750f29609",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "इवेंट्स का उपयोग करके गेम बनाना\nप्री-लेक्चर क्विज़\nप्री-लेक्चर क्विज़\nइवेंट-ड्रिवन प्रोग्रामिंग\nजब हम एक ब्राउज़र आधारित एप्लिकेशन बनाते हैं, तो हम उपयोगकर्ता के लिए एक ग्राफिकल यूजर इंटरफेस (GUI) प्रदान करते हैं, जिससे वे हमारे द्वारा बनाए गए एप्लिकेशन के साथ इंटरैक्ट कर सकें। ब्राउज़र के साथ इंटरैक्ट करने का सबसे सामान्य तरीका विभिन्न तत्वों पर क्लिक करना और टाइप करना है। एक डेवलपर के रूप में हमारी चुनौती यह है कि हमें यह नहीं पता होता कि उपयोगकर्ता ये ऑपरेशन कब करेंगे",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 469,
    "chunk_index": 0,
    "total_chunks": 25
  },
  {
    "id": "7723459bc62d41eaeb809f9909db767c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "प्री-लेक्चर क्विज़ इवेंट-ड्रिवन प्रोग्रामिंग जब हम एक ब्राउज़र आधारित एप्लिकेशन बनाते हैं, तो हम उपयोगकर्ता के लिए एक ग्राफिकल यूजर इंटरफेस (GUI) प्रदान करते हैं, जिससे वे हमारे द्वारा बनाए गए एप्लिकेशन के साथ इंटरैक्ट कर सकें। ब्राउज़र के साथ इंटरैक्ट करने का सबसे सामान्य तरीका विभिन्न तत्वों पर क्लिक करना और टाइप करना है। एक डेवलपर के रूप में हमारी चुनौती यह है कि हमें यह नहीं पता होता कि उपयोगकर्ता ये ऑपरेशन कब करेंगेइवेंट-ड्रिवन प्रोग्रामिंग वह प्रकार की प्रोग्रामिंग है जो हमें अपने GUI को बनाने के लिए करनी होती है। यदि हम इस वाक्यांश को थोड़ा तोड़ें, तो हम देखेंगे कि इसका मुख्य शब्द इवेंट है। Merriam-Webster के अनुसार, इवेंट का अर्थ है \"कुछ जो होता है\"। यह हमारी स्थिति को पूरी तरह से वर्णित करता है। हमें पता है कि कुछ ऐसा होगा जिसके लिए हमें प्रतिक्रिया स्वरूप कोड निष्पादित करना है, लेकिन हमें यह नहीं पता कि यह कब होगा।\nजिस तरह से हम उस कोड के हिस्से को चिह्नित करते हैं जिसे हम निष्पादित करना चाहते हैं, वह है एक फ़ंक्शन बनाकर। जब हम प्रोसीजरल प्रोग्रामिंग के बारे में सोचते हैं, तो फ़ंक्शन्स को एक विशिष्ट क्रम में कॉल किया जाता है। इवेंट-ड्रिवन प्रोग्रामिंग के साथ भी यही बात सच होगी। फर्क सिर्फ इतना है कि कैसे फ़ंक्शन्स को कॉल किया जाएगा।\nइवेंट्स (जैसे बटन क्लिक करना, टाइप करना आदि) को संभालने के लिए, हम इवेंट लिसनर्स रजिस्टर करते हैं। एक इवेंट लिसनर एक फ़ंक्शन होता है जो किसी इवेंट के होने का इंतजार करता है और प्रतिक्रिया स्वरूप निष्पादित होता है। इवेंट लिसनर्स UI को अपडेट कर सकते हैं, सर्वर को कॉल कर सकते हैं, या उपयोगकर्ता की क्रिया के जवाब में जो भी करना हो, वह कर सकते हैं। हम addEventListener का उपयोग करके और एक फ़ंक्शन प्रदान करके एक इवेंट लिसनर जोड़ते हैं।\nNOTE: यह ध्यान देने योग्य है कि इवेंट लिसनर्स बनाने के कई तरीके हैं। आप गुमनाम फ़ंक्शन्स का उपयोग कर सकते हैं, या नामित फ़ंक्शन्स बना सकते हैं। आप click प्रॉपर्टी सेट करने जैसे शॉर्टकट्स का उपयोग कर सकते हैं, या addEventListener का उपयोग कर सकते हैं। हमारे अभ्यास में, हम addEventListener और गुमनाम फ़ंक्शन्स पर ध्यान केंद्रित करेंगे, क्योंकि यह शायद वेब डेवलपर्स द्वारा उपयोग की जाने वाली सबसे सामान्य तकनीक है। यह सबसे लचीला भी है, क्योंकि addEventListener सभी इवेंट्स के लिए काम करता है, और इवेंट का नाम एक पैरामीटर के रूप में प्रदान किया जा सकता है।\nसामान्य इवेंट्स\nऐप्लिकेशन बनाते समय आपके लिए कई दर्जन इवेंट्स उपलब्ध हैं। मूल रूप से, उपयोगकर्ता द्वारा पेज पर की गई लगभग हर क्रिया एक इवेंट को ट्रिगर करती है, जो आपको यह सुनिश्चित करने की शक्ति देती है कि उन्हें वह अनुभव मिले जो आप चाहते हैं। सौभाग्य से, आमतौर पर आपको केवल कुछ ही इवेंट्स की आवश्यकता होती है। यहां कुछ सामान्य इवेंट्स दिए गए हैं (उनमें से दो का उपयोग हम अपने गेम में करेंगे):\nclick: उपयोगकर्ता ने किसी चीज़ पर क्लिक किया, आमतौर पर एक बटन या हाइपरलिंक\ncontextmenu: उपयोगकर्ता ने राइट माउस बटन क्लिक किया\nselect: उपयोगकर्ता ने कुछ टेक्स्ट को हाइलाइट किया\ninput: उपयोगकर्ता ने कुछ टेक्स्ट इनपुट किया\nगेम बनाना\nहम इवेंट्स के साथ काम करने के तरीके को समझने के लिए एक गेम बनाएंगे। हमारा गेम एक खिलाड़ी की टाइपिंग स्किल का परीक्षण करेगा, जो कि सभी डेवलपर्स के लिए एक बहुत ही महत्वपूर्ण कौशल है। हमें अपनी टाइपिंग का अभ्यास करते रहना चाहिए",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2846,
    "chunk_index": 1,
    "total_chunks": 25
  },
  {
    "id": "992595f1563782627273c8d31e500d23",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "आमतौर पर एक बटन या हाइपरलिंक contextmenu: उपयोगकर्ता ने राइट माउस बटन क्लिक किया select: उपयोगकर्ता ने कुछ टेक्स्ट को हाइलाइट किया input: उपयोगकर्ता ने कुछ टेक्स्ट इनपुट किया गेम बनाना हम इवेंट्स के साथ काम करने के तरीके को समझने के लिए एक गेम बनाएंगे। हमारा गेम एक खिलाड़ी की टाइपिंग स्किल का परीक्षण करेगा, जो कि सभी डेवलपर्स के लिए एक बहुत ही महत्वपूर्ण कौशल है। हमें अपनी टाइपिंग का अभ्यास करते रहना चाहिएगेम का सामान्य प्रवाह इस प्रकार होगा:\nखिलाड़ी स्टार्ट बटन पर क्लिक करता है और उसे टाइप करने के लिए एक कोट दिया जाता है\nखिलाड़ी जितनी जल्दी हो सके टेक्स्टबॉक्स में कोट टाइप करता है\nजैसे ही प्रत्येक शब्द पूरा होता है, अगला शब्द हाइलाइट हो जाता है\nयदि खिलाड़ी कोई टाइपो करता है, तो टेक्स्टबॉक्स लाल हो जाता है\nजब खिलाड़ी कोट पूरा करता है, तो एक सफलता संदेश और समय दिखाया जाता है\nआइए अपना गेम बनाएं और इवेंट्स के बारे में जानें",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 806,
    "chunk_index": 2,
    "total_chunks": 25
  },
  {
    "id": "c8c84efe8d521e646c61f9d08612f013",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "पर क्लिक करता है और उसे टाइप करने के लिए एक कोट दिया जाता है खिलाड़ी जितनी जल्दी हो सके टेक्स्टबॉक्स में कोट टाइप करता है जैसे ही प्रत्येक शब्द पूरा होता है, अगला शब्द हाइलाइट हो जाता है यदि खिलाड़ी कोई टाइपो करता है, तो टेक्स्टबॉक्स लाल हो जाता है जब खिलाड़ी कोट पूरा करता है, तो एक सफलता संदेश और समय दिखाया जाता है आइए अपना गेम बनाएं और इवेंट्स के बारे में जानेंफाइल संरचना\nहमें कुल तीन फाइलों की आवश्यकता होगी: index html, script js और style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 423,
    "chunk_index": 3,
    "total_chunks": 25
  },
  {
    "id": "2711ccad5723d92c972f2f1705adf029",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "है खिलाड़ी जितनी जल्दी हो सके टेक्स्टबॉक्स में कोट टाइप करता है जैसे ही प्रत्येक शब्द पूरा होता है, अगला शब्द हाइलाइट हो जाता है यदि खिलाड़ी कोई टाइपो करता है, तो टेक्स्टबॉक्स लाल हो जाता है जब खिलाड़ी कोट पूरा करता है, तो एक सफलता संदेश और समय दिखाया जाता है आइए अपना गेम बनाएं और इवेंट्स के बारे में जानेंफाइल संरचना हमें कुल तीन फाइलों की आवश्यकता होगी: index html, script js और stylecss। चलिए इन्हें सेटअप करते हैं ताकि हमारा काम आसान हो जाए।\nएक नया फोल्डर बनाएं और उसमें काम शुरू करने के लिए कंसोल या टर्मिनल में निम्नलिखित कमांड चलाएं:\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Code खोलें\nbash\ncode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 557,
    "chunk_index": 4,
    "total_chunks": 25
  },
  {
    "id": "6f925d0a561f37a2c4380fa29f49bb5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "है आइए अपना गेम बनाएं और इवेंट्स के बारे में जानेंफाइल संरचना हमें कुल तीन फाइलों की आवश्यकता होगी: index html, script js और stylecss। चलिए इन्हें सेटअप करते हैं ताकि हमारा काम आसान हो जाए। एक नया फोल्डर बनाएं और उसमें काम शुरू करने के लिए कंसोल या टर्मिनल में निम्नलिखित कमांड चलाएं: ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` Visual Studio Code खोलें bash codeVisual Studio Code में फोल्डर में तीन फाइलें जोड़ें:\nindex html\nscript js\nstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 334,
    "chunk_index": 5,
    "total_chunks": 25
  },
  {
    "id": "8f1659cdcdfd25f4d9945213ac1beeca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "कुल तीन फाइलों की आवश्यकता होगी: index html, script js और stylecss। चलिए इन्हें सेटअप करते हैं ताकि हमारा काम आसान हो जाए। एक नया फोल्डर बनाएं और उसमें काम शुरू करने के लिए कंसोल या टर्मिनल में निम्नलिखित कमांड चलाएं: ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` Visual Studio Code खोलें bash codeVisual Studio Code में फोल्डर में तीन फाइलें जोड़ें: index html script js stylecss\nयूजर इंटरफेस बनाएं\nयदि हम आवश्यकताओं का विश्लेषण करें, तो हमें अपने HTML पेज पर कुछ तत्वों की आवश्यकता होगी। यह एक रेसिपी की तरह है, जहां हमें कुछ सामग्री चाहिए:\nउपयोगकर्ता के लिए टाइप करने के लिए कोट दिखाने की जगह\nसंदेश दिखाने की जगह, जैसे सफलता संदेश\nटाइपिंग के लिए एक टेक्स्टबॉक्स\nएक स्टार्ट बटन\nइनमें से प्रत्येक को IDs की आवश्यकता होगी ताकि हम उन्हें अपने JavaScript में उपयोग कर सकें। हम CSS और JavaScript फाइलों के संदर्भ भी जोड़ेंगे जिन्हें हम बनाने जा रहे हैं।\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 712,
    "chunk_index": 6,
    "total_chunks": 25
  },
  {
    "id": "c914d4cb8017eb0dd37b2bed968af2cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "पर कुछ तत्वों की आवश्यकता होगी। यह एक रेसिपी की तरह है, जहां हमें कुछ सामग्री चाहिए: उपयोगकर्ता के लिए टाइप करने के लिए कोट दिखाने की जगह संदेश दिखाने की जगह, जैसे सफलता संदेश टाइपिंग के लिए एक टेक्स्टबॉक्स एक स्टार्ट बटन इनमें से प्रत्येक को IDs की आवश्यकता होगी ताकि हम उन्हें अपने JavaScript में उपयोग कर सकें। हम CSS और JavaScript फाइलों के संदर्भ भी जोड़ेंगे जिन्हें हम बनाने जा रहे हैं। indexhtml नामक एक नई फाइल बनाएं। निम्नलिखित HTML जोड़ें:\n```html\nTyping game\nTyping game Practice your typing skills with a quote from Sherlock Holmes Click **start** to begin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 439,
    "chunk_index": 7,
    "total_chunks": 25
  },
  {
    "id": "4832e2a310d701d04014516c07d218fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "जगह संदेश दिखाने की जगह, जैसे सफलता संदेश टाइपिंग के लिए एक टेक्स्टबॉक्स एक स्टार्ट बटन इनमें से प्रत्येक को IDs की आवश्यकता होगी ताकि हम उन्हें अपने JavaScript में उपयोग कर सकें। हम CSS और JavaScript फाइलों के संदर्भ भी जोड़ेंगे जिन्हें हम बनाने जा रहे हैं। indexhtml नामक एक नई फाइल बनाएं। निम्नलिखित HTML जोड़ें: ```html Typing game Typing game Practice your typing skills with a quote from Sherlock Holmes Click **start** to beginStart\n```\nएप्लिकेशन लॉन्च करें\nहमेशा यह बेहतर होता है कि हम चीजों को धीरे-धीरे विकसित करें और देखें कि वे कैसी दिखती हैं। चलिए अपना एप्लिकेशन लॉन्च करते हैं। Visual Studio Code के लिए Live Server नामक एक शानदार एक्सटेंशन है, जो आपके एप्लिकेशन को लोकली होस्ट करेगा और हर बार जब आप सेव करेंगे, ब्राउज़र को रिफ्रेश करेगा।\nLive Server इंस्टॉल करें। लिंक पर क्लिक करें और Install पर क्लिक करें।\nब्राउज़र आपको Visual Studio Code खोलने के लिए कहेगा, और फिर Visual Studio Code इंस्टॉलेशन करने के लिए कहेगा।\nयदि Visual Studio Code आपको रीस्टार्ट करने के लिए कहे, तो इसे रीस्टार्ट करें।\nइंस्टॉल होने के बाद, Visual Studio Code में Ctrl-Shift-P (या Cmd-Shift-P) दबाएं और कमांड पैलेट खोलें।\nLive Server: Open with Live Server टाइप करें।\nLive Server आपके एप्लिकेशन को होस्ट करना शुरू कर देगा।\nब्राउज़र खोलें और https://localhost:5500 पर जाएं।\nअब आपको वह पेज दिखना चाहिए जो आपने बनाया है",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 990,
    "chunk_index": 8,
    "total_chunks": 25
  },
  {
    "id": "628c91c20b2832b1698379bdace718b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "लिए कहेगा, और फिर Visual Studio Code इंस्टॉलेशन करने के लिए कहेगा। यदि Visual Studio Code आपको रीस्टार्ट करने के लिए कहे, तो इसे रीस्टार्ट करें। इंस्टॉल होने के बाद, Visual Studio Code में Ctrl-Shift-P (या Cmd-Shift-P) दबाएं और कमांड पैलेट खोलें। Live Server: Open with Live Server टाइप करें। Live Server आपके एप्लिकेशन को होस्ट करना शुरू कर देगा। ब्राउज़र खोलें और https://localhost:5500 पर जाएं। अब आपको वह पेज दिखना चाहिए जो आपने बनाया हैचलो अब कुछ फंक्शनलिटी जोड़ते हैं।\nCSS जोड़ें\nहमारे HTML के तैयार होने के बाद, चलिए कोर स्टाइलिंग के लिए CSS जोड़ते हैं। हमें उस शब्द को हाइलाइट करना होगा जिसे खिलाड़ी को टाइप करना चाहिए, और यदि उन्होंने गलत टाइप किया है तो टेक्स्टबॉक्स को रंगीन करना होगा। हम यह दो क्लासेस के साथ करेंगे।\nstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 599,
    "chunk_index": 9,
    "total_chunks": 25
  },
  {
    "id": "96be51182e89d215ed25764c1dee5c82",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "करना शुरू कर देगा। ब्राउज़र खोलें और https://localhost:5500 पर जाएं। अब आपको वह पेज दिखना चाहिए जो आपने बनाया हैचलो अब कुछ फंक्शनलिटी जोड़ते हैं। CSS जोड़ें हमारे HTML के तैयार होने के बाद, चलिए कोर स्टाइलिंग के लिए CSS जोड़ते हैं। हमें उस शब्द को हाइलाइट करना होगा जिसे खिलाड़ी को टाइप करना चाहिए, और यदि उन्होंने गलत टाइप किया है तो टेक्स्टबॉक्स को रंगीन करना होगा। हम यह दो क्लासेस के साथ करेंगे। stylecss नामक एक नई फाइल बनाएं और निम्नलिखित सिंटैक्स जोड़ें:\n```css\n/ inside style css / highlight {\nbackground-color: yellow;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 10,
    "total_chunks": 25
  },
  {
    "id": "dde747a84a0de9730d603ce64ef61713",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "अब कुछ फंक्शनलिटी जोड़ते हैं। CSS जोड़ें हमारे HTML के तैयार होने के बाद, चलिए कोर स्टाइलिंग के लिए CSS जोड़ते हैं। हमें उस शब्द को हाइलाइट करना होगा जिसे खिलाड़ी को टाइप करना चाहिए, और यदि उन्होंने गलत टाइप किया है तो टेक्स्टबॉक्स को रंगीन करना होगा। हम यह दो क्लासेस के साथ करेंगे। stylecss नामक एक नई फाइल बनाएं और निम्नलिखित सिंटैक्स जोड़ें: ```css / inside style css / highlight { background-color: yellow; }error {\nbackground-color: lightcoral;\nborder: red;\n}\n```\n✅ CSS के मामले में आप अपने पेज को अपनी पसंद के अनुसार डिज़ाइन कर सकते हैं। थोड़ा समय लें और पेज को और आकर्षक बनाएं:\nएक अलग फॉन्ट चुनें\nहेडर्स को रंगीन करें\nआइटम्स का आकार बदलें\nJavaScript\nहमारे UI के तैयार होने के बाद, अब हम JavaScript पर ध्यान केंद्रित करेंगे, जो लॉजिक प्रदान करेगा। हम इसे कुछ चरणों में तोड़ेंगे:\nConstants बनाएं\nगेम शुरू करने के लिए इवेंट लिसनर\nटाइपिंग के लिए इवेंट लिसनर\nलेकिन पहले, script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 740,
    "chunk_index": 11,
    "total_chunks": 25
  },
  {
    "id": "2b08bd2a599fa1727ca50cc903fbe64a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "में आप अपने पेज को अपनी पसंद के अनुसार डिज़ाइन कर सकते हैं। थोड़ा समय लें और पेज को और आकर्षक बनाएं: एक अलग फॉन्ट चुनें हेडर्स को रंगीन करें आइटम्स का आकार बदलें JavaScript हमारे UI के तैयार होने के बाद, अब हम JavaScript पर ध्यान केंद्रित करेंगे, जो लॉजिक प्रदान करेगा। हम इसे कुछ चरणों में तोड़ेंगे: Constants बनाएं गेम शुरू करने के लिए इवेंट लिसनर टाइपिंग के लिए इवेंट लिसनर लेकिन पहले, scriptjs नामक एक नई फाइल बनाएं।\nConstants जोड़ें\nहमें प्रोग्रामिंग को आसान बनाने के लिए कुछ चीजों की आवश्यकता होगी। यह भी एक रेसिपी की तरह है, जहां हमें कुछ सामग्री चाहिए:\nसभी कोट्स की सूची के साथ एक ऐरे\nवर्तमान कोट के सभी शब्दों को स्टोर करने के लिए एक खाली ऐरे\nखिलाड़ी जिस शब्द को टाइप कर रहा है, उसका इंडेक्स स्टोर करने की जगह\nवह समय जब खिलाड़ी ने स्टार्ट पर क्लिक किया\nहमें UI तत्वों के संदर्भ भी चाहिए:\nटेक्स्टबॉक्स (typed-value)\nकोट डिस्प्ले (quote)\nसंदेश (message)\njavascript\n// inside script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 792,
    "chunk_index": 12,
    "total_chunks": 25
  },
  {
    "id": "9f61ec6518d63804fa182795be24b215",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "आवश्यकता होगी। यह भी एक रेसिपी की तरह है, जहां हमें कुछ सामग्री चाहिए: सभी कोट्स की सूची के साथ एक ऐरे वर्तमान कोट के सभी शब्दों को स्टोर करने के लिए एक खाली ऐरे खिलाड़ी जिस शब्द को टाइप कर रहा है, उसका इंडेक्स स्टोर करने की जगह वह समय जब खिलाड़ी ने स्टार्ट पर क्लिक किया हमें UI तत्वों के संदर्भ भी चाहिए: टेक्स्टबॉक्स (typed-value) कोट डिस्प्ले (quote) संदेश (message) javascript // inside scriptjs\n// all of our quotes\nconst quotes = [\n'When you have eliminated the impossible, whatever remains, however improbable, must be the truth ',\n'There is nothing more deceptive than an obvious fact ',\n'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation ',\n'I never make exceptions An exception disproves the rule ',\n'What one man can invent another can discover ',\n'Nothing clears up a case so much as stating it to another person ',\n'Education never ends, Watson It is a series of lessons, with the greatest for the last",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 13,
    "total_chunks": 25
  },
  {
    "id": "fea70ce7f22a70dbc2c87e8e01539eff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation ', 'I never make exceptions An exception disproves the rule ', 'What one man can invent another can discover ', 'Nothing clears up a case so much as stating it to another person ', 'Education never ends, Watson It is a series of lessons, with the greatest for the last',\n];\n// store the list of words and the index of the word the player is currently typing\nlet words = [];\nlet wordIndex = 0;\n// the starting time\nlet startTime = Date now();\n// page elements\nconst quoteElement = document getElementById('quote');\nconst messageElement = document getElementById('message');\nconst typedValueElement = document getElementById('typed-value');\n✅ अपने गेम में और कोट्स जोड़ें\nNOTE: हम document getElementById का उपयोग करके कोड में जब चाहें तत्वों को पुनः प्राप्त कर सकते हैं। चूंकि हम इन तत्वों का नियमित रूप से संदर्भ लेंगे, हम स्ट्रिंग लिटेरल्स के साथ टाइपो से बचने के लिए Constants का उपयोग करेंगे। Vue",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 379,
    "chunk_index": 14,
    "total_chunks": 25
  },
  {
    "id": "afc414e840c8c403bbd50be58ff55f49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ अपने गेम में और कोट्स जोड़ें NOTE: हम document getElementById का उपयोग करके कोड में जब चाहें तत्वों को पुनः प्राप्त कर सकते हैं। चूंकि हम इन तत्वों का नियमित रूप से संदर्भ लेंगे, हम स्ट्रिंग लिटेरल्स के साथ टाइपो से बचने के लिए Constants का उपयोग करेंगे। Vuejs या React जैसे फ्रेमवर्क्स आपके कोड को केंद्रीकृत करने में मदद कर सकते हैं।\nconst, let और var का उपयोग करने पर एक वीडियो देखें:\n🎥 ऊपर दी गई छवि पर क्लिक करें और वेरिएबल्स के बारे में वीडियो देखें।\nस्टार्ट लॉजिक जोड़ें\nगेम शुरू करने के लिए, खिलाड़ी स्टार्ट पर क्लिक करेगा। बेशक, हमें यह नहीं पता कि वे कब क्लिक करेंगे। यही वह जगह है जहां इवेंट लिसनर काम आता है। एक इवेंट लिसनर हमें किसी चीज़ (इवेंट) के होने का इंतजार करने और प्रतिक्रिया स्वरूप कोड निष्पादित करने की अनुमति देता है। हमारे मामले में, हम चाहते हैं कि जब उपयोगकर्ता स्टार्ट पर क्लिक करे, तो कोड निष्पादित हो।\nजब उपयोगकर्ता स्टार्ट पर क्लिक करता है, तो हमें एक कोट चुनना होगा, यूजर इंटरफेस सेटअप करना होगा, और वर्तमान शब्द और समय को ट्रैक करना होगा। नीचे वह JavaScript है जिसे आपको जोड़ने की आवश्यकता है; हम इसे स्क्रिप्ट ब्लॉक के बाद चर्चा करेंगे।\n```javascript\n// at the end of script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 34300,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hi\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1053,
    "chunk_index": 15,
    "total_chunks": 25
  }
]