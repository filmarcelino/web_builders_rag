[
  {
    "id": "0e519133635e4b9aef96cf234d1ea80b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "玻璃花园项目第三部分：DOM操作与闭包\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！\n此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。\nJavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。\n我们将使用闭包来操作DOM。\n可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。\nDOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui\n在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。\n前置条件\n你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。\n任务\n在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。\nDOM元素\n首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。\n任务\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 848,
    "chunk_index": 12,
    "total_chunks": 50
  },
  {
    "id": "e1a13506106792e70a0cdf44f84c00b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "玻璃花园项目第三部分：DOM操作与闭包\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！\n此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。\nJavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。\n我们将使用闭包来操作DOM。\n可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。\nDOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui\n在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。\n前置条件\n你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。\n任务\n在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。\nDOM元素\n首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。\n任务\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 857,
    "chunk_index": 13,
    "total_chunks": 50
  },
  {
    "id": "90cef2dd47a6936126eaa48915c0d1f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "玻璃花园项目第三部分：DOM操作与闭包\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！\n此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。\nJavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。\n我们将使用闭包来操作DOM。\n可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。\nDOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui\n在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。\n前置条件\n你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。\n任务\n在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。\nDOM元素\n首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。\n任务\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 866,
    "chunk_index": 14,
    "total_chunks": 50
  },
  {
    "id": "42c4c224db1bb1644368647a069aa399",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "玻璃花园项目第三部分：DOM操作与闭包\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！\n此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。\nJavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。\n我们将使用闭包来操作DOM。\n可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。\nDOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui\n在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。\n前置条件\n你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。\n任务\n在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。\nDOM元素\n首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。\n任务\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 875,
    "chunk_index": 15,
    "total_chunks": 50
  },
  {
    "id": "ac1f1afd1304e7c3bab10dba6fd1e631",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "玻璃花园项目第三部分：DOM操作与闭包\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！\n此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。\nJavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。\n我们将使用闭包来操作DOM。\n可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。\nDOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui\n在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。\n前置条件\n你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。\n任务\n在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。\nDOM元素\n首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。\n任务\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(documentgetElementById('plant13'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 884,
    "chunk_index": 16,
    "total_chunks": 50
  },
  {
    "id": "18faedadfab5c4559315372467de57ed",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "玻璃花园项目第三部分：DOM操作与闭包\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！\n此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。\nJavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。\n我们将使用闭包来操作DOM。\n可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。\nDOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui\n在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。\n前置条件\n你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。\n任务\n在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。\nDOM元素\n首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。\n任务\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(documentgetElementById('plant13'));\ndragElement(documentgetElementById('plant14'));\n这里发生了什么？你正在引用文档并在其DOM中查找具有特定Id的元素。还记得在HTML课程中你为每个植物图片分配了单独的Id（例如 id=\"plant1\"）吗？现在你将利用这些Id。识别每个元素后，你将该元素传递给一个名为 dragElement 的函数（稍后会创建）。因此，HTML中的元素现在可以被拖动，或者很快就可以被拖动。\n✅ 为什么我们通过Id引用元素，而不是通过CSS类？你可以参考之前关于CSS的课程来回答这个问题。\n闭包\n现在你可以创建 dragElement 闭包了，这是一个外部函数，包裹了一个或多个内部函数（在我们的案例中是三个）。\n当一个或多个函数需要访问外部函数的作用域时，闭包非常有用。以下是一个示例：\njavascript\nfunction displayCandy(){\nlet candy = ['jellybeans'];\nfunction addCandy(candyType) {\ncandy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1179,
    "chunk_index": 17,
    "total_chunks": 50
  },
  {
    "id": "308a0d4353f087d9e851f64c00625a32",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "的手绘笔记 课前测验 课前测验 简介 操作DOM（文档对象模型）是网页开发的关键部分。根据 MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！ 此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。 JavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。 我们将使用闭包来操作DOM。 可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。 DOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui 在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。 前置条件 你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。 任务 在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件： html <script src=\"/scriptjs\" defer></script> > 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。 DOM元素 首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。 任务 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 这里发生了什么？你正在引用文档并在其DOM中查找具有特定Id的元素。还记得在HTML课程中你为每个植物图片分配了单独的Id（例如 id=\"plant1\"）吗？现在你将利用这些Id。识别每个元素后，你将该元素传递给一个名为 dragElement 的函数（稍后会创建）。因此，HTML中的元素现在可以被拖动，或者很快就可以被拖动。 ✅ 为什么我们通过Id引用元素，而不是通过CSS类？你可以参考之前关于CSS的课程来回答这个问题。 闭包 现在你可以创建 dragElement 闭包了，这是一个外部函数，包裹了一个或多个内部函数（在我们的案例中是三个）。 当一个或多个函数需要访问外部函数的作用域时，闭包非常有用。以下是一个示例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType)\n}\naddCandy('gumdrops');\n}\ndisplayCandy();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1181,
    "chunk_index": 18,
    "total_chunks": 50
  },
  {
    "id": "8db55f76bdcddc2138c66a0d5fc25be2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "MDN 的定义，“文档对象模型（DOM）是网页中构成文档结构和内容的对象的数据表示形式。” 由于网页上的DOM操作的复杂性，开发者通常会选择使用JavaScript框架而不是原生JavaScript来管理DOM，但在本课程中，我们将自己动手完成！ 此外，本课程将介绍 JavaScript闭包 的概念。闭包可以理解为一个函数被另一个函数包裹，使得内部函数可以访问外部函数的作用域。 JavaScript闭包是一个广泛且复杂的主题。本课程仅涉及最基础的概念。在玻璃花园的代码中，你会发现一个闭包：一个内部函数和一个外部函数构造在一起，使得内部函数可以访问外部函数的作用域。想要了解更多关于闭包的工作原理，请访问 详细文档。 我们将使用闭包来操作DOM。 可以将DOM想象成一棵树，代表了网页文档可以被操作的所有方式。各种API（应用程序接口）被设计出来，使得程序员可以使用自己选择的编程语言访问DOM并进行编辑、修改、重新排列或其他管理操作。 DOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui 在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。 前置条件 你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。 任务 在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件： html <script src=\"/scriptjs\" defer></script> > 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。 DOM元素 首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。 任务 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 这里发生了什么？你正在引用文档并在其DOM中查找具有特定Id的元素。还记得在HTML课程中你为每个植物图片分配了单独的Id（例如 id=\"plant1\"）吗？现在你将利用这些Id。识别每个元素后，你将该元素传递给一个名为 dragElement 的函数（稍后会创建）。因此，HTML中的元素现在可以被拖动，或者很快就可以被拖动。 ✅ 为什么我们通过Id引用元素，而不是通过CSS类？你可以参考之前关于CSS的课程来回答这个问题。 闭包 现在你可以创建 dragElement 闭包了，这是一个外部函数，包裹了一个或多个内部函数（在我们的案例中是三个）。 当一个或多个函数需要访问外部函数的作用域时，闭包非常有用。以下是一个示例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy)\n在这个示例中，displayCandy 函数包裹了一个函数，该函数将新的糖果类型推入已经存在于函数中的数组。如果你运行这段代码，candy 数组将是未定义的，因为它是一个局部变量（局限于闭包的作用域）。\n✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。\n任务\n在 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1276,
    "chunk_index": 19,
    "total_chunks": 50
  },
  {
    "id": "7c0ef64ea0533fe64e31cc8ca59749b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "DOM及其对应HTML标记的表示形式。图片来源：Olfa Nasraoui 在本课程中，我们将完成互动玻璃花园项目，通过创建JavaScript代码让用户能够在页面上操作植物。 前置条件 你应该已经完成了玻璃花园的HTML和CSS部分。在本课程结束时，你将能够通过拖动将植物移入或移出玻璃花园。 任务 在你的玻璃花园文件夹中，创建一个名为 scriptjs 的新文件。在 <head> 部分导入该文件： html <script src=\"/scriptjs\" defer></script> > 注意：在将外部JavaScript文件导入HTML文件时，使用 defer 属性可以确保JavaScript代码在HTML文件完全加载后才执行。你也可以使用 async 属性，它允许脚本在HTML文件解析时执行，但在我们的案例中，确保HTML元素完全加载后再执行拖动脚本是很重要的。 DOM元素 首先，你需要在DOM中创建对你想要操作的元素的引用。在我们的案例中，这些元素是当前位于侧边栏的14个植物。 任务 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 这里发生了什么？你正在引用文档并在其DOM中查找具有特定Id的元素。还记得在HTML课程中你为每个植物图片分配了单独的Id（例如 id=\"plant1\"）吗？现在你将利用这些Id。识别每个元素后，你将该元素传递给一个名为 dragElement 的函数（稍后会创建）。因此，HTML中的元素现在可以被拖动，或者很快就可以被拖动。 ✅ 为什么我们通过Id引用元素，而不是通过CSS类？你可以参考之前关于CSS的课程来回答这个问题。 闭包 现在你可以创建 dragElement 闭包了，这是一个外部函数，包裹了一个或多个内部函数（在我们的案例中是三个）。 当一个或多个函数需要访问外部函数的作用域时，闭包非常有用。以下是一个示例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在这个示例中，displayCandy 函数包裹了一个函数，该函数将新的糖果类型推入已经存在于函数中的数组。如果你运行这段代码，candy 数组将是未定义的，因为它是一个局部变量（局限于闭包的作用域）。 ✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数：\njavascript\nfunction dragElement(terrariumElement) {\n//set 4 positions for positioning on the screen\nlet pos1 = 0,\npos2 = 0,\npos3 = 0,\npos4 = 0;\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 981,
    "chunk_index": 20,
    "total_chunks": 50
  },
  {
    "id": "38d93152a416970d18d3c43cb7691ebc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 这里发生了什么？你正在引用文档并在其DOM中查找具有特定Id的元素。还记得在HTML课程中你为每个植物图片分配了单独的Id（例如 id=\"plant1\"）吗？现在你将利用这些Id。识别每个元素后，你将该元素传递给一个名为 dragElement 的函数（稍后会创建）。因此，HTML中的元素现在可以被拖动，或者很快就可以被拖动。 ✅ 为什么我们通过Id引用元素，而不是通过CSS类？你可以参考之前关于CSS的课程来回答这个问题。 闭包 现在你可以创建 dragElement 闭包了，这是一个外部函数，包裹了一个或多个内部函数（在我们的案例中是三个）。 当一个或多个函数需要访问外部函数的作用域时，闭包非常有用。以下是一个示例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在这个示例中，displayCandy 函数包裹了一个函数，该函数将新的糖果类型推入已经存在于函数中的数组。如果你运行这段代码，candy 数组将是未定义的，因为它是一个局部变量（局限于闭包的作用域）。 ✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag;\n}\ndragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。\n此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。\n✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。\nPointerdrag函数\nterrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 974,
    "chunk_index": 21,
    "total_chunks": 50
  },
  {
    "id": "e9649b2f7fc585534d4180df7547e642",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在这个示例中，displayCandy 函数包裹了一个函数，该函数将新的糖果类型推入已经存在于函数中的数组。如果你运行这段代码，candy 数组将是未定义的，因为它是一个局部变量（局限于闭包的作用域）。 ✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;：\n任务\njavascript\nfunction pointerDrag(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 22,
    "total_chunks": 50
  },
  {
    "id": "a9e68697fb508361e271fc59a4104781",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "consolelog(candy) 在这个示例中，displayCandy 函数包裹了一个函数，该函数将新的糖果类型推入已经存在于函数中的数组。如果你运行这段代码，candy 数组将是未定义的，因为它是一个局部变量（局限于闭包的作用域）。 ✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 579,
    "chunk_index": 23,
    "total_chunks": 50
  },
  {
    "id": "855b047deeab9fcbc9b51832f285b491",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "在这个示例中，displayCandy 函数包裹了一个函数，该函数将新的糖果类型推入已经存在于函数中的数组。如果你运行这段代码，candy 数组将是未定义的，因为它是一个局部变量（局限于闭包的作用域）。 ✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e);\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 581,
    "chunk_index": 24,
    "total_chunks": 50
  },
  {
    "id": "86d0f181eb29f075723856c43fe8750d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "✅ 如何让 candy 数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 25,
    "total_chunks": 50
  },
  {
    "id": "1530bd1b5563f52996bd30234c7f2ff5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "数组可访问？尝试将它移到闭包外部。这样，数组就变成了全局变量，而不是仅限于闭包的局部作用域。 任务 在 scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY;\n}\n发生了几件事。首先，你通过使用 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 519,
    "chunk_index": 26,
    "total_chunks": 50
  },
  {
    "id": "dbe22e91e36631a93c78a88200115f85",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "scriptjs 文件的元素声明部分下，创建一个函数： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。\n完成脚本文件后，回到这一行，尝试去掉 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 525,
    "chunk_index": 27,
    "total_chunks": 50
  },
  {
    "id": "1c9ff9b916d0c75c04ecfcecae871378",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "{ //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？\n其次，在浏览器窗口中打开 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 530,
    "chunk_index": 28,
    "total_chunks": 50
  },
  {
    "id": "f89cfd5a7dbf6ce430b756a3f5844a0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！\n接下来，注意局部变量 pos3 和 pos4 如何被设置为 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 29,
    "total_chunks": 50
  },
  {
    "id": "736c34d093448e1b491519f2dd94b234",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。\n✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？\n完成初始函数后，在 pos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 743,
    "chunk_index": 30,
    "total_chunks": 50
  },
  {
    "id": "b33c2a8506eb638ffa0962669b88ff88",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "0; terrariumElementonpointerdown = pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作：\nhtml\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 744,
    "chunk_index": 31,
    "total_chunks": 50
  },
  {
    "id": "635d14af394387889697d5acb3e2b0a0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "pointerDrag; } dragElement 从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 742,
    "chunk_index": 32,
    "total_chunks": 50
  },
  {
    "id": "de18b65ffc2b91fa52e5d772f53dd79c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "从脚本顶部的声明中获取其 terrariumElement 对象。然后，你为传递给函数的对象设置一些初始位置为 0 的局部变量。这些局部变量将在闭包中为每个元素添加拖动功能时被操作。玻璃花园将通过这些拖动的元素填充，因此应用程序需要跟踪它们的放置位置。 此外，传递给该函数的 terrariumElement 被分配了一个 pointerdown 事件，这是 web API 的一部分，旨在帮助管理DOM。onpointerdown 在按钮被按下时触发，或者在我们的案例中，当一个可拖动的元素被触摸时触发。这个事件处理程序适用于 网页和移动浏览器，但有一些例外。 ✅ 事件处理程序 onclick 在跨浏览器支持方面更广泛；为什么不在这里使用它？思考一下你想要创建的屏幕交互的具体类型。 Pointerdrag函数 terrariumElement 已准备好被拖动；当触发 onpointerdown 事件时，函数 pointerDrag 被调用。在这行代码下添加该函数：terrariumElementonpointerdown = pointerDrag;： 任务 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag;\n现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。\nelementDrag 和 stopElementDrag 函数\n通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。\n任务\n在 pointerDrag 的结束大括号后添加 elementDrag 函数：\njavascript\nfunction elementDrag(e) {\npos1 = pos3 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1017,
    "chunk_index": 33,
    "total_chunks": 50
  },
  {
    "id": "0bf263b71c3f36959c820d9f3d16dc6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "{ epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX;\npos2 = pos4 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 673,
    "chunk_index": 34,
    "total_chunks": 50
  },
  {
    "id": "09281856be9b3804f3a9c3f834bc7c12",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "eclientX; pos4 = eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY;\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 668,
    "chunk_index": 35,
    "total_chunks": 50
  },
  {
    "id": "889792c6bd79239f085035753938705a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "eclientY; } 发生了几件事。首先，你通过使用 epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 668,
    "chunk_index": 36,
    "total_chunks": 50
  },
  {
    "id": "fbcc2de42af98d4009b5ee03b36cdcf1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "epreventDefault(); 阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 37,
    "total_chunks": 50
  },
  {
    "id": "72ab7dc195dbec60948a0d9a8b667108",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "阻止了在 pointerdown 上通常发生的默认事件。这样你可以更好地控制界面的行为。 完成脚本文件后，回到这一行，尝试去掉 epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4);\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 664,
    "chunk_index": 38,
    "total_chunks": 50
  },
  {
    "id": "b28527b2444603fcfbe4785bc2fa1ec4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 612,
    "chunk_index": 39,
    "total_chunks": 50
  },
  {
    "id": "69d5a03a2c4122926b562916216d8aaf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "epreventDefault() ——会发生什么？ 其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 617,
    "chunk_index": 40,
    "total_chunks": 50
  },
  {
    "id": "014a50d7a0d2eaaf4c6940e671e6641e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "其次，在浏览器窗口中打开 indexhtml，并检查界面。当你点击一个植物时，你可以看到如何捕获 'e' 事件。深入研究事件，看看一个 pointerdown 事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px';\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 614,
    "chunk_index": 41,
    "total_chunks": 50
  },
  {
    "id": "fd1cf5a92ef3a513ae6e7106def8bed3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 551,
    "chunk_index": 42,
    "total_chunks": 50
  },
  {
    "id": "262281caebf265c0ba760781d11412cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "事件可以收集多少信息！ 接下来，注意局部变量 pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 556,
    "chunk_index": 43,
    "total_chunks": 50
  },
  {
    "id": "3b3e3674051ffacf176f1c07f06a0c7f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "pos3 和 pos4 如何被设置为 eclientX。你可以在检查面板中找到 e 的值。这些值捕获了你点击或触摸植物时的x和y坐标。你需要对植物的行为进行精细控制，因此需要跟踪它们的坐标。 ✅ 为什么整个应用程序是用一个大的闭包构建的是否变得更清晰了？如果不是闭包，你如何为14个可拖动的植物维护作用域？ 完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px';\n}\n在这个函数中，你对外部函数中设置的初始位置1-4进行了大量编辑。这里发生了什么？\n在拖动过程中，你通过将 pos3（之前设置为 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 602,
    "chunk_index": 44,
    "total_chunks": 50
  },
  {
    "id": "122f91cbee6d02e1c01688b9a29f518c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "完成初始函数后，在 pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在这个函数中，你对外部函数中设置的初始位置1-4进行了大量编辑。这里发生了什么？ 在拖动过程中，你通过将 pos3（之前设置为 eclientX）减去当前的 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 456,
    "chunk_index": 45,
    "total_chunks": 50
  },
  {
    "id": "f5d54763fe3162b84384515d21cfe61c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "pos4 = eclientY 下添加两个指针事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 现在你正在指示植物随着指针移动而被拖动，并在取消选择植物时停止拖动。onpointermove 和 onpointerup 都是与 onpointerdown 属于同一API的一部分。界面现在会抛出错误，因为你尚未定义 elementDrag 和 stopElementDrag 函数，因此接下来构建这些函数。 elementDrag 和 stopElementDrag 函数 通过添加两个内部函数来完成闭包，这些函数将处理拖动植物和停止拖动时发生的事情。你希望的行为是，用户可以随时拖动任何植物并将其放置在屏幕上的任意位置。这个界面非常灵活（例如没有特定的放置区域），允许用户通过添加、移除和重新定位植物来自由设计玻璃花园。 任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在这个函数中，你对外部函数中设置的初始位置1-4进行了大量编辑。这里发生了什么？ 在拖动过程中，你通过将 pos3（之前设置为 eclientX）减去当前的 eclientX 值来重新分配 pos1。对 pos2 进行了类似的操作。然后，你将 pos3 和 pos4 重置为元素的新x和y坐标。你可以在拖动时在控制台中观察这些变化。接着，你操作植物的CSS样式，根据与这些新位置的偏移量计算植物的顶部和左侧x和y坐标，从而设置其新位置。\noffsetTop 和 offsetLeft 是CSS属性，用于根据其父元素设置元素的位置；其父元素可以是任何非 static 定位的元素。\n所有这些位置重新计算使你能够微调玻璃花园及其植物的行为。\n任务\n完成界面的最后一步是在 elementDrag 的结束大括号后添加 stopElementDrag 函数：\njavascript\nfunction stopElementDrag() {\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 691,
    "chunk_index": 46,
    "total_chunks": 50
  },
  {
    "id": "5930e3b890b9f5ff22dd5296e28bc25b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "任务 在 pointerDrag 的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在这个函数中，你对外部函数中设置的初始位置1-4进行了大量编辑。这里发生了什么？ 在拖动过程中，你通过将 pos3（之前设置为 eclientX）减去当前的 eclientX 值来重新分配 pos1。对 pos2 进行了类似的操作。然后，你将 pos3 和 pos4 重置为元素的新x和y坐标。你可以在拖动时在控制台中观察这些变化。接着，你操作植物的CSS样式，根据与这些新位置的偏移量计算植物的顶部和左侧x和y坐标，从而设置其新位置。 offsetTop 和 offsetLeft 是CSS属性，用于根据其父元素设置元素的位置；其父元素可以是任何非 static 定位的元素。 所有这些位置重新计算使你能够微调玻璃花园及其植物的行为。 任务 完成界面的最后一步是在 elementDrag 的结束大括号后添加 stopElementDrag 函数： javascript function stopElementDrag() { documentonpointerup = null;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 423,
    "chunk_index": 47,
    "total_chunks": 50
  },
  {
    "id": "a71c7ed67cac68409c6f1c740e658be1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "的结束大括号后添加 elementDrag 函数： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在这个函数中，你对外部函数中设置的初始位置1-4进行了大量编辑。这里发生了什么？ 在拖动过程中，你通过将 pos3（之前设置为 eclientX）减去当前的 eclientX 值来重新分配 pos1。对 pos2 进行了类似的操作。然后，你将 pos3 和 pos4 重置为元素的新x和y坐标。你可以在拖动时在控制台中观察这些变化。接着，你操作植物的CSS样式，根据与这些新位置的偏移量计算植物的顶部和左侧x和y坐标，从而设置其新位置。 offsetTop 和 offsetLeft 是CSS属性，用于根据其父元素设置元素的位置；其父元素可以是任何非 static 定位的元素。 所有这些位置重新计算使你能够微调玻璃花园及其植物的行为。 任务 完成界面的最后一步是在 elementDrag 的结束大括号后添加 stopElementDrag 函数： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null;\n}\n这个小函数重置了 onpointerup 和 onpointermove 事件，使得用户可以通过重新开始拖动植物或开始拖动新植物来重新启动植物的进程。\n✅ 如果不将这些事件设置为null，会发生什么？\n现在你已经完成了你的项目！\n🥇恭喜！你完成了美丽的玻璃花园！\n🚀挑战\n为你的闭包添加新的事件处理程序，让植物实现更多功能；例如，双击植物将其置于最前面。发挥创意吧！\n课后测验\n课后测验\n复习与自学\n虽然在屏幕上拖动元素看起来很简单，但实现这一功能有很多方法和陷阱，具体取决于你想要的效果。事实上，有一个完整的 拖放API 供你尝试。我们没有在本模块中使用它，因为我们想要的效果有所不同，但你可以在自己的项目中尝试这个API，看看能实现什么。\n在 W3C文档 和 MDN网页文档 上找到更多关于指针事件的信息。\n始终使用 CanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 778,
    "chunk_index": 48,
    "total_chunks": 50
  },
  {
    "id": "a8d141477afa25d4f283b5ac9487aa5e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花园项目第三部分：DOM操作与闭包",
    "content": "terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在这个函数中，你对外部函数中设置的初始位置1-4进行了大量编辑。这里发生了什么？ 在拖动过程中，你通过将 pos3（之前设置为 eclientX）减去当前的 eclientX 值来重新分配 pos1。对 pos2 进行了类似的操作。然后，你将 pos3 和 pos4 重置为元素的新x和y坐标。你可以在拖动时在控制台中观察这些变化。接着，你操作植物的CSS样式，根据与这些新位置的偏移量计算植物的顶部和左侧x和y坐标，从而设置其新位置。 offsetTop 和 offsetLeft 是CSS属性，用于根据其父元素设置元素的位置；其父元素可以是任何非 static 定位的元素。 所有这些位置重新计算使你能够微调玻璃花园及其植物的行为。 任务 完成界面的最后一步是在 elementDrag 的结束大括号后添加 stopElementDrag 函数： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null; } 这个小函数重置了 onpointerup 和 onpointermove 事件，使得用户可以通过重新开始拖动植物或开始拖动新植物来重新启动植物的进程。 ✅ 如果不将这些事件设置为null，会发生什么？ 现在你已经完成了你的项目！ 🥇恭喜！你完成了美丽的玻璃花园！ 🚀挑战 为你的闭包添加新的事件处理程序，让植物实现更多功能；例如，双击植物将其置于最前面。发挥创意吧！ 课后测验 课后测验 复习与自学 虽然在屏幕上拖动元素看起来很简单，但实现这一功能有很多方法和陷阱，具体取决于你想要的效果。事实上，有一个完整的 拖放API 供你尝试。我们没有在本模块中使用它，因为我们想要的效果有所不同，但你可以在自己的项目中尝试这个API，看看能实现什么。 在 W3C文档 和 MDN网页文档 上找到更多关于指针事件的信息。 始终使用 CanIUsecom 检查浏览器兼容性。\n作业\n进一步练习DOM操作\n免责声明：\n本文档使用AI翻译服务 Co-op Translator 进行翻译。尽管我们努力确保翻译的准确性，但请注意，自动翻译可能包含错误或不准确之处。应以原文档的原始语言版本为权威来源。对于关键信息，建议使用专业人工翻译。因使用本翻译而引起的任何误解或误读，我们概不负责。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 879,
    "chunk_index": 49,
    "total_chunks": 50
  },
  {
    "id": "f4341dc152c0b92f189f87f3dc37a4e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\README.md",
    "source_type": "git_repo",
    "title": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的專案 🌵🌱",
    "content": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的專案 🌵🌱\n一個小型的拖放程式練習。通過一些 HTML、JS 和 CSS，你將能夠建立一個網頁介面，為其設計樣式，甚至添加多種互動功能。\n課程\nHTML 入門\nCSS 入門\nDOM 和 JS 閉包入門\n致謝\n由 Jen Looper 用 ♥️ 編寫\n通過 CSS 創建的微型植物園靈感來自 Jakub Mandra 的玻璃罐 codepen。\n藝術作品由 Jen Looper 使用 Procreate 手繪完成。\n部署你的微型植物園\n你可以使用 Azure 靜態網頁應用程式將你的微型植物園部署或發佈到網路上。\nFork 此儲存庫\n按下這個按鈕\n按照向導步驟建立你的應用程式。請確保將應用程式根目錄設置為 /solution 或你的程式碼根目錄。此應用程式中沒有 API，因此不需要添加相關內容。一個 GitHub 資料夾將會在你 Fork 的儲存庫中建立，這將幫助 Azure 靜態網頁應用程式的建置服務，建置並發佈你的應用程式到一個新的 URL。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2216,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 645,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "52dd1df2a85c36de38f142e1e1e7d33c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\README.md",
    "source_type": "git_repo",
    "title": "事件驅動程式設計 - 建立一個打字遊戲",
    "content": "事件驅動程式設計 - 建立一個打字遊戲\n簡介\n打字是開發者最被低估的技能之一。能夠快速地將腦中的想法轉移到編輯器中，可以讓創意自由流動。而學習的最佳方式之一就是玩遊戲！\n那麼，讓我們來建立一個打字遊戲吧！\n你將使用到目前為止學到的 JavaScript、HTML 和 CSS 技能來創建一個打字遊戲。遊戲會向玩家展示一段隨機的引言（我們使用的是 福爾摩斯 的引言），並計時玩家準確輸入這段文字所需的時間。你將使用到目前為止學到的 JavaScript、HTML 和 CSS 技能來創建這個打字遊戲。\n先決條件\n本課程假設你已熟悉以下概念：\n建立文字輸入框和按鈕控制項\nCSS 和使用類別設定樣式\nJavaScript 基礎\n建立陣列\n生成隨機數\n獲取當前時間\n課程\n使用事件驅動程式設計建立打字遊戲\n致謝\n由 Christopher Harrison 用 ♥️ 撰寫\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1823,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 595,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "fa45d3099ffcd343eeca2891dd5f9441",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\README.md",
    "source_type": "git_repo",
    "title": "建立瀏覽器擴充功能",
    "content": "建立瀏覽器擴充功能\n建立瀏覽器擴充功能是一種有趣且引人入勝的方式，可以在開發不同類型的網頁資產時，思考應用程式的效能。本模組包含有關瀏覽器運作方式以及如何部署瀏覽器擴充功能的課程，還有如何建立表單、呼叫 API、使用本地存儲，以及如何評估網站效能並加以改進。\n您將建立一個可在 Edge、Chrome 和 Firefox 上運作的瀏覽器擴充功能。這個擴充功能類似於一個專門針對特定任務的小型網站，它會檢查 C02 Signal API 中某個地區的電力使用情況和碳強度，並返回該地區的碳足跡讀數。\n使用者可以在輸入 API 金鑰和地區代碼到表單後，隨時調用此擴充功能，以確定當地的電力使用情況，從而提供數據來影響使用者的用電決策。例如，在您所在地區電力使用量高的時段，可能更適合延遲使用衣物烘乾機（這是一項碳密集型活動）。\n主題\n關於瀏覽器\n表單與本地存儲\n背景任務與效能\n致謝\n致謝\n這個網頁碳觸發器的想法由 Microsoft 的綠色雲端倡導團隊負責人 Asim Hussain 提供，他也是 Green Principles 的作者。最初它是一個 網站專案。\n瀏覽器擴充功能的結構受到 Adebola Adeniran 的 COVID 擴充功能 的啟發。\n「點」圖標系統的概念則是參考了 Energy Lollipop 瀏覽器擴充功能的圖標結構，該擴充功能用於加州的排放量。\n這些課程由 Jen Looper 用 ♥️ 編寫。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2653,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 864,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "1711b313ad3b29dc59322c9fcf438727",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\README.md",
    "source_type": "git_repo",
    "title": ":dollar: 建立銀行",
    "content": ":dollar: 建立銀行\n在這個專案中，你將學習如何建立一個虛構的銀行。這些課程包括如何設計網頁應用程式的佈局和路由、建立表單、管理狀態，以及從 API 獲取銀行數據。\n|  |  |\n|--------------------------------|--------------------------------|\n課程\n網頁應用程式中的 HTML 模板和路由\n建立登入和註冊表單\n獲取和使用數據的方法\n狀態管理的概念\n致謝\n這些課程由 Yohan Lasorsa 用 :hearts: 編寫。\n如果你有興趣學習如何建立這些課程中使用的 伺服器 API，可以觀看 這系列影片（特別是第 17 至 21 集）。\n你也可以查看 這個互動式學習教程。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1735,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3594d790d0a8ea3059ad185ee6c8b58d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "建造一個太空遊戲",
    "content": "建造一個太空遊戲\n一個用來學習更高級 JavaScript 基礎的太空遊戲\n在這堂課中，你將學習如何製作自己的太空遊戲。如果你曾玩過「太空侵略者」這款遊戲，這個遊戲的概念與其相似：操控一艘太空船並射擊從上方降下的怪物。以下是完成後的遊戲樣貌：\n在這六堂課中，你將學到以下內容：\n互動 Canvas 元素以在螢幕上繪製物件\n理解 笛卡爾座標系統\n學習 Pub-Sub 模式以建立更易於維護和擴展的遊戲架構\n運用 Async/Await 來載入遊戲資源\n處理 鍵盤事件\n概述\n理論\n使用 JavaScript 建造遊戲的介紹\n實作\n繪製到 Canvas\n在螢幕上移動元素\n碰撞檢測\n計分\n結束並重新開始遊戲\n致謝\n本遊戲使用的資源來自 https://www kenney",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1954,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 399,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "a4fc1a3b96503ea1bca1fdc966c5e0ff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "建造一個太空遊戲",
    "content": "建造一個太空遊戲\n一個用來學習更高級 JavaScript 基礎的太空遊戲\n在這堂課中，你將學習如何製作自己的太空遊戲。如果你曾玩過「太空侵略者」這款遊戲，這個遊戲的概念與其相似：操控一艘太空船並射擊從上方降下的怪物。以下是完成後的遊戲樣貌：\n在這六堂課中，你將學到以下內容：\n互動 Canvas 元素以在螢幕上繪製物件\n理解 笛卡爾座標系統\n學習 Pub-Sub 模式以建立更易於維護和擴展的遊戲架構\n運用 Async/Await 來載入遊戲資源\n處理 鍵盤事件\n概述\n理論\n使用 JavaScript 建造遊戲的介紹\n實作\n繪製到 Canvas\n在螢幕上移動元素\n碰撞檢測\n計分\n結束並重新開始遊戲\n致謝\n本遊戲使用的資源來自 https://www kenneynl/。\n如果你對製作遊戲感興趣，這裡有一些非常棒的資源，許多是免費的，也有一些是付費的。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1954,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 642,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "46c1c722eca7718f5addaa5fb01b267d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "GitHub简介\n本课程介绍了GitHub的基础知识，这是一个用于托管和管理代码变更的平台。\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n在本课程中，我们将学习：\n如何跟踪你在本地机器上的工作\n如何与他人协作完成项目\n如何为开源软件做贡献\n前置条件\n在开始之前，你需要检查是否安装了Git。在终端中输入：\ngit --version\n如果未安装Git，请下载Git。然后，在终端中设置你的本地Git配置文件：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要检查Git是否已配置，可以输入：\ngit config --list\n你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。\n访问 github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 256,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "6d195b4847602fd53f7a3c9ffb8a0dc5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "GitHub简介\n本课程介绍了GitHub的基础知识，这是一个用于托管和管理代码变更的平台。\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n在本课程中，我们将学习：\n如何跟踪你在本地机器上的工作\n如何与他人协作完成项目\n如何为开源软件做贡献\n前置条件\n在开始之前，你需要检查是否安装了Git。在终端中输入：\ngit --version\n如果未安装Git，请下载Git。然后，在终端中设置你的本地Git配置文件：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要检查Git是否已配置，可以输入：\ngit config --list\n你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。\n访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。\n✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。\n准备工作\n你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。\n代码管理\n假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。\n任务：创建仓库并提交代码\n查看视频\n在GitHub上创建仓库。在GitHub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 532,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "be331be6653fa5cb6cf6b8d0651cab67",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "GitHub简介\n本课程介绍了GitHub的基础知识，这是一个用于托管和管理代码变更的平台。\nTomomi Imura 的手绘笔记\n课前测验\n课前测验\n简介\n在本课程中，我们将学习：\n如何跟踪你在本地机器上的工作\n如何与他人协作完成项目\n如何为开源软件做贡献\n前置条件\n在开始之前，你需要检查是否安装了Git。在终端中输入：\ngit --version\n如果未安装Git，请下载Git。然后，在终端中设置你的本地Git配置文件：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要检查Git是否已配置，可以输入：\ngit config --list\n你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。\n访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。\n✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。\n准备工作\n你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。\n代码管理\n假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。\n任务：创建仓库并提交代码\n查看视频\n在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。\n给你的仓库（文件夹）命名\n选择创建仓库。\n导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入：\nbash\ncd [name of your folder]\n初始化Git仓库。在你的项目中输入：\nbash\ngit init\n检查状态。要检查仓库的状态，输入：\nbash\ngit status\n输出可能如下所示：\n```output\nChanges not staged for commit:\n(use \"git add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 691,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "a35549938326d31b062380fea2c699ed",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "本课程介绍了GitHub的基础知识，这是一个用于托管和管理代码变更的平台。 Tomomi Imura 的手绘笔记 课前测验 课前测验 简介 在本课程中，我们将学习： 如何跟踪你在本地机器上的工作 如何与他人协作完成项目 如何为开源软件做贡献 前置条件 在开始之前，你需要检查是否安装了Git。在终端中输入： git --version 如果未安装Git，请下载Git。然后，在终端中设置你的本地Git配置文件： * git config --global user name \"your-name\" * git config --global user email \"your-email\" 要检查Git是否已配置，可以输入： git config --list 你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。 访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。 ✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。 准备工作 你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。 代码管理 假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。 任务：创建仓库并提交代码 查看视频 在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。 给你的仓库（文件夹）命名 选择创建仓库。 导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入： bash cd [name of your folder] 初始化Git仓库。在你的项目中输入： bash git init 检查状态。要检查仓库的状态，输入： bash git status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed)\n(use \"git checkout --",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 696,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "0ffb8e0cba3b998ed3a64af5f3765bd1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "如何为开源软件做贡献 前置条件 在开始之前，你需要检查是否安装了Git。在终端中输入： git --version 如果未安装Git，请下载Git。然后，在终端中设置你的本地Git配置文件： * git config --global user name \"your-name\" * git config --global user email \"your-email\" 要检查Git是否已配置，可以输入： git config --list 你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。 访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。 ✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。 准备工作 你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。 代码管理 假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。 任务：创建仓库并提交代码 查看视频 在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。 给你的仓库（文件夹）命名 选择创建仓库。 导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入： bash cd [name of your folder] 初始化Git仓库。在你的项目中输入： bash git init 检查状态。要检查仓库的状态，输入： bash git status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory)\nmodified:   file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "a51bd2b01832c8fe03f210fb138afdd7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "config --global user name \"your-name\" * git config --global user email \"your-email\" 要检查Git是否已配置，可以输入： git config --list 你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。 访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。 ✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。 准备工作 你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。 代码管理 假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。 任务：创建仓库并提交代码 查看视频 在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。 给你的仓库（文件夹）命名 选择创建仓库。 导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入： bash cd [name of your folder] 初始化Git仓库。在你的项目中输入： bash git init 检查状态。要检查仓库的状态，输入： bash git status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt\nmodified:   file2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 541,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "9505ccf473502146e133a3568753c7a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "user name \"your-name\" * git config --global user email \"your-email\" 要检查Git是否已配置，可以输入： git config --list 你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。 访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。 ✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。 准备工作 你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。 代码管理 假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。 任务：创建仓库并提交代码 查看视频 在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。 给你的仓库（文件夹）命名 选择创建仓库。 导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入： bash cd [name of your folder] 初始化Git仓库。在你的项目中输入： bash git init 检查状态。要检查仓库的状态，输入： bash git status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt\n```\n通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。\n添加所有文件进行跟踪\n这也称为暂存文件/将文件添加到暂存区。\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 616,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "b4f2e7317f71e953cc95cb10ce42446e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "email \"your-email\" 要检查Git是否已配置，可以输入： git config --list 你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。 访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。 ✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。 准备工作 你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。 代码管理 假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。 任务：创建仓库并提交代码 查看视频 在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。 给你的仓库（文件夹）命名 选择创建仓库。 导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入： bash cd [name of your folder] 初始化Git仓库。在你的项目中输入： bash git init 检查状态。要检查仓库的状态，输入： bash git status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "53ac4de4b27f347e6fabcc32657af36b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "\"your-email\" 要检查Git是否已配置，可以输入： git config --list 你还需要一个GitHub账号，一个代码编辑器（如Visual Studio Code），并打开你的终端（或命令提示符）。 访问 githubcom 创建一个账号（如果尚未创建），或者登录并完善你的个人资料。 ✅ GitHub并不是世界上唯一的代码仓库平台；还有其他平台，但GitHub是最知名的。 准备工作 你需要一个本地机器（笔记本或PC）上的代码项目文件夹，以及一个GitHub上的公共仓库，这将作为如何为他人项目做贡献的示例。 代码管理 假设你在本地有一个代码项目文件夹，并希望使用Git（版本控制系统）开始跟踪你的进度。有些人将使用Git比作写给未来自己的情书。几天、几周或几个月后阅读你的提交信息时，你可以回忆起为什么做出某个决定，或者“回滚”某个更改——前提是你写了好的“提交信息”。 任务：创建仓库并提交代码 查看视频 在GitHub上创建仓库。在GitHubcom的仓库标签中，或从右上角导航栏找到新建仓库按钮。 给你的仓库（文件夹）命名 选择创建仓库。 导航到你的工作文件夹。在终端中，切换到你想开始跟踪的文件夹（也称为目录）。输入： bash cd [name of your folder] 初始化Git仓库。在你的项目中输入： bash git init 检查状态。要检查仓库的状态，输入： bash git status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。\n添加选定文件进行跟踪\nbash\ngit add [file or folder name]\n当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。\n取消暂存所有文件\nbash\ngit reset\n此命令帮助我们一次性取消暂存所有文件。\n取消暂存特定文件\nbash\ngit reset [file or folder name]\n此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。\n持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交：\nbash\ngit commit -m \"first commit\"\n这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。\n将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令：\n注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1053,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "5287c51459c08cdf72c510b277f1d249",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 588,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "f77986cdd79d999ad891bdf00f6895c7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "status 输出可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。\nbash\ngit remote add origin https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 607,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "2055867abdd414d4e97a162af6fea38d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。 bash git remote add origin https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 597,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "f59e695f29bf59efcdb2424c8deb7a77",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit\n这会创建一个名为“origin”的远程连接，指向你之前创建的GitHub仓库。\n将本地文件发送到GitHub。到目前为止，你已经在本地仓库和GitHub仓库之间创建了连接。使用以下命令git push将这些文件发送到GitHub：\n注意，你的分支名称可能与main不同。\nbash\ngit push -u origin main\n这会将你的“main”分支中的提交发送到GitHub。\n添加更多更改。如果你想继续进行更改并将其推送到GitHub，你只需要使用以下三个命令：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 753,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "f04ec6a137bd6617f3d4005c9829e2db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 这会创建一个名为“origin”的远程连接，指向你之前创建的GitHub仓库。 将本地文件发送到GitHub。到目前为止，你已经在本地仓库和GitHub仓库之间创建了连接。使用以下命令git push将这些文件发送到GitHub： 注意，你的分支名称可能与main不同。 bash git push -u origin main 这会将你的“main”分支中的提交发送到GitHub。 添加更多更改。如果你想继续进行更改并将其推送到GitHub，你只需要使用以下三个命令： bash git addgit commit -m \"type your commit message here\"\ngit push\n提示，你可能还需要采用",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 752,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "c9697d0b0f0093d71d834c1b9a6ab9fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 这会创建一个名为“origin”的远程连接，指向你之前创建的GitHub仓库。 将本地文件发送到GitHub。到目前为止，你已经在本地仓库和GitHub仓库之间创建了连接。使用以下命令git push将这些文件发送到GitHub： 注意，你的分支名称可能与main不同。 bash git push -u origin main 这会将你的“main”分支中的提交发送到GitHub。 添加更多更改。如果你想继续进行更改并将其推送到GitHub，你只需要使用以下三个命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能还需要采用gitignore文件，以防止你不想跟踪的文件出现在GitHub上——例如存储在同一文件夹中的笔记文件，但不适合放在公共仓库中。你可以在",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 794,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "b34e41a50f3446ac5b51b60aa4c27fbf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 这会创建一个名为“origin”的远程连接，指向你之前创建的GitHub仓库。 将本地文件发送到GitHub。到目前为止，你已经在本地仓库和GitHub仓库之间创建了连接。使用以下命令git push将这些文件发送到GitHub： 注意，你的分支名称可能与main不同。 bash git push -u origin main 这会将你的“main”分支中的提交发送到GitHub。 添加更多更改。如果你想继续进行更改并将其推送到GitHub，你只需要使用以下三个命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能还需要采用gitignore文件，以防止你不想跟踪的文件出现在GitHub上——例如存储在同一文件夹中的笔记文件，但不适合放在公共仓库中。你可以在gitignore模板中找到",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 801,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "e3b557d4c8bdf1a21a7ae9b307dceda0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "通常，git status命令会告诉你哪些文件准备好被保存到仓库，或者哪些文件有更改需要持久化。 添加所有文件进行跟踪 这也称为暂存文件/将文件添加到暂存区。 bash git addgit add加上参数表示将所有文件和更改添加到跟踪中。 添加选定文件进行跟踪 bash git add [file or folder name] 当你不想一次提交所有文件时，这可以帮助我们仅添加选定文件到暂存区。 取消暂存所有文件 bash git reset 此命令帮助我们一次性取消暂存所有文件。 取消暂存特定文件 bash git reset [file or folder name] 此命令帮助我们一次性取消暂存特定文件，不将其包含在下一次提交中。 持久化你的工作。此时你已经将文件添加到所谓的暂存区，这是Git跟踪文件的地方。要使更改永久化，你需要提交文件。使用git commit命令创建一个提交。提交代表仓库历史中的一个保存点。输入以下命令创建提交： bash git commit -m \"first commit\" 这会提交所有文件，并添加信息“首次提交”。对于未来的提交信息，你需要更具描述性，以传达你进行了什么类型的更改。 将本地Git仓库连接到GitHub。本地Git仓库很好，但最终你可能希望将文件备份到某个地方，并邀请其他人与你一起工作。GitHub是一个很好的选择。记住我们已经在GitHub上创建了一个仓库，现在只需要将本地Git仓库连接到GitHub。git remote add命令可以实现这一点。输入以下命令： 注意，在输入命令之前，访问你的GitHub仓库页面以找到仓库URL。你将在下面的命令中使用它。将https://githubcom/username/repository_namegit替换为你的GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 这会创建一个名为“origin”的远程连接，指向你之前创建的GitHub仓库。 将本地文件发送到GitHub。到目前为止，你已经在本地仓库和GitHub仓库之间创建了连接。使用以下命令git push将这些文件发送到GitHub： 注意，你的分支名称可能与main不同。 bash git push -u origin main 这会将你的“main”分支中的提交发送到GitHub。 添加更多更改。如果你想继续进行更改并将其推送到GitHub，你只需要使用以下三个命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能还需要采用gitignore文件，以防止你不想跟踪的文件出现在GitHub上——例如存储在同一文件夹中的笔记文件，但不适合放在公共仓库中。你可以在gitignore模板中找到gitignore文件的模板。\n提交信息\n一个好的Git提交主题行可以完成以下句子：\n如果应用此提交，它将<你的主题行>\n对于主题行，请使用命令式现在时：“更改”而不是“已更改”或“正在更改”。\n在正文中（可选）也使用命令式现在时。正文应包括更改的动机，并与之前的行为进行对比。你是在解释“为什么”，而不是“如何”。\n✅ 花几分钟浏览GitHub。你能找到一个非常好的提交信息吗？你能找到一个非常简短的提交信息吗？你认为提交信息中最重要和最有用的信息是什么？\n任务：协作\n将内容放到GitHub上的主要原因是为了与其他开发者协作。\n与他人协作完成项目\n查看视频\n在你的仓库中，导航到Insights > Community，查看你的项目与推荐的社区标准的比较。\n以下是一些可以改善GitHub仓库的事项：\n- 描述。你是否为项目添加了描述？\n- README。你是否添加了README？GitHub提供了编写README的指导。\n- 贡献指南。你的项目是否有贡献指南？\n- 行为准则。是否有行为准则？\n- 许可证。或许最重要的是，许可证？\n所有这些资源都将有助于新团队成员的入门。这些通常是新贡献者在查看你的代码之前会关注的内容，以了解你的项目是否值得他们投入时间。\n✅ README文件虽然需要时间准备，但经常被忙碌的维护者忽略。你能找到一个特别详细的README示例吗？注意：有一些工具可以帮助创建好的README，你可能会想尝试一下。\n任务：合并代码\n贡献文档帮助人们为项目做贡献。它解释了你希望的贡献类型以及流程如何运作。贡献者需要完成一系列步骤才能为你的GitHub仓库做贡献：\nFork你的仓库。你可能希望人们Fork你的项目。Fork意味着在他们的GitHub个人资料中创建你的仓库的副本。\n克隆。然后他们会将项目克隆到本地机器。\n创建分支。你会希望他们为自己的工作创建一个分支。\n专注于一个领域的更改。要求贡献者一次专注于一个方面的贡献——这样你合并他们工作的可能性会更高。想象他们修复了一个bug，添加了一个新功能，并更新了几个测试——如果你只想实现其中的2个或3个，或者1个更改怎么办？\n✅ 想象一个分支在编写和发布优质代码时特别重要的场景。你能想到哪些用例？\n注意，成为你希望看到的改变，自己也为自己的工作创建分支。你进行的任何提交都会在当前“检出”的分支上进行。使用git status查看当前分支。\n让我们来看看贡献者的工作流程。假设贡献者已经Fork并克隆了仓库，因此他们在本地机器上有一个准备工作的Git仓库：\n创建分支。使用git branch命令创建一个分支，包含他们计划贡献的更改：\nbash\ngit branch [branch-name]\n切换到工作分支。使用git switch切换到指定分支并更新工作目录：\nbash\ngit switch [branch-name]\n进行工作。此时你可以添加更改。别忘了用以下命令告诉Git：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1875,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "22442642c30cce5cc37f5d11b7429dc2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "bash git push -u origin main 这会将你的“main”分支中的提交发送到GitHub。 添加更多更改。如果你想继续进行更改并将其推送到GitHub，你只需要使用以下三个命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能还需要采用gitignore文件，以防止你不想跟踪的文件出现在GitHub上——例如存储在同一文件夹中的笔记文件，但不适合放在公共仓库中。你可以在gitignore模板中找到gitignore文件的模板。 提交信息 一个好的Git提交主题行可以完成以下句子： 如果应用此提交，它将<你的主题行> 对于主题行，请使用命令式现在时：“更改”而不是“已更改”或“正在更改”。 在正文中（可选）也使用命令式现在时。正文应包括更改的动机，并与之前的行为进行对比。你是在解释“为什么”，而不是“如何”。 ✅ 花几分钟浏览GitHub。你能找到一个非常好的提交信息吗？你能找到一个非常简短的提交信息吗？你认为提交信息中最重要和最有用的信息是什么？ 任务：协作 将内容放到GitHub上的主要原因是为了与其他开发者协作。 与他人协作完成项目 查看视频 在你的仓库中，导航到Insights > Community，查看你的项目与推荐的社区标准的比较。 以下是一些可以改善GitHub仓库的事项： - 描述。你是否为项目添加了描述？ - README。你是否添加了README？GitHub提供了编写README的指导。 - 贡献指南。你的项目是否有贡献指南？ - 行为准则。是否有行为准则？ - 许可证。或许最重要的是，许可证？ 所有这些资源都将有助于新团队成员的入门。这些通常是新贡献者在查看你的代码之前会关注的内容，以了解你的项目是否值得他们投入时间。 ✅ README文件虽然需要时间准备，但经常被忙碌的维护者忽略。你能找到一个特别详细的README示例吗？注意：有一些工具可以帮助创建好的README，你可能会想尝试一下。 任务：合并代码 贡献文档帮助人们为项目做贡献。它解释了你希望的贡献类型以及流程如何运作。贡献者需要完成一系列步骤才能为你的GitHub仓库做贡献： Fork你的仓库。你可能希望人们Fork你的项目。Fork意味着在他们的GitHub个人资料中创建你的仓库的副本。 克隆。然后他们会将项目克隆到本地机器。 创建分支。你会希望他们为自己的工作创建一个分支。 专注于一个领域的更改。要求贡献者一次专注于一个方面的贡献——这样你合并他们工作的可能性会更高。想象他们修复了一个bug，添加了一个新功能，并更新了几个测试——如果你只想实现其中的2个或3个，或者1个更改怎么办？ ✅ 想象一个分支在编写和发布优质代码时特别重要的场景。你能想到哪些用例？ 注意，成为你希望看到的改变，自己也为自己的工作创建分支。你进行的任何提交都会在当前“检出”的分支上进行。使用git status查看当前分支。 让我们来看看贡献者的工作流程。假设贡献者已经Fork并克隆了仓库，因此他们在本地机器上有一个准备工作的Git仓库： 创建分支。使用git branch命令创建一个分支，包含他们计划贡献的更改： bash git branch [branch-name] 切换到工作分支。使用git switch切换到指定分支并更新工作目录： bash git switch [branch-name] 进行工作。此时你可以添加更改。别忘了用以下命令告诉Git： bash git addgit commit -m \"my changes\"\n确保为你的提交起一个好名字，对你自己和维护者来说都很重要。\n将工作与main分支合并。完成工作后，你希望将你的工作与main分支的工作合并。main分支可能已经发生了变化，因此请确保首先更新到最新状态，使用以下命令：\nbash\ngit switch main\ngit pull\n此时你需要确保任何冲突（Git无法轻松合并的情况）发生在你的工作分支中。因此运行以下命令：\nbash\ngit switch [branch_name]\ngit merge main\n这会将main中的所有更改带入你的分支，希望你可以继续。如果不能，VS Code会告诉你Git“困惑”的地方，你只需修改受影响的文件以确定哪个内容最准确。\n将工作发送到GitHub。将工作发送到GitHub意味着两件事：将分支推送到你的仓库，然后打开一个PR（Pull Request）。\nbash\ngit push --set-upstream origin [branch-name]\n上述命令会在你的Fork仓库中创建分支。\n打开PR。接下来，你需要打开一个PR。通过导航到GitHub上的Fork仓库，你会看到GitHub提示是否要创建一个新的PR，点击它，你会进入一个界面，可以更改提交信息标题，给出更合适的描述。现在你Fork的仓库的维护者会看到这个PR，_希望_他们会欣赏并合并你的PR。你现在是贡献者了，太棒了 :)\n清理。成功合并PR后，清理工作被认为是良好的实践。你需要清理本地分支和推送到GitHub的分支。首先用以下命令在本地删除它：\nbash\ngit branch -d [branch-name]\n确保你进入了 GitHub 页面，找到你刚刚推送的远程分支，并将其删除。\nPull request（拉取请求）这个术语听起来有点奇怪，因为实际上你是想将你的更改推送到项目中。但项目的维护者（项目所有者）或核心团队需要在将你的更改合并到项目的“主”分支之前进行审查，因此实际上你是在请求维护者对更改做出决策。\n拉取请求是一个用于比较和讨论分支中引入的差异的地方，可以进行审查、评论、集成测试等。一个好的拉取请求通常遵循与提交信息相似的规则。你可以在问题跟踪器中引用一个问题，例如当你的工作解决了某个问题时。这可以通过使用 # 后跟问题编号来完成，例如 #97。\n🤞希望所有检查都通过，项目所有者将你的更改合并到项目中🤞\n更新你当前的本地工作分支，使其包含 GitHub 上对应远程分支的所有新提交：\ngit pull\n如何为开源项目做贡献\n首先，找到一个你感兴趣并希望贡献更改的 GitHub 仓库（或 repo）。你需要将其内容复制到你的电脑上。\n✅ 找到“适合初学者”的仓库的一个好方法是通过标签 'good-first-issue' 进行搜索。\n有几种复制代码的方法，其中一种是使用 HTTPS、SSH 或 GitHub CLI（命令行界面）“克隆”仓库的内容。\n打开你的终端并像这样克隆仓库：\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2223,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "6b6e50ad245e84a5177c2f8b8391bc1f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "进行工作。此时你可以添加更改。别忘了用以下命令告诉Git： bash git addgit commit -m \"my changes\" 确保为你的提交起一个好名字，对你自己和维护者来说都很重要。 将工作与main分支合并。完成工作后，你希望将你的工作与main分支的工作合并。main分支可能已经发生了变化，因此请确保首先更新到最新状态，使用以下命令： bash git switch main git pull 此时你需要确保任何冲突（Git无法轻松合并的情况）发生在你的工作分支中。因此运行以下命令： bash git switch [branch_name] git merge main 这会将main中的所有更改带入你的分支，希望你可以继续。如果不能，VS Code会告诉你Git“困惑”的地方，你只需修改受影响的文件以确定哪个内容最准确。 将工作发送到GitHub。将工作发送到GitHub意味着两件事：将分支推送到你的仓库，然后打开一个PR（Pull Request）。 bash git push --set-upstream origin [branch-name] 上述命令会在你的Fork仓库中创建分支。 打开PR。接下来，你需要打开一个PR。通过导航到GitHub上的Fork仓库，你会看到GitHub提示是否要创建一个新的PR，点击它，你会进入一个界面，可以更改提交信息标题，给出更合适的描述。现在你Fork的仓库的维护者会看到这个PR，_希望_他们会欣赏并合并你的PR。你现在是贡献者了，太棒了 :) 清理。成功合并PR后，清理工作被认为是良好的实践。你需要清理本地分支和推送到GitHub的分支。首先用以下命令在本地删除它： bash git branch -d [branch-name] 确保你进入了 GitHub 页面，找到你刚刚推送的远程分支，并将其删除。 Pull request（拉取请求）这个术语听起来有点奇怪，因为实际上你是想将你的更改推送到项目中。但项目的维护者（项目所有者）或核心团队需要在将你的更改合并到项目的“主”分支之前进行审查，因此实际上你是在请求维护者对更改做出决策。 拉取请求是一个用于比较和讨论分支中引入的差异的地方，可以进行审查、评论、集成测试等。一个好的拉取请求通常遵循与提交信息相似的规则。你可以在问题跟踪器中引用一个问题，例如当你的工作解决了某个问题时。这可以通过使用 # 后跟问题编号来完成，例如 #97。 🤞希望所有检查都通过，项目所有者将你的更改合并到项目中🤞 更新你当前的本地工作分支，使其包含 GitHub 上对应远程分支的所有新提交： git pull 如何为开源项目做贡献 首先，找到一个你感兴趣并希望贡献更改的 GitHub 仓库（或 repo）。你需要将其内容复制到你的电脑上。 ✅ 找到“适合初学者”的仓库的一个好方法是通过标签 'good-first-issue' 进行搜索。 有几种复制代码的方法，其中一种是使用 HTTPS、SSH 或 GitHub CLI（命令行界面）“克隆”仓库的内容。 打开你的终端并像这样克隆仓库： git clone https://githubcom/ProjectURL\n要开始处理项目，切换到正确的文件夹：\ncd ProjectURL\n你还可以使用 Codespaces（GitHub 的嵌入式代码编辑器/云开发环境）或 GitHub Desktop 打开整个项目。\n最后，你也可以下载代码的压缩文件夹。\n关于 GitHub 的一些有趣的事情\n你可以对 GitHub 上的任何公共仓库进行加星、关注或“fork”（派生）。你可以在右上角的下拉菜单中找到你加星的仓库。这就像为代码添加书签。\n项目通常有一个问题跟踪器，大多数情况下在 GitHub 的“Issues”标签中，除非另有说明，人们会在这里讨论与项目相关的问题。而“Pull Requests”标签是人们讨论和审查正在进行的更改的地方。\n项目可能还会在论坛、邮件列表或聊天频道（如 Slack、Discord 或 IRC）中进行讨论。\n✅ 浏览一下你的新 GitHub 仓库，尝试一些操作，比如编辑设置、向仓库添加信息以及创建项目（例如看板）。你可以做很多事情！\n🚀 挑战\n与朋友配对，共同处理彼此的代码。协作创建一个项目，派生代码，创建分支并合并更改。\n课后测验\n课后测验\n复习与自学\n阅读更多关于如何为开源软件做贡献的内容。\nGit 速查表。\n多练习，多实践。GitHub 提供了很棒的学习路径：skills",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1467,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "3f7f47067a19e4a68b5ffbbd28b1b155",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "git branch -d [branch-name] 确保你进入了 GitHub 页面，找到你刚刚推送的远程分支，并将其删除。 Pull request（拉取请求）这个术语听起来有点奇怪，因为实际上你是想将你的更改推送到项目中。但项目的维护者（项目所有者）或核心团队需要在将你的更改合并到项目的“主”分支之前进行审查，因此实际上你是在请求维护者对更改做出决策。 拉取请求是一个用于比较和讨论分支中引入的差异的地方，可以进行审查、评论、集成测试等。一个好的拉取请求通常遵循与提交信息相似的规则。你可以在问题跟踪器中引用一个问题，例如当你的工作解决了某个问题时。这可以通过使用 # 后跟问题编号来完成，例如 #97。 🤞希望所有检查都通过，项目所有者将你的更改合并到项目中🤞 更新你当前的本地工作分支，使其包含 GitHub 上对应远程分支的所有新提交： git pull 如何为开源项目做贡献 首先，找到一个你感兴趣并希望贡献更改的 GitHub 仓库（或 repo）。你需要将其内容复制到你的电脑上。 ✅ 找到“适合初学者”的仓库的一个好方法是通过标签 'good-first-issue' 进行搜索。 有几种复制代码的方法，其中一种是使用 HTTPS、SSH 或 GitHub CLI（命令行界面）“克隆”仓库的内容。 打开你的终端并像这样克隆仓库： git clone https://githubcom/ProjectURL 要开始处理项目，切换到正确的文件夹： cd ProjectURL 你还可以使用 Codespaces（GitHub 的嵌入式代码编辑器/云开发环境）或 GitHub Desktop 打开整个项目。 最后，你也可以下载代码的压缩文件夹。 关于 GitHub 的一些有趣的事情 你可以对 GitHub 上的任何公共仓库进行加星、关注或“fork”（派生）。你可以在右上角的下拉菜单中找到你加星的仓库。这就像为代码添加书签。 项目通常有一个问题跟踪器，大多数情况下在 GitHub 的“Issues”标签中，除非另有说明，人们会在这里讨论与项目相关的问题。而“Pull Requests”标签是人们讨论和审查正在进行的更改的地方。 项目可能还会在论坛、邮件列表或聊天频道（如 Slack、Discord 或 IRC）中进行讨论。 ✅ 浏览一下你的新 GitHub 仓库，尝试一些操作，比如编辑设置、向仓库添加信息以及创建项目（例如看板）。你可以做很多事情！ 🚀 挑战 与朋友配对，共同处理彼此的代码。协作创建一个项目，派生代码，创建分支并合并更改。 课后测验 课后测验 复习与自学 阅读更多关于如何为开源软件做贡献的内容。 Git 速查表。 多练习，多实践。GitHub 提供了很棒的学习路径：skillsgithub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 934,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "710907f9d4a112d65f1131130a753913",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub简介",
    "content": "git branch -d [branch-name] 确保你进入了 GitHub 页面，找到你刚刚推送的远程分支，并将其删除。 Pull request（拉取请求）这个术语听起来有点奇怪，因为实际上你是想将你的更改推送到项目中。但项目的维护者（项目所有者）或核心团队需要在将你的更改合并到项目的“主”分支之前进行审查，因此实际上你是在请求维护者对更改做出决策。 拉取请求是一个用于比较和讨论分支中引入的差异的地方，可以进行审查、评论、集成测试等。一个好的拉取请求通常遵循与提交信息相似的规则。你可以在问题跟踪器中引用一个问题，例如当你的工作解决了某个问题时。这可以通过使用 # 后跟问题编号来完成，例如 #97。 🤞希望所有检查都通过，项目所有者将你的更改合并到项目中🤞 更新你当前的本地工作分支，使其包含 GitHub 上对应远程分支的所有新提交： git pull 如何为开源项目做贡献 首先，找到一个你感兴趣并希望贡献更改的 GitHub 仓库（或 repo）。你需要将其内容复制到你的电脑上。 ✅ 找到“适合初学者”的仓库的一个好方法是通过标签 'good-first-issue' 进行搜索。 有几种复制代码的方法，其中一种是使用 HTTPS、SSH 或 GitHub CLI（命令行界面）“克隆”仓库的内容。 打开你的终端并像这样克隆仓库： git clone https://githubcom/ProjectURL 要开始处理项目，切换到正确的文件夹： cd ProjectURL 你还可以使用 Codespaces（GitHub 的嵌入式代码编辑器/云开发环境）或 GitHub Desktop 打开整个项目。 最后，你也可以下载代码的压缩文件夹。 关于 GitHub 的一些有趣的事情 你可以对 GitHub 上的任何公共仓库进行加星、关注或“fork”（派生）。你可以在右上角的下拉菜单中找到你加星的仓库。这就像为代码添加书签。 项目通常有一个问题跟踪器，大多数情况下在 GitHub 的“Issues”标签中，除非另有说明，人们会在这里讨论与项目相关的问题。而“Pull Requests”标签是人们讨论和审查正在进行的更改的地方。 项目可能还会在论坛、邮件列表或聊天频道（如 Slack、Discord 或 IRC）中进行讨论。 ✅ 浏览一下你的新 GitHub 仓库，尝试一些操作，比如编辑设置、向仓库添加信息以及创建项目（例如看板）。你可以做很多事情！ 🚀 挑战 与朋友配对，共同处理彼此的代码。协作创建一个项目，派生代码，创建分支并合并更改。 课后测验 课后测验 复习与自学 阅读更多关于如何为开源软件做贡献的内容。 Git 速查表。 多练习，多实践。GitHub 提供了很棒的学习路径：skillsgithubcom:\nGitHub 的第一周\n你还可以找到更高级的课程。\n作业\n完成GitHub 的第一周课程。\n免责声明：\n本文档使用AI翻译服务Co-op Translator进行翻译。尽管我们努力确保翻译的准确性，但请注意，自动翻译可能包含错误或不准确之处。应以原文档的原始语言版本为权威来源。对于关键信息，建议使用专业人工翻译。我们对因使用本翻译而引起的任何误解或误读不承担责任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16061,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\zh\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1105,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "58d395616bba9d226b6ac01f395069a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\docs\\_sidebar.md",
    "source_type": "git_repo",
    "title": "_sidebar",
    "content": "介紹\n1\n2\n3\nJS 基礎\n4\n5\n6\n7\nHTML、CSS、JS\n8\n9\n10\n打字遊戲\n11\n瀏覽器擴展\n12\n13\n14\n太空遊戲\n15\n16\n17\n18\n19\n20\n銀行專案\n21\n22\n23\n24\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2149,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\docs\\_sidebar.md",
      "source_type": "git_repo"
    },
    "token_count": 274,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "cad7205248a70ee6717059f4dda3c377",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\docs\\_navbar.md",
    "source_type": "git_repo",
    "title": "_navbar",
    "content": "翻譯\nEnglish (United States)\nবাংলা\n中文(中国)\n中文(台湾)\nEspañol\nFrançais\nΕλληνικά\nहिन्दी\nBahasa Melayu\nമലയാളം\nதமிழ்\nతెలుగు\nBahasa Indonesia\nItaliano\n日本語\nNederlands\nनेपाली\nPortuguês\nРусский\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1537,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\docs\\_navbar.md",
      "source_type": "git_repo"
    },
    "token_count": 303,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "6cf8f2b52a8c41acb9840f4ec97abdf5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\lesson-template\\assignment.md",
    "source_type": "git_repo",
    "title": "[Assignment Name]",
    "content": "[Assignment Name]\n說明\n評分標準\n| 評分標準 | 優秀 | 合格 | 需要改進 |\n| -------- | ---- | ---- | -------- |\n|          |      |      |          |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 852,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\lesson-template\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 248,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "192ed992f69fecf1c9e85df30343c157",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\lesson-template\\README.md",
    "source_type": "git_repo",
    "title": "[課程主題]",
    "content": "[課程主題]\n課前測驗\n[描述我們將學習的內容]\n介紹\n描述將涵蓋的內容\n注意事項\n前置條件\n在本課程之前應完成哪些步驟？\n準備工作\n開始本課程的準備步驟\n[逐步瀏覽內容區塊]\n[主題 1]\n任務：\n共同合作逐步改進你的代碼庫，以使用共享代碼構建專案：\nhtml\ncode blocks\n✅ 知識檢查 - 利用這個時機通過開放性問題擴展學生的知識\n[主題 2]\n[主題 3]\n🚀 挑戰：為學生設計一個課堂合作挑戰，以改進專案\n可選：如果適合，添加完成課程後的 UI 截圖\n課後測驗\n回顧與自學\n作業截止日期 [MM/YY]: 作業名稱\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\lesson-template\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 501,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "fa09bea4340b0e0c17145a205a98c526",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "測驗應用程式\n這些測驗是資料科學課程的課前和課後測驗，課程網址為：https://aka ms/webdev-beginners\n新增翻譯的測驗集\n透過在 assets/translations 資料夾中建立相應的測驗結構來新增測驗翻譯。原始測驗位於 assets/translations/en。測驗分為多個組別。請確保編號與正確的測驗部分對齊。在此課程中共有 40 個測驗，編號從 0 開始。\n以下是翻譯檔案的結構範例：\n```\n[\n{\n\"title\": \"A title\",\n\"complete\": \"A complete button title\",\n\"error\": \"An error message upon selecting the wrong answer\",\n\"quizzes\": [\n{\n\"id\": 1,\n\"title\": \"Title\",\n\"quiz\": [\n{\n\"questionText\": \"The question asked\",\n\"answerOptions\": [\n{\n\"answerText\": \"Option 1 title\",\n\"isCorrect\": true\n},\n{\n\"answerText\": \"Option 2 title\",\n\"isCorrect\": false\n}\n]\n}\n]\n}\n]\n}\n]\n```\n編輯翻譯後，請編輯翻譯資料夾中的 index js 檔案，按照 en 中的慣例匯入所有檔案。\n編輯 assets/translations 中的 index js 檔案以匯入新的翻譯檔案。\n例如，如果您的翻譯 JSON 檔案是 ex json，請將 'ex' 設為本地化鍵，然後按照以下方式匯入：\nindex js\n```\nimport ex from \" /ex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "73a6e2af24c1b125ebb70593875af456",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "\"error\": \"An error message upon selecting the wrong answer\", \"quizzes\": [ { \"id\": 1, \"title\": \"Title\", \"quiz\": [ { \"questionText\": \"The question asked\", \"answerOptions\": [ { \"answerText\": \"Option 1 title\", \"isCorrect\": true }, { \"answerText\": \"Option 2 title\", \"isCorrect\": false } ] } ] } ] } ] ``` 編輯翻譯後，請編輯翻譯資料夾中的 index js 檔案，按照 en 中的慣例匯入所有檔案。 編輯 assets/translations 中的 index js 檔案以匯入新的翻譯檔案。 例如，如果您的翻譯 JSON 檔案是 ex json，請將 'ex' 設為本地化鍵，然後按照以下方式匯入： index js ``` import ex from \" /exjson\";\n// if 'ex' is localization key then enter it like so in `messages` to expose it\nconst messages = {\nex: ex[0],\n};\nexport default messages;\n```\n在本地執行測驗應用程式\n先決條件\n一個 GitHub 帳戶\nNode js 和 Git\n安裝與設置\n從此 範本 建立一個儲存庫\n複製您的新儲存庫，並導航至 quiz-app\nbash\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 385,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "dca5f6698d3129eee68853717f9d594f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "} ] ``` 編輯翻譯後，請編輯翻譯資料夾中的 index js 檔案，按照 en 中的慣例匯入所有檔案。 編輯 assets/translations 中的 index js 檔案以匯入新的翻譯檔案。 例如，如果您的翻譯 JSON 檔案是 ex json，請將 'ex' 設為本地化鍵，然後按照以下方式匯入： index js ``` import ex from \" /exjson\"; // if 'ex' is localization key then enter it like so in `messages` to expose it const messages = { ex: ex[0], }; export default messages; ``` 在本地執行測驗應用程式 先決條件 一個 GitHub 帳戶 Node js 和 Git 安裝與設置 從此 範本 建立一個儲存庫 複製您的新儲存庫，並導航至 quiz-app bash git clone https://githubcom/your-github-organization/repo-name\ncd repo-name/quiz-app\n安裝 npm 套件與依賴項\nbash\nnpm install\n建置應用程式\n要建置解決方案，請執行：\nbash\nnpm run build\n啟動應用程式\n要執行解決方案，請執行：\nbash\nnpm run dev\n[可選] 程式碼檢查\n要確保程式碼已檢查，請執行：\nbash\nnpm run lint\n部署測驗應用程式至 Azure\n先決條件\n一個 Azure 訂閱。您可以在 此處 免費註冊。\n部署此測驗應用程式的成本估算：免費\n登入 Azure 後，選擇一個訂閱和資源群組，然後：\n靜態網頁應用程式詳細資訊：提供名稱並選擇一個主機方案\nGitHub 登入：將您的部署來源設置為 GitHub，然後登入並填寫表單中的必要欄位：\n組織 – 選擇您的組織。\n儲存庫 – 選擇 Web Dev for Beginners 課程儲存庫。\n分支 - 選擇分支（main）\n建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測您的應用程式所使用的框架。\n應用程式位置 -",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 758,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "f5f355d98d9ba42754402e7a78810446",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "帳戶 Node js 和 Git 安裝與設置 從此 範本 建立一個儲存庫 複製您的新儲存庫，並導航至 quiz-app bash git clone https://githubcom/your-github-organization/repo-name cd repo-name/quiz-app 安裝 npm 套件與依賴項 bash npm install 建置應用程式 要建置解決方案，請執行： bash npm run build 啟動應用程式 要執行解決方案，請執行： bash npm run dev [可選] 程式碼檢查 要確保程式碼已檢查，請執行： bash npm run lint 部署測驗應用程式至 Azure 先決條件 一個 Azure 訂閱。您可以在 此處 免費註冊。 部署此測驗應用程式的成本估算：免費 登入 Azure 後，選擇一個訂閱和資源群組，然後： 靜態網頁應用程式詳細資訊：提供名稱並選擇一個主機方案 GitHub 登入：將您的部署來源設置為 GitHub，然後登入並填寫表單中的必要欄位： 組織 – 選擇您的組織。 儲存庫 – 選擇 Web Dev for Beginners 課程儲存庫。 分支 - 選擇分支（main） 建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測您的應用程式所使用的框架。 應用程式位置 -/quiz-app\nAPI 位置 -\n輸出位置 - dist\n部署：點擊 'Review + Create'，然後點擊 'Create'\n部署完成後，工作流程檔案將會在您的儲存庫的",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "9a9626802d0f4f1449a9b13774757356",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "git clone https://githubcom/your-github-organization/repo-name cd repo-name/quiz-app 安裝 npm 套件與依賴項 bash npm install 建置應用程式 要建置解決方案，請執行： bash npm run build 啟動應用程式 要執行解決方案，請執行： bash npm run dev [可選] 程式碼檢查 要確保程式碼已檢查，請執行： bash npm run lint 部署測驗應用程式至 Azure 先決條件 一個 Azure 訂閱。您可以在 此處 免費註冊。 部署此測驗應用程式的成本估算：免費 登入 Azure 後，選擇一個訂閱和資源群組，然後： 靜態網頁應用程式詳細資訊：提供名稱並選擇一個主機方案 GitHub 登入：將您的部署來源設置為 GitHub，然後登入並填寫表單中的必要欄位： 組織 – 選擇您的組織。 儲存庫 – 選擇 Web Dev for Beginners 課程儲存庫。 分支 - 選擇分支（main） 建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測您的應用程式所使用的框架。 應用程式位置 -/quiz-app API 位置 - 輸出位置 - dist 部署：點擊 'Review + Create'，然後點擊 'Create' 部署完成後，工作流程檔案將會在您的儲存庫的github 資料夾中建立。此工作流程檔案包含觸發應用程式重新部署至 Azure 的事件指令，例如，在 main 分支上的 push 等。\n工作流程檔案範例\n以下是 GitHub Actions 工作流程檔案的範例：\nname: Azure Static Web Apps CI/CD\n```\non:\npush:\nbranches:\n- main\npull_request:\ntypes: [opened, synchronize, reopened, closed]\nbranches:\n- main\njobs:\nbuild_and_deploy_job:\nruns-on: ubuntu-latest\nname: Build and Deploy Job\nsteps:\n- uses: actions/checkout@v2\n- name: Build And Deploy\nid: builddeploy\nuses: Azure/static-web-apps-deploy@v1\nwith:\nazure_static_web_apps_api_token: ${{ secrets",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 742,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "3ba267bf1d66b7cfe71c18aa92504f8e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "選擇分支（main） 建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測您的應用程式所使用的框架。 應用程式位置 -/quiz-app API 位置 - 輸出位置 - dist 部署：點擊 'Review + Create'，然後點擊 'Create' 部署完成後，工作流程檔案將會在您的儲存庫的github 資料夾中建立。此工作流程檔案包含觸發應用程式重新部署至 Azure 的事件指令，例如，在 main 分支上的 push 等。 工作流程檔案範例 以下是 GitHub Actions 工作流程檔案的範例： name: Azure Static Web Apps CI/CD ``` on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v2 - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secretsAZURE_STATIC_WEB_APPS_API_TOKEN }}\nrepo_token: ${{ secrets",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 349,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "8922119ff2a7dc8bd157e66b12d5b027",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "-/quiz-app API 位置 - 輸出位置 - dist 部署：點擊 'Review + Create'，然後點擊 'Create' 部署完成後，工作流程檔案將會在您的儲存庫的github 資料夾中建立。此工作流程檔案包含觸發應用程式重新部署至 Azure 的事件指令，例如，在 main 分支上的 push 等。 工作流程檔案範例 以下是 GitHub Actions 工作流程檔案的範例： name: Azure Static Web Apps CI/CD ``` on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v2 - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secretsAZURE_STATIC_WEB_APPS_API_TOKEN }} repo_token: ${{ secretsGITHUB_TOKEN }}\naction: \"upload\"\napp_location: \"quiz-app\" # App source code path\napi_location: \"\"API source code path optional\noutput_location: \"dist\" #Built app content directory - optional\n```\n部署後：部署完成後，點擊 'Go to Deployment'，然後點擊 'View app in browser'。\n當您的 GitHub Action（工作流程）成功執行後，刷新線上頁面以查看您的應用程式。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 583,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "837a2ae31ecab5bf363790c40d9b6c6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\assignment.md",
    "source_type": "git_repo",
    "title": "改善路由",
    "content": "改善路由\n說明\n目前的路由宣告僅包含模板 ID，但在顯示新頁面時，有時需要更多功能。讓我們透過以下兩個額外功能來改進路由實現：\n為每個模板指定標題，並在模板變更時更新窗口標題為新標題。\n增加一個選項，在模板變更後執行一些程式碼。我們希望每次顯示儀表板頁面時，在開發者主控台中打印 'Dashboard is shown'。\n評分標準\n| 評分標準 | 卓越                                                                                                                          | 合格                                                                                                                                                                                  | 需要改進                                       |\n| -------- | ----------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |\n|          | 兩個功能均已實現並正常運作。標題和程式碼新增功能也適用於在 routes 宣告中新增的路由。                                           | 兩個功能均正常運作，但行為是硬編碼的，無法透過 routes 宣告進行配置。新增第三個具有標題和程式碼新增功能的路由無法正常運作或僅部分運作。                                              | 缺少其中一個功能或功能未正常運作。            |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 580,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b29629b8e04dc1a055ae289d059088f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "使用 vscode dev 建立履歷網站\n當面試官要求你的履歷時，你能直接發送一個網址給他們，這有多酷呢？ 😎\n目標\n完成此任務後，你將學會：\n建立一個網站來展示你的履歷\n先決條件\n一個 GitHub 帳號。如果你還沒有，請前往 GitHub 註冊一個帳號。\n步驟\n步驟 1： 建立一個新的 GitHub 儲存庫，命名為 my-resume\n步驟 2： 在你的儲存庫中建立一個 index html 檔案。我們需要在 github com 上新增至少一個檔案，因為空的儲存庫無法在 vscode dev 中開啟。\n點擊 creating a new file 連結，輸入檔案名稱 index html，然後選擇 Commit new file 按鈕。\n步驟 3： 開啟 VSCode dev 並選擇 Open Remote Repository 按鈕。\n複製剛剛為你的履歷網站建立的儲存庫網址，並將其貼到輸入框中：\n將 your-username 替換為你的 GitHub 使用者名稱\nhttps://github com/your-username/my-resume\n✅ 如果成功，你將在瀏覽器中的文字編輯器看到你的專案和 index html 檔案。\n步驟 4： 開啟 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 470,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "df5ba4e7409831879dba0b3fa71821bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "使用 vscode dev 建立履歷網站\n當面試官要求你的履歷時，你能直接發送一個網址給他們，這有多酷呢？ 😎\n目標\n完成此任務後，你將學會：\n建立一個網站來展示你的履歷\n先決條件\n一個 GitHub 帳號。如果你還沒有，請前往 GitHub 註冊一個帳號。\n步驟\n步驟 1： 建立一個新的 GitHub 儲存庫，命名為 my-resume\n步驟 2： 在你的儲存庫中建立一個 index html 檔案。我們需要在 github com 上新增至少一個檔案，因為空的儲存庫無法在 vscode dev 中開啟。\n點擊 creating a new file 連結，輸入檔案名稱 index html，然後選擇 Commit new file 按鈕。\n步驟 3： 開啟 VSCode dev 並選擇 Open Remote Repository 按鈕。\n複製剛剛為你的履歷網站建立的儲存庫網址，並將其貼到輸入框中：\n將 your-username 替換為你的 GitHub 使用者名稱\nhttps://github com/your-username/my-resume\n✅ 如果成功，你將在瀏覽器中的文字編輯器看到你的專案和 index html 檔案。\n步驟 4： 開啟 indexhtml 檔案，將以下程式碼貼到你的編輯區域並儲存。\n負責履歷網站內容的 HTML 程式碼。\n你的名字在這裡！\n你的名字在這裡！\n你的角色！\n聯絡方式\n在這裡填寫你的電子郵件\n在這裡填寫你的 GitHub 使用者名稱！\n在這裡填寫你的 LinkedIn 使用者名稱！\n技能\n技能 1！\n技能 2！\n技能 3！\n技能 4！\n教育背景\n在這裡填寫你的課程！\n在這裡填寫你的學校名稱！\n開始 - 結束日期\n關於我\n在這裡寫一段關於自己的簡介！\n工作經歷\n職位名稱\n在這裡填寫組織名稱 | 開始月份 – 結束月份\n任務 1 - 描述你做了什麼！\n任務 2 - 描述你做了什麼！\n描述你的貢獻成果/影響\n職位名稱 2\n在這裡填寫組織名稱 | 開始月份 – 結束月份\n任務 1 - 描述你做了什麼！\n任務 2 - 描述你做了什麼！\n描述你的貢獻成果/影響\n將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。\n步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 985,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "f2e6271e901399afbd1ea5ccb218bc6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "indexhtml 檔案，將以下程式碼貼到你的編輯區域並儲存。 負責履歷網站內容的 HTML 程式碼。 你的名字在這裡！ 你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始 - 結束日期 關於我 在這裡寫一段關於自己的簡介！ 工作經歷 職位名稱 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 職位名稱 2 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。 步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File圖示，並在你的專案中建立兩個新檔案：style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 536,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "9a65db93f4919600fdfcd3f19d8ffa39",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "indexhtml 檔案，將以下程式碼貼到你的編輯區域並儲存。 負責履歷網站內容的 HTML 程式碼。 你的名字在這裡！ 你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始 - 結束日期 關於我 在這裡寫一段關於自己的簡介！ 工作經歷 職位名稱 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 職位名稱 2 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。 步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File圖示，並在你的專案中建立兩個新檔案：stylecss 和 codeswing",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 540,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "da7560a047c2f341b03786c4156f237a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "負責履歷網站內容的 HTML 程式碼。 你的名字在這裡！ 你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始 - 結束日期 關於我 在這裡寫一段關於自己的簡介！ 工作經歷 職位名稱 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 職位名稱 2 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。 步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File圖示，並在你的專案中建立兩個新檔案：stylecss 和 codeswingjson。\n步驟 6： 開啟 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 518,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "24fbde352c980de113f23acf5eb8f612",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始 - 結束日期 關於我 在這裡寫一段關於自己的簡介！ 工作經歷 職位名稱 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 職位名稱 2 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。 步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File圖示，並在你的專案中建立兩個新檔案：stylecss 和 codeswingjson。 步驟 6： 開啟 stylecss 檔案，將以下程式碼貼上並儲存。\n用於格式化網站佈局的 CSS 程式碼。\nbody {\nfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\nfont-size: 16px;\nmax-width: 960px;\nmargin: auto;\n}\nh1 {\nfont-size: 3em;\nletter-spacing:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 579,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "ba2744f003a81c5e5af0122d522d4815",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "關於我 在這裡寫一段關於自己的簡介！ 工作經歷 職位名稱 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 職位名稱 2 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。 步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File圖示，並在你的專案中建立兩個新檔案：stylecss 和 codeswingjson。 步驟 6： 開啟 stylecss 檔案，將以下程式碼貼上並儲存。 用於格式化網站佈局的 CSS 程式碼。 body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em;\npadding-top: 1em;\npadding-bottom: 1em;\n}\nh2 {\nfont-size: 1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 457,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "b60927730ec2ce19dd9757b7a2ac4de7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 職位名稱 2 在這裡填寫組織名稱 | 開始月份 – 結束月份 任務 1 - 描述你做了什麼！ 任務 2 - 描述你做了什麼！ 描述你的貢獻成果/影響 將你的履歷細節替換掉 HTML 程式碼中的 佔位文字。 步驟 5： 將滑鼠懸停在 My-Resume 資料夾上，點擊 New File圖示，並在你的專案中建立兩個新檔案：stylecss 和 codeswingjson。 步驟 6： 開啟 stylecss 檔案，將以下程式碼貼上並儲存。 用於格式化網站佈局的 CSS 程式碼。 body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em; padding-top: 1em; padding-bottom: 1em; } h2 { font-size: 15em;\npadding-bottom: 1em;\n}\nh3 {\nfont-size: 1em;\npadding-bottom: 1em;\n}\nmain {\ndisplay: grid;\ngrid-template-columns: 40% 60%;\nmargin-top: 3em;\n}\nheader {\ntext-align: center;\nmargin: auto 2em;\n}\nsection {\nmargin: auto 1em 4em 2em;\n}\ni {\nmargin-right: 5em;\n}\np {\nmargin:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "79334a66c9dbf8768258a19c846538c2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "CSS 程式碼。 body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em; padding-top: 1em; padding-bottom: 1em; } h2 { font-size: 15em; padding-bottom: 1em; } h3 { font-size: 1em; padding-bottom: 1em; } main { display: grid; grid-template-columns: 40% 60%; margin-top: 3em; } header { text-align: center; margin: auto 2em; } section { margin: auto 1em 4em 2em; } i { margin-right: 5em; } p { margin:2em auto\n}\nhr {\nborder: none;\nbackground-color: lightgray;\nheight: 1px;\n}\nh1, h2, h3 {\nfont-weight: 100;\nmargin-bottom: 0;\n}\n#mainLeft {\nborder-right: 1px solid lightgray;\n}\n步驟 6： 開啟 codeswing",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 257,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "a2f0efe35b2732bda3306b69cc4a18af",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "15em; padding-bottom: 1em; } h3 { font-size: 1em; padding-bottom: 1em; } main { display: grid; grid-template-columns: 40% 60%; margin-top: 3em; } header { text-align: center; margin: auto 2em; } section { margin: auto 1em 4em 2em; } i { margin-right: 5em; } p { margin:2em auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } 步驟 6： 開啟 codeswingjson 檔案，將以下程式碼貼上並儲存。\n{\n\"scripts\": [],\n\"styles\": []\n}\n步驟 7： 安裝 Codeswing extension 以在程式碼區域中預覽履歷網站。\n點擊活動列上的 Extensions 圖示，輸入 Codeswing。點擊展開活動列上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。安裝擴展後，觀察你的程式碼區域，看看專案的變化 😃。\n安裝擴展後，你的螢幕上將會看到以下內容。\n如果你對所做的更改感到滿意，將滑鼠懸停在 Changes 資料夾上，點擊 + 按鈕以暫存更改。\n輸入提交訊息 (描述你對專案所做的更改)，然後點擊 check 提交更改。完成專案後，選擇左上角的漢堡選單圖示返回 GitHub 上的儲存庫。\n恭喜 🎉 你已經在幾個步驟內使用 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 561,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "ecbcb8a4538b9fda68459393a900501d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "} i { margin-right: 5em; } p { margin:2em auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } 步驟 6： 開啟 codeswingjson 檔案，將以下程式碼貼上並儲存。 { \"scripts\": [], \"styles\": [] } 步驟 7： 安裝 Codeswing extension 以在程式碼區域中預覽履歷網站。 點擊活動列上的 Extensions 圖示，輸入 Codeswing。點擊展開活動列上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。安裝擴展後，觀察你的程式碼區域，看看專案的變化 😃。 安裝擴展後，你的螢幕上將會看到以下內容。 如果你對所做的更改感到滿意，將滑鼠懸停在 Changes 資料夾上，點擊 + 按鈕以暫存更改。 輸入提交訊息 (描述你對專案所做的更改)，然後點擊 check 提交更改。完成專案後，選擇左上角的漢堡選單圖示返回 GitHub 上的儲存庫。 恭喜 🎉 你已經在幾個步驟內使用 vscodedev 建立了你的履歷網站。\n🚀 挑戰\n開啟一個你有權限進行更改的遠端儲存庫並更新一些檔案。接下來，嘗試建立一個包含更改的新分支並發起 Pull Request。\n回顧與自學\n閱讀更多關於 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 597,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "ff62c6cfa6acf2b6a116f88197bcf08d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } 步驟 6： 開啟 codeswingjson 檔案，將以下程式碼貼上並儲存。 { \"scripts\": [], \"styles\": [] } 步驟 7： 安裝 Codeswing extension 以在程式碼區域中預覽履歷網站。 點擊活動列上的 Extensions 圖示，輸入 Codeswing。點擊展開活動列上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。安裝擴展後，觀察你的程式碼區域，看看專案的變化 😃。 安裝擴展後，你的螢幕上將會看到以下內容。 如果你對所做的更改感到滿意，將滑鼠懸停在 Changes 資料夾上，點擊 + 按鈕以暫存更改。 輸入提交訊息 (描述你對專案所做的更改)，然後點擊 check 提交更改。完成專案後，選擇左上角的漢堡選單圖示返回 GitHub 上的儲存庫。 恭喜 🎉 你已經在幾個步驟內使用 vscodedev 建立了你的履歷網站。 🚀 挑戰 開啟一個你有權限進行更改的遠端儲存庫並更新一些檔案。接下來，嘗試建立一個包含更改的新分支並發起 Pull Request。 回顧與自學 閱讀更多關於 VSCodedev 及其其他功能的資訊。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10110,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 780,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "6613bfbbaa92d5a90462c1a38b61640c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "為您的銀行應用程式設計樣式",
    "content": "為您的銀行應用程式設計樣式\n指示\n建立一個新的 styles css 檔案，並在您目前的 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2146,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 48,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "22fb7c68fe8d5fd76d4ce8b5bb36d5bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "為您的銀行應用程式設計樣式",
    "content": "為您的銀行應用程式設計樣式\n指示\n建立一個新的 styles css 檔案，並在您目前的 indexhtml 檔案中加入連結。在您剛建立的 CSS 檔案中，添加一些樣式，使 登入 和 儀表板 頁面看起來整潔美觀。嘗試創建一個色彩主題，為您的應用程式打造自己的品牌形象。\n提示：如果需要，您可以修改 HTML，並添加新的元素和類別。\n評分標準\n| 評分標準 | 卓越                                                                                                                   | 合格                                                                         | 需要改進                                                                                     |\n| -------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- |\n|          | 所有頁面看起來乾淨且易於閱讀，具有一致的色彩主題，不同的區塊能夠清楚地突出。                                             | 頁面有樣式，但缺乏主題或區塊未清楚劃分。                                         | 頁面缺乏樣式，區塊看起來雜亂無章，資訊難以閱讀。                                             |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2146,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 530,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "f47da52a386442fe0627633ee8c47d59",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 394,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "23d58ced91808b403ed505d85e6fe369",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似以下圖片：\n主要有三個區域，從左到右分別是：\n活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動列，預設為 檔案總管，稱為 側邊欄。\n最右側的程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。\n當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。\n開啟 GitHub 儲存庫\n首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 754,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "0486e41c60f3faa7032bcd513cee22d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似以下圖片：\n主要有三個區域，從左到右分別是：\n活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動列，預設為 檔案總管，稱為 側邊欄。\n最右側的程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。\n當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。\n開啟 GitHub 儲存庫\n首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。\n1使用編輯器\n使用編輯器本身開啟遠端儲存庫。進入 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 789,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "02234bc8fb203d3b72186c4f39641088",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似以下圖片：\n主要有三個區域，從左到右分別是：\n活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動列，預設為 檔案總管，稱為 側邊欄。\n最右側的程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。\n當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。\n開啟 GitHub 儲存庫\n首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。\n1使用編輯器\n使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕：\n您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。\n開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框：\nhttps://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1043,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "b61f342898bf05604d42afec863e95f9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似以下圖片：\n主要有三個區域，從左到右分別是：\n活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動列，預設為 檔案總管，稱為 側邊欄。\n最右側的程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。\n當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。\n開啟 GitHub 儲存庫\n首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。\n1使用編輯器\n使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕：\n您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。\n開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框：\nhttps://githubcom/microsoft/Web-Dev-For-Beginners\n✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1094,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "07f693f5c7f1c27e37c903e21733cafc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似以下圖片：\n主要有三個區域，從左到右分別是：\n活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動列，預設為 檔案總管，稱為 側邊欄。\n最右側的程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。\n當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。\n開啟 GitHub 儲存庫\n首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。\n1使用編輯器\n使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕：\n您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。\n開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框：\nhttps://githubcom/microsoft/Web-Dev-For-Beginners\n✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。\n2使用 URL\n您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1133,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "6a64c156861bfa20106b264d472216d9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程介紹如何使用 VSCode dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。\n學習目標\n在本課程中，您將學習如何：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。\n開始使用 VSCode dev\nVSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似以下圖片：\n主要有三個區域，從左到右分別是：\n活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動列，預設為 檔案總管，稱為 側邊欄。\n最右側的程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。\n當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。\n開啟 GitHub 儲存庫\n首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。\n1使用編輯器\n使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕：\n您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。\n開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框：\nhttps://githubcom/microsoft/Web-Dev-For-Beginners\n✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。\n2使用 URL\n您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1165,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "bc3dff36dbaedd9538244a2187a7e2f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "dev 這款基於網頁的程式碼編輯器，讓您可以在不需要安裝任何軟體的情況下修改程式碼並參與專案。 學習目標 在本課程中，您將學習如何： 在程式碼專案中使用程式碼編輯器 使用版本控制追蹤變更 自訂編輯器以進行開發 先決條件 在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。 開始使用 VSCode dev VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1176,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "a106dcbf9d943360cf715ff5f8d5f9a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "在本課程中，您將學習如何： 在程式碼專案中使用程式碼編輯器 使用版本控制追蹤變更 自訂編輯器以進行開發 先決條件 在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。 開始使用 VSCode dev VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。\n編輯檔案\n在瀏覽器或 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1137,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "97783a516fa5feb5088e783227a7e180",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "自訂編輯器以進行開發 先決條件 在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。 開始使用 VSCode dev VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1112,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "93c4e043880f9e034e28da4bb567a472",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "在開始之前，您需要先建立 GitHub 帳戶。如果尚未建立帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。 開始使用 VSCode dev VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案\n您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1190,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "771771b200a5ee74dd051b8e9aa2fd37",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "簡介 程式碼編輯器是撰寫程式及協作現有程式專案的重要工具。一旦了解編輯器的基本功能及如何使用其特性，您便能在撰寫程式碼時靈活運用。 開始使用 VSCode dev VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案 您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file' 圖示，命名檔案並按下 Enter。\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1166,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "65f8502cae6c0c7e51195b2762ed60cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "VSCode dev VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案 您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案\n使用 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1103,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "88b32b2b555c4b979da275a3b4f6fb5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "VSCode dev 是一款基於網頁的程式碼編輯器。您不需要安裝任何軟體，只需像開啟其他網站一樣使用它。要開始使用編輯器，請開啟以下連結：https://vscodedev。如果您尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似以下圖片： 主要有三個區域，從左到右分別是： 活動列，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動列，預設為 檔案總管，稱為 側邊欄。 最右側的程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始位置。 當您開始撰寫程式碼或修改現有程式碼時，操作將在右側最大的區域進行。您也可以在此區域查看現有程式碼，接下來將進行相關操作。 開啟 GitHub 儲存庫 首先，您需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫，本節將介紹兩種方法，讓您可以開始進行修改。 1使用編輯器 使用編輯器本身開啟遠端儲存庫。進入 VSCodedev，您會看到一個 \"Open Remote Repository\" 按鈕： 您也可以使用指令面板。指令面板是一個輸入框，您可以輸入任何指令或動作的關鍵字來找到相應的指令。使用左上方的選單，選擇 檢視，然後選擇 指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案 您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 非常方便，尤其是在您需要快速更新專案而不想在本地載入任何軟體時。\n要更新程式碼，點擊活動列上的 '檔案總管' 圖示以查看儲存庫中的檔案和資料夾。\n選擇一個檔案以在程式碼區域中開啟，進行修改並儲存。\n完成專案更新後，選擇 版本控制 圖示，該圖示包含您對儲存庫所做的所有新變更。\n要查看您對專案所做的變更，選擇展開的活動列中 Changes 資料夾中的檔案。這將開啟一個 '工作樹'，讓您直觀地查看檔案的變更。紅色表示刪除，綠色表示新增。\n如果您對所做的變更感到滿意，將滑鼠移至 Changes 資料夾並點擊 + 按鈕以暫存變更。暫存表示準備將變更提交到 GitHub。\n如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。\n接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。\n完成專案工作後，選擇左上方的 漢堡選單圖示 返回 github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1598,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "9a8d34083644871825888e6e61e3f28c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "指令面板，或使用以下快捷鍵：Ctrl-Shift-P（MacOS 上為 Command-Shift-P）。 開啟選單後，輸入 open remote repository，然後選擇第一個選項。您參與的或最近開啟的多個儲存庫將顯示出來。您也可以使用完整的 GitHub URL 選擇一個儲存庫。將以下 URL 貼入輸入框： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，您將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 您也可以直接使用 URL 載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但您可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案 您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 非常方便，尤其是在您需要快速更新專案而不想在本地載入任何軟體時。 要更新程式碼，點擊活動列上的 '檔案總管' 圖示以查看儲存庫中的檔案和資料夾。 選擇一個檔案以在程式碼區域中開啟，進行修改並儲存。 完成專案更新後，選擇 版本控制 圖示，該圖示包含您對儲存庫所做的所有新變更。 要查看您對專案所做的變更，選擇展開的活動列中 Changes 資料夾中的檔案。這將開啟一個 '工作樹'，讓您直觀地查看檔案的變更。紅色表示刪除，綠色表示新增。 如果您對所做的變更感到滿意，將滑鼠移至 Changes 資料夾並點擊 + 按鈕以暫存變更。暫存表示準備將變更提交到 GitHub。 如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。\n使用擴充功能\n在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。\n要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。\n您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。\n您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1400,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "5f3410585a18c1507717d72e8a33024d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 為 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案 您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 非常方便，尤其是在您需要快速更新專案而不想在本地載入任何軟體時。 要更新程式碼，點擊活動列上的 '檔案總管' 圖示以查看儲存庫中的檔案和資料夾。 選擇一個檔案以在程式碼區域中開啟，進行修改並儲存。 完成專案更新後，選擇 版本控制 圖示，該圖示包含您對儲存庫所做的所有新變更。 要查看您對專案所做的變更，選擇展開的活動列中 Changes 資料夾中的檔案。這將開啟一個 '工作樹'，讓您直觀地查看檔案的變更。紅色表示刪除，綠色表示新增。 如果您對所做的變更感到滿意，將滑鼠移至 Changes 資料夾並點擊 + 按鈕以暫存變更。暫存表示準備將變更提交到 GitHub。 如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。 使用擴充功能 在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。 要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。 您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。 您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。 1安裝擴充功能\n要安裝擴充功能，請在搜尋框中輸入擴充功能名稱，並點擊它以在展開的活動列中查看該擴充功能的更多資訊。\n您可以點擊展開的活動列中的 藍色安裝按鈕 安裝，或在選擇擴充功能以載入更多資訊後，使用程式碼區域中的安裝按鈕。\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1313,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "fd20a31a26893716078d21becfdf2156",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "編輯檔案 在瀏覽器或 vscodedev 中開啟儲存庫後，下一步是更新或修改專案。 1建立新檔案 您可以在現有資料夾中建立檔案，也可以在根目錄/資料夾中建立檔案。要建立新檔案，請開啟您希望儲存檔案的位置/目錄，選擇活動列 (左側) 的 'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 非常方便，尤其是在您需要快速更新專案而不想在本地載入任何軟體時。 要更新程式碼，點擊活動列上的 '檔案總管' 圖示以查看儲存庫中的檔案和資料夾。 選擇一個檔案以在程式碼區域中開啟，進行修改並儲存。 完成專案更新後，選擇 版本控制 圖示，該圖示包含您對儲存庫所做的所有新變更。 要查看您對專案所做的變更，選擇展開的活動列中 Changes 資料夾中的檔案。這將開啟一個 '工作樹'，讓您直觀地查看檔案的變更。紅色表示刪除，綠色表示新增。 如果您對所做的變更感到滿意，將滑鼠移至 Changes 資料夾並點擊 + 按鈕以暫存變更。暫存表示準備將變更提交到 GitHub。 如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。 使用擴充功能 在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。 要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。 您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。 您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。 1安裝擴充功能 要安裝擴充功能，請在搜尋框中輸入擴充功能名稱，並點擊它以在展開的活動列中查看該擴充功能的更多資訊。 您可以點擊展開的活動列中的 藍色安裝按鈕 安裝，或在選擇擴充功能以載入更多資訊後，使用程式碼區域中的安裝按鈕。 2自訂擴充功能\n安裝擴充功能後，您可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴充功能圖示，這次您的擴充功能將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航至 擴充功能設定。\n3",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1395,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "ff4d53b8f848afba2beabd9631091a46",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "的 'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 非常方便，尤其是在您需要快速更新專案而不想在本地載入任何軟體時。 要更新程式碼，點擊活動列上的 '檔案總管' 圖示以查看儲存庫中的檔案和資料夾。 選擇一個檔案以在程式碼區域中開啟，進行修改並儲存。 完成專案更新後，選擇 版本控制 圖示，該圖示包含您對儲存庫所做的所有新變更。 要查看您對專案所做的變更，選擇展開的活動列中 Changes 資料夾中的檔案。這將開啟一個 '工作樹'，讓您直觀地查看檔案的變更。紅色表示刪除，綠色表示新增。 如果您對所做的變更感到滿意，將滑鼠移至 Changes 資料夾並點擊 + 按鈕以暫存變更。暫存表示準備將變更提交到 GitHub。 如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。 使用擴充功能 在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。 要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。 您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。 您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。 1安裝擴充功能 要安裝擴充功能，請在搜尋框中輸入擴充功能名稱，並點擊它以在展開的活動列中查看該擴充功能的更多資訊。 您可以點擊展開的活動列中的 藍色安裝按鈕 安裝，或在選擇擴充功能以載入更多資訊後，使用程式碼區域中的安裝按鈕。 2自訂擴充功能 安裝擴充功能後，您可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴充功能圖示，這次您的擴充功能將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航至 擴充功能設定。 3管理擴充功能\n安裝並使用擴充功能後，vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1277,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "1747883f53a1c2634906f4e202f020f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "'New file' 圖示，命名檔案並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 非常方便，尤其是在您需要快速更新專案而不想在本地載入任何軟體時。 要更新程式碼，點擊活動列上的 '檔案總管' 圖示以查看儲存庫中的檔案和資料夾。 選擇一個檔案以在程式碼區域中開啟，進行修改並儲存。 完成專案更新後，選擇 版本控制 圖示，該圖示包含您對儲存庫所做的所有新變更。 要查看您對專案所做的變更，選擇展開的活動列中 Changes 資料夾中的檔案。這將開啟一個 '工作樹'，讓您直觀地查看檔案的變更。紅色表示刪除，綠色表示新增。 如果您對所做的變更感到滿意，將滑鼠移至 Changes 資料夾並點擊 + 按鈕以暫存變更。暫存表示準備將變更提交到 GitHub。 如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。 使用擴充功能 在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。 要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。 您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。 您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。 1安裝擴充功能 要安裝擴充功能，請在搜尋框中輸入擴充功能名稱，並點擊它以在展開的活動列中查看該擴充功能的更多資訊。 您可以點擊展開的活動列中的 藍色安裝按鈕 安裝，或在選擇擴充功能以載入更多資訊後，使用程式碼區域中的安裝按鈕。 2自訂擴充功能 安裝擴充功能後，您可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴充功能圖示，這次您的擴充功能將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航至 擴充功能設定。 3管理擴充功能 安裝並使用擴充功能後，vscodedev 提供了根據不同需求管理擴充功能的選項。例如，您可以選擇：\n停用： (當您暫時不需要擴充功能但不想完全卸載時，可以停用它)\n選擇展開的活動列中的已安裝擴充功能 > 點擊齒輪圖示 > 選擇 '停用' 或 '停用（工作區）' 或 開啟程式碼區域中的擴充功能並點擊藍色停用按鈕。\n卸載： 選擇展開的活動列中的已安裝擴充功能 > 點擊齒輪圖示 > 選擇 '卸載' 或 開啟程式碼區域中的擴充功能並點擊藍色卸載按鈕。\n作業\n使用 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1558,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "839c81afddaa9dbdf70e6484d96f0620",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "如果您對某些變更不滿意並希望捨棄它們，將滑鼠移至 Changes 資料夾並選擇 撤銷 圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。 使用擴充功能 在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。 要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。 您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。 您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。 1安裝擴充功能 要安裝擴充功能，請在搜尋框中輸入擴充功能名稱，並點擊它以在展開的活動列中查看該擴充功能的更多資訊。 您可以點擊展開的活動列中的 藍色安裝按鈕 安裝，或在選擇擴充功能以載入更多資訊後，使用程式碼區域中的安裝按鈕。 2自訂擴充功能 安裝擴充功能後，您可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴充功能圖示，這次您的擴充功能將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航至 擴充功能設定。 3管理擴充功能 安裝並使用擴充功能後，vscodedev 提供了根據不同需求管理擴充功能的選項。例如，您可以選擇： 停用： (當您暫時不需要擴充功能但不想完全卸載時，可以停用它) 選擇展開的活動列中的已安裝擴充功能 > 點擊齒輪圖示 > 選擇 '停用' 或 '停用（工作區）' 或 開啟程式碼區域中的擴充功能並點擊藍色停用按鈕。 卸載： 選擇展開的活動列中的已安裝擴充功能 > 點擊齒輪圖示 > 選擇 '卸載' 或 開啟程式碼區域中的擴充功能並點擊藍色卸載按鈕。 作業 使用 vscodedev 建立履歷網站\n複習與自學\n閱讀更多關於 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1196,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "68cdef28ebee3c949529717e95e574a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "圖示。 接著，輸入 提交訊息 (描述您對專案所做的變更)，點擊 勾選圖示 提交並推送您的變更。 完成專案工作後，選擇左上方的 漢堡選單圖示 返回 githubcom 上的儲存庫。 使用擴充功能 在 VSCode 中安裝擴充功能可以為編輯器新增功能並自訂開發環境選項，以改善您的開發工作流程。這些擴充功能還能幫助您支援多種程式語言，通常分為通用擴充功能或基於語言的擴充功能。 要瀏覽所有可用擴充功能的列表，點擊活動列上的 擴充功能圖示，並在標記為 'Search Extensions in Marketplace' 的文字框中輸入擴充功能名稱。 您將看到一個擴充功能列表，每個擴充功能包含 名稱、發佈者名稱、一句描述、下載次數 和 星級評分。 您還可以透過展開 已安裝資料夾 查看所有已安裝的擴充功能，透過 熱門資料夾 查看大多數開發者使用的熱門擴充功能，以及透過 推薦資料夾 查看基於您最近開啟的檔案或相同工作區使用者推薦的擴充功能。 1安裝擴充功能 要安裝擴充功能，請在搜尋框中輸入擴充功能名稱，並點擊它以在展開的活動列中查看該擴充功能的更多資訊。 您可以點擊展開的活動列中的 藍色安裝按鈕 安裝，或在選擇擴充功能以載入更多資訊後，使用程式碼區域中的安裝按鈕。 2自訂擴充功能 安裝擴充功能後，您可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴充功能圖示，這次您的擴充功能將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航至 擴充功能設定。 3管理擴充功能 安裝並使用擴充功能後，vscodedev 提供了根據不同需求管理擴充功能的選項。例如，您可以選擇： 停用： (當您暫時不需要擴充功能但不想完全卸載時，可以停用它) 選擇展開的活動列中的已安裝擴充功能 > 點擊齒輪圖示 > 選擇 '停用' 或 '停用（工作區）' 或 開啟程式碼區域中的擴充功能並點擊藍色停用按鈕。 卸載： 選擇展開的活動列中的已安裝擴充功能 > 點擊齒輪圖示 > 選擇 '卸載' 或 開啟程式碼區域中的擴充功能並點擊藍色卸載按鈕。 作業 使用 vscodedev 建立履歷網站 複習與自學 閱讀更多關於 VSCodedev 及其其他功能的資訊。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8951,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1324,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "d5ca1a3740867a195c78521839ebc8ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "重構並添加註解到你的程式碼",
    "content": "重構並添加註解到你的程式碼\n指導方針\n隨著程式碼庫的擴展，定期重構程式碼以保持其可讀性和可維護性是非常重要的。請添加註解並重構你的 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 91,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "a15d6a463d5043a3894e8ac1f23c2fa2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "重構並添加註解到你的程式碼",
    "content": "重構並添加註解到你的程式碼\n指導方針\n隨著程式碼庫的擴展，定期重構程式碼以保持其可讀性和可維護性是非常重要的。請添加註解並重構你的 appjs 以提升程式碼品質：\n提取常數，例如伺服器 API 的基礎 URL\n將相似的程式碼進行統一：例如，你可以建立一個 sendRequest() 函數，將 createAccount() 和 getAccount() 中使用的程式碼整合起來\n重新組織程式碼，使其更易於閱讀，並添加註解\n評分標準\n| 評分標準 | 優秀                                                                                                                                                     | 合格                                                                                          | 需要改進                                                                     |\n| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\n|          | 程式碼有註解，分成不同的區塊且易於閱讀。常數已提取，並建立了統一的 sendRequest() 函數。                                                                | 程式碼乾淨，但仍可透過添加更多註解、提取常數或統一程式碼進一步改善。                                                                | 程式碼混亂，沒有註解，常數未提取，程式碼未統一。                                                                |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而產生的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2440,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "0ab6e4ae7ea652737951d6891fa414b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完整功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接透過 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 395,
    "chunk_index": 0,
    "total_chunks": 49
  },
  {
    "id": "d6d8b3318e58429e169dd8eaf2cdcdae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完整功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接透過 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。\n準備工作\n在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 1,
    "total_chunks": 49
  },
  {
    "id": "8c623f9b33e6c8843f398ed0a4c2f18b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完整功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接透過 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。\n準備工作\n在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 indexhtml 的檔案。我們將從這個 HTML 樣板開始：\n```html\nBank App\n```\nHTML 模板\n如果您想為網頁建立多個畫面，一種解決方案是為每個想要顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處：\n切換畫面時需要重新載入整個 HTML，可能會很慢。\n在不同畫面之間共享資料會變得困難。\n另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須在執行時透過 JavaScript 實例化。\n任務\n我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後將用來實例化應用程式的不同畫面：\n```html\nLoading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 868,
    "chunk_index": 2,
    "total_chunks": 49
  },
  {
    "id": "469ccac91dcfaa3fac2c6902ddfe3393",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完整功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接透過 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。\n準備工作\n在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 indexhtml 的檔案。我們將從這個 HTML 樣板開始：\n```html\nBank App\n```\nHTML 模板\n如果您想為網頁建立多個畫面，一種解決方案是為每個想要顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處：\n切換畫面時需要重新載入整個 HTML，可能會很慢。\n在不同畫面之間共享資料會變得困難。\n另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須在執行時透過 JavaScript 實例化。\n任務\n我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後將用來實例化應用程式的不同畫面：\n```html\nLoading```\n我們給它一個 id，以便稍後使用 JavaScript 更容易找到它。\n提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。\n接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。\n```html\nLogin\n```\n然後，我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段：\n一個包含標題和登出連結的標頭\n銀行帳戶的當前餘額\n一個以表格顯示的交易列表\n```html\nBalance: 100$\nTransactions\nDate\nObject\nAmount\n```\n提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1192,
    "chunk_index": 3,
    "total_chunks": 49
  },
  {
    "id": "85495e88bad4277bc18008e6e433002c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "頁面。 先決條件 您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。 準備工作 在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 indexhtml 的檔案。我們將從這個 HTML 樣板開始： ```html Bank App ``` HTML 模板 如果您想為網頁建立多個畫面，一種解決方案是為每個想要顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處： 切換畫面時需要重新載入整個 HTML，可能會很慢。 在不同畫面之間共享資料會變得困難。 另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須在執行時透過 JavaScript 實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後將用來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易找到它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後，我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。\n✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？\n使用 JavaScript 顯示模板\n如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 956,
    "chunk_index": 4,
    "total_chunks": 49
  },
  {
    "id": "7fc96d42cbcec6e2da885b5d6bfeaafd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "樣板開始： ```html Bank App ``` HTML 模板 如果您想為網頁建立多個畫面，一種解決方案是為每個想要顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處： 切換畫面時需要重新載入整個 HTML，可能會很慢。 在不同畫面之間共享資料會變得困難。 另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須在執行時透過 JavaScript 實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後將用來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易找到它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後，我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。\n實例化模板通常分為三個步驟：\n在 DOM 中檢索模板元素，例如使用 document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 825,
    "chunk_index": 5,
    "total_chunks": 49
  },
  {
    "id": "b6dc9adc292f266c5c72ed6a766a9fa4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "檔案。然而，這種解決方案有一些不便之處： 切換畫面時需要重新載入整個 HTML，可能會很慢。 在不同畫面之間共享資料會變得困難。 另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須在執行時透過 JavaScript 實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後將用來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易找到它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後，我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。\n使用 cloneNode 複製模板元素。\n將其附加到 DOM 中的可見元素，例如使用 appendChild。\n✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？\n任務\n在您的專案資料夾中建立一個名為 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 877,
    "chunk_index": 6,
    "total_chunks": 49
  },
  {
    "id": "787f43849f55c02cd5c0faa9e2f23e89",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後將用來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易找到它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後，我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案：\n```html\n```\n現在在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 753,
    "chunk_index": 7,
    "total_chunks": 49
  },
  {
    "id": "397557c1b972ff87fc0554fb56151c08",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "JavaScript 更容易找到它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後，我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute：\njs\nfunction updateRoute(templateId) {\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 661,
    "chunk_index": 8,
    "total_chunks": 49
  },
  {
    "id": "5bab2bb85023fd45892aebfd219b38fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId);\nconst view = template content",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 9,
    "total_chunks": 49
  },
  {
    "id": "302b7e4010ad52232021b52033012351",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true);\nconst app = document getElementById('app');\napp innerHTML = '';\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 441,
    "chunk_index": 10,
    "total_chunks": 49
  },
  {
    "id": "20ae4065d2d8fe826fedd3289cf6318c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼在模板上使用 id 屬性？是否可以使用其他方式，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view);\n}\n我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。\n現在使用其中一個模板呼叫此函數並查看結果。\njs\nupdateRoute('login');\n✅ 這段程式碼 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 566,
    "chunk_index": 11,
    "total_chunks": 49
  },
  {
    "id": "6a004ccbd2e922b6f70cf43f606581dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？\n建立路由\n在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案：\nmywebsite/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 647,
    "chunk_index": 12,
    "total_chunks": 49
  },
  {
    "id": "c1c3e9580e03b8cda77f36ff3d20d3b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml\nmywebsite/login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 547,
    "chunk_index": 13,
    "total_chunks": 49
  },
  {
    "id": "ee6b2e0a02bd883db80574b534f7e808",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml\nmywebsite/admin/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 540,
    "chunk_index": 14,
    "total_chunks": 49
  },
  {
    "id": "b5da87a822fef85ee96aec344aaa06ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml\n如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是：\nhttps://site",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 15,
    "total_chunks": 49
  },
  {
    "id": "21b59d579aee74b971f64c1b8f34e73e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom            --> mywebsite/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 560,
    "chunk_index": 16,
    "total_chunks": 49
  },
  {
    "id": "e44ee17097863342ca8c42fa579d42aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml\nhttps://site",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 552,
    "chunk_index": 17,
    "total_chunks": 49
  },
  {
    "id": "bef26fcd24a06f4f33c603052a6121e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 551,
    "chunk_index": 18,
    "total_chunks": 49
  },
  {
    "id": "dc4e7a96d8838756f14e71772175aa65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 556,
    "chunk_index": 19,
    "total_chunks": 49
  },
  {
    "id": "532976a10c176ab9a71d02ea921cf9c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "之前複製模板？如果跳過這一步，您認為會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml\nhttps://site",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 542,
    "chunk_index": 20,
    "total_chunks": 49
  },
  {
    "id": "efb5b2c555dc25bf117e9af4c501da97",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/     --> mywebsite/admin/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 512,
    "chunk_index": 21,
    "total_chunks": 49
  },
  {
    "id": "6048624262359e126ded1a994bf40678",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml\n然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。\n任務\n我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 640,
    "chunk_index": 22,
    "total_chunks": 49
  },
  {
    "id": "28aa89a502e047d4378c54485eef9092",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard' },\n};\n現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 722,
    "chunk_index": 23,
    "total_chunks": 49
  },
  {
    "id": "2c4da7787d0ce62692d396576d855f15",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 24,
    "total_chunks": 49
  },
  {
    "id": "01fbb5e6577d52df6f8c1474792216e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templateId 實例化模板，並將其複製的內容放入應用程式的佔位符中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。\n```js\nfunction updateRoute() {\nconst path = window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 676,
    "chunk_index": 25,
    "total_chunks": 49
  },
  {
    "id": "8b523f630558cfee217bb02d823c8914",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 562,
    "chunk_index": 26,
    "total_chunks": 49
  },
  {
    "id": "27c5b6969d0d48db820f1749cd6e4d5b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname;\nconst route = routes[path];\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 574,
    "chunk_index": 27,
    "total_chunks": 49
  },
  {
    "id": "c3c78a4841387a5623780e5315f83d6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，在您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您以 mywebsite 作為根建立一個網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId);\nconst view = template content cloneNode(true);\nconst app = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 28,
    "total_chunks": 49
  },
  {
    "id": "65cb3826fc7fff85e890f713194b0092",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app');\napp innerHTML = '';\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 397,
    "chunk_index": 29,
    "total_chunks": 49
  },
  {
    "id": "d3dfe82f68d8dd85a5965defab4b358f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立此映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view);\n}\n```\n在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。\n✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？\n新增導航功能\n我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事：\n更新當前的 URL\n根據新的 URL 更新顯示的模板\n第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。\n我們需要使用 JavaScript，特別是 history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 631,
    "chunk_index": 30,
    "total_chunks": 49
  },
  {
    "id": "611346922acd02d461466f5366050c17",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改一下 updateRoute 函數。我們不再直接傳遞 templateId 作為參數，而是希望先查看當前的 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。\n注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。\n任務\n讓我們建立一個新函數，可以用來在應用程式中進行導航：\njs\nfunction navigate(path) {\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 622,
    "chunk_index": 31,
    "total_chunks": 49
  },
  {
    "id": "ac558211f92bb74d20f8a3ae7c63acf6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistory",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 32,
    "total_chunks": 49
  },
  {
    "id": "82cf3e881354d4b44f0abb73b33be5c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path);\nupdateRoute();\n}\n此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 33,
    "total_chunks": 49
  },
  {
    "id": "f11d3bd28161504ce10f2def819a5028",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 519,
    "chunk_index": 34,
    "total_chunks": 49
  },
  {
    "id": "6b7ea91ffe14c8f3ebea4ab832289d33",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。\n現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。\n```js\nfunction updateRoute() {\nconst path = window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 643,
    "chunk_index": 35,
    "total_chunks": 49
  },
  {
    "id": "94c7b8bf03ff9f1c56e9d7af40465de2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 619,
    "chunk_index": 36,
    "total_chunks": 49
  },
  {
    "id": "c4f8062bd2da525f7942993002eede2a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname;\nconst route = routes[path];\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 629,
    "chunk_index": 37,
    "total_chunks": 49
  },
  {
    "id": "4b9ce5906a6396587b112b1b38b1801f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) {\nreturn navigate('/login');\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 38,
    "total_chunks": 49
  },
  {
    "id": "cdd6a426ea3ebb5b427a43d21a954961",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這包含兩件事： 更新當前的 URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }```\n如果找不到路由，我們現在會重定向到 login 頁面。\n現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為：\njs\nfunction onLinkClick(event) {\nevent",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 718,
    "chunk_index": 39,
    "total_chunks": 49
  },
  {
    "id": "55d34c2b6add6d111db01de8da8cdad2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "URL 根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault();\nnavigate(event",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 553,
    "chunk_index": 40,
    "total_chunks": 49
  },
  {
    "id": "efce3c9a64a38653575fc75bd06fc6b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtarget",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 553,
    "chunk_index": 41,
    "total_chunks": 49
  },
  {
    "id": "7e34b1a6965c123884947d32e116318a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "根據新的 URL 更新顯示的模板 第二部分我們已經透過 updateRoute 函數處理了，因此我們需要弄清楚如何更新當前的 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref);\n}\n讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。\nhtml\n<a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 612,
    "chunk_index": 42,
    "total_chunks": 49
  },
  {
    "id": "e4199b15267696ab36a173d662947100",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，可以用來在應用程式中進行導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a>\n上述的 event 物件捕捉了 click 事件並將其傳遞給我們的 onLinkClick 函數。\n使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。\n嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間進行導航。\n✅ history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 647,
    "chunk_index": 43,
    "total_chunks": 49
  },
  {
    "id": "e1fd29111bed9a5120329302fe6cf61d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前的 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 的根，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉了 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間進行導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容的路由，且不會重新載入頁面，因為它的目的是在頁面內建立內部連結。\n處理瀏覽器的返回與前進按鈕\n使用 history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 679,
    "chunk_index": 44,
    "total_chunks": 49
  },
  {
    "id": "75a9b55691685dd8a98593d702119bbc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將修改 updateRoute 函數，新增一個回退到現有路由的機制，如果找不到匹配。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉了 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間進行導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容的路由，且不會重新載入頁面，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以透過按住瀏覽器的返回按鈕檢查，它應該顯示類似以下的內容：\n如果您嘗試多次點擊返回按鈕，您會看到當前的 URL 發生變化，歷史被更新，但顯示的模板保持不變。\n這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 782,
    "chunk_index": 45,
    "total_chunks": 49
  },
  {
    "id": "5ac419b48849b413e82ad5d36782c7f7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "{ const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉了 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間進行導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容的路由，且不會重新載入頁面，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以透過按住瀏覽器的返回按鈕檢查，它應該顯示類似以下的內容： 如果您嘗試多次點擊返回按鈕，您會看到當前的 URL 發生變化，歷史被更新，但顯示的模板保持不變。 這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 historypushState 文件，您會看到如果狀態改變——意味著我們移動到不同的 URL——popstate 事件會被觸發。我們將利用這一點來修正此問題。\n任務\n為了確保當瀏覽器歷史變更時顯示的模板被更新，我們將附加一個新函數來呼叫 updateRoute()。我們會在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 833,
    "chunk_index": 46,
    "total_chunks": 49
  },
  {
    "id": "32ce1e1929cd5b1f8d2261672771961c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "= routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉了 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間進行導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容的路由，且不會重新載入頁面，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以透過按住瀏覽器的返回按鈕檢查，它應該顯示類似以下的內容： 如果您嘗試多次點擊返回按鈕，您會看到當前的 URL 發生變化，歷史被更新，但顯示的模板保持不變。 這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 historypushState 文件，您會看到如果狀態改變——意味著我們移動到不同的 URL——popstate 事件會被觸發。我們將利用這一點來修正此問題。 任務 為了確保當瀏覽器歷史變更時顯示的模板被更新，我們將附加一個新函數來呼叫 updateRoute()。我們會在 appjs 檔案的底部完成此操作：\njs\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 839,
    "chunk_index": 47,
    "total_chunks": 49
  },
  {
    "id": "88e823211a24f2dd7af15144653c693d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "(route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在連結被點擊時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們透過在 HTML 中的 登入 和 登出 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉了 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間進行導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容的路由，且不會重新載入頁面，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以透過按住瀏覽器的返回按鈕檢查，它應該顯示類似以下的內容： 如果您嘗試多次點擊返回按鈕，您會看到當前的 URL 發生變化，歷史被更新，但顯示的模板保持不變。 這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 historypushState 文件，您會看到如果狀態改變——意味著我們移動到不同的 URL——popstate 事件會被觸發。我們將利用這一點來修正此問題。 任務 為了確保當瀏覽器歷史變更時顯示的模板被更新，我們將附加一個新函數來呼叫 updateRoute()。我們會在 appjs 檔案的底部完成此操作： js windowonpopstate = () => updateRoute();\nupdateRoute();\n注意：我們在這裡使用了箭頭函數來宣告 popstate 事件處理器以簡化程式碼，但使用常規函數也可以達到相同效果。\n以下是箭頭函數的影片回顧：\n🎥 點擊上方圖片觀看有關箭頭函數的影片。\n現在嘗試使用瀏覽器的返回與前進按鈕，檢查這次顯示的路由是否正確更新。\n🚀 挑戰\n新增一個新的模板和路由，用於顯示此應用程式的製作人員名單的第三個頁面。\n課後測驗\n課後測驗\n回顧與自學\n路由是網頁開發中令人驚訝的棘手部分之一，特別是當網頁從頁面刷新行為轉向單頁應用程式的頁面刷新時。閱讀一些有關 Azure 靜態網頁應用程式服務 如何處理路由的資料。您能否解釋為什麼文件中描述的一些決策是必要的？\n作業\n改善路由\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14069,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1401,
    "chunk_index": 48,
    "total_chunks": 49
  },
  {
    "id": "154c54b5df7cc581ab8c452fbc41bf58",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\assignment.md",
    "source_type": "git_repo",
    "title": "實現「新增交易」對話框",
    "content": "實現「新增交易」對話框\n說明\n我們的銀行應用程式仍然缺少一個重要功能：輸入新交易的可能性。\n使用您在前四節課中學到的所有內容，實現一個「新增交易」對話框：\n在儀表板頁面新增一個「新增交易」按鈕\n可以選擇建立一個帶有 HTML 模板的新頁面，或者使用 JavaScript 顯示/隱藏對話框的 HTML，而不離開儀表板頁面（您可以使用 hidden 屬性或 CSS 類別來完成此操作）\n確保處理好對話框的鍵盤和螢幕閱讀器的可訪問性\n實現一個 HTML 表單以接收輸入數據\n從表單數據創建 JSON 數據並將其發送到 API\n使用新數據更新儀表板頁面\n查看 伺服器 API 規範，了解需要調用的 API 以及預期的 JSON 格式。\n以下是完成作業後的示例結果：\n評分標準\n| 評分標準 | 卓越                                                                                              | 合格                                                                                                                    | 需要改進                                   |\n| -------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------ |\n|          | 完全按照課程中看到的所有最佳實踐實現新增交易功能。                                               | 新增交易功能已實現，但未完全遵循課程中看到的最佳實踐，或者僅部分運作。                                                   | 新增交易功能完全無法運作。                 |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而產生的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e03ba28fa55ede3e68d85fa03c7910b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "建立銀行應用程式第4部分：狀態管理概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有資料流變得越來越困難。哪些程式碼獲取資料，哪些頁面使用資料，資料需要在何時何地更新……很容易導致程式碼混亂且難以維護。尤其是當需要在應用程式的不同頁面之間共享資料時，例如使用者資料。狀態管理的概念一直存在於各種程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中需要特別考慮這一點。\n在這最後一部分中，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，以支援瀏覽器在任何時候刷新，並在使用者會話期間持續保存資料。\n前置條件\n您需要完成本課程的網頁應用程式資料擷取部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便管理帳戶資料。\n您可以在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 0,
    "total_chunks": 27
  },
  {
    "id": "f0715d1ba1d54773ca74f6e64e4dc28f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "建立銀行應用程式第4部分：狀態管理概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有資料流變得越來越困難。哪些程式碼獲取資料，哪些頁面使用資料，資料需要在何時何地更新……很容易導致程式碼混亂且難以維護。尤其是當需要在應用程式的不同頁面之間共享資料時，例如使用者資料。狀態管理的概念一直存在於各種程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中需要特別考慮這一點。\n在這最後一部分中，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，以支援瀏覽器在任何時候刷新，並在使用者會話期間持續保存資料。\n前置條件\n您需要完成本課程的網頁應用程式資料擷取部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便管理帳戶資料。\n您可以在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\n重新思考狀態管理\n在上一課中，我們在應用程式中引入了基本的狀態概念，使用全域變數 account 來保存當前登入使用者的銀行資料。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新，會發生什麼？\n目前程式碼有三個問題：\n狀態未持久化，瀏覽器刷新會將您帶回登入頁面。\n有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。\n狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。\n我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。\n我們真正想要解決的問題是什麼？\n狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題：\n如何使應用程式中的資料流易於理解？\n如何確保狀態資料始終與使用者介面同步（反之亦然）？\n一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示：\n我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。\n✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。\n任務\n我們將從一些重構開始。替換 account 宣告：\njs\nlet account = null;\n改為：\njs\nlet state = {\naccount: null\n};\n這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。\n我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1467,
    "chunk_index": 1,
    "total_chunks": 27
  },
  {
    "id": "a6ec800ae840c36068bccd189e6a5c15",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "建立銀行應用程式第4部分：狀態管理概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有資料流變得越來越困難。哪些程式碼獲取資料，哪些頁面使用資料，資料需要在何時何地更新……很容易導致程式碼混亂且難以維護。尤其是當需要在應用程式的不同頁面之間共享資料時，例如使用者資料。狀態管理的概念一直存在於各種程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中需要特別考慮這一點。\n在這最後一部分中，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，以支援瀏覽器在任何時候刷新，並在使用者會話期間持續保存資料。\n前置條件\n您需要完成本課程的網頁應用程式資料擷取部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便管理帳戶資料。\n您可以在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\n重新思考狀態管理\n在上一課中，我們在應用程式中引入了基本的狀態概念，使用全域變數 account 來保存當前登入使用者的銀行資料。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新，會發生什麼？\n目前程式碼有三個問題：\n狀態未持久化，瀏覽器刷新會將您帶回登入頁面。\n有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。\n狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。\n我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。\n我們真正想要解決的問題是什麼？\n狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題：\n如何使應用程式中的資料流易於理解？\n如何確保狀態資料始終與使用者介面同步（反之亦然）？\n一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示：\n我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。\n✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。\n任務\n我們將從一些重構開始。替換 account 宣告：\njs\nlet account = null;\n改為：\njs\nlet state = {\naccount: null\n};\n這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。\n我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1475,
    "chunk_index": 2,
    "total_chunks": 27
  },
  {
    "id": "f26f767cb994de0e6188119243ea1bbb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "建立銀行應用程式第4部分：狀態管理概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有資料流變得越來越困難。哪些程式碼獲取資料，哪些頁面使用資料，資料需要在何時何地更新……很容易導致程式碼混亂且難以維護。尤其是當需要在應用程式的不同頁面之間共享資料時，例如使用者資料。狀態管理的概念一直存在於各種程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中需要特別考慮這一點。\n在這最後一部分中，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，以支援瀏覽器在任何時候刷新，並在使用者會話期間持續保存資料。\n前置條件\n您需要完成本課程的網頁應用程式資料擷取部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便管理帳戶資料。\n您可以在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\n重新思考狀態管理\n在上一課中，我們在應用程式中引入了基本的狀態概念，使用全域變數 account 來保存當前登入使用者的銀行資料。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新，會發生什麼？\n目前程式碼有三個問題：\n狀態未持久化，瀏覽器刷新會將您帶回登入頁面。\n有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。\n狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。\n我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。\n我們真正想要解決的問題是什麼？\n狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題：\n如何使應用程式中的資料流易於理解？\n如何確保狀態資料始終與使用者介面同步（反之亦然）？\n一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示：\n我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。\n✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。\n任務\n我們將從一些重構開始。替換 account 宣告：\njs\nlet account = null;\n改為：\njs\nlet state = {\naccount: null\n};\n這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。\n我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1477,
    "chunk_index": 3,
    "total_chunks": 27
  },
  {
    "id": "c0dc74d9316a6b81c0bd994a0a7f3b6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "建立銀行應用程式第4部分：狀態管理概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有資料流變得越來越困難。哪些程式碼獲取資料，哪些頁面使用資料，資料需要在何時何地更新……很容易導致程式碼混亂且難以維護。尤其是當需要在應用程式的不同頁面之間共享資料時，例如使用者資料。狀態管理的概念一直存在於各種程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中需要特別考慮這一點。\n在這最後一部分中，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，以支援瀏覽器在任何時候刷新，並在使用者會話期間持續保存資料。\n前置條件\n您需要完成本課程的網頁應用程式資料擷取部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便管理帳戶資料。\n您可以在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\n重新思考狀態管理\n在上一課中，我們在應用程式中引入了基本的狀態概念，使用全域變數 account 來保存當前登入使用者的銀行資料。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新，會發生什麼？\n目前程式碼有三個問題：\n狀態未持久化，瀏覽器刷新會將您帶回登入頁面。\n有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。\n狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。\n我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。\n我們真正想要解決的問題是什麼？\n狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題：\n如何使應用程式中的資料流易於理解？\n如何確保狀態資料始終與使用者介面同步（反之亦然）？\n一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示：\n我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。\n✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。\n任務\n我們將從一些重構開始。替換 account 宣告：\njs\nlet account = null;\n改為：\njs\nlet state = {\naccount: null\n};\n這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。\n我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =;\n在 updateDashboard() 函數的頂部，添加以下行：\njs\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1501,
    "chunk_index": 4,
    "total_chunks": 27
  },
  {
    "id": "5f22ac4a883cefaa7bb0d8a688853f62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "前置條件 您需要完成本課程的網頁應用程式資料擷取部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便管理帳戶資料。 您可以在終端執行以下命令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了基本的狀態概念，使用全域變數 account 來保存當前登入使用者的銀行資料。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新，會發生什麼？ 目前程式碼有三個問題： 狀態未持久化，瀏覽器刷新會將您帶回登入頁面。 有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。 狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。 我們真正想要解決的問題是什麼？ 狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題： 如何使應用程式中的資料流易於理解？ 如何確保狀態資料始終與使用者介面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示： 我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。 任務 我們將從一些重構開始。替換 account 宣告： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount;\n這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。\n追蹤資料變更\n現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。\n為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。\n在 JavaScript 中，您可以使用 Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1498,
    "chunk_index": 5,
    "total_chunks": 27
  },
  {
    "id": "a1d7a921a0195b2810eef7b71ff44a7c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "return \"Bank API v1 00\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了基本的狀態概念，使用全域變數 account 來保存當前登入使用者的銀行資料。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新，會發生什麼？ 目前程式碼有三個問題： 狀態未持久化，瀏覽器刷新會將您帶回登入頁面。 有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。 狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。 我們真正想要解決的問題是什麼？ 狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題： 如何使應用程式中的資料流易於理解？ 如何確保狀態資料始終與使用者介面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示： 我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。 任務 我們將從一些重構開始。替換 account 宣告： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。\n✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。\n任務\n讓我們創建一個新的 updateState() 函數：\njs\nfunction updateState(property, newData) {\nstate = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1508,
    "chunk_index": 6,
    "total_chunks": 27
  },
  {
    "id": "7322bea97ac3fd51e621a59d6a635206",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。 狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。 我們真正想要解決的問題是什麼？ 狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題： 如何使應用程式中的資料流易於理解？ 如何確保狀態資料始終與使用者介面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示： 我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。 任務 我們將從一些重構開始。替換 account 宣告： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1322,
    "chunk_index": 7,
    "total_chunks": 27
  },
  {
    "id": "79a6fc4975a7f015e22e8edcb8826382",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "有多個函數修改狀態。隨著應用程式的增長，這可能使追蹤變更變得困難，並且容易忘記更新某些部分。 狀態未清理，因此當您點擊登出時，帳戶資料仍然存在，即使您已經回到登入頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘重新思考策略。 我們真正想要解決的問題是什麼？ 狀態管理的核心在於找到一個良好的方法來解決以下兩個特定問題： 如何使應用程式中的資料流易於理解？ 如何確保狀態資料始終與使用者介面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示： 我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。 任務 我們將從一些重構開始。替換 account 宣告： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state,\n[property]: newData\n});\n}\n在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1369,
    "chunk_index": 8,
    "total_chunks": 27
  },
  {
    "id": "3d83e4a31c1308d232e01c6dc3a4846e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "如何確保狀態資料始終與使用者介面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經解決，要麼變得更容易解決。有許多可能的方法可以解決這些問題，但我們將採用一種常見的解決方案，即集中化資料及其變更方式。資料流將如下所示： 我們在此不會涵蓋資料自動觸發視圖更新的部分，因為這涉及到更高級的反應式程式設計概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。 任務 我們將從一些重構開始。替換 account 宣告： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製資料。然後使用方括號表示法 [property] 覆蓋狀態物件的特定屬性。最後，我們使用 Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1137,
    "chunk_index": 9,
    "total_chunks": 27
  },
  {
    "id": "9377a36243bc7043c87b9d4cdd9c155c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其使用的概念和模式通常是學習大型網頁應用程式可能面臨的問題及其解決方法的好途徑。 任務 我們將從一些重構開始。替換 account 宣告： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製資料。然後使用方括號表示法 [property] 覆蓋狀態物件的特定屬性。最後，我們使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲 account 屬性，但使用此方法，您可以在狀態中添加任意多的屬性。\n我們還需要更新 state 的初始化，以確保初始狀態也是不可變的：\njs\nlet state = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 989,
    "chunk_index": 10,
    "total_chunks": 27
  },
  {
    "id": "fa89e0d246ea4afa1e8a3700cc1338c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "null; 改為： js let state = { account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製資料。然後使用方括號表示法 [property] 覆蓋狀態物件的特定屬性。最後，我們使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲 account 屬性，但使用此方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({\naccount: null\n});\n之後，更新 register 函數，將 state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 878,
    "chunk_index": 11,
    "total_chunks": 27
  },
  {
    "id": "0b0504399f78cd50a9e222b080433fc8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "account: null }; 這個想法是將我們的應用程式資料集中化到一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展奠定了基礎。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製資料。然後使用方括號表示法 [property] 覆蓋狀態物件的特定屬性。最後，我們使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲 account 屬性，但使用此方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({ account: null }); 之後，更新 register 函數，將 stateaccount = result; 替換為：\njs\nupdateState('account', result);\n對 login 函數進行相同的操作，將 state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 904,
    "chunk_index": 12,
    "total_chunks": 27
  },
  {
    "id": "c9a3aeb510cf30494ca0872d694a8241",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "account =替換為 stateaccount =; 在 updateDashboard() 函數的頂部，添加以下行： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的變更奠定基礎。 追蹤資料變更 現在我們已經設置了 state 物件來存儲資料，下一步是集中更新。目的是使追蹤任何變更及其發生時間變得更容易。 為了避免對 state 物件進行更改，將其視為不可變是一個良好的做法，這意味著它完全不能被修改。這也意味著如果您想更改其中的任何內容，必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）開闢可能性，同時使調試更容易。例如，您可以記錄對狀態所做的每次更改並保留更改歷史，以了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將引發異常。 ✅ 您知道淺層和深層不可變物件的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製資料。然後使用方括號表示法 [property] 覆蓋狀態物件的特定屬性。最後，我們使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲 account 屬性，但使用此方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({ account: null }); 之後，更新 register 函數，將 stateaccount = result; 替換為： js updateState('account', result); 對 login 函數進行相同的操作，將 stateaccount = data; 替換為：\njs\nupdateState('account', data);\n現在我們可以趁機修復使用者點擊登出時帳戶資料未清除的問題。\n創建一個新的函數 logout()：\njs\nfunction logout() {\nupdateState('account', null);\nnavigate('/login');\n}\n在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();\n嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。\n提示：您可以在 updateState() 的底部添加 console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 948,
    "chunk_index": 13,
    "total_chunks": 27
  },
  {
    "id": "46753079f1e68efeab40cbec1c20493b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在此函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製資料。然後使用方括號表示法 [property] 覆蓋狀態物件的特定屬性。最後，我們使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲 account 屬性，但使用此方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({ account: null }); 之後，更新 register 函數，將 stateaccount = result; 替換為： js updateState('account', result); 對 login 函數進行相同的操作，將 stateaccount = data; 替換為： js updateState('account', data); 現在我們可以趁機修復使用者點擊登出時帳戶資料未清除的問題。 創建一個新的函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。\n持久化狀態\n大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。\n當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己：\n資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。\n您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？\n根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。\n另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣：\nlocalStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。\nsessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。\n請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1089,
    "chunk_index": 14,
    "total_chunks": 27
  },
  {
    "id": "42a6c12c63d76882e95218298754e176",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "state = Objectfreeze({ account: null }); 之後，更新 register 函數，將 stateaccount = result; 替換為： js updateState('account', result); 對 login 函數進行相同的操作，將 stateaccount = data; 替換為： js updateState('account', data); 現在我們可以趁機修復使用者點擊登出時帳戶資料未清除的問題。 創建一個新的函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。\n✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。\n任務\n我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。\njs\nconst storageKey = 'savedAccount';\n然後在 updateState() 函數的末尾添加以下行：\njs\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1111,
    "chunk_index": 15,
    "total_chunks": 27
  },
  {
    "id": "4c18c786c20fd08252d9119aa09ab481",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "替換為： js updateState('account', data); 現在我們可以趁機修復使用者點擊登出時帳戶資料未清除的問題。 創建一個新的函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1056,
    "chunk_index": 16,
    "total_chunks": 27
  },
  {
    "id": "59cb2cdf044e9fd85db222eb02ec486f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "js updateState('account', data); 現在我們可以趁機修復使用者點擊登出時帳戶資料未清除的問題。 創建一個新的函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSONstringify(state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1051,
    "chunk_index": 17,
    "total_chunks": 27
  },
  {
    "id": "50ca2279c1f9f6255c0eb8058677956a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "js updateState('account', data); 現在我們可以趁機修復使用者點擊登出時帳戶資料未清除的問題。 創建一個新的函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSONstringify(stateaccount));\n有了這個，使用者帳戶資料將被持久化並始終保持最新，因為我們之前已集中化所有狀態更新。這就是我們開始從之前的重構中受益的地方 🙂。\n由於資料已保存，我們還需要在應用程式加載時恢復它。由於我們開始有更多的初始化程式碼，創建一個新的 init 函數可能是一個好主意，並將之前的程式碼也包含在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1227,
    "chunk_index": 18,
    "total_chunks": 27
  },
  {
    "id": "154a22b3c33fab4844fadd773e157ece",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 有了這個，使用者帳戶資料將被持久化並始終保持最新，因為我們之前已集中化所有狀態更新。這就是我們開始從之前的重構中受益的地方 🙂。 由於資料已保存，我們還需要在應用程式加載時恢復它。由於我們開始有更多的初始化程式碼，創建一個新的 init 函數可能是一個好主意，並將之前的程式碼也包含在 appjs 的底部：\n```js\nfunction init() {\nconst savedAccount = localStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1182,
    "chunk_index": 19,
    "total_chunks": 27
  },
  {
    "id": "0f5c1ca47844db5e1e1533c941d053a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 有了這個，使用者帳戶資料將被持久化並始終保持最新，因為我們之前已集中化所有狀態更新。這就是我們開始從之前的重構中受益的地方 🙂。 由於資料已保存，我們還需要在應用程式加載時恢復它。由於我們開始有更多的初始化程式碼，創建一個新的 init 函數可能是一個好主意，並將之前的程式碼也包含在 appjs 的底部： ```js function init() { const savedAccount = localStoragegetItem(storageKey);\nif (savedAccount) {\nupdateState('account', JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1179,
    "chunk_index": 20,
    "total_chunks": 27
  },
  {
    "id": "44f315776c8d6d29beada8817b030f5b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "return logout(); 嘗試註冊新帳戶，登出並重新登入，檢查是否一切正常。 提示：您可以在 updateState() 的底部添加 consolelog(state)，並打開瀏覽器的開發工具控制台查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 有了這個，使用者帳戶資料將被持久化並始終保持最新，因為我們之前已集中化所有狀態更新。這就是我們開始從之前的重構中受益的地方 🙂。 由於資料已保存，我們還需要在應用程式加載時恢復它。由於我們開始有更多的初始化程式碼，創建一個新的 init 函數可能是一個好主意，並將之前的程式碼也包含在 appjs 的底部： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount));\n}\n// Our previous initialization code\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1169,
    "chunk_index": 21,
    "total_chunks": 27
  },
  {
    "id": "36322bf2cb1198eea8be02529fea2e48",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "持久化狀態 大多數網頁應用程式需要持久化資料才能正常工作。所有關鍵資料通常存儲在資料庫中，並通過伺服器 API 訪問，例如我們的使用者帳戶資料。但有時，將某些資料存儲在瀏覽器中的客戶端應用程式中也是有益的，這可以改善使用者體驗或提高加載性能。 當您想在瀏覽器中持久化資料時，有幾個重要問題需要問自己： 資料是否敏感？ 您應避免在客戶端存儲任何敏感資料，例如使用者密碼。 您需要保存這些資料多久？ 您是僅在當前會話中訪問這些資料，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲資訊。例如，您可以使用 URL 存儲搜尋查詢，並使其可在使用者之間共享。您還可以使用 HTTP cookies 存儲需要與伺服器共享的資料，例如身份驗證資訊。 另一個選項是使用多種瀏覽器 API 來存儲資料，其中有兩個特別有趣： localStorage：一種鍵值存儲，允許跨不同會話持久化特定於當前網站的資料。存儲在其中的資料永不過期。 sessionStorage：此方法與 localStorage 的工作方式相同，但存儲的資料在會話結束（瀏覽器關閉）時會被清除。 請注意，這兩個 API 只允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建資料庫。此方法適用於高級使用案例或需要存儲大量資料的情況，因為它使用起來更為複雜。 任務 我們希望使用者在明確點擊登出按鈕之前保持登入狀態，因此我們將使用 localStorage 存儲帳戶資料。首先，定義一個用於存儲資料的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下行： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 有了這個，使用者帳戶資料將被持久化並始終保持最新，因為我們之前已集中化所有狀態更新。這就是我們開始從之前的重構中受益的地方 🙂。 由於資料已保存，我們還需要在應用程式加載時恢復它。由於我們開始有更多的初始化程式碼，創建一個新的 init 函數可能是一個好主意，並將之前的程式碼也包含在 appjs 的底部： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute();\nupdateRoute();\n}\ninit();\n```\n在這裡，我們檢索保存的資料，如果有任何資料，我們會相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。\n我們還可以將儀表板頁面設為應用程式的預設頁面，因為我們現在正在持久化帳戶資料。如果未找到資料，儀表板會負責重定向到登入頁面。在 updateRoute() 中，將回退 return navigate('/login'); 替換為 return navigate('/dashboard');。\n現在登入應用程式並嘗試刷新頁面。您應該停留在儀表板頁面。通過這次更新，我們解決了所有初始問題……\n刷新資料\n……但我們可能也創造了一個新問題。糟糕！\n使用 test 帳戶進入儀表板，然後在終端執行以下命令以創建新交易：\nsh\ncurl --request POST \\\n--header \"Content-Type: application/json\" \\\n--data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\\nhttp://localhost:5000/api/accounts/test/transactions\n現在嘗試刷新瀏覽器中的儀表板頁面。會發生什麼？您是否看到新的交易？\n由於 localStorage 的狀態被無限期持久化，但這也意味著在您登出並重新登入之前，它永遠不會更新！\n解決此問題的一種可能策略是每次加載儀表板時重新載入帳戶資料，以避免資料過時。\n任務\n創建一個新的函數 updateAccountData：\n```js\nasync function updateAccountData() {\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1688,
    "chunk_index": 22,
    "total_chunks": 27
  },
  {
    "id": "5fde27ae4baf00e1d6f62661f4633877",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的資料，如果有任何資料，我們會相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將儀表板頁面設為應用程式的預設頁面，因為我們現在正在持久化帳戶資料。如果未找到資料，儀表板會負責重定向到登入頁面。在 updateRoute() 中，將回退 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登入應用程式並嘗試刷新頁面。您應該停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新資料 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端執行以下命令以創建新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試刷新瀏覽器中的儀表板頁面。會發生什麼？您是否看到新的交易？ 由於 localStorage 的狀態被無限期持久化，但這也意味著在您登出並重新登入之前，它永遠不會更新！ 解決此問題的一種可能策略是每次加載儀表板時重新載入帳戶資料，以避免資料過時。 任務 創建一個新的函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount;\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 643,
    "chunk_index": 23,
    "total_chunks": 27
  },
  {
    "id": "e9f600fc97d5b636f0df28eff08f0cd3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的資料，如果有任何資料，我們會相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將儀表板頁面設為應用程式的預設頁面，因為我們現在正在持久化帳戶資料。如果未找到資料，儀表板會負責重定向到登入頁面。在 updateRoute() 中，將回退 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登入應用程式並嘗試刷新頁面。您應該停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新資料 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端執行以下命令以創建新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試刷新瀏覽器中的儀表板頁面。會發生什麼？您是否看到新的交易？ 由於 localStorage 的狀態被無限期持久化，但這也意味著在您登出並重新登入之前，它永遠不會更新！ 解決此問題的一種可能策略是每次加載儀表板時重新載入帳戶資料，以避免資料過時。 任務 創建一個新的函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount; if (account) {\nreturn logout();\n}\nconst data = await getAccount(account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 24,
    "total_chunks": 27
  },
  {
    "id": "8cefe6ed225dd950672168ac21a970da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的資料，如果有任何資料，我們會相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將儀表板頁面設為應用程式的預設頁面，因為我們現在正在持久化帳戶資料。如果未找到資料，儀表板會負責重定向到登入頁面。在 updateRoute() 中，將回退 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登入應用程式並嘗試刷新頁面。您應該停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新資料 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端執行以下命令以創建新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試刷新瀏覽器中的儀表板頁面。會發生什麼？您是否看到新的交易？ 由於 localStorage 的狀態被無限期持久化，但這也意味著在您登出並重新登入之前，它永遠不會更新！ 解決此問題的一種可能策略是每次加載儀表板時重新載入帳戶資料，以避免資料過時。 任務 創建一個新的函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount; if (account) { return logout(); } const data = await getAccount(accountuser);\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 635,
    "chunk_index": 25,
    "total_chunks": 27
  },
  {
    "id": "7e9eb5a97c962ae0115ad042597da001",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第4部分：狀態管理概念",
    "content": "code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的資料，如果有任何資料，我們會相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將儀表板頁面設為應用程式的預設頁面，因為我們現在正在持久化帳戶資料。如果未找到資料，儀表板會負責重定向到登入頁面。在 updateRoute() 中，將回退 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登入應用程式並嘗試刷新頁面。您應該停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新資料 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端執行以下命令以創建新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試刷新瀏覽器中的儀表板頁面。會發生什麼？您是否看到新的交易？ 由於 localStorage 的狀態被無限期持久化，但這也意味著在您登出並重新登入之前，它永遠不會更新！ 解決此問題的一種可能策略是每次加載儀表板時重新載入帳戶資料，以避免資料過時。 任務 創建一個新的函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount; if (account) { return logout(); } const data = await getAccount(accountuser); if (dataerror) {\nreturn logout();\n}\nupdateState('account', data);\n}\n```\n此方法檢查我們當前是否已登入，然後從伺服器重新載入帳戶資料。\n創建另一個名為 refresh 的函數：\njs\nasync function refresh() {\nawait updateAccountData();\nupdateDashboard();\n}\n此函數更新帳戶資料，然後負責更新儀表板頁面的 HTML。這是我們需要在儀表板路由加載時調用的函數。使用以下程式碼更新路由定義：\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: refresh }\n};\n現在嘗試重新載入儀表板，它應顯示更新的帳戶資料。\n🚀 挑戰\n現在我們每次加載儀表板時都重新載入帳戶資料，您認為我們是否仍需要持久化所有帳戶資料？\n嘗試合作修改 localStorage 中保存和加載的內容，使其僅包含應用程式正常運行所需的資料。\n課後測驗\n課後測驗\n作業\n實作「新增交易」對話框\n以下是完成作業後的範例結果：\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對於因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14377,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1207,
    "chunk_index": 26,
    "total_chunks": 27
  },
  {
    "id": "778e11a8902ff3f0bfffa9545a025b2c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行 API",
    "content": "銀行 API\n使用 Node js + Express 建立的銀行 API。\n此 API 已經為您建置完成，並非練習的一部分。\n不過，如果您有興趣學習如何建立這樣的 API，可以參考這系列影片：https://aka ms/NodeBeginner（第 17 到 21 集涵蓋了這個 API 的完整內容）。\n您也可以查看這個互動式教學：https://aka ms/learn/express-api\n啟動伺服器\n請確保您已安裝 Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2600,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 176,
    "chunk_index": 0,
    "total_chunks": 3
  },
  {
    "id": "97a566a7f5253f127e9dcf334ca1b8ae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行 API",
    "content": "銀行 API\n使用 Node js + Express 建立的銀行 API。\n此 API 已經為您建置完成，並非練習的一部分。\n不過，如果您有興趣學習如何建立這樣的 API，可以參考這系列影片：https://aka ms/NodeBeginner（第 17 到 21 集涵蓋了這個 API 的完整內容）。\n您也可以查看這個互動式教學：https://aka ms/learn/express-api\n啟動伺服器\n請確保您已安裝 Nodejs。\nGit clone 此儲存庫 The Web-Dev-For-Beginners。\n打開終端機，進入 Web-Dev-For-Beginners/7-bank-project/api 資料夾。\n執行 npm install，並等待套件安裝完成（根據您的網路連線品質，可能需要一些時間）。\n安裝完成後，執行 npm start，即可開始使用。\n伺服器應該會開始監聽埠號 5000。\n此伺服器將與主要的銀行應用程式伺服器終端機（監聽埠號 3000）同時運行，請勿關閉。\n注意：所有的資料都儲存在記憶體中，並不會被持久化，因此當伺服器停止時，所有資料都會遺失。\nAPI 詳細資訊\n路由                                         | 描述\n---------------------------------------------|------------------------------------\nGET    /api/                                 | 獲取伺服器資訊\nPOST   /api/accounts/                        | 建立帳戶，例如：{ user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 }\nGET    /api/accounts/:user                   | 獲取指定帳戶的所有資料\nDELETE /api/accounts/:user                   | 刪除指定帳戶\nPOST   /api/accounts/:user/transactions      | 新增交易，例如：{ date: '2020-07-23T18:25:43",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2600,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 597,
    "chunk_index": 1,
    "total_chunks": 3
  },
  {
    "id": "dae95c5ddb4dda5f98e730915b299882",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行 API",
    "content": "建立的銀行 API。 此 API 已經為您建置完成，並非練習的一部分。 不過，如果您有興趣學習如何建立這樣的 API，可以參考這系列影片：https://aka ms/NodeBeginner（第 17 到 21 集涵蓋了這個 API 的完整內容）。 您也可以查看這個互動式教學：https://aka ms/learn/express-api 啟動伺服器 請確保您已安裝 Nodejs。 Git clone 此儲存庫 The Web-Dev-For-Beginners。 打開終端機，進入 Web-Dev-For-Beginners/7-bank-project/api 資料夾。 執行 npm install，並等待套件安裝完成（根據您的網路連線品質，可能需要一些時間）。 安裝完成後，執行 npm start，即可開始使用。 伺服器應該會開始監聽埠號 5000。 此伺服器將與主要的銀行應用程式伺服器終端機（監聽埠號 3000）同時運行，請勿關閉。 注意：所有的資料都儲存在記憶體中，並不會被持久化，因此當伺服器停止時，所有資料都會遺失。 API 詳細資訊 路由 | 描述 ---------------------------------------------|------------------------------------ GET /api/ | 獲取伺服器資訊 POST /api/accounts/ | 建立帳戶，例如：{ user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 } GET /api/accounts/:user | 獲取指定帳戶的所有資料 DELETE /api/accounts/:user | 刪除指定帳戶 POST /api/accounts/:user/transactions | 新增交易，例如：{ date: '2020-07-23T18:25:43511Z', object: 'Bought a book', amount: -20 }\nDELETE  /api/accounts/:user/transactions/:id | 刪除指定交易\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2600,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 781,
    "chunk_index": 2,
    "total_chunks": 3
  },
  {
    "id": "743934c6e1841d5891a6dd394308101a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\solution\\README.md",
    "source_type": "git_repo",
    "title": "銀行應用程式",
    "content": "銀行應用程式\n銀行應用程式專案的範例解決方案，使用原生的 HTML5、CSS 和 JavaScript 開發（未使用任何框架或函式庫）。\n運行應用程式\n首先，請確保您已經啟動了 API 伺服器。\n任何網頁伺服器都可以用來運行此應用程式，但由於您應該已經安裝了 Node.js 來運行 API，因此您可以：\nGit clone 此儲存庫。\n打開終端機，導航到此目錄，然後執行 npx lite-server .。這將在埠 3000 啟動一個開發用的網頁伺服器。\n在瀏覽器中打開 http://localhost:3000 來運行應用程式。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1349,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "6f57a6ae33de243721afdcaedfdb2057",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "建立銀行應用程式第 2 部分：建立登入和註冊表單\n課前測驗\n課前測驗\n簡介\n在幾乎所有現代網頁應用程式中，您都可以創建一個帳戶來擁有自己的私人空間。由於多個使用者可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個使用者的個人資料並選擇要顯示的資訊。我們不會涵蓋如何安全地管理使用者身份，因為這是一個非常廣泛的主題，但我們會確保每個使用者能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式新增登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義使用者輸入的基本驗證規則。\n先決條件\n您需要完成本課程的HTML 模板和路由部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n您將需要同時運行兩個終端，如下所列：\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 0,
    "total_chunks": 75
  },
  {
    "id": "06c9703559a4f44451aa438d2e6ea2c7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "建立銀行應用程式第 2 部分：建立登入和註冊表單\n課前測驗\n課前測驗\n簡介\n在幾乎所有現代網頁應用程式中，您都可以創建一個帳戶來擁有自己的私人空間。由於多個使用者可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個使用者的個人資料並選擇要顯示的資訊。我們不會涵蓋如何安全地管理使用者身份，因為這是一個非常廣泛的主題，但我們會確保每個使用者能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式新增登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義使用者輸入的基本驗證規則。\n先決條件\n您需要完成本課程的HTML 模板和路由部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n您將需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 510,
    "chunk_index": 1,
    "total_chunks": 75
  },
  {
    "id": "071578ff5e541c919021bf73d8fec7bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "建立銀行應用程式第 2 部分：建立登入和註冊表單\n課前測驗\n課前測驗\n簡介\n在幾乎所有現代網頁應用程式中，您都可以創建一個帳戶來擁有自己的私人空間。由於多個使用者可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個使用者的個人資料並選擇要顯示的資訊。我們不會涵蓋如何安全地管理使用者身份，因為這是一個非常廣泛的主題，但我們會確保每個使用者能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式新增登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義使用者輸入的基本驗證規則。\n先決條件\n您需要完成本課程的HTML 模板和路由部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n您將需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2用於我們剛剛設置的銀行應用程式伺服器 API\n您需要這兩個伺服器都在運行，才能繼續完成本課程的其餘部分。它們分別監聽不同的埠（埠 3000 和埠 5000），因此應該不會有問題。\n您可以通過在終端中執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 2,
    "total_chunks": 75
  },
  {
    "id": "b015a0d179963a2e4a0fbcdef9594eda",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "建立銀行應用程式第 2 部分：建立登入和註冊表單\n課前測驗\n課前測驗\n簡介\n在幾乎所有現代網頁應用程式中，您都可以創建一個帳戶來擁有自己的私人空間。由於多個使用者可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個使用者的個人資料並選擇要顯示的資訊。我們不會涵蓋如何安全地管理使用者身份，因為這是一個非常廣泛的主題，但我們會確保每個使用者能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式新增登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義使用者輸入的基本驗證規則。\n先決條件\n您需要完成本課程的HTML 模板和路由部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n您將需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2用於我們剛剛設置的銀行應用程式伺服器 API\n您需要這兩個伺服器都在運行，才能繼續完成本課程的其餘部分。它們分別監聽不同的埠（埠 3000 和埠 5000），因此應該不會有問題。\n您可以通過在終端中執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 3,
    "total_chunks": 75
  },
  {
    "id": "e1ee9f5eecf08830ad3a9c3f906b6917",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "建立銀行應用程式第 2 部分：建立登入和註冊表單\n課前測驗\n課前測驗\n簡介\n在幾乎所有現代網頁應用程式中，您都可以創建一個帳戶來擁有自己的私人空間。由於多個使用者可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個使用者的個人資料並選擇要顯示的資訊。我們不會涵蓋如何安全地管理使用者身份，因為這是一個非常廣泛的主題，但我們會確保每個使用者能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式新增登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義使用者輸入的基本驗證規則。\n先決條件\n您需要完成本課程的HTML 模板和路由部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n您將需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2用於我們剛剛設置的銀行應用程式伺服器 API\n您需要這兩個伺服器都在運行，才能繼續完成本課程的其餘部分。它們分別監聽不同的埠（埠 3000 和埠 5000），因此應該不會有問題。\n您可以通過在終端中執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n表單與控制項\n<form> 元素封裝了 HTML 文件的一個區域，使用者可以通過互動式控制項輸入和提交資料。在表單中可以使用各種使用者介面（UI）控制項，其中最常見的是 <input> 和 <button> 元素。\n<input> 有許多不同的類型，例如，要創建一個讓使用者輸入用戶名的欄位，您可以使用：\nhtml\n<input id=\"username\" name=\"username\" type=\"text\">\nname 屬性將在表單資料發送時用作屬性名稱。id 屬性用於將 <label> 與表單控制項關聯。\n查看 <input> 類型 和其他表單控制項的完整列表，了解您在構建 UI 時可以使用的所有原生 UI 元素。\n✅ 注意 <input> 是一個空元素，您不應為其添加匹配的關閉標籤。不過，您可以使用自閉合的 <input/> 標記，但這不是必須的。\n表單中的 <button> 元素有些特殊。如果您未指定其 type 屬性，按下時它將自動提交表單資料到伺服器。以下是可能的 type 值：\nsubmit：表單中的預設值，按鈕觸發表單提交操作。\nreset：按鈕將所有表單控制項重置為其初始值。\nbutton：按鈕按下時不分配任何預設行為。您可以使用 JavaScript 為其分配自定義操作。\n任務\n讓我們從在 login 模板中新增一個表單開始。我們需要一個用戶名欄位和一個登入按鈕。\n```html\nLogin\nUsername\nLogin\n```\n如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處：\n通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。\n您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。\n網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。\n現在我們將在前一個表單下方新增第二個註冊表單：\n```html\nRegister\nUsername\nCurrency\nDescription\nCurrent balance\nRegister\n```\n通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。\n另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。\n✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？\n將資料提交到伺服器\n現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？\n您是否注意到瀏覽器的 URL 區域發生了變化？\n<form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點：\n發送的資料大小非常有限（約 2000 個字元）\n資料直接顯示在 URL 中（對於密碼來說不太好）\n不支持文件上傳\n因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。\n雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。\n任務\n為註冊表單新增 action 和 method 屬性：\n```html\n```\n現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2219,
    "chunk_index": 4,
    "total_chunks": 75
  },
  {
    "id": "af513ff631a7bd98b9d9b6b40b447939",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "login 模板中新增一個表單開始。我們需要一個用戶名欄位和一個登入按鈕。 ```html Login Username Login ``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1079,
    "chunk_index": 5,
    "total_chunks": 75
  },
  {
    "id": "7c42e93a470ccce3f5286e48000bc64c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "Username Login ``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1037,
    "chunk_index": 6,
    "total_chunks": 75
  },
  {
    "id": "4db9d32579c270e598e24010c24a4519",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "Username Login ``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1037,
    "chunk_index": 7,
    "total_chunks": 75
  },
  {
    "id": "3dcc27765543e33df5a0b4bddf002d07",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "Username Login ``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1037,
    "chunk_index": 8,
    "total_chunks": 75
  },
  {
    "id": "be392a9e29cbcae4182b1d4f9ce8d7f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "Username Login ``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-post",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1048,
    "chunk_index": 9,
    "total_chunks": 75
  },
  {
    "id": "45af5de26b7e378bae832996432517d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "Username Login ``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng)\n如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1089,
    "chunk_index": 10,
    "total_chunks": 75
  },
  {
    "id": "e9e41b33f9abd6372387085126989f0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjson",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1088,
    "chunk_index": 11,
    "total_chunks": 75
  },
  {
    "id": "f0d60ed769c9b8279e67be7c345558f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1091,
    "chunk_index": 12,
    "total_chunks": 75
  },
  {
    "id": "e0cde784cb87f6b4c8f7ec7e423273b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "``` 如果您仔細觀察，會注意到我們還新增了一個 <label> 元素。<label> 元素用於為 UI 控制項（例如我們的用戶名欄位）添加名稱。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的使用者了解他們需要提供什麼資料。 您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。\n✅ 再次使用相同的名字註冊。會發生什麼？\n## 無需重新加載頁面提交資料\n正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1273,
    "chunk_index": 13,
    "total_chunks": 75
  },
  {
    "id": "9a383f6089298f315a35104c34398ab8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1101,
    "chunk_index": 14,
    "total_chunks": 75
  },
  {
    "id": "8edfcb3067cf8cd613ab48b5f14d082a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "您可以點擊標籤直接將焦點放在相關的輸入欄位上，這使得在觸控螢幕設備上更容易操作。 網頁無障礙性是一個非常重要但經常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建無障礙內容並不困難。您可以閱讀更多關於無障礙性的內容，以避免常見錯誤並成為一名負責任的開發者。 現在我們將在前一個表單下方新增第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 通過使用 value 屬性，我們可以為給定的輸入欄位定義預設值。 另外，注意 balance 的輸入欄位使用了 number 類型。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 您能僅使用鍵盤導航並與表單互動嗎？您會怎麼做？ 將資料提交到伺服器 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用當前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 您是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。\n要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務：\n- 獲取表單資料\n- 將表單資料轉換並編碼為合適的格式\n- 創建 HTTP 請求並將其發送到伺服器\n### 任務\n將註冊表單的 `action` 替換為：\n```html\n```\n打開 `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1348,
    "chunk_index": 15,
    "total_chunks": 75
  },
  {
    "id": "4c5c851ce236e6d25e57da74f47ff21a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單資料提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小非常有限（約 2000 個字元） 資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數：\n```js\nfunction register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 897,
    "chunk_index": 16,
    "total_chunks": 75
  },
  {
    "id": "a84abe0dd3b412b437a70d548a5c69e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "資料直接顯示在 URL 中（對於密碼來說不太好） 不支持文件上傳 因此，您可以將其更改為使用 POST 方法，該方法將表單資料作為 HTTP 請求的主體發送到伺服器，沒有上述限制。 雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst data = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 811,
    "chunk_index": 17,
    "total_chunks": 75
  },
  {
    "id": "070b06060f19e68d0e7066fcfa348128",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "雖然 POST 是最常用來發送資料的方法，但在某些特定情況下，例如實現搜尋欄時，使用 GET 方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData);\nconst jsonData = JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 722,
    "chunk_index": 18,
    "total_chunks": 75
  },
  {
    "id": "230c746780fce0b793b2a0807a08925a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "方法更為合適。 任務 為註冊表單新增 action 和 method 屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data);\n}\n```\n在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 716,
    "chunk_index": 19,
    "total_chunks": 75
  },
  {
    "id": "6fc94b3f6b84c585e7dadab95c1a6eb1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 690,
    "chunk_index": 20,
    "total_chunks": 75
  },
  {
    "id": "a0c8ae03c59cd78298976923c303dec0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "屬性： ```html ``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 21,
    "total_chunks": 75
  },
  {
    "id": "b2cacbee97e6363e01f74cd54d119e74",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 740,
    "chunk_index": 22,
    "total_chunks": 75
  },
  {
    "id": "58f2baf77266cf5393260fd6183838d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 742,
    "chunk_index": 23,
    "total_chunks": 75
  },
  {
    "id": "fb1461cb801ff595b95b822bb690d604",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "``` 現在嘗試使用您的名字註冊一個新帳戶。點擊*註冊*按鈕後，您應該會看到如下畫面：[瀏覽器窗口顯示 localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 794,
    "chunk_index": 24,
    "total_chunks": 75
  },
  {
    "id": "87be381476cbf86e2917a4090004f518",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjson",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 721,
    "chunk_index": 25,
    "total_chunks": 75
  },
  {
    "id": "4f9aaca96368c40ec908f9d4d83e97ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 724,
    "chunk_index": 26,
    "total_chunks": 75
  },
  {
    "id": "cf51b2fe6f3cd058a5942da65952fd87",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "localhost:5000/api/accounts 的地址，並顯示包含使用者資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以包含創建的帳戶資料的 [JSON](https://wwwjsonorg/json-enhtml) 響應回覆您的請求。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 正如您可能注意到的，我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在構建一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，您可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著您需要實現一些以前由瀏覽器自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。\n資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數：\n```js\nasync function createAccount(account) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts', {\nmethod: 'POST',\nheaders: { 'Content-Type': 'application/json' },\nbody: account\n});\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 27,
    "total_chunks": 75
  },
  {
    "id": "3212ca713492a828a0ddcbf0484360a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson();\n} catch (error) {\nreturn { error: error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 427,
    "chunk_index": 28,
    "total_chunks": 75
  },
  {
    "id": "1f666c5360f7d6ba52e257c504b95ba7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "`action` 替換為： ```html ``` 打開 `appjs`，新增一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' };\n}\n}\n```\n這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 29,
    "total_chunks": 75
  },
  {
    "id": "b7335ef78ac5863eaf7a64cc04e34045",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "{ const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。\n這裡有一段關於 `async/await` 用法的簡短影片：\n[",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 30,
    "total_chunks": 75
  },
  {
    "id": "962ffdcd6a52fad4fe44dfe01ff137b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://img",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 31,
    "total_chunks": 75
  },
  {
    "id": "7006398d3c309fc2baa195ff0277369f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://imgyoutube",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 32,
    "total_chunks": 75
  },
  {
    "id": "181b49552af1f266c37db67bed9e77c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://imgyoutubecom/vi/YwmlRkrxvkk/0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 514,
    "chunk_index": 33,
    "total_chunks": 75
  },
  {
    "id": "2ee9e67495474f001d53949c8e3cdfc6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtube",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 520,
    "chunk_index": 34,
    "total_chunks": 75
  },
  {
    "id": "048d581acb73a8f8cfa07ffa42d7b8ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watch",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 35,
    "total_chunks": 75
  },
  {
    "id": "cb0b4003bc878d4c54537707f49abb1e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助器將表單控制項的值提取為一組鍵/值對。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種網頁上常用的資料交換格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"管理 Promise 的 Async 和 Await\")\n> 🎥 點擊上方圖片觀看有關 async/await 的影片。\n我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數：\n- 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。\n- 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們將 JSON 資料發送到伺服器，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。\n由於伺服器將以 JSON 響應請求，我們可以使用 `await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 777,
    "chunk_index": 36,
    "total_chunks": 75
  },
  {
    "id": "5d7b9833e4d45c670a72ed50c2ce8484",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著該函數包含將以[**非同步**](https://developer mozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 用法的簡短影片： [[管理 Promise 的 Async 和 Await](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"管理 Promise 的 Async 和 Await\") > 🎥 點擊上方圖片觀看有關 async/await 的影片。 我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們將 JSON 資料發送到伺服器，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器將以 JSON 響應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。\n現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`：\n```js\nconst result = await createAccount(jsonData);\n```\n由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字：\n```js\nasync function register() {\n```\n最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示：\n```js\nasync function register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 742,
    "chunk_index": 37,
    "total_chunks": 75
  },
  {
    "id": "9bf1f5f3a2253424db1a07e205a806e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "和 Await](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"管理 Promise 的 Async 和 Await\") > 🎥 點擊上方圖片觀看有關 async/await 的影片。 我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們將 JSON 資料發送到伺服器，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器將以 JSON 響應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst jsonData = JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 530,
    "chunk_index": 38,
    "total_chunks": 75
  },
  {
    "id": "bbb9976a16b5848a7836961978edf697",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "🎥 點擊上方圖片觀看有關 async/await 的影片。 我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們將 JSON 資料發送到伺服器，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器將以 JSON 響應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData));\nconst result = await createAccount(jsonData);\nif (result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 39,
    "total_chunks": 75
  },
  {
    "id": "bc24aafaf944048a0d58a5617b2aae8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們將 JSON 資料發送到伺服器，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器將以 JSON 響應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) {\nreturn console log('An error occurred:', result error);\n}\nconsole log('Account created",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 483,
    "chunk_index": 40,
    "total_chunks": 75
  },
  {
    "id": "ef566dd7aac3d849395187cc970721b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "`Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器將以 JSON 響應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result);\n}\n```\n這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 483,
    "chunk_index": 41,
    "total_chunks": 75
  },
  {
    "id": "a22d30667a21b53b26902c463b24fcb5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "`await responsejson()` 解析 JSON 內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 459,
    "chunk_index": 42,
    "total_chunks": 75
  },
  {
    "id": "c4c378582cedba16c20989a2e34d543c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "內容並返回結果物件。請注意，此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng)\n✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 517,
    "chunk_index": 43,
    "total_chunks": 75
  },
  {
    "id": "9edbeb0d135bb8fbfcc22774b1084a73",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 44,
    "total_chunks": 75
  },
  {
    "id": "e220e5a7a96c2302e89987739f4e194a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "關鍵字以確保在解析期間的任何錯誤也能被捕獲。 現在在 `register` 函數中新增一些程式碼來調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。\n## 資料驗證\n如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 583,
    "chunk_index": 45,
    "total_chunks": 75
  },
  {
    "id": "5bff40c44aec7fceb88d25441261f2e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 520,
    "chunk_index": 46,
    "total_chunks": 75
  },
  {
    "id": "fdbcc80deb34478b6aac22b71cab1c94",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 565,
    "chunk_index": 47,
    "total_chunks": 75
  },
  {
    "id": "94ab45bd5e83ff489cc84fbc9bddcaaf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。\n在將資料發送到伺服器之前，最好先[驗證表單資料](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 48,
    "total_chunks": 75
  },
  {
    "id": "dca405d4391d1a5f204ef95048d39b3c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "= await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 49,
    "total_chunks": 75
  },
  {
    "id": "af4cd3b89ce22e62dd916578c53373c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "= await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前新增 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現：\n- `required`：該欄位必須填寫，否則表單無法提交。\n- `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。\n- `min` 和 `max`：定義數字欄位的最小和最大值。\n- `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 795,
    "chunk_index": 50,
    "total_chunks": 75
  },
  {
    "id": "d4e42f8b31920dc7cca5ae8d7553de84",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "{ ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 736,
    "chunk_index": 51,
    "total_chunks": 75
  },
  {
    "id": "fc8483cf522a7e55f299bb3e3083c1ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "{ ``` 最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。\n- `pattern`：允許定義一個[正則表達式](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 801,
    "chunk_index": 52,
    "total_chunks": 75
  },
  {
    "id": "181a5d42cfd6f36a58f8e40ba22dc809",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 801,
    "chunk_index": 53,
    "total_chunks": 75
  },
  {
    "id": "a663bbe86d619eded9cc70d306bfccd5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "最後，讓我們新增一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。\n提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。\n### 任務\n建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成：\n```html\nUsername (required)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 970,
    "chunk_index": 54,
    "total_chunks": 75
  },
  {
    "id": "eae5a58c514f9940114d97d8f877b5ae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required)\n```\n雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。\n為文字欄位新增 `maxlength` 屬性：\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1003,
    "chunk_index": 55,
    "total_chunks": 75
  },
  {
    "id": "3e439e059d45fb7e357a58ddbd5d0729",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "= await createAccount(jsonData); if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html```\n現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1062,
    "chunk_index": 56,
    "total_chunks": 75
  },
  {
    "id": "34a3f77a9c2aeb2fe6c7e7513c5cde97",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1083,
    "chunk_index": 57,
    "total_chunks": 75
  },
  {
    "id": "586e0aa483ca748542ff2f74a7b62f94",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1084,
    "chunk_index": 58,
    "total_chunks": 75
  },
  {
    "id": "ae52cbbf9d713ea1a8e0c0f6d515504e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1084,
    "chunk_index": 59,
    "total_chunks": 75
  },
  {
    "id": "ca999418d44adcb411c65a58de4f6fa7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1084,
    "chunk_index": 60,
    "total_chunks": 75
  },
  {
    "id": "5dff4678f08aee2d83525c29d60fb35c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1095,
    "chunk_index": 61,
    "total_chunks": 75
  },
  {
    "id": "0ced1308724c8e654d12ff1ec6785b58",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "if (resulterror) { return console log('An error occurred:', result error); } console log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng)\n像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。\n通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。\n---\n## 🚀 挑戰\n如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。\n以下是一個經過一些樣式設計後的最終登入頁面的範例：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1432,
    "chunk_index": 62,
    "total_chunks": 75
  },
  {
    "id": "a0c8f6db8b85d6f8da77405c75e11785",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "log('Account created', result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1434,
    "chunk_index": 63,
    "total_chunks": 75
  },
  {
    "id": "45e2bb12a379f2a8761ef1a84ea0803f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1430,
    "chunk_index": 64,
    "total_chunks": 75
  },
  {
    "id": "e38a8bdefa3eab7325b13a634c874300",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1430,
    "chunk_index": 65,
    "total_chunks": 75
  },
  {
    "id": "7803cfa2f687d470d097bb1a88c6336e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1430,
    "chunk_index": 66,
    "total_chunks": 75
  },
  {
    "id": "76d13b73f76265415373669ce786190b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1440,
    "chunk_index": 67,
    "total_chunks": 75
  },
  {
    "id": "a93fee930d910408813cb2d14723e230",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "result); } ``` 這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng)\n## 課後測驗\n[課後測驗](https://ashy-river-0debb7803",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1473,
    "chunk_index": 68,
    "total_chunks": 75
  },
  {
    "id": "8c38f9ab3554ac4773928bb8e437ff59",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1467,
    "chunk_index": 69,
    "total_chunks": 75
  },
  {
    "id": "e21b3e194793a4a9bd4f74a6122911c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1470,
    "chunk_index": 70,
    "total_chunks": 75
  },
  {
    "id": "7e251c8090fa62deff47382a3c61f1e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "這部分有點長，但我們完成了！如果您打開[瀏覽器開發者工具](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊一個新帳戶，您應該不會看到網頁有任何變化，但控制台中會出現一條訊息，確認一切正常。[瀏覽器控制台中顯示日誌訊息的截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44)\n## 回顧與自學\n開發者在表單構建方面變得非常有創意，特別是在驗證策略方面。透過瀏覽 [CodePen](https://codepen",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1544,
    "chunk_index": 71,
    "total_chunks": 75
  },
  {
    "id": "33a6e5a20d495959bbbee6bfc76bc75a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "/ / /7-bank-project/2-forms/images/browser-consolepng) ✅ 您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 回顧與自學 開發者在表單構建方面變得非常有創意，特別是在驗證策略方面。透過瀏覽 [CodePen](https://codepencom) 來了解不同的表單流程；你能找到一些有趣且具有啟發性的表單嗎？\n## 作業\n[為你的銀行應用程式設計樣式](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1465,
    "chunk_index": 72,
    "total_chunks": 75
  },
  {
    "id": "f06d1819bd1d81fd7fe09ae0d8e8a382",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "您認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？您可以閱讀[HTTPS](https://enwikipediaorg/wiki/HTTPS)來了解更多關於安全資料通信的內容。 ## 資料驗證 如果您嘗試在未設置用戶名的情況下註冊新帳戶，您會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 回顧與自學 開發者在表單構建方面變得非常有創意，特別是在驗證策略方面。透過瀏覽 [CodePen](https://codepencom) 來了解不同的表單流程；你能找到一些有趣且具有啟發性的表單嗎？ ## 作業 [為你的銀行應用程式設計樣式](assignmentmd)\n**免責聲明**：\n本文件使用 AI 翻譯服務 [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1477,
    "chunk_index": 73,
    "total_chunks": 75
  },
  {
    "id": "b31edc27523e1cfcede5fd4880833018",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 2 部分：建立登入和註冊表單",
    "content": "Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保您發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，通過各種屬性實現： - `required`：該欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文字欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，用於測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效自訂其外觀。 ### 任務 建立一個有效的新帳戶需要兩個必填欄位：使用者名稱和貨幣，其他欄位則為選填。更新表單的 HTML，使用 `required` 屬性以及欄位標籤中的文字來達成： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實作並未對欄位的最大長度設置特定限制，但為任何使用者輸入的文字定義合理的限制始終是個好習慣。 為文字欄位新增 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到類似以下的畫面：[嘗試提交表單時顯示的驗證錯誤截圖](////7-bank-project/2-forms/images/validation-errorpng) 像這樣在將任何數據發送到伺服器之前執行的驗證稱為 **客戶端驗證**。但請注意，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同使用者名稱的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實作這兩種驗證。雖然使用客戶端驗證可以通過即時反饋提升使用者體驗，但伺服器端驗證對於確保你處理的使用者數據是可靠且安全的至關重要。 --- ## 🚀 挑戰 如果使用者已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登入頁面的範例：[添加 CSS 樣式後的登入頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 回顧與自學 開發者在表單構建方面變得非常有創意，特別是在驗證策略方面。透過瀏覽 [CodePen](https://codepencom) 來了解不同的表單流程；你能找到一些有趣且具有啟發性的表單嗎？ ## 作業 [為你的銀行應用程式設計樣式](assignmentmd) **免責聲明**： 本文件使用 AI 翻譯服務 [Co-op Translator](https://githubcom/Azure/co-op-translator) 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17190,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1488,
    "chunk_index": 74,
    "total_chunks": 75
  },
  {
    "id": "d6b3fcf050b5a074f566e50f88ad359e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\assignment.md",
    "source_type": "git_repo",
    "title": "模擬一個遊戲",
    "content": "模擬一個遊戲\n說明\n使用課程中的程式碼範例，撰寫一個你喜歡的遊戲的簡易版本。這必須是一個簡單的遊戲，但目標是使用類別或組合模式以及發布/訂閱模式來展示遊戲如何啟動。發揮創意！\n評分標準\n| 評分標準 | 卓越                                               | 合格                                               | 需要改進                                       |\n| -------- | ------------------------------------------------- | ------------------------------------------------- | --------------------------------------------- |\n|          | 在螢幕上放置並操作三個元素                        | 在螢幕上放置並操作兩個元素                        | 在螢幕上放置並操作一個元素                    |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1519,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 425,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "9302cb3c62211afc79a61afa23a3b3bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\assignment.md",
    "source_type": "git_repo",
    "title": "使用 Canvas API 玩創意",
    "content": "使用 Canvas API 玩創意\n說明\n選擇 Canvas API 的一個元素，圍繞它創造一些有趣的東西。你能創造一個由重複星星組成的小銀河嗎？你能創造一個由彩色線條組成的有趣紋理嗎？你可以參考 CodePen 尋找靈感（但不要抄襲）。\n評分標準\n| 評分標準 | 優秀                                                      | 合格                              | 需要改進             |\n| -------- | --------------------------------------------------------- | --------------------------------- | --------------------- |\n|          | 提交的程式碼展示了一個有趣的紋理或形狀                   | 提交了程式碼，但無法執行          | 未提交程式碼          |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1423,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 412,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f2c4f64316c9e562d7020f9090d4e8bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas\n課前測驗\n課前測驗\nCanvas\nCanvas 是一個 HTML 元素，預設沒有內容；它是一個空白的畫布。你需要透過繪製來添加內容。\n✅ 在 MDN 上閱讀 更多關於 Canvas API 的資訊。\n以下是它通常在頁面中宣告的方式：\n```html\n```\n上面我們設定了 id、width 和 height。\nid：設定這個值以便在需要與其互動時取得引用。\nwidth：這是元素的寬度。\nheight：這是元素的高度。\n繪製簡單幾何圖形\nCanvas 使用笛卡爾座標系統來繪製物件。因此，它使用 x 軸和 y 軸來表示物件的位置。位置 0,0 是左上角，而右下角則是你設定的 Canvas 的寬度和高度。\n圖片來源：MDN\n要在 Canvas 元素上繪製，你需要完成以下步驟：\n取得 Canvas 元素的引用。\n取得 Canvas 元素上的 Context 元素的引用。\n使用 Context 元素執行繪製操作。\n上述步驟的程式碼通常如下所示：\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = document getElementById(\"myCanvas\");\n//2 set the context to 2D to draw basic shapes\nctx = canvas getContext(\"2d\");\n//3 fill it with the color red\nctx fillStyle = 'red';\n//4 and draw a rectangle with these parameters, setting location and size\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 478,
    "chunk_index": 0,
    "total_chunks": 16
  },
  {
    "id": "cbdc56cef54901d280fc8f531bc576e7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "軸和 y 軸來表示物件的位置。位置 0,0 是左上角，而右下角則是你設定的 Canvas 的寬度和高度。 圖片來源：MDN 要在 Canvas 元素上繪製，你需要完成以下步驟： 取得 Canvas 元素的引用。 取得 Canvas 元素上的 Context 元素的引用。 使用 Context 元素執行繪製操作。 上述步驟的程式碼通常如下所示： ```javascript // draws a red rectangle //1 get the canvas reference canvas = document getElementById(\"myCanvas\"); //2 set the context to 2D to draw basic shapes ctx = canvas getContext(\"2d\"); //3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height\n```\n✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。\n使用 Canvas API，你可以繪製各種內容，例如：\n幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。\n文字，你可以使用任何字體和顏色繪製文字。\n圖片，你可以基於圖片資源（例如 jpg 或",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 389,
    "chunk_index": 1,
    "total_chunks": 16
  },
  {
    "id": "0ed8c5540dbd7ea812710557f1e66b6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "// draws a red rectangle //1 get the canvas reference canvas = document getElementById(\"myCanvas\"); //2 set the context to 2D to draw basic shapes ctx = canvas getContext(\"2d\"); //3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API，你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字體和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。\n✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。\n加載並繪製圖片資源\n你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後，監聽 load 事件以確保圖片已準備好使用。程式碼如下：\n加載資源\njavascript\nconst img = new Image();\nimg src = 'path/to/my/image png';\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 470,
    "chunk_index": 2,
    "total_chunks": 16
  },
  {
    "id": "cc10ca4472bad5d2048533a129367d5b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "//3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API，你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字體和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。 ✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。 加載並繪製圖片資源 你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後，監聽 load 事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => {\n// image loaded and ready to be used\n}\n加載資源模式\n建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在圖片完全加載後才嘗試操作它：\n```javascript\nfunction loadAsset(path) {\nreturn new Promise((resolve) => {\nconst img = new Image();\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 539,
    "chunk_index": 3,
    "total_chunks": 16
  },
  {
    "id": "ec244a0d158c6338debcf5b9416590a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API，你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字體和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。 ✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。 加載並繪製圖片資源 你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後，監聽 load 事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } 加載資源模式 建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在圖片完全加載後才嘗試操作它： ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path;\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 4,
    "total_chunks": 16
  },
  {
    "id": "6a92a78a96863ad890cf21f584f14f3f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API，你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字體和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。 ✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。 加載並繪製圖片資源 你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後，監聽 load 事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } 加載資源模式 建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在圖片完全加載後才嘗試操作它： ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path; imgonload = () => {\n// image loaded and ready to be used\nresolve(img);\n}\n})\n}\n// use like so\nasync function run() {\nconst heroImg = await loadAsset('hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 5,
    "total_chunks": 16
  },
  {
    "id": "022a4ec3984d1053ce60b009da75fc03",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } 加載資源模式 建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在圖片完全加載後才嘗試操作它： ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path; imgonload = () => { // image loaded and ready to be used resolve(img); } }) } // use like so async function run() { const heroImg = await loadAsset('heropng')\nconst monsterImg = await loadAsset('monster png')\n}\n```\n要將遊戲資源繪製到螢幕上，程式碼如下：\n```javascript\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster png')\ncanvas = document getElementById(\"myCanvas\");\nctx = canvas getContext(\"2d\");\nctx drawImage(heroImg, canvas width/2,canvas height/2);\nctx drawImage(monsterImg, 0,0);\n}\n```\n現在是開始建立你的遊戲的時候了\n要建立什麼\n你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片：\n英雄飛船\n5*5 怪物\n建議的開發步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 6,
    "total_chunks": 16
  },
  {
    "id": "32857b2d528f59486f36c262209f41cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "} // use like so async function run() { const heroImg = await loadAsset('heropng') const monsterImg = await loadAsset('monster png') } ``` 要將遊戲資源繪製到螢幕上，程式碼如下： ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是開始建立你的遊戲的時候了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng\n-| player png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 335,
    "chunk_index": 7,
    "total_chunks": 16
  },
  {
    "id": "9efc08e324e142d2a1b44459aa6d79e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "= await loadAsset('heropng') const monsterImg = await loadAsset('monster png') } ``` 要將遊戲資源繪製到螢幕上，程式碼如下： ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是開始建立你的遊戲的時候了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson\n在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code，並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡是設置方法。\n通過導航到 your_work 資料夾來啟動你的專案：\nbash\ncd your-work\nnpm start\n上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。\n注意：要在螢幕上看到更改，請刷新瀏覽器。\n添加程式碼\n在 your-work/app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 546,
    "chunk_index": 8,
    "total_chunks": 16
  },
  {
    "id": "826dbfcf221b2555f7b68fcc00dcec20",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是開始建立你的遊戲的時候了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code，並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡是設置方法。 通過導航到 your_work 資料夾來啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到更改，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下內容：\n繪製一個黑色背景的 Canvas\n提示：在 /app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 9,
    "total_chunks": 16
  },
  {
    "id": "d02e75a83d88402de913b438dff0d8b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "= canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是開始建立你的遊戲的時候了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code，並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡是設置方法。 通過導航到 your_work 資料夾來啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到更改，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下內容： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將左上角座標設置為 0,0，高度和寬度等於 Canvas 的大小。\n加載材質\n提示：使用 await loadTexture 並傳入圖片路徑來添加玩家和敵人圖片。你暫時還看不到它們出現在螢幕上！\n繪製英雄到螢幕中央的下半部分\n提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 681,
    "chunk_index": 10,
    "total_chunks": 16
  },
  {
    "id": "a584ad67dd91a6998c8f0aecd8ce109e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code，並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡是設置方法。 通過導航到 your_work 資料夾來啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到更改，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下內容： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將左上角座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來添加玩家和敵人圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕中央的下半部分 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 542,
    "chunk_index": 11,
    "total_chunks": 16
  },
  {
    "id": "9436cf444145e0423582e22c53c51f25",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "-| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code，並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡是設置方法。 通過導航到 your_work 資料夾來啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到更改，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下內容： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將左上角座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來添加玩家和敵人圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕中央的下半部分 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 12,
    "total_chunks": 16
  },
  {
    "id": "21bb25f66436b47618083d9663deee9e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "-| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code，並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡是設置方法。 通過導航到 your_work 資料夾來啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到更改，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下內容： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將左上角座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來添加玩家和敵人圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕中央的下半部分 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvasheight / 4)。\n繪製 5*5 怪物\n提示：現在你可以取消註解程式碼以在螢幕上繪製敵人。接下來，進入 createEnemies 函數並完成它。\n首先，設置一些常數：\n```javascript\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 600,
    "chunk_index": 13,
    "total_chunks": 16
  },
  {
    "id": "9e992d9ebbad6c72c92a801fccea1262",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "npm，這裡是設置方法。 通過導航到 your_work 資料夾來啟動你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到更改，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下內容： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將左上角座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來添加玩家和敵人圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕中央的下半部分 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvasheight / 4)。 繪製 5*5 怪物 提示：現在你可以取消註解程式碼以在螢幕上繪製敵人。接下來，進入 createEnemies 函數並完成它。 首先，設置一些常數： ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\n```\n然後，建立一個迴圈以將怪物陣列繪製到螢幕上：\n```javascript\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 613,
    "chunk_index": 14,
    "total_chunks": 16
  },
  {
    "id": "c576febe89200025d980cac31a81d66d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvasheight / 4)。 繪製 5*5 怪物 提示：現在你可以取消註解程式碼以在螢幕上繪製敵人。接下來，進入 createEnemies 函數並完成它。 首先，設置一些常數： ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; ``` 然後，建立一個迴圈以將怪物陣列繪製到螢幕上： ```javascript for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { ctxdrawImage(enemyImg, x, y);\n}\n}\n```\n結果\n完成的結果應如下所示：\n解答\n請先嘗試自己解決，但如果遇到困難，可以查看 解答。\n🚀 挑戰\n你已經學習了使用以 2D 為主的 Canvas API；看看 WebGL API，並嘗試繪製一個 3D 物件。\n課後測驗\n課後測驗\n複習與自學\n透過 閱讀相關內容 來深入了解 Canvas API。\n作業\n使用 Canvas API\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 630,
    "chunk_index": 15,
    "total_chunks": 16
  },
  {
    "id": "56685d3cbd025d8e22fd545ba9e69e2b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "建立太空遊戲第一部分：介紹\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於專案規模較小，並不需要過多考慮應用程式的設計架構。然而，當應用程式的規模和範圍擴大時，架構設計就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩者各有優缺點，但我們可以從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一是關於設計模式。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡爾座標系統中有一個位置，通常由 x 和 y 座標來表示。當你開發遊戲時，你會注意到所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，例如：\n基於位置 大多數（如果不是全部）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些物件可以移動到新的位置。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在一段時間，然後會設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件的一個典型屬性。典型例子是文字或圖形效果（如爆炸），它們只需要顯示幾毫秒。\n✅ 想想像吃豆人這樣的遊戲。你能在這個遊戲中識別出上述四種物件類型嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼我們如何編碼這些行為呢？我們可以通過與類別或物件相關聯的方法來表達這些行為。\n類別\n我們可以使用 類別 和 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的文章關於繼承 中了解更多。\n用程式碼表示，遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 938,
    "chunk_index": 0,
    "total_chunks": 18
  },
  {
    "id": "f418037c73a221716a54e391920a19b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "建立太空遊戲第一部分：介紹\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於專案規模較小，並不需要過多考慮應用程式的設計架構。然而，當應用程式的規模和範圍擴大時，架構設計就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩者各有優缺點，但我們可以從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一是關於設計模式。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡爾座標系統中有一個位置，通常由 x 和 y 座標來表示。當你開發遊戲時，你會注意到所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，例如：\n基於位置 大多數（如果不是全部）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些物件可以移動到新的位置。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在一段時間，然後會設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件的一個典型屬性。典型例子是文字或圖形效果（如爆炸），它們只需要顯示幾毫秒。\n✅ 想想像吃豆人這樣的遊戲。你能在這個遊戲中識別出上述四種物件類型嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼我們如何編碼這些行為呢？我們可以通過與類別或物件相關聯的方法來表達這些行為。\n類別\n我們可以使用 類別 和 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的文章關於繼承 中了解更多。\n用程式碼表示，遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 943,
    "chunk_index": 1,
    "total_chunks": 18
  },
  {
    "id": "53aac2e41a5ece52b753904647937cd9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "建立太空遊戲第一部分：介紹\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於專案規模較小，並不需要過多考慮應用程式的設計架構。然而，當應用程式的規模和範圍擴大時，架構設計就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩者各有優缺點，但我們可以從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一是關於設計模式。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡爾座標系統中有一個位置，通常由 x 和 y 座標來表示。當你開發遊戲時，你會注意到所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，例如：\n基於位置 大多數（如果不是全部）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些物件可以移動到新的位置。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在一段時間，然後會設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件的一個典型屬性。典型例子是文字或圖形效果（如爆炸），它們只需要顯示幾毫秒。\n✅ 想想像吃豆人這樣的遊戲。你能在這個遊戲中識別出上述四種物件類型嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼我們如何編碼這些行為呢？我們可以通過與類別或物件相關聯的方法來表達這些行為。\n類別\n我們可以使用 類別 和 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的文章關於繼承 中了解更多。\n用程式碼表示，遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthisy = y;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 948,
    "chunk_index": 2,
    "total_chunks": 18
  },
  {
    "id": "7610147c6ed4a16a0988c6e2862fea4e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "建立太空遊戲第一部分：介紹\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於專案規模較小，並不需要過多考慮應用程式的設計架構。然而，當應用程式的規模和範圍擴大時，架構設計就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩者各有優缺點，但我們可以從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一是關於設計模式。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡爾座標系統中有一個位置，通常由 x 和 y 座標來表示。當你開發遊戲時，你會注意到所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，例如：\n基於位置 大多數（如果不是全部）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些物件可以移動到新的位置。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在一段時間，然後會設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件的一個典型屬性。典型例子是文字或圖形效果（如爆炸），它們只需要顯示幾毫秒。\n✅ 想想像吃豆人這樣的遊戲。你能在這個遊戲中識別出上述四種物件類型嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼我們如何編碼這些行為呢？我們可以通過與類別或物件相關聯的方法來表達這些行為。\n類別\n我們可以使用 類別 和 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的文章關於繼承 中了解更多。\n用程式碼表示，遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthisy = y;\nthistype = type;\n}\n}\n//this class will extend the GameObject's inherent class properties\nclass Movable extends GameObject {\nconstructor(x,y, type) {\nsuper(x,y, type)\n}\n//this movable object can be moved on the screen\nmoveTo(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1006,
    "chunk_index": 3,
    "total_chunks": 18
  },
  {
    "id": "a8187d130738fe341e264d92e6623677",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "冷卻時間 \"冷卻時間\" 是短暫存在的物件的一個典型屬性。典型例子是文字或圖形效果（如爆炸），它們只需要顯示幾毫秒。 ✅ 想想像吃豆人這樣的遊戲。你能在這個遊戲中識別出上述四種物件類型嗎？ 表達行為 上述描述的都是遊戲物件可能具有的行為。那麼我們如何編碼這些行為呢？我們可以通過與類別或物件相關聯的方法來表達這些行為。 類別 我們可以使用 類別 和 繼承 來為類別添加特定的行為。 ✅ 繼承是一個重要的概念。可以在 MDN 的文章關於繼承 中了解更多。 用程式碼表示，遊戲物件通常看起來像這樣： ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x; thisy = y; thistype = type; } } //this class will extend the GameObject's inherent class properties class Movable extends GameObject { constructor(x,y, type) { super(x,y, type) } //this movable object can be moved on the screen moveTo(x, y) { thisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 411,
    "chunk_index": 4,
    "total_chunks": 18
  },
  {
    "id": "99632764542586297aea23caa4eae464",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "✅ 想想像吃豆人這樣的遊戲。你能在這個遊戲中識別出上述四種物件類型嗎？ 表達行為 上述描述的都是遊戲物件可能具有的行為。那麼我們如何編碼這些行為呢？我們可以通過與類別或物件相關聯的方法來表達這些行為。 類別 我們可以使用 類別 和 繼承 來為類別添加特定的行為。 ✅ 繼承是一個重要的概念。可以在 MDN 的文章關於繼承 中了解更多。 用程式碼表示，遊戲物件通常看起來像這樣： ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x; thisy = y; thistype = type; } } //this class will extend the GameObject's inherent class properties class Movable extends GameObject { constructor(x,y, type) { super(x,y, type) } //this movable object can be moved on the screen moveTo(x, y) { thisx = x; thisy = y;\n}\n}\n//this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits\nclass Hero extends Movable {\nconstructor(x,y) {\nsuper(x,y, 'Hero')\n}\n}\n//this class, on the other hand, only inherits the GameObject properties\nclass Tree extends GameObject {\nconstructor(x,y) {\nsuper(x,y, 'Tree')\n}\n}\n//a hero can move const hero = new Hero();\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 440,
    "chunk_index": 5,
    "total_chunks": 18
  },
  {
    "id": "a34480493eb57c5ed0d9b42cee4422d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "moveTo(x, y) { thisx = x; thisy = y; } } //this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits class Hero extends Movable { constructor(x,y) { super(x,y, 'Hero') } } //this class, on the other hand, only inherits the GameObject properties class Tree extends GameObject { constructor(x,y) { super(x,y, 'Tree') } } //a hero can move const hero = new Hero(); heromoveTo(5,5);\n//but a tree cannot\nconst tree = new Tree();\n```\n✅ 花幾分鐘重新構想一個吃豆人英雄（例如 Inky、Pinky 或 Blinky），並思考如何用 JavaScript 編寫它。\n組合\n另一種處理物件繼承的方法是使用 組合。在這種情況下，物件的行為表達如下：\n```javascript\n//create a constant gameObject\nconst gameObject = {\nx: 0,\ny: 0,\ntype: ''\n};\n// and a constant movable\nconst movable = {\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//then the constant movableObject is composed of the gameObject and movable constants\nconst movableObject = { gameObject, movable};\n//then create a function to create a new Hero who inherits the movableObject properties\nfunction createHero(x, y) {\nreturn { movableObject,\nx,\ny,\ntype: 'Hero'\n}\n}\n// and a static object that inherits only the gameObject properties\nfunction createStatic(x, y, type) {\nreturn { gameObject\nx,\ny,\ntype\n}\n}\n//create the hero and move it\nconst hero = createHero(10,10);\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 410,
    "chunk_index": 6,
    "total_chunks": 18
  },
  {
    "id": "c5885be94bd41150f02d4703c5e233d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "is composed of the gameObject and movable constants const movableObject = { gameObject, movable}; //then create a function to create a new Hero who inherits the movableObject properties function createHero(x, y) { return { movableObject, x, y, type: 'Hero' } } // and a static object that inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); heromoveTo(5,5);\n//and create a static tree which only stands around\nconst tree = createStatic(0,0, 'Tree');\n```\n我應該使用哪種模式？\n選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。\n--\n在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。\nPub/sub 模式\n✅ Pub/Sub 代表 \"發布-訂閱\"\n這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成：\n訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。\n發布者：這個元素發布訊息並將其發送給所有訂閱者。\n訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。\n這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式：\n```javascript\n//set up an EventEmitter class that contains listeners\nclass EventEmitter {\nconstructor() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 596,
    "chunk_index": 7,
    "total_chunks": 18
  },
  {
    "id": "5492cca7a95c1cee10c13e97387c6640",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 我應該使用哪種模式？ 選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {};\n}\n//when a message is received, let the listener to handle its payload\non(message, listener) {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 561,
    "chunk_index": 8,
    "total_chunks": 18
  },
  {
    "id": "447527b4aa2cf12a41c1629caf7fed53",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 我應該使用哪種模式？ 選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 533,
    "chunk_index": 9,
    "total_chunks": 18
  },
  {
    "id": "cf1e7f16830bdd1cd5a4ecb93b760760",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 我應該使用哪種模式？ 選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 539,
    "chunk_index": 10,
    "total_chunks": 18
  },
  {
    "id": "d55e6ebae6151f3aa1c17440f7fec2db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 我應該使用哪種模式？ 選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = [];\n}\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 11,
    "total_chunks": 18
  },
  {
    "id": "f86e4e81a47ae11a42930088c47687cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "= createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 我應該使用哪種模式？ 選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 12,
    "total_chunks": 18
  },
  {
    "id": "d9e56a51deaee02da758b1789943d0bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "= createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 我應該使用哪種模式？ 選擇哪種模式完全取決於你自己。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener);\n}\n//when a message is sent, send it to a listener with some payload\nemit(message, payload = null) {\nif (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 13,
    "total_chunks": 18
  },
  {
    "id": "2982c32e01e5f84f87a6ee12fae7578f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "-- 在遊戲開發中，另一種常見模式是解決遊戲的使用者體驗和效能問題。 Pub/sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 14,
    "total_chunks": 18
  },
  {
    "id": "553428c0a30af7325d4ac201016de6cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "模式 ✅ Pub/Sub 代表 \"發布-訂閱\" 這種模式的核心理念是應用程式的不同部分不應該彼此了解。為什麼呢？這樣可以讓整體運作更加清晰，並且在需要時更容易改變行為。我們如何實現這一點？我們通過建立以下概念來完成： 訊息：訊息通常是一個文字字串，並伴隨一個可選的有效負載（用於說明訊息內容的資料）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布訊息並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定訊息，並根據接收到的訊息執行某些任務，例如發射雷射。 這種模式的實現非常簡單，但功能非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { this listeners[message]forEach(l => l(message, payload))\n}\n}\n}\n```\n要使用上述程式碼，我們可以建立一個非常小的實現：\n```javascript\n//set up a message structure\nconst Messages = {\nHERO_MOVE_LEFT: 'HERO_MOVE_LEFT'\n};\n//invoke the eventEmitter you set up above\nconst eventEmitter = new EventEmitter();\n//set up a hero\nconst hero = createHero(0,0);\n//let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 567,
    "chunk_index": 15,
    "total_chunks": 18
  },
  {
    "id": "c994bd301894f8b18e1fc238c44f3375",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { this listeners[message]forEach(l => l(message, payload)) } } } ``` 要使用上述程式碼，我們可以建立一個非常小的實現： ```javascript //set up a message structure const Messages = { HERO_MOVE_LEFT: 'HERO_MOVE_LEFT' }; //invoke the eventEmitter you set up above const eventEmitter = new EventEmitter(); //set up a hero const hero = createHero(0,0); //let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it eventEmitteron(Messages HERO_MOVE_LEFT, () => {\nhero move(5,0);\n});\n//set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left\nwindow addEventListener('keyup', (evt) => {\nif (evt key === 'ArrowLeft') {\neventEmitter emit(Messages HERO_MOVE_LEFT)\n}\n});\n```\n在上面的程式碼中，我們連接了一個鍵盤事件 ArrowLeft，並發送 HERO_MOVE_LEFT 訊息。我們監聽該訊息並移動 hero 作為結果。這種模式的優勢在於事件監聽器和英雄彼此並不相互了解。你可以將 ArrowLeft 重新映射到 A 鍵。此外，通過對 eventEmitter 的 on 函數進行一些編輯，也可以在 ArrowLeft 上執行完全不同的操作：\njavascript\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 404,
    "chunk_index": 16,
    "total_chunks": 18
  },
  {
    "id": "bec04280c95dd8e362afd1898dc71675",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第一部分：介紹",
    "content": "on it eventEmitteron(Messages HERO_MOVE_LEFT, () => { hero move(5,0); }); //set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left window addEventListener('keyup', (evt) => { if (evt key === 'ArrowLeft') { eventEmitter emit(Messages HERO_MOVE_LEFT) } }); ``` 在上面的程式碼中，我們連接了一個鍵盤事件 ArrowLeft，並發送 HERO_MOVE_LEFT 訊息。我們監聽該訊息並移動 hero 作為結果。這種模式的優勢在於事件監聽器和英雄彼此並不相互了解。你可以將 ArrowLeft 重新映射到 A 鍵。此外，通過對 eventEmitter 的 on 函數進行一些編輯，也可以在 ArrowLeft 上執行完全不同的操作： javascript eventEmitter on(Messages HERO_MOVE_LEFT, () => { heromove(5,0);\n});\n隨著遊戲規模的擴大，這種模式的複雜度保持不變，並且你的程式碼保持整潔。非常推薦採用這種模式。\n🚀 挑戰\n思考 Pub-Sub 模式如何增強遊戲。哪些部分應該發出事件，遊戲應如何對它們做出反應？現在是你發揮創意的時候，想出一個新遊戲並思考它的各個部分可能如何運作。\n課後測驗\n課後測驗\n回顧與自學\n透過閱讀相關內容來了解更多關於 Pub/Sub 的知識。\n作業\n模擬一個遊戲\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8808,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 697,
    "chunk_index": 17,
    "total_chunks": 18
  },
  {
    "id": "1d7061d152da4b0051fbf47ac7649210",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "為程式碼添加註解",
    "content": "為程式碼添加註解\n說明\n檢查你遊戲資料夾中的 /app.js 檔案，找出可以添加註解和整理的地方。程式碼很容易變得混亂，現在是一個好機會添加註解，確保你的程式碼易於閱讀，方便日後使用。\n評分標準\n| 評分標準 | 優秀                                                          | 合格                              | 需要改進                                              |\n| -------- | ------------------------------------------------------------- | --------------------------------- | ---------------------------------------------------- |\n|          | app.js 程式碼完全添加了註解，並整理成邏輯區塊               | app.js 程式碼有適當的註解       | app.js 程式碼有些混亂，缺乏良好的註解              |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1518,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 422,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "1565cb29f417aecd2318deca353a4060",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\assignment.md",
    "source_type": "git_repo",
    "title": "探索碰撞",
    "content": "探索碰撞\n說明\n為了更好地理解碰撞的運作方式，建立一個包含少量物件的簡單遊戲，讓這些物件可以發生碰撞。透過按鍵或滑鼠點擊讓它們移動，並在其中一個物件被撞擊時觸發某些事件。這可以是像隕石撞擊地球，或者碰碰車之類的情境。發揮創意吧！\n評分標準\n| 評分項目 | 卓越                                                                                                                | 合格                       | 需要改進         |\n| -------- | -------------------------------------------------------------------------------------------------------------------- | -------------------------- | ----------------- |\n|          | 提供完整可運行的程式碼範例，物件成功繪製到畫布上，基本碰撞發生，並且有反應產生                                       | 程式碼在某些方面不完整     | 程式碼運行失敗   |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "68d4940b95419a6ce0dab183ab2932ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "建立銀行應用程式第 3 部分：抓取與使用資料的方法\n課前測驗\n課前測驗\n簡介\n在每個網頁應用程式的核心都有一個關鍵元素：資料。資料可以有多種形式，但其主要目的是向使用者顯示資訊。隨著網頁應用程式變得越來越互動且複雜，使用者如何存取和互動資訊已成為網頁開發中的關鍵部分。\n在本課中，我們將學習如何從伺服器非同步抓取資料，並使用這些資料在不重新載入 HTML 的情況下，在網頁上顯示資訊。\n先決條件\n在本課之前，你需要完成網頁應用程式的 登入與註冊表單 部分。此外，你需要安裝 Node js 並在本地執行 伺服器 API，以便獲取帳戶資料。\n你可以透過在終端機執行以下指令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 407,
    "chunk_index": 0,
    "total_chunks": 79
  },
  {
    "id": "a870c8eabbeac57cda80fe15b4ba329c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "建立銀行應用程式第 3 部分：抓取與使用資料的方法\n課前測驗\n課前測驗\n簡介\n在每個網頁應用程式的核心都有一個關鍵元素：資料。資料可以有多種形式，但其主要目的是向使用者顯示資訊。隨著網頁應用程式變得越來越互動且複雜，使用者如何存取和互動資訊已成為網頁開發中的關鍵部分。\n在本課中，我們將學習如何從伺服器非同步抓取資料，並使用這些資料在不重新載入 HTML 的情況下，在網頁上顯示資訊。\n先決條件\n在本課之前，你需要完成網頁應用程式的 登入與註冊表單 部分。此外，你需要安裝 Node js 並在本地執行 伺服器 API，以便獲取帳戶資料。\n你可以透過在終端機執行以下指令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAX 與資料抓取\n傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。\n隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。\n在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。\n雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 982,
    "chunk_index": 1,
    "total_chunks": 79
  },
  {
    "id": "fe28ea3217d8fc06d38b01961fc7541b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "課前測驗 簡介 在每個網頁應用程式的核心都有一個關鍵元素：資料。資料可以有多種形式，但其主要目的是向使用者顯示資訊。隨著網頁應用程式變得越來越互動且複雜，使用者如何存取和互動資訊已成為網頁開發中的關鍵部分。 在本課中，我們將學習如何從伺服器非同步抓取資料，並使用這些資料在不重新載入 HTML 的情況下，在網頁上顯示資訊。 先決條件 在本課之前，你需要完成網頁應用程式的 登入與註冊表單 部分。此外，你需要安裝 Node js 並在本地執行 伺服器 API，以便獲取帳戶資料。 你可以透過在終端機執行以下指令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。\n任務\n在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1016,
    "chunk_index": 2,
    "total_chunks": 79
  },
  {
    "id": "3159886980225a02242141c016d48005",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "HTML 的情況下，在網頁上顯示資訊。 先決條件 在本課之前，你需要完成網頁應用程式的 登入與註冊表單 部分。此外，你需要安裝 Node js 並在本地執行 伺服器 API，以便獲取帳戶資料。 你可以透過在終端機執行以下指令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式：\njs\nasync function login() {\nconst loginForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 847,
    "chunk_index": 3,
    "total_chunks": 79
  },
  {
    "id": "89d0c98cc764ef38e436b8b230046263",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm')\nconst user = loginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 711,
    "chunk_index": 4,
    "total_chunks": 79
  },
  {
    "id": "e460f377dfc4eaea118137b7a8f26cb5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "should return \"Bank API v1 00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 701,
    "chunk_index": 5,
    "total_chunks": 79
  },
  {
    "id": "3690f468b9cd08d351c4b47c1af4c278",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "should return \"Bank API v1 00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue;\n}\n我們首先使用 getElementById() 取得表單元素，然後透過 loginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 6,
    "total_chunks": 79
  },
  {
    "id": "87b8aab21c63e7331e38b414931a7597",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 我們首先使用 getElementById() 取得表單元素，然後透過 loginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 7,
    "total_chunks": 79
  },
  {
    "id": "0f73faaf097d0023c215eca5309fa0e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "00\" as a result ``` AJAX 與資料抓取 傳統的網站在使用者點擊連結或提交表單時，會透過重新載入整個 HTML 頁面來更新顯示的內容。每次需要載入新資料時，網頁伺服器會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的使用者操作並限制重新載入期間的互動。這種工作流程也被稱為 多頁應用程式（Multi-Page Application, MPA）。 隨著網頁應用程式變得更加複雜和互動性更強，一種名為 AJAX（非同步 JavaScript 和 XML） 的新技術應運而生。這種技術允許網頁應用程式使用 JavaScript 非同步地向伺服器發送和接收資料，而無需重新載入 HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 我們首先使用 getElementById() 取得表單元素，然後透過 loginFormuservalue 從輸入欄位中獲取使用者名稱。每個表單控制項都可以透過其名稱（在 HTML 中使用 name 屬性設定）作為表單的屬性來存取。\n類似於我們為註冊所做的，我們將建立另一個函式來執行伺服器請求，但這次是為了抓取帳戶資料：\njs\nasync function getAccount(user) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 898,
    "chunk_index": 8,
    "total_chunks": 79
  },
  {
    "id": "e68cf229b1cf385d03d89f6cf649c75d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "HTML 頁面，從而實現更快的更新和更流暢的使用者互動。當從伺服器接收到新資料時，可以使用 DOM API 透過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 我們首先使用 getElementById() 取得表單元素，然後透過 loginFormuservalue 從輸入欄位中獲取使用者名稱。每個表單控制項都可以透過其名稱（在 HTML 中使用 name 屬性設定）作為表單的屬性來存取。 類似於我們為註冊所做的，我們將建立另一個函式來執行伺服器請求，但這次是為了抓取帳戶資料： js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson();\n} catch (error) {\nreturn { error: error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 607,
    "chunk_index": 9,
    "total_chunks": 79
  },
  {
    "id": "f7d525ff75f38219a5efb96bf252ed79",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "頁面。隨著時間的推移，這種方法演變成現在所謂的 單頁應用程式（Single-Page Application, SPA）。 在 AJAX 剛推出時，唯一可用的非同步抓取資料的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 資料。 雖然所有現代瀏覽器都支援 Fetch API，但如果你希望你的網頁應用程式能在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 上的相容性表。 任務 在上一課中，我們實現了註冊表單來建立帳戶。現在我們將新增程式碼來使用現有帳戶登入並抓取其資料。打開 appjs 檔案，新增一個新的 login 函式： js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } 我們首先使用 getElementById() 取得表單元素，然後透過 loginFormuservalue 從輸入欄位中獲取使用者名稱。每個表單控制項都可以透過其名稱（在 HTML 中使用 name 屬性設定）作為表單的屬性來存取。 類似於我們為註冊所做的，我們將建立另一個函式來執行伺服器請求，但這次是為了抓取帳戶資料： js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' };\n}\n}\n我們使用 fetch API 非同步地向伺服器請求資料，但這次除了要呼叫的 URL 外，我們不需要其他額外的參數，因為我們只是查詢資料。預設情況下，fetch 會建立一個 GET HTTP 請求，這正是我們需要的。\n✅ encodeURIComponent() 是一個用於對 URL 中的特殊字元進行編碼的函式。如果我們不呼叫此函式而直接在 URL 中使用 user 值，可能會出現什麼問題？\n現在我們來更新 login 函式以使用 getAccount：\n```js\nasync function login() {\nconst loginForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 766,
    "chunk_index": 10,
    "total_chunks": 79
  },
  {
    "id": "7b665dba03ed40efc0e3688818bfba80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "= loginFormuservalue; } 我們首先使用 getElementById() 取得表單元素，然後透過 loginFormuservalue 從輸入欄位中獲取使用者名稱。每個表單控制項都可以透過其名稱（在 HTML 中使用 name 屬性設定）作為表單的屬性來存取。 類似於我們為註冊所做的，我們將建立另一個函式來執行伺服器請求，但這次是為了抓取帳戶資料： js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } 我們使用 fetch API 非同步地向伺服器請求資料，但這次除了要呼叫的 URL 外，我們不需要其他額外的參數，因為我們只是查詢資料。預設情況下，fetch 會建立一個 GET HTTP 請求，這正是我們需要的。 ✅ encodeURIComponent() 是一個用於對 URL 中的特殊字元進行編碼的函式。如果我們不呼叫此函式而直接在 URL 中使用 user 值，可能會出現什麼問題？ 現在我們來更新 login 函式以使用 getAccount： ```js async function login() { const loginForm = documentgetElementById('loginForm')\nconst user = loginForm user value;\nconst data = await getAccount(user);\nif (data error) {\nreturn console log('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 11,
    "total_chunks": 79
  },
  {
    "id": "21c4657187d57c57c38fac8b9331c8c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "{ const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } 我們使用 fetch API 非同步地向伺服器請求資料，但這次除了要呼叫的 URL 外，我們不需要其他額外的參數，因為我們只是查詢資料。預設情況下，fetch 會建立一個 GET HTTP 請求，這正是我們需要的。 ✅ encodeURIComponent() 是一個用於對 URL 中的特殊字元進行編碼的函式。如果我們不呼叫此函式而直接在 URL 中使用 user 值，可能會出現什麼問題？ 現在我們來更新 login 函式以使用 getAccount： ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror);\n}\naccount = data;\nnavigate('/dashboard');\n}\n```\n首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。\n接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數：\njs\nlet account = null;\n在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。\n最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML：\n```html\n```\n透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。\n在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式：\n```js\naccount = result;\nnavigate('/dashboard');\n```\n✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 882,
    "chunk_index": 12,
    "total_chunks": 79
  },
  {
    "id": "cacc5a443c56bfd6f0052ac4484f9aef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 632,
    "chunk_index": 13,
    "total_chunks": 79
  },
  {
    "id": "c2b837505efe874c5e951034731b86cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。\n> 透過學習這個[課程](https://docs",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 721,
    "chunk_index": 14,
    "total_chunks": 79
  },
  {
    "id": "173630335277bec28646042c5324d730",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 711,
    "chunk_index": 15,
    "total_chunks": 79
  },
  {
    "id": "3c7a7ac97362f66c1bfc98b916ec2901",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 724,
    "chunk_index": 16,
    "total_chunks": 79
  },
  {
    "id": "0f5f84097d9a4de3b5da15fde8ae7553",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WT",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 17,
    "total_chunks": 79
  },
  {
    "id": "a39e84f872117ad9febeca19b5a27727",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const user = loginForm user value; const data = await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。\n## 更新 HTML 以顯示資料\n現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 810,
    "chunk_index": 18,
    "total_chunks": 79
  },
  {
    "id": "f6498d3feb9905d9490cf05d36853a9f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "await getAccount(user); if (data error) { return console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API：\n- 使用 [`textContent`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 850,
    "chunk_index": 19,
    "total_chunks": 79
  },
  {
    "id": "a42cfd8cbf2b6cf8533774024062eca4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 840,
    "chunk_index": 20,
    "total_chunks": 79
  },
  {
    "id": "43faa28d75b4de4ee0f001a8238d7475",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "console log('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。\n- 使用 [`document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 947,
    "chunk_index": 21,
    "total_chunks": 79
  },
  {
    "id": "e6868899c740bcf0b929e0245d585bb4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 941,
    "chunk_index": 22,
    "total_chunks": 79
  },
  {
    "id": "772afe83d22c231462b96a08d3e47ec1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 943,
    "chunk_index": 23,
    "total_chunks": 79
  },
  {
    "id": "25e18beb26480fd766ac798ea22c84c0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "data; navigate('/dashboard'); } ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 962,
    "chunk_index": 24,
    "total_chunks": 79
  },
  {
    "id": "022cf87b0ad24c41273635adbf1b0e54",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "} ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 958,
    "chunk_index": 25,
    "total_chunks": 79
  },
  {
    "id": "dc6b5d28cd3b86e38210c4b9f924ecf7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "} ``` 首先，由於 getAccount 是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。\n✅ 使用元素的 [`innerHTML`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1002,
    "chunk_index": 26,
    "total_chunks": 79
  },
  {
    "id": "8fcbb7a6a24269ce3c2e7163ce60fd95",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 992,
    "chunk_index": 27,
    "total_chunks": 79
  },
  {
    "id": "c81848ebd74bfc25c6410fca146058b8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "是一個非同步函式，我們需要使用 await 關鍵字來等待伺服器的結果。與任何伺服器請求一樣，我們還需要處理錯誤情況。目前我們只會新增一個日誌訊息來顯示錯誤，稍後再回來處理。 接著，我們需要將資料儲存到某個地方，以便稍後用於顯示儀表板資訊。由於 account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1053,
    "chunk_index": 28,
    "total_chunks": 79
  },
  {
    "id": "2feedf918f0e6e4fd0d8fc3f0ab131d0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 895,
    "chunk_index": 29,
    "total_chunks": 79
  },
  {
    "id": "7e4ec74e55672a3d014ec9d81cf566fc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "account 變數尚未存在，我們會在檔案的頂部建立一個全域變數： js let account = null; 在使用者資料儲存到變數後，我們可以使用我們已有的 navigate() 函式從 登入 頁面導航到 儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。\n### 任務\n在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。\n讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前：\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1098,
    "chunk_index": 30,
    "total_chunks": 79
  },
  {
    "id": "553dfbd3024a3d9fd15f397ddaa627f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1010,
    "chunk_index": 31,
    "total_chunks": 79
  },
  {
    "id": "1144c31e2583ac5433b0092da752f96c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "儀表板。 最後，我們需要在提交登入表單時呼叫 login 函式，透過修改 HTML： ```html ``` 透過註冊新帳戶並嘗試使用相同帳戶登入，測試一切是否正常運行。 在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin```\n這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。\n回到 `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1106,
    "chunk_index": 32,
    "total_chunks": 79
  },
  {
    "id": "3ce6d6939cf61da036d680e711c8229f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "在進入下一部分之前，我們還可以透過在函式底部新增以下內容來完成 `register` 函式： ```js account = result; navigate('/dashboard'); ``` ✅ 你知道嗎？預設情況下，你只能從與你正在查看的網頁相同的 *域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`：\n```js\nfunction updateElement(id, text) {\nconst element = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1064,
    "chunk_index": 33,
    "total_chunks": 79
  },
  {
    "id": "492e3134ad5f7e034f0b0722174939cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "*域名與埠* 呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id);\nelement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 975,
    "chunk_index": 34,
    "total_chunks": 79
  },
  {
    "id": "2f353f9a661e4cbe23b1445db34097f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "呼叫伺服器 API？這是瀏覽器強制執行的安全機制。但等等，我們的網頁應用程式運行在 `localhost:3000`，而伺服器 API 運行在 `localhost:5000`，為什麼它能正常運行？透過使用一種名為 [跨來源資源共享（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS) 的技術，如果伺服器在回應中新增特殊標頭，允許特定域名的例外情況，就可以執行跨來源 HTTP 請求。 > 透過學習這個[課程](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)來進一步了解 API。 ## 更新 HTML 以顯示資料 現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text;\n}\n```\n這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息：\n```js\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1062,
    "chunk_index": 35,
    "total_chunks": 79
  },
  {
    "id": "54faf177c72cc3f0d55554e0f3ee7531",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "現在我們已經有了使用者資料，我們需要更新現有的 HTML 來顯示它。我們已經知道如何使用例如 `documentgetElementById()` 從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) {\nreturn updateElement('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 803,
    "chunk_index": 36,
    "total_chunks": 79
  },
  {
    "id": "c213af9c82bb553c0550d4d2b6f1af7d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "從 DOM 中檢索元素。在獲取基礎元素後，以下是一些可以用來修改或新增子元素的 API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror);\n}\n```\n現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 794,
    "chunk_index": 37,
    "total_chunks": 79
  },
  {
    "id": "753c9c6e541378d8c5ecce103282f87f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 38,
    "total_chunks": 79
  },
  {
    "id": "8283368e8b8b9ddfafab6817172a8384",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 777,
    "chunk_index": 39,
    "total_chunks": 79
  },
  {
    "id": "5fd73c5eea9c760ec55255b41b109d7f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 777,
    "chunk_index": 40,
    "total_chunks": 79
  },
  {
    "id": "b9cd6c4698bba0c7b521e0c13fc361a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 777,
    "chunk_index": 41,
    "total_chunks": 79
  },
  {
    "id": "1eab5e8518150de2d1a48aa3888d029a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](////7-bank-project/3-data/images/login-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 787,
    "chunk_index": 42,
    "total_chunks": 79
  },
  {
    "id": "6f58eb3f73ffb4fef44fd81c72acdfed",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "API： - 使用 [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](////7-bank-project/3-data/images/login-errorpng)\n現在我們有了視覺上顯示的錯誤文字，但如果你使用螢幕閱讀器嘗試，會發現什麼都沒有被宣告。為了讓動態新增到頁面的文字能被螢幕閱讀器宣告，我們需要使用一種名為 [Live Region](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 906,
    "chunk_index": 43,
    "total_chunks": 79
  },
  {
    "id": "6f0ceb4ec25b4090e19c547d8d371e1c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "[`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](////7-bank-project/3-data/images/login-errorpng) 現在我們有了視覺上顯示的錯誤文字，但如果你使用螢幕閱讀器嘗試，會發現什麼都沒有被宣告。為了讓動態新增到頁面的文字能被螢幕閱讀器宣告，我們需要使用一種名為 [Live Region](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 905,
    "chunk_index": 44,
    "total_chunks": 79
  },
  {
    "id": "d7bb44323a5d105b40decda5cdec0693",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "[`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent) 屬性可以更改元素的文字內容。請注意，更改此值會移除該元素的所有子元素（如果有的話），並用提供的文字取代。因此，將空字串 `''` 賦值給它也是一種有效的方法來移除給定元素的所有子元素。 - 使用 [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement) 與 [`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append) 方法可以建立並附加一個或多個新的子元素。 ✅ 使用元素的 [`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML) 屬性也可以更改其 HTML 內容，但應避免使用此方法，因為它容易受到 [跨站腳本（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting) 攻擊。 ### 任務 在進入 *儀表板* 畫面之前，我們還需要在 *登入* 頁面上完成一件事。目前，如果你嘗試使用不存在的使用者名稱登入，會在主控台顯示一條訊息，但對於普通使用者來說，畫面上什麼都沒變，完全不知道發生了什麼。 讓我們在登入表單中新增一個佔位元素，以便在需要時顯示錯誤訊息。一個不錯的位置是在登入 `` 之前： ```htmlLogin``` 這個 `` 元素是空的，這意味著在我們新增內容之前，畫面上不會顯示任何東西。我們還為它設定了一個 `id`，以便可以透過 JavaScript 輕鬆檢索它。 回到 `appjs` 檔案，建立一個新的輔助函式 `updateElement`： ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` 這個函式非常簡單：給定一個元素 *id* 和 *text*，它會更新具有匹配 `id` 的 DOM 元素的文字內容。讓我們在 `login` 函式中用此方法取代之前的錯誤訊息： ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` 現在，如果你嘗試使用無效帳戶登入，你應該會看到類似以下的畫面：[登入時顯示錯誤訊息的截圖](////7-bank-project/3-data/images/login-errorpng) 現在我們有了視覺上顯示的錯誤文字，但如果你使用螢幕閱讀器嘗試，會發現什麼都沒有被宣告。為了讓動態新增到頁面的文字能被螢幕閱讀器宣告，我們需要使用一種名為 [Live Region](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) 的技術。在這裡，我們將使用一種特定類型的 Live Region，稱為警示（alert）：\n```html\n```\n為 `register` 函式的錯誤實現相同的行為（別忘了更新 HTML）。\n## 在儀表板上顯示資訊\n使用我們剛剛學到的技術，我們還將處理在儀表板頁面上顯示帳戶資訊。\n以下是從伺服器接收到的帳戶物件的樣子：\n```json\n{\n\"user\": \"test\",\n\"currency\": \"$\",\n\"description\": \"Test account\",\n\"balance\": 75,\n\"transactions\": [\n{ \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 },\n{ \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 },\n{ \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 }\n],\n}\n```\n> 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。\n### 任務\n首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素：\n```html\nBalance:\n```\n接著，我們會在下方新增一個區塊來顯示帳戶描述：\n```html\n```\n✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1418,
    "chunk_index": 45,
    "total_chunks": 79
  },
  {
    "id": "1e9311113230107d9a33a22e66e5d22e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "``` 為 `register` 函式的錯誤實現相同的行為（別忘了更新 HTML）。 ## 在儀表板上顯示資訊 使用我們剛剛學到的技術，我們還將處理在儀表板頁面上顯示帳戶資訊。 以下是從伺服器接收到的帳戶物件的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensa",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 46,
    "total_chunks": 79
  },
  {
    "id": "5094981802825c22d1b836091a5eaef7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "``` 為 `register` 函式的錯誤實現相同的行為（別忘了更新 HTML）。 ## 在儀表板上顯示資訊 使用我們剛剛學到的技術，我們還將處理在儀表板頁面上顯示帳戶資訊。 以下是從伺服器接收到的帳戶物件的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。\n接下來，我們會在 `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 536,
    "chunk_index": 47,
    "total_chunks": 79
  },
  {
    "id": "cd28ff9cbec332f5c8216c35de32c4d9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "函式的錯誤實現相同的行為（別忘了更新 HTML）。 ## 在儀表板上顯示資訊 使用我們剛剛學到的技術，我們還將處理在儀表板頁面上顯示帳戶資訊。 以下是從伺服器接收到的帳戶物件的樣子： ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素：\n```js\nfunction updateDashboard() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 563,
    "chunk_index": 48,
    "total_chunks": 79
  },
  {
    "id": "18ef3dd9e33ea218c3c0d7de7afca108",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "{ \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) {\nreturn navigate('/login');\n}\nupdateElement('description', account description);\nupdateElement('balance', account balance toFixed(2));\nupdateElement('currency', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 49,
    "total_chunks": 79
  },
  {
    "id": "217ea6267cc2578db612bb859ca1e254",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "\"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency);\n}\n```\n首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。\n> 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 546,
    "chunk_index": 50,
    "total_chunks": 79
  },
  {
    "id": "1e0d0e39743ba4e2b21999aebc3aaed9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "}, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 51,
    "total_chunks": 79
  },
  {
    "id": "54937c563f24b9bdab19d3b916581bfc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "}, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。\n現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 602,
    "chunk_index": 52,
    "total_chunks": 79
  },
  {
    "id": "8a1c3548fd8e39f554df3791c5d28229",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "\"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。 現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](/1-template-route/assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 587,
    "chunk_index": 53,
    "total_chunks": 79
  },
  {
    "id": "c221cef846dafab2927f0b72937201ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "\"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。 現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則你可以使用以下實現。\n將以下程式碼新增到 `updateRoute()` 函式的結尾：\n```js\nif (typeof route",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 645,
    "chunk_index": 54,
    "total_chunks": 79
  },
  {
    "id": "9aa68fef3d488ce7aa886ccfc89b5703",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "\"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。 現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則你可以使用以下實現。 將以下程式碼新增到 `updateRoute()` 函式的結尾： ```js if (typeof routeinit === 'function') {\nroute",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 635,
    "chunk_index": 55,
    "total_chunks": 79
  },
  {
    "id": "5e37957f941477d919c117881083b95b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "\"amount\": -5 } ], } ``` > 注意：為了讓你的操作更簡單，你可以使用已經填充了資料的預設 `test` 帳戶。 ### 任務 首先，將 HTML 中的 \"Balance\" 區塊替換為新增的佔位元素： ```html Balance: ``` 接著，我們會在下方新增一個區塊來顯示帳戶描述： ```html ``` ✅ 由於帳戶描述作為其下方內容的標題，因此它被語意化地標記為標題。了解更多關於 [標題結構](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility) 為何對無障礙性很重要，並批判性地檢視頁面，判斷還有哪些內容可以作為標題。 接下來，我們會在 `appjs` 中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。 現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則你可以使用以下實現。 將以下程式碼新增到 `updateRoute()` 函式的結尾： ```js if (typeof routeinit === 'function') { routeinit();\n}\n```\n並更新路由定義為：\n```js\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: updateDashboard }\n};\n```\n透過此更改，每次顯示儀表板頁面時，`updateDashboard()` 函式都會被呼叫。登入後，你應該能看到帳戶餘額、貨幣和描述。\n## 使用 HTML 模板動態建立表格列\n在[第一課](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 763,
    "chunk_index": 56,
    "total_chunks": 79
  },
  {
    "id": "f3be5c88c74be29e9a6299fdb1c99f61",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "中建立一個新函式來填充佔位元素： ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。 現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則你可以使用以下實現。 將以下程式碼新增到 `updateRoute()` 函式的結尾： ```js if (typeof routeinit === 'function') { routeinit(); } ``` 並更新路由定義為： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 透過此更改，每次顯示儀表板頁面時，`updateDashboard()` 函式都會被呼叫。登入後，你應該能看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態建立表格列 在[第一課](/1-template-route/README md)中，我們使用 HTML 模板與 [`appendChild()`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 57,
    "total_chunks": 79
  },
  {
    "id": "5a6c809d5565a541d497a46ad7476dee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "if (account) { return navigate('/login'); } updateElement('description', account description); updateElement('balance', account balance toFixed(2)); updateElement('currency', accountcurrency); } ``` 首先，我們檢查是否有需要的帳戶資料，然後再繼續。接著，我們使用之前建立的 `updateElement()` 函式來更新 HTML。 > 為了讓餘額顯示得更漂亮，我們使用方法 [`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 強制顯示小數點後 2 位數。 現在我們需要在每次載入儀表板時呼叫 `updateDashboard()` 函式。如果你已完成 [第一課的作業](/1-template-route/assignmentmd)，這應該很簡單，否則你可以使用以下實現。 將以下程式碼新增到 `updateRoute()` 函式的結尾： ```js if (typeof routeinit === 'function') { routeinit(); } ``` 並更新路由定義為： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 透過此更改，每次顯示儀表板頁面時，`updateDashboard()` 函式都會被呼叫。登入後，你應該能看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態建立表格列 在[第一課](/1-template-route/README md)中，我們使用 HTML 模板與 [`appendChild()`](https://developer mozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中重複的部分。\n我們將使用類似的方法來在 HTML 表格中顯示交易列表。\n### 任務\n在 HTML `` 中新增一個新模板：\n```html\n```\n此模板代表一個表格列，包含我們想要填充的 3 個欄位：交易的 *日期*、*物件* 和 *金額*。\n接著，為儀表板模板中的表格 `` 元素新增此 `id` 屬性，以便透過 JavaScript 更容易找到它：\n```html\n```\n我們的 HTML 已準備好，現在切換到 JavaScript 程式碼並建立一個新函式 `createTransactionRow`：\n```js\nfunction createTransactionRow(transaction) {\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 735,
    "chunk_index": 58,
    "total_chunks": 79
  },
  {
    "id": "0d19d6e96a3fe3df2b25b071e11780bc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "routeinit(); } ``` 並更新路由定義為： ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` 透過此更改，每次顯示儀表板頁面時，`updateDashboard()` 函式都會被呼叫。登入後，你應該能看到帳戶餘額、貨幣和描述。 ## 使用 HTML 模板動態建立表格列 在[第一課](/1-template-route/README md)中，我們使用 HTML 模板與 [`appendChild()`](https://developer mozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中重複的部分。 我們將使用類似的方法來在 HTML 表格中顯示交易列表。 ### 任務 在 HTML `` 中新增一個新模板： ```html ``` 此模板代表一個表格列，包含我們想要填充的 3 個欄位：交易的 *日期*、*物件* 和 *金額*。 接著，為儀表板模板中的表格 `` 元素新增此 `id` 屬性，以便透過 JavaScript 更容易找到它： ```html ``` 我們的 HTML 已準備好，現在切換到 JavaScript 程式碼並建立一個新函式 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction');\nconst transactionRow = template content cloneNode(true);\nconst tr = transactionRow querySelector('tr');\ntr children[0] textContent = transaction date;\ntr children[1] textContent = transaction object;\ntr children[2] textContent = transaction amount",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 501,
    "chunk_index": 59,
    "total_chunks": 79
  },
  {
    "id": "e82652b251f57bfe6074a00da9c5fc58",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "在[第一課](/1-template-route/README md)中，我們使用 HTML 模板與 [`appendChild()`](https://developer mozillaorg/docs/Web/API/Node/appendChild) 方法實現了應用程式中的導航。模板也可以更小，並用於動態填充頁面中重複的部分。 我們將使用類似的方法來在 HTML 表格中顯示交易列表。 ### 任務 在 HTML `` 中新增一個新模板： ```html ``` 此模板代表一個表格列，包含我們想要填充的 3 個欄位：交易的 *日期*、*物件* 和 *金額*。 接著，為儀表板模板中的表格 `` 元素新增此 `id` 屬性，以便透過 JavaScript 更容易找到它： ```html ``` 我們的 HTML 已準備好，現在切換到 JavaScript 程式碼並建立一個新函式 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transaction amounttoFixed(2);\nreturn transactionRow;\n}\n```\n此函式正如其名稱所示：使用我們先前建立的模板，建立一個新的表格列，並使用交易資料填充其內容。我們將在 `updateDashboard()` 函式中使用此函式來填充表格：\n```js\nconst transactionsRows = document createDocumentFragment();\nfor (const transaction of account transactions) {\nconst transactionRow = createTransactionRow(transaction);\ntransactionsRows",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 60,
    "total_chunks": 79
  },
  {
    "id": "68262996ff2f1295378c81e8cee3b614",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "`` 元素新增此 `id` 屬性，以便透過 JavaScript 更容易找到它： ```html ``` 我們的 HTML 已準備好，現在切換到 JavaScript 程式碼並建立一個新函式 `createTransactionRow`： ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = template content cloneNode(true); const tr = transactionRow querySelector('tr'); tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transaction amounttoFixed(2); return transactionRow; } ``` 此函式正如其名稱所示：使用我們先前建立的模板，建立一個新的表格列，並使用交易資料填充其內容。我們將在 `updateDashboard()` 函式中使用此函式來填充表格： ```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow);\n}\nupdateElement('transactions', transactionsRows);\n```\n在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。\n在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼：\n```js\nfunction updateElement(id, textOrNode) {\nconst element = document getElementById(id);\nelement textContent = ''; // Removes all children\nelement append(textOrNode);\n}\n```\n我們使用 [`append()`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 61,
    "total_chunks": 79
  },
  {
    "id": "f02bda84afc824471caf06cb67336e80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "textContent = transaction object; tr children[2] textContent = transaction amounttoFixed(2); return transactionRow; } ``` 此函式正如其名稱所示：使用我們先前建立的模板，建立一個新的表格列，並使用交易資料填充其內容。我們將在 `updateDashboard()` 函式中使用此函式來填充表格： ```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 381,
    "chunk_index": 62,
    "total_chunks": 79
  },
  {
    "id": "0e18ac9bd31a1e36b16984800036e0fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "tr children[2] textContent = transaction amounttoFixed(2); return transactionRow; } ``` 此函式正如其名稱所示：使用我們先前建立的模板，建立一個新的表格列，並使用交易資料填充其內容。我們將在 `updateDashboard()` 函式中使用此函式來填充表格： ```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。\n如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。\n---\n## 🚀 挑戰\n一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 550,
    "chunk_index": 63,
    "total_chunks": 79
  },
  {
    "id": "817c964ccd265de7b35640c39fb570f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "`updateDashboard()` 函式中使用此函式來填充表格： ```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 64,
    "total_chunks": 79
  },
  {
    "id": "6ce55453666957651eba3446f7e7067f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "`updateDashboard()` 函式中使用此函式來填充表格： ```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 65,
    "total_chunks": 79
  },
  {
    "id": "ba1e2ef28becb90514c24c002c4945d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 66,
    "total_chunks": 79
  },
  {
    "id": "adce9bafc230b8a227b1f1489b7e8614",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "```js const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。\n以下是一個設計過的儀表板頁面的範例：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 552,
    "chunk_index": 67,
    "total_chunks": 79
  },
  {
    "id": "ff6faf17b6ce6141808d6261c6a788fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 68,
    "total_chunks": 79
  },
  {
    "id": "eaf2ab8011f94d9e6aaef04c6c6e5829",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 69,
    "total_chunks": 79
  },
  {
    "id": "546b68291189982cfa428801c4146023",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 70,
    "total_chunks": 79
  },
  {
    "id": "4e3586dd95326e4d31945e22acc97380",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 71,
    "total_chunks": 79
  },
  {
    "id": "8680cc78b1d85ad82218b2284368e371",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 583,
    "chunk_index": 72,
    "total_chunks": 79
  },
  {
    "id": "8903be793515af86e5f677f171742c21",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionsRows = document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2png)\n## 課後測驗\n[課後測驗](https://ashy-river-0debb7803",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 616,
    "chunk_index": 73,
    "total_chunks": 79
  },
  {
    "id": "2d7a02b255c01af3630e55f428b471fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 611,
    "chunk_index": 74,
    "total_chunks": 79
  },
  {
    "id": "6e754542fcc4d37a7dc43ed8abdf2c1b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 614,
    "chunk_index": 75,
    "total_chunks": 79
  },
  {
    "id": "4331b52f7dbe76a22b903e0c69c202f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "document createDocumentFragment(); for (const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/46)\n## 作業\n[重構並註解你的程式碼](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 644,
    "chunk_index": 76,
    "total_chunks": 79
  },
  {
    "id": "a7ce524d1be561560f8b30110b9f34d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "(const transaction of account transactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/46) ## 作業 [重構並註解你的程式碼](assignmentmd)\n**免責聲明**：\n本文件使用 AI 翻譯服務 [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 668,
    "chunk_index": 77,
    "total_chunks": 79
  },
  {
    "id": "6b45571fe9eca72f50906c0a327dc792",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 3 部分：抓取與使用資料的方法",
    "content": "const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` 在這裡，我們使用方法 [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment)，它會建立一個新的 DOM 片段，我們可以在其上操作，然後最終將其附加到 HTML 表格中。 在此程式碼能正常運行之前，我們還需要做一件事，因為我們的 `updateElement()` 函式目前僅支援文字內容。讓我們稍微修改其程式碼： ```js function updateElement(id, textOrNode) { const element = document getElementById(id); element textContent = ''; // Removes all children element append(textOrNode); } ``` 我們使用 [`append()`](https://developer mozillaorg/docs/Web/API/ParentNode/append) 方法，因為它允許將文字或 [DOM 節點](https://developer mozillaorg/docs/Web/API/Node) 附加到父元素，這非常適合我們的所有使用情境。 如果你嘗試使用 `test` 帳戶登入，現在應該可以在儀表板上看到交易清單了 🎉。 --- ## 🚀 挑戰 一起合作讓儀表板頁面看起來像一個真正的銀行應用程式。如果你已經為你的應用程式設計了樣式，試著使用 [媒體查詢](https://developermozillaorg/docs/Web/CSS/Media_Queries) 來創建一個 [響應式設計](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)，讓它在桌面和行動裝置上都能良好運作。 以下是一個設計過的儀表板頁面的範例：[儀表板樣式化後的範例結果截圖](////7-bank-project/images/screen2png) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/46) ## 作業 [重構並註解你的程式碼](assignmentmd) **免責聲明**： 本文件使用 AI 翻譯服務 [Co-op Translator](https://githubcom/Azure/co-op-translator) 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對於因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17064,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 824,
    "chunk_index": 78,
    "total_chunks": 79
  },
  {
    "id": "f3eddbd4e46957c76ea4919a1050f2cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\assignment.md",
    "source_type": "git_repo",
    "title": "建立一個計分遊戲",
    "content": "建立一個計分遊戲\n指導說明\n創建一個遊戲，並以創意的方式顯示生命值和分數。一個建議是將生命值顯示為心形，並將分數顯示為螢幕底部中央的大數字。可以參考這裡的免費遊戲資源\n評分標準\n| 評分標準 | 優秀                     | 合格                        | 需要改進                   |\n| -------- | ------------------------ | --------------------------- | -------------------------- |\n|          | 完整的遊戲呈現           | 部分遊戲呈現                | 部分遊戲包含錯誤           |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1316,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 406,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "295534fd722b29dcb78a51aba846f8d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 667,
    "chunk_index": 0,
    "total_chunks": 53
  },
  {
    "id": "bf4e9619398e65cb1bd7d509306df381",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 1,
    "total_chunks": 53
  },
  {
    "id": "eae3dbd0c41ad3409aeaa5982f4b9c68",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 2,
    "total_chunks": 53
  },
  {
    "id": "d0152b7c367d7a9ef5fb221a66fd7bba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 680,
    "chunk_index": 3,
    "total_chunks": 53
  },
  {
    "id": "336a80ff11f692651f5495a53d21c23f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 685,
    "chunk_index": 4,
    "total_chunks": 53
  },
  {
    "id": "c9380b14c4003b6a342014e6c9d77d35",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 5,
    "total_chunks": 53
  },
  {
    "id": "7a6947927f5768bceeee4f36f952b0af",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 729,
    "chunk_index": 6,
    "total_chunks": 53
  },
  {
    "id": "5b3433e068d58d461c3cad888490b49b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 7,
    "total_chunks": 53
  },
  {
    "id": "3482854fe034df0e2b35e193229ff768",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 735,
    "chunk_index": 8,
    "total_chunks": 53
  },
  {
    "id": "362d28cd01f6116f61851131d06a523b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 9,
    "total_chunks": 53
  },
  {
    "id": "2eb40cbe4aa53e45c40abe9ab8a46136",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 743,
    "chunk_index": 10,
    "total_chunks": 53
  },
  {
    "id": "8e56f7e254aab1c8d9632a84219f8b9b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 747,
    "chunk_index": 11,
    "total_chunks": 53
  },
  {
    "id": "5c9d92e76da866341dba97ffe0b75d49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 751,
    "chunk_index": 12,
    "total_chunks": 53
  },
  {
    "id": "7a7661f65ce6c7563f10ea326f40bee2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 755,
    "chunk_index": 13,
    "total_chunks": 53
  },
  {
    "id": "41516442691ee341bef2da4b7e93f38c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 759,
    "chunk_index": 14,
    "total_chunks": 53
  },
  {
    "id": "f1c2db8f04c53433fb1ae9b9bb365cbd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1top);\n}\n我們如何銷毀物件\n要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示：\njavascript\n// collision happened\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 884,
    "chunk_index": 15,
    "total_chunks": 53
  },
  {
    "id": "16bda96988c3b73b657fdb6cb44cad51",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "建造太空遊戲第四部分：新增雷射並檢測碰撞\n課前測驗\n課前測驗\n在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能：\n雷射：雷射從英雄的飛船垂直向上發射\n碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。\n✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？\n讓我們一起成為英雄吧！\n碰撞檢測\n我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。\n如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容：\n一種獲取遊戲物件矩形表示的方法，例如：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n一個比較函數，該函數可以如下所示：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1top);\n}\n我們如何銷毀物件\n要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示：\njavascript\n// collision happened\nenemydead = true\n然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示：\njavascript\ngameObjects = gameObject",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 930,
    "chunk_index": 16,
    "total_chunks": 53
  },
  {
    "id": "77dbda5b207f23e8a6f898bd6bb0a47c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "課前測驗 在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能： 雷射：雷射從英雄的飛船垂直向上發射 碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。 ✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？ 讓我們一起成為英雄吧！ 碰撞檢測 我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容： 一種獲取遊戲物件矩形表示的方法，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 895,
    "chunk_index": 17,
    "total_chunks": 53
  },
  {
    "id": "ffe4812a49b6c47867f5647d24c37691",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能： 雷射：雷射從英雄的飛船垂直向上發射 碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。 ✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？ 讓我們一起成為英雄吧！ 碰撞檢測 我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容： 一種獲取遊戲物件矩形表示的方法，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 889,
    "chunk_index": 18,
    "total_chunks": 53
  },
  {
    "id": "5b2ac2eb076612d7bc8eb4b9f67dfcca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "在本課中，你將學習如何使用 JavaScript 發射雷射！我們將為遊戲新增以下兩項功能： 雷射：雷射從英雄的飛船垂直向上發射 碰撞檢測，作為實現射擊功能的一部分，我們還會加入一些有趣的遊戲規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 簡而言之，你——英雄——需要在敵人到達螢幕底部之前，用雷射擊中所有敵人。 ✅ 做一些研究，了解第一個被編寫的電腦遊戲。它的功能是什麼？ 讓我們一起成為英雄吧！ 碰撞檢測 我們如何進行碰撞檢測？需要將遊戲物件視為移動的矩形。你可能會問為什麼？因為用來繪製遊戲物件的圖像是一個矩形：它有 x、y、寬度 和 高度。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容： 一種獲取遊戲物件矩形表示的方法，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead);\n我們如何發射雷射\n發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟：\n創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。\n綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。\n創建看起來像雷射的遊戲物件：當按下按鍵時。\n雷射的冷卻時間\n雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現：\n```javascript\nclass Cooldown {\nconstructor(time) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1237,
    "chunk_index": 19,
    "total_chunks": 53
  },
  {
    "id": "369067fd253ac1bb1011c3783cfb01cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "x、y、寬度 和 高度。 如果兩個矩形（例如英雄和敵人）相交，就發生了碰撞。碰撞後應該發生什麼取決於遊戲規則。要實現碰撞檢測，你需要以下內容： 一種獲取遊戲物件矩形表示的方法，例如： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false;\nsetTimeout(() => {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 760,
    "chunk_index": 20,
    "total_chunks": 53
  },
  {
    "id": "2aaba2f5a5037e95cf73cd3cd37a1232",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true;\n}, time)\n}\n}\nclass Weapon {\nconstructor {\n}\nfire() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 657,
    "chunk_index": 21,
    "total_chunks": 53
  },
  {
    "id": "581fbe3d4662dc6a566a61b8cb433954",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "} } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 22,
    "total_chunks": 53
  },
  {
    "id": "bc52033bd71cd71a49a350901377d5d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "} } 一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 629,
    "chunk_index": 23,
    "total_chunks": 53
  },
  {
    "id": "3086cca1f71bfb195ec0371ab104c291",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldown",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 24,
    "total_chunks": 53
  },
  {
    "id": "412202b0a19398feffa5bede1526d84d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "一個比較函數，該函數可以如下所示： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) {\n// produce a laser\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 25,
    "total_chunks": 53
  },
  {
    "id": "de383bc5c3e11d71caf71be063a72ce2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500);\n} else {\n// do nothing - it hasn't cooled down yet",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 26,
    "total_chunks": 53
  },
  {
    "id": "7f4f0c38dbd41c981b8a2bc76170ed5f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "} 我們如何銷毀物件 要在遊戲中銷毀物件，你需要讓遊戲知道在某個時間間隔觸發的遊戲迴圈中不再繪製該物件。一種方法是當某些事情發生時，將遊戲物件標記為死亡，如下所示： javascript // collision happened enemydead = true 然後你可以在重新繪製螢幕之前篩選出死亡的物件，如下所示： javascript gameObjects = gameObjectfilter(go =>godead); 我們如何發射雷射 發射雷射意味著響應按鍵事件並創建一個向某個方向移動的物件。因此，我們需要執行以下步驟： 創建雷射物件：從英雄飛船的頂部開始，創建後立即向螢幕頂部移動。 綁定按鍵事件：我們需要選擇鍵盤上的某個按鍵來代表玩家發射雷射。 創建看起來像雷射的遊戲物件：當按下按鍵時。 雷射的冷卻時間 雷射需要在每次按下按鍵（例如 空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet}\n}\n}\n```\n✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。\n要建造什麼\n你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。\n提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。\n新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則：\n雷射擊中敵人：敵人被雷射擊中後死亡\n雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀\n敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀\n敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1007,
    "chunk_index": 27,
    "total_chunks": 53
  },
  {
    "id": "74dcdff2a06b949e2d674cebab90e755",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "空格鍵）時發射。為了防止遊戲在短時間內生成過多雷射，我們需要解決這個問題。解決方法是實現所謂的冷卻時間，即一個計時器，確保雷射只能以一定頻率發射。你可以這樣實現： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 614,
    "chunk_index": 28,
    "total_chunks": 53
  },
  {
    "id": "99176ee0f8a779e99148848d2c6cd751",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 505,
    "chunk_index": 29,
    "total_chunks": 53
  },
  {
    "id": "a4237079b8aecc98cb25f96fd7b89940",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "{ constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 30,
    "total_chunks": 53
  },
  {
    "id": "473c95fa6cee1b22e4843c7bb1855fae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "{ thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 31,
    "total_chunks": 53
  },
  {
    "id": "175f88f7a1bcfbd5657849e168654a04",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "= false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 32,
    "total_chunks": 53
  },
  {
    "id": "de6399a82072783d63eed194f5d0dee0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson\n你可以通過輸入以下指令啟動你的專案：\nbash\ncd your-work\nnpm start\n上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。\n新增程式碼\n設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它：\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 695,
    "chunk_index": 33,
    "total_chunks": 53
  },
  {
    "id": "a25ec04460f92120ed2254d175526878",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy,\nleft: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 662,
    "chunk_index": 34,
    "total_chunks": 53
  },
  {
    "id": "85aeb69688ae9455c457498be5a877ed",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 665,
    "chunk_index": 35,
    "total_chunks": 53
  },
  {
    "id": "7bc183159ce178d970e26e743aa43e8a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 665,
    "chunk_index": 36,
    "total_chunks": 53
  },
  {
    "id": "2a1eaeda04465117846a3a673ee143b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "} else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight,\nright: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 664,
    "chunk_index": 37,
    "total_chunks": 53
  },
  {
    "id": "27f373bd794b4cd2c9844a1d841333dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "{ // do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 665,
    "chunk_index": 38,
    "total_chunks": 53
  },
  {
    "id": "7fdf9655fddf543f948e351c82beae3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "do nothing - it hasn't cooled down yet} } } ``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth,\n};\n}\n新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交：\njavascript\nfunction intersectRect(r1, r2) {\nreturn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 729,
    "chunk_index": 39,
    "total_chunks": 53
  },
  {
    "id": "a8c952b5ff5ef2e290da5e6b4f9c6ef0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "``` ✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return(\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 720,
    "chunk_index": 40,
    "total_chunks": 53
  },
  {
    "id": "d3cdb994b10c3d1f495068488e7e61d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "✅ 回顧太空遊戲系列的第一課，提醒自己關於冷卻時間的內容。 要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 723,
    "chunk_index": 41,
    "total_chunks": 53
  },
  {
    "id": "10e295417f85351654538ae169ce76a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "要建造什麼 你將使用上一課的現有程式碼（應該已清理並重構），並進行擴展。可以選擇使用第二部分的程式碼或使用 第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 683,
    "chunk_index": 42,
    "total_chunks": 53
  },
  {
    "id": "d573cf2761be4ebd75dfdde68bed586c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "第三部分的起始程式碼。 提示：你將使用的雷射已經在你的資產資料夾中，並且已被程式碼引用。 新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 618,
    "chunk_index": 43,
    "total_chunks": 53
  },
  {
    "id": "9b17add810c4ac50f77b37a76b77362c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "新增碰撞檢測，當雷射與某物件碰撞時，應遵循以下規則： 雷射擊中敵人：敵人被雷射擊中後死亡 雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 566,
    "chunk_index": 44,
    "total_chunks": 53
  },
  {
    "id": "604ce0de3adf9c5b5398817fb7462662",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "雷射擊中螢幕頂部：雷射擊中螢幕頂部後被銷毀 敵人與英雄碰撞：敵人與英雄相撞後雙方都被銷毀 敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 45,
    "total_chunks": 53
  },
  {
    "id": "d702b1899b2111002de9d0275a95d07e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "敵人到達螢幕底部：敵人到達螢幕底部後，敵人和英雄都被銷毀 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom ||\nr2 bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 430,
    "chunk_index": 46,
    "total_chunks": 53
  },
  {
    "id": "3e94b18bab4bff946f4115f1100363cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動 HTTP 伺服器。打開瀏覽器並輸入該地址，目前應該可以渲染英雄和所有敵人，但還沒有任何移動。 新增程式碼 設置遊戲物件的矩形表示以處理碰撞 以下程式碼允許你獲取 GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2 bottom < r1top\n);\n}\n新增雷射發射功能\n新增按鍵事件訊息。空格鍵應在英雄飛船上方創建雷射。在 Messages 物件中新增三個常數：\njavascript\nKEY_EVENT_SPACE: \"KEY_EVENT_SPACE\",\nCOLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\",\nCOLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\",\n處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵：\njavascript\n} else if(evt keyCode === 32) {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 47,
    "total_chunks": 53
  },
  {
    "id": "a88042bddc3d5a95ec0b54866e56276c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "GameObject 的矩形表示。編輯你的 GameObject 類以擴展它： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 新增檢測碰撞的程式碼 這將是一個新函數，用於測試兩個矩形是否相交： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2 bottom < r1top ); } 新增雷射發射功能 新增按鍵事件訊息。空格鍵應在英雄飛船上方創建雷射。在 Messages 物件中新增三個常數： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", 處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵： javascript } else if(evt keyCode === 32) { eventEmitter emit(MessagesKEY_EVENT_SPACE);\n}\n新增監聽器。編輯 initGame() 函數以確保英雄在按下空格鍵時可以發射雷射：\njavascript\neventEmitter on(Messages KEY_EVENT_SPACE, () => {\nif (hero canFire()) {\nhero fire();\n}\n並新增一個新的 eventEmitter on() 函數以確保當敵人與雷射碰撞時的行為：\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 456,
    "chunk_index": 48,
    "total_chunks": 53
  },
  {
    "id": "e1677e78e10f8db882bb9986778381b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "|| r2top > r1bottom || r2 bottom < r1top ); } 新增雷射發射功能 新增按鍵事件訊息。空格鍵應在英雄飛船上方創建雷射。在 Messages 物件中新增三個常數： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", 處理空格鍵。編輯 window addEventListener 的 keyup 函數以處理空格鍵： javascript } else if(evt keyCode === 32) { eventEmitter emit(MessagesKEY_EVENT_SPACE); } 新增監聽器。編輯 initGame() 函數以確保英雄在按下空格鍵時可以發射雷射： javascript eventEmitter on(Messages KEY_EVENT_SPACE, () => { if (hero canFire()) { hero fire(); } 並新增一個新的 eventEmitter on() 函數以確保當敵人與雷射碰撞時的行為： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; seconddead = true;\n})\n```\n移動物件，確保雷射逐漸移動到螢幕頂部。你將創建一個新的 Laser 類，該類擴展了 GameObject，如之前所做：\njavascript\nclass Laser extends GameObject {\nconstructor(x, y) {\nsuper(x,y);\n(this width = 9), (this height = 33);\nthis type = 'Laser';\nthis img = laserImg;\nlet id = setInterval(() => {\nif (this y > 0) {\nthis y -= 15;\n} else {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 49,
    "total_chunks": 53
  },
  {
    "id": "d83be987a00e07cef87f90b6915c0be9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "fire(); } 並新增一個新的 eventEmitter on() 函數以確保當敵人與雷射碰撞時的行為： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; seconddead = true; }) ``` 移動物件，確保雷射逐漸移動到螢幕頂部。你將創建一個新的 Laser 類，該類擴展了 GameObject，如之前所做： javascript class Laser extends GameObject { constructor(x, y) { super(x,y); (this width = 9), (this height = 33); this type = 'Laser'; this img = laserImg; let id = setInterval(() => { if (this y > 0) { this y -= 15; } else { thisdead = true;\nclearInterval(id);\n}\n}, 100)\n}\n}\n處理碰撞，實現雷射的碰撞規則。新增一個 updateGameObjects() 函數，用於測試碰撞物件是否命中：\n```javascript\nfunction updateGameObjects() {\nconst enemies = gameObjects filter(go => go type === 'Enemy');\nconst lasers = gameObjects filter((go) => go type === \"Laser\");\n// laser hit something\nlasers forEach((l) => {\nenemies forEach((m) => {\nif (intersectRect(l rectFromGameObject(), m rectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_LASER, {\nfirst: l,\nsecond: m,\n});\n}\n});\n});\ngameObjects = gameObjects filter(go => go dead);\n}\n```\n確保將 updateGameObjects() 新增到 window onload 的遊戲迴圈中。\n實現雷射的冷卻時間，確保雷射只能以一定頻率發射。\n最後，編輯 Hero 類以實現冷卻功能：\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 50,
    "total_chunks": 53
  },
  {
    "id": "b986b9073aed2a7cff85caade0a1104a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "=> go type === 'Enemy'); const lasers = gameObjects filter((go) => go type === \"Laser\"); // laser hit something lasers forEach((l) => { enemies forEach((m) => { if (intersectRect(l rectFromGameObject(), m rectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_LASER, { first: l, second: m, }); } }); }); gameObjects = gameObjects filter(go => go dead); } ``` 確保將 updateGameObjects() 新增到 window onload 的遊戲迴圈中。 實現雷射的冷卻時間，確保雷射只能以一定頻率發射。 最後，編輯 Hero 類以實現冷卻功能： ```javascript class Hero extends GameObject { constructor(x, y) { super(x, y); (thiswidth = 99), (this height = 75);\nthis type = \"Hero\";\nthis speed = { x: 0, y: 0 };\nthis cooldown = 0;\n}\nfire() {\ngameObjects push(new Laser(this x + 45, this y - 10));\nthis cooldown = 500;\nlet id = setInterval(() => {\nif (this cooldown > 0) {\nthis cooldown -= 100;\n} else {\nclearInterval(id);\n}\n}, 200);\n}\ncanFire() {\nreturn this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 303,
    "chunk_index": 51,
    "total_chunks": 53
  },
  {
    "id": "7e9cb416e8ace782593421e00d742a91",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲第四部分：新增雷射並檢測碰撞",
    "content": "GameObject { constructor(x, y) { super(x, y); (thiswidth = 99), (this height = 75); this type = \"Hero\"; this speed = { x: 0, y: 0 }; this cooldown = 0; } fire() { gameObjects push(new Laser(this x + 45, this y - 10)); this cooldown = 500; let id = setInterval(() => { if (this cooldown > 0) { this cooldown -= 100; } else { clearInterval(id); } }, 200); } canFire() { return thiscooldown === 0;\n}\n}\n```\n到此為止，你的遊戲已具備一些功能！你可以使用方向鍵移動，用空格鍵發射雷射，並且當雷射擊中敵人時，敵人會消失。做得好！\n🚀 挑戰\n新增爆炸效果！查看 太空藝術資源庫 中的遊戲資產，嘗試在雷射擊中外星人時新增爆炸效果。\n課後測驗\n課後測驗\n回顧與自學\n嘗試調整遊戲中的時間間隔。當你改變它們時會發生什麼？閱讀更多關於 JavaScript 計時事件 的內容。\n作業\n探索碰撞\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10677,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 552,
    "chunk_index": 52,
    "total_chunks": 53
  },
  {
    "id": "1d50aaee630a84edb0cb058b64e28ad3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "建立太空遊戲第三部分：加入動作\n課前測驗\n課前測驗\n遊戲中有外星人在螢幕上移動才會更有趣！在這個遊戲中，我們將使用兩種移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與螢幕上的物件互動時。\n遊戲引發的移動：當遊戲以一定的時間間隔移動物件時。\n那麼我們如何在螢幕上移動物件呢？這一切都與笛卡爾座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常需要以下步驟來完成螢幕上的移動：\n設定物件的新位置：這是讓物件看起來像移動過的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以通過繪製一個填充背景色的矩形來清除螢幕。\n在新位置重新繪製物件：通過這樣做，我們最終完成了將物件從一個位置移動到另一個位置。\n以下是程式碼的示例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx fillRect(0, 0, canvas width, canvas height)\nctx fillStyle = \"black\";\nctx drawImage(heroImg, hero x, hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 0,
    "total_chunks": 44
  },
  {
    "id": "af766795cd3e779d53ba18b894a22d6c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "建立太空遊戲第三部分：加入動作\n課前測驗\n課前測驗\n遊戲中有外星人在螢幕上移動才會更有趣！在這個遊戲中，我們將使用兩種移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與螢幕上的物件互動時。\n遊戲引發的移動：當遊戲以一定的時間間隔移動物件時。\n那麼我們如何在螢幕上移動物件呢？這一切都與笛卡爾座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常需要以下步驟來完成螢幕上的移動：\n設定物件的新位置：這是讓物件看起來像移動過的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以通過繪製一個填充背景色的矩形來清除螢幕。\n在新位置重新繪製物件：通過這樣做，我們最終完成了將物件從一個位置移動到另一個位置。\n以下是程式碼的示例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx fillRect(0, 0, canvas width, canvas height)\nctx fillStyle = \"black\";\nctx drawImage(heroImg, hero x, heroy);\n✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。\n處理鍵盤事件\n你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。\n要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。\n以下是一個示例：\njavascript\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 752,
    "chunk_index": 1,
    "total_chunks": 44
  },
  {
    "id": "f64969399419187252fbf00cf616bf65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "建立太空遊戲第三部分：加入動作\n課前測驗\n課前測驗\n遊戲中有外星人在螢幕上移動才會更有趣！在這個遊戲中，我們將使用兩種移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與螢幕上的物件互動時。\n遊戲引發的移動：當遊戲以一定的時間間隔移動物件時。\n那麼我們如何在螢幕上移動物件呢？這一切都與笛卡爾座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常需要以下步驟來完成螢幕上的移動：\n設定物件的新位置：這是讓物件看起來像移動過的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以通過繪製一個填充背景色的矩形來清除螢幕。\n在新位置重新繪製物件：通過這樣做，我們最終完成了將物件從一個位置移動到另一個位置。\n以下是程式碼的示例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx fillRect(0, 0, canvas width, canvas height)\nctx fillStyle = \"black\";\nctx drawImage(heroImg, hero x, heroy);\n✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。\n處理鍵盤事件\n你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。\n要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。\n以下是一個示例：\njavascript\nwindowaddEventListener('keyup', (evt) => {\n// `evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 764,
    "chunk_index": 2,
    "total_chunks": 44
  },
  {
    "id": "8519a99c25e06af1652df8e634945b7e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "建立太空遊戲第三部分：加入動作\n課前測驗\n課前測驗\n遊戲中有外星人在螢幕上移動才會更有趣！在這個遊戲中，我們將使用兩種移動方式：\n鍵盤/滑鼠移動：當使用者透過鍵盤或滑鼠與螢幕上的物件互動時。\n遊戲引發的移動：當遊戲以一定的時間間隔移動物件時。\n那麼我們如何在螢幕上移動物件呢？這一切都與笛卡爾座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。\n通常需要以下步驟來完成螢幕上的移動：\n設定物件的新位置：這是讓物件看起來像移動過的必要步驟。\n清除螢幕：在每次繪製之間需要清除螢幕。我們可以通過繪製一個填充背景色的矩形來清除螢幕。\n在新位置重新繪製物件：通過這樣做，我們最終完成了將物件從一個位置移動到另一個位置。\n以下是程式碼的示例：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx fillRect(0, 0, canvas width, canvas height)\nctx fillStyle = \"black\";\nctx drawImage(heroImg, hero x, heroy);\n✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。\n處理鍵盤事件\n你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。\n要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。\n以下是一個示例：\njavascript\nwindowaddEventListener('keyup', (evt) => {\n// `evtkey` = string representation of the key\nif (evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 3,
    "total_chunks": 44
  },
  {
    "id": "8b27dada4f0ac874fd722b82a22ef3db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "那麼我們如何在螢幕上移動物件呢？這一切都與笛卡爾座標有關：我們改變物件的位置 (x, y)，然後重新繪製螢幕。 通常需要以下步驟來完成螢幕上的移動： 設定物件的新位置：這是讓物件看起來像移動過的必要步驟。 清除螢幕：在每次繪製之間需要清除螢幕。我們可以通過繪製一個填充背景色的矩形來清除螢幕。 在新位置重新繪製物件：通過這樣做，我們最終完成了將物件從一個位置移動到另一個位置。 以下是程式碼的示例： javascript //set the hero's location hero x += 5; // clear the rectangle that hosts the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctx fillRect(0, 0, canvas width, canvas height) ctx fillStyle = \"black\"; ctx drawImage(heroImg, hero x, heroy); ✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。 處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') {\n// do something\n}\n})\n對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵：\nkey：這是一個按鍵的字串表示，例如ArrowUp。\nkeyCode：這是一個數字表示，例如37，對應於ArrowLeft。\n✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？\n特殊鍵：注意事項\n有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼：\n```javascript\nlet onKeyDown = function (e) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 897,
    "chunk_index": 4,
    "total_chunks": 44
  },
  {
    "id": "3263d1b3f1d84f12b8c7514a1e23f817",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctx fillRect(0, 0, canvas width, canvas height) ctx fillStyle = \"black\"; ctx drawImage(heroImg, hero x, heroy); ✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。 處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 622,
    "chunk_index": 5,
    "total_chunks": 44
  },
  {
    "id": "860868461636c9f861ddc94ff7ef47dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctx fillRect(0, 0, canvas width, canvas height) ctx fillStyle = \"black\"; ctx drawImage(heroImg, hero x, heroy); ✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。 處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode);\nswitch (e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 6,
    "total_chunks": 44
  },
  {
    "id": "e11e9264a25ac10a37b34204575e1406",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctx fillRect(0, 0, canvas width, canvas height) ctx fillStyle = \"black\"; ctx drawImage(heroImg, hero x, heroy); ✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。 處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) {\ncase 37:\ncase 39:\ncase 38:\ncase 40: // Arrow keys\ncase 32:\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 653,
    "chunk_index": 7,
    "total_chunks": 44
  },
  {
    "id": "96659238d99ff7a9512f47d515c4cd29",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "fillRect(0, 0, canvas width, canvas height) ctx fillStyle = \"black\"; ctx drawImage(heroImg, hero x, heroy); ✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。 處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault();\nbreak; // Space\ndefault:\nbreak; // do not block other keys\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 651,
    "chunk_index": 8,
    "total_chunks": 44
  },
  {
    "id": "b6569f9ca8664ef780202a630558f813",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "heroy); ✅ 你能想到為什麼每秒重繪你的英雄多幀可能會導致性能成本嗎？閱讀此模式的替代方案。 處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown);\n```\n上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 9,
    "total_chunks": 44
  },
  {
    "id": "8acfee47c31f4d2da354cc8a1d51d961",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "處理鍵盤事件 你可以通過將特定事件附加到程式碼來處理事件。鍵盤事件是在整個窗口上觸發的，而滑鼠事件（例如click）可以連接到點擊特定元素。我們將在整個專案中使用鍵盤事件。 要處理事件，你需要使用窗口的addEventListener()方法並提供兩個輸入參數。第一個參數是事件的名稱，例如keyup。第二個參數是事件發生時應該調用的函數。 以下是一個示例： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。\n遊戲引發的移動\n我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例：\njavascript\nlet id = setInterval(() => {\n//move the enemy on the y axis\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 722,
    "chunk_index": 10,
    "total_chunks": 44
  },
  {
    "id": "be7c3e76b092f532da9a4d0aa421933d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "if (evtkey === 'ArrowUp') { // do something } }) 對於鍵盤事件，事件上有兩個屬性可以用來查看按下了哪個鍵： key：這是一個按鍵的字串表示，例如ArrowUp。 keyCode：這是一個數字表示，例如37，對應於ArrowLeft。 ✅ 鍵盤事件操作在遊戲開發之外也很有用。你能想到這種技術的其他用途嗎？ 特殊鍵：注意事項 有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10;\n})\n遊戲循環\n遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。\n以下是遊戲循環的典型程式碼示例：\njavascript\nlet gameLoopId = setInterval(() =>\nfunction gameLoop() {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 786,
    "chunk_index": 11,
    "total_chunks": 44
  },
  {
    "id": "d3e981bf503cd794407bce5ad3075c8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "有一些特殊鍵會影響窗口。這意味著如果你正在監聽keyup事件並使用這些特殊鍵移動你的英雄，它也會執行水平滾動。因此，在構建遊戲時，你可能需要關閉這種內建的瀏覽器行為。你需要如下程式碼： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 12,
    "total_chunks": 44
  },
  {
    "id": "92633883f36b518c3eec190b6e11f21c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 519,
    "chunk_index": 13,
    "total_chunks": 44
  },
  {
    "id": "25a31e8b877a07d5445391340530a359",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight);\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 522,
    "chunk_index": 14,
    "total_chunks": 44
  },
  {
    "id": "fd50b30a9d470967a22da20cbe9c4056",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "= function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 527,
    "chunk_index": 15,
    "total_chunks": 44
  },
  {
    "id": "979fd5142c799f0a3af921f5ded09c31",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "{ consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 531,
    "chunk_index": 16,
    "total_chunks": 44
  },
  {
    "id": "2cf40441e850b60e8fef38dd740c16b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 528,
    "chunk_index": 17,
    "total_chunks": 44
  },
  {
    "id": "0b13c192c80be59240bc6cb4908b055d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "(ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight);\ndrawHero();\ndrawEnemies();\ndrawStaticObjects();\n}, 200);\n上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。\n繼續太空遊戲\n你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。\n移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。\n移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。\n推薦步驟\n找到在your-work子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 772,
    "chunk_index": 18,
    "total_chunks": 44
  },
  {
    "id": "d5ceac04ca75924a3ada1116272c1759",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "// Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 746,
    "chunk_index": 19,
    "total_chunks": 44
  },
  {
    "id": "309e878d55bdeea6d694dead0e4d6153",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 20,
    "total_chunks": 44
  },
  {
    "id": "c95a46ec85cb678335a1c382be17c4e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "// do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 21,
    "total_chunks": 44
  },
  {
    "id": "30217ae1713b0eb5d6ed8894da53ea82",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 750,
    "chunk_index": 22,
    "total_chunks": 44
  },
  {
    "id": "41061cbc00c093570d9949874b6f116f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上述程式碼將確保箭頭鍵和空格鍵的預設行為被關閉。關閉機制發生在我們調用epreventDefault()時。 遊戲引發的移動 我們可以通過使用計時器（例如setTimeout()或setInterval()函數）讓物件自行移動，這些計時器會在每個時間間隔更新物件的位置。以下是程式碼示例： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson\n你可以通過輸入以下指令啟動你的專案：\nbash\ncd your-work\nnpm start\n上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！\n添加程式碼\n為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。\n提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。\n提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上：\n```javascript\nclass GameObject {\nconstructor(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1016,
    "chunk_index": 23,
    "total_chunks": 44
  },
  {
    "id": "0b3cc4b5d35b762aec8bc1728de7b567",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "the y axis enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 850,
    "chunk_index": 24,
    "total_chunks": 44
  },
  {
    "id": "a85458fba2f89f29ee5aca39e4f5bfe8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "enemyy += 10; }) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 852,
    "chunk_index": 25,
    "total_chunks": 44
  },
  {
    "id": "d0c1e8f85be54232e895edddf9dafe85",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "}) 遊戲循環 遊戲循環是一個概念，基本上是一個以固定間隔調用的函數。它被稱為遊戲循環，因為所有應該顯示給使用者的內容都會在循環中繪製。遊戲循環使用所有屬於遊戲的遊戲物件，繪製所有物件，除非某些原因使其不再屬於遊戲。例如，如果某個物件是被雷射擊中的敵人並爆炸，它就不再屬於當前的遊戲循環（你會在後續課程中學到更多）。 以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 851,
    "chunk_index": 26,
    "total_chunks": 44
  },
  {
    "id": "a35a0d644adf43dc875dab13b088c8e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "以下是遊戲循環的典型程式碼示例： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\";\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 619,
    "chunk_index": 27,
    "total_chunks": 44
  },
  {
    "id": "73eb1011de75f566d774ba5f8ce5c517",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 28,
    "total_chunks": 44
  },
  {
    "id": "3d5b41e2e9b124bcd3ee2bfd60ae205d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "=> function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 29,
    "total_chunks": 44
  },
  {
    "id": "c2c963945e0e602c4678f4e6720cdb56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "{ ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined;\n}\ndraw(ctx) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 30,
    "total_chunks": 44
  },
  {
    "id": "c6a5a02426e5710440ac2b6c66c57c36",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "= \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 590,
    "chunk_index": 31,
    "total_chunks": 44
  },
  {
    "id": "f4b9b0dc2e9366845da8077952c59f62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "= \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 32,
    "total_chunks": 44
  },
  {
    "id": "e4405a14dd32cac95886cc966f92432a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "\"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, thisx, this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 595,
    "chunk_index": 33,
    "total_chunks": 44
  },
  {
    "id": "72aed3c6464e7ff04953a43276175ccd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, thisx, thisy, this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 595,
    "chunk_index": 34,
    "total_chunks": 44
  },
  {
    "id": "776349c18bb8c842e155a8f93b0887ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, thisx, thisy, thiswidth, this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 591,
    "chunk_index": 35,
    "total_chunks": 44
  },
  {
    "id": "337918540e2162a7f36c519b53d484f9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上述循環每200毫秒調用一次以重繪畫布。你可以選擇最適合你的遊戲的間隔。 繼續太空遊戲 你將擴展現有的程式碼。可以使用你在第一部分完成的程式碼，或者使用第二部分的起始程式碼。 移動英雄：你將添加程式碼以確保可以使用箭頭鍵移動英雄。 移動敵人：你還需要添加程式碼以確保敵人以一定速度從上到下移動。 推薦步驟 找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, thisx, thisy, thiswidth, thisheight);\n}\n}\n```\n現在，擴展這個GameObject以創建Hero和Enemy。\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 630,
    "chunk_index": 36,
    "total_chunks": 44
  },
  {
    "id": "45d41610fe02932849c6b0ce1cd64f3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "找到在your-work子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動你的專案： bash cd your-work npm start 上述指令將在地址http://localhost:5000啟動一個HTTP伺服器。打開瀏覽器並輸入該地址，現在它應該渲染英雄和所有敵人；目前還沒有任何移動！ 添加程式碼 為hero、enemy和game object添加專用物件，它們應該具有x和y屬性。（記住繼承或組合部分）。 提示：game object應該是具有x和y屬性並能夠將自己繪製到畫布上的物件。 提示：首先添加一個新的GameObject類，其構造函數如下所示，然後將其繪製到畫布上： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, thisx, thisy, thiswidth, thisheight); } } ``` 現在，擴展這個GameObject以創建Hero和Enemy。 ```javascript class Hero extends GameObject { constructor(x, y) {it needs an x, y, type, and speed\n}\n}\n```\n```javascript\nclass Enemy extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 98), (this height = 50);\nthis type = \"Enemy\";\nlet id = setInterval(() => {\nif (this y < canvas height - this height) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 37,
    "total_chunks": 44
  },
  {
    "id": "793f4a78d3029a64e3f388c3f64ebad1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "= 0; thisimg = undefined; } draw(ctx) { ctxdrawImage(thisimg, thisx, thisy, thiswidth, thisheight); } } ``` 現在，擴展這個GameObject以創建Hero和Enemy。 ```javascript class Hero extends GameObject { constructor(x, y) {it needs an x, y, type, and speed } } ``` ```javascript class Enemy extends GameObject { constructor(x, y) { super(x, y); (this width = 98), (this height = 50); this type = \"Enemy\"; let id = setInterval(() => { if (this y < canvas height - this height) { thisy += 5;\n} else {\nconsole log('Stopped at', this y)\nclearInterval(id);\n}\n}, 300)\n}\n}\n```\n添加鍵盤事件處理程式以處理鍵盤導航（移動英雄上下左右）。\n記住：這是一個笛卡爾系統，左上角是0,0。還要記得添加程式碼以停止預設行為。\n提示：創建你的onKeyDown函數並將其附加到窗口：\n```javascript\nlet onKeyDown = function (e) {\nconsole log(e keyCode); add the code from the lesson above to stop default behavior\n}\n};\nwindow addEventListener(\"keydown\", onKeyDown);\n```\n此時檢查你的瀏覽器控制台，並觀察按鍵被記錄。\n實現Pub sub模式，這將使你的程式碼在接下來的部分中保持乾淨。\n要完成這部分，你可以：\n在窗口上添加事件監聽器：\njavascript\nwindow addEventListener(\"keyup\", (evt) => {\nif (evt key === \"ArrowUp\") {\neventEmitter emit(Messages KEY_EVENT_UP);\n} else if (evt key === \"ArrowDown\") {\neventEmitter emit(Messages KEY_EVENT_DOWN);\n} else if (evt key === \"ArrowLeft\") {\neventEmitter emit(Messages KEY_EVENT_LEFT);\n} else if (evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 38,
    "total_chunks": 44
  },
  {
    "id": "4736f2e3a768e8b3cf36566e40ff5f62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "添加鍵盤事件處理程式以處理鍵盤導航（移動英雄上下左右）。 記住：這是一個笛卡爾系統，左上角是0,0。還要記得添加程式碼以停止預設行為。 提示：創建你的onKeyDown函數並將其附加到窗口： ```javascript let onKeyDown = function (e) { console log(e keyCode); add the code from the lesson above to stop default behavior } }; window addEventListener(\"keydown\", onKeyDown); ``` 此時檢查你的瀏覽器控制台，並觀察按鍵被記錄。 實現Pub sub模式，這將使你的程式碼在接下來的部分中保持乾淨。 要完成這部分，你可以： 在窗口上添加事件監聽器： javascript window addEventListener(\"keyup\", (evt) => { if (evt key === \"ArrowUp\") { eventEmitter emit(Messages KEY_EVENT_UP); } else if (evt key === \"ArrowDown\") { eventEmitter emit(Messages KEY_EVENT_DOWN); } else if (evt key === \"ArrowLeft\") { eventEmitter emit(Messages KEY_EVENT_LEFT); } else if (evtkey === \"ArrowRight\") {\neventEmitter emit(Messages KEY_EVENT_RIGHT);\n}\n});\n創建一個EventEmitter類以發布和訂閱消息：\n```javascript\nclass EventEmitter {\nconstructor() {\nthis listeners = {};\n}\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 428,
    "chunk_index": 39,
    "total_chunks": 44
  },
  {
    "id": "611a07c935bafe4c0e2b3cf54ab0efba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "emit(Messages KEY_EVENT_UP); } else if (evt key === \"ArrowDown\") { eventEmitter emit(Messages KEY_EVENT_DOWN); } else if (evt key === \"ArrowLeft\") { eventEmitter emit(Messages KEY_EVENT_LEFT); } else if (evtkey === \"ArrowRight\") { eventEmitter emit(Messages KEY_EVENT_RIGHT); } }); 創建一個EventEmitter類以發布和訂閱消息： ```javascript class EventEmitter { constructor() { this listeners = {}; } on(message, listener) { if ( this listeners[message]) { this listeners[message] = []; } this listeners[message] push(listener); } emit(message, payload = null) { if (this listeners[message]) { this listeners[message]forEach((l) => l(message, payload));\n}\n}\n}\n```\n添加常數並設置EventEmitter：\n```javascript\nconst Messages = {\nKEY_EVENT_UP: \"KEY_EVENT_UP\",\nKEY_EVENT_DOWN: \"KEY_EVENT_DOWN\",\nKEY_EVENT_LEFT: \"KEY_EVENT_LEFT\",\nKEY_EVENT_RIGHT: \"KEY_EVENT_RIGHT\",\n};\nlet heroImg,\nenemyImg,\nlaserImg,\ncanvas, ctx,\ngameObjects = [],\nhero,\neventEmitter = new EventEmitter();\n```\n初始化遊戲\n```javascript\nfunction initGame() {\ngameObjects = [];\ncreateEnemies();\ncreateHero();\neventEmitter on(Messages KEY_EVENT_UP, () => {\nhero y -=5 ;\n})\neventEmitter on(Messages KEY_EVENT_DOWN, () => {\nhero y += 5;\n});\neventEmitter on(Messages KEY_EVENT_LEFT, () => {\nhero x -= 5;\n});\neventEmitter on(Messages KEY_EVENT_RIGHT, () => {\nhero x += 5;\n});\n}\n```\n設置遊戲循環\n重構window onload函數以初始化遊戲並以適當的間隔設置遊戲循環。你還將添加一個雷射光束：\n```javascript\nwindow onload = async () => {\ncanvas = document getElementById(\"canvas\");\nctx = canvas getContext(\"2d\");\nheroImg = await loadTexture(\"assets/player png\");\nenemyImg = await loadTexture(\"assets/enemyShip png\");\nlaserImg = await loadTexture(\"assets/laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 40,
    "total_chunks": 44
  },
  {
    "id": "7de731a1552b1aadb54fc8efe94aa5b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "() => { hero y -=5 ; }) eventEmitter on(Messages KEY_EVENT_DOWN, () => { hero y += 5; }); eventEmitter on(Messages KEY_EVENT_LEFT, () => { hero x -= 5; }); eventEmitter on(Messages KEY_EVENT_RIGHT, () => { hero x += 5; }); } ``` 設置遊戲循環 重構window onload函數以初始化遊戲並以適當的間隔設置遊戲循環。你還將添加一個雷射光束： ```javascript window onload = async () => { canvas = document getElementById(\"canvas\"); ctx = canvas getContext(\"2d\"); heroImg = await loadTexture(\"assets/player png\"); enemyImg = await loadTexture(\"assets/enemyShip png\"); laserImg = await loadTexture(\"assets/laserRedpng\");\ninitGame();\nlet gameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\ndrawGameObjects(ctx);\n}, 100)\n};\n```\n添加程式碼以使敵人在一定間隔內移動\n重構createEnemies()函數以創建敵人並將它們推入新的gameObjects類：\n```javascript\nfunction createEnemies() {\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas width - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nconst enemy = new Enemy(x, y);\nenemy img = enemyImg;\ngameObjects push(enemy);\n}\n}\n}\n```\n並添加一個createHero()函數以對英雄執行類似的過程。\njavascript\nfunction createHero() {\nhero = new Hero(\ncanvas width / 2 - 45,\ncanvas height - canvas height / 4\n);\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 41,
    "total_chunks": 44
  },
  {
    "id": "ce411f9698a7ade1406e29619c999bfb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "- MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { const enemy = new Enemy(x, y); enemy img = enemyImg; gameObjects push(enemy); } } } ``` 並添加一個createHero()函數以對英雄執行類似的過程。 javascript function createHero() { hero = new Hero( canvas width / 2 - 45, canvas height - canvas height / 4 ); heroimg = heroImg;\ngameObjects push(hero);\n}\n最後，添加一個drawGameObjects()函數以開始繪製：\njavascript\nfunction drawGameObjects(ctx) {\ngameObjects forEach(go => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 197,
    "chunk_index": 42,
    "total_chunks": 44
  },
  {
    "id": "9b273bef13904d7af7eca9f286ff43d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第三部分：加入動作",
    "content": "START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { const enemy = new Enemy(x, y); enemy img = enemyImg; gameObjects push(enemy); } } } ``` 並添加一個createHero()函數以對英雄執行類似的過程。 javascript function createHero() { hero = new Hero( canvas width / 2 - 45, canvas height - canvas height / 4 ); heroimg = heroImg; gameObjects push(hero); } 最後，添加一個drawGameObjects()函數以開始繪製： javascript function drawGameObjects(ctx) { gameObjects forEach(go => godraw(ctx));\n}\n你的敵人應該開始向你的英雄飛船進攻！\n🚀 挑戰\n如你所見，當你開始添加函數、變數和類時，你的程式碼可能會變成「意大利麵條程式碼」。你如何更好地組織你的程式碼，使其更易讀？即使程式碼仍然位於一個檔案中，也請設計一個系統來組織你的程式碼。\n課後測驗\n課後測驗\n回顧與自學\n雖然我們在不使用框架的情況下編寫遊戲，但有許多基於JavaScript的畫布框架可用於遊戲開發。花些時間閱讀相關內容。\n作業\n為你的程式碼添加註解\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而產生的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13493,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 640,
    "chunk_index": 43,
    "total_chunks": 44
  },
  {
    "id": "9fb58112282ea89b56a030dbd0d77a08",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\assignment.md",
    "source_type": "git_repo",
    "title": "建立一個範例遊戲",
    "content": "建立一個範例遊戲\n指示\n嘗試建立一個小型遊戲，練習不同的結局條件。可以設計得分達到一定數量、英雄失去所有生命值或所有怪物被擊敗等情況。建立一個簡單的遊戲，例如基於控制台的冒險遊戲。以下的遊戲流程可以作為靈感：\nHero> Strikes with broadsword - orc takes 3p damage\nOrc> Hits with club - hero takes 2p damage\nHero> Kicks - orc takes 1p damage\nGame> Orc is defeated - Hero collects 2 coins\nGame> ****No more monsters, you have conquered the evil fortress****\n評分標準\n| 評分標準 | 優秀表現              | 合格表現                    | 需要改進                  |\n| -------- | --------------------- | --------------------------- | -------------------------- |\n|          | 完整的遊戲呈現        | 部分遊戲呈現                | 部分遊戲存在錯誤          |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1587,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b54a12eb5478637ce3385fb57b6d9d26",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 685,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 193,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "105e06da5b01b3985e23d415667f6f71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 698,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 192,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "287be324b3eb138c693d3e753b03d4c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對於因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 705,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 195,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "7325cd6fb1d6ae2802887a3906b25f62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 722,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 203,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "baa4e513b9774301bf980653ac78afbd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 702,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 193,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b29539d2c760b84089a245191bbf7b43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 707,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 193,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "4d2cbdaa8b824dd1401c6534b34973a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 238,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "05e0df5103e5b7546576afe805899db1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 680,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "4a409baac9428a8a4c78da0545433a6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "20ffd1aa70ece691ea38c66378ba62d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 692,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "e4203e4e5bcac7f09b332ff86e8fda73",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 697,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "f2e6dc5960ae26b526a0693d98813376",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 702,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "73c8f636fd9a812e51c927eb25eba01f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 707,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "5a530ae302993179bed1cb367368b871",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "建立太空遊戲第 5 部分：分數與生命\n課前測驗\n課前測驗\n在本課中，你將學習如何在遊戲中添加分數計算以及生命計算。\n在螢幕上繪製文字\n為了能夠在螢幕上顯示遊戲分數，你需要知道如何在螢幕上放置文字。答案是使用 canvas 物件的 fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！\n生命作為遊戲概念\n在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。\n要實現的功能\n讓我們為你的遊戲添加以下功能：\n遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。\n生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。\n建議步驟\n找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\n你可以通過輸入以下指令啟動 your_work 資料夾中的專案：\nbash\ncd your-work\nnpm start\n上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。\n添加程式碼\n複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 906,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "4d33a90c2a8d1df4d9b48756eea741a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "fillText() 方法。你還可以控制其他方面，例如使用的字體、文字的顏色，甚至是對齊方式（左、右、居中）。以下是一些在螢幕上繪製文字的程式碼。 javascript ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。 要實現的功能 讓我們為你的遊戲添加以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 762,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "940d8ff3698a08acd8cdac37303fb67a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "javascript ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。 要實現的功能 讓我們為你的遊戲添加以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg：\njavascript\nlifeImg = await loadTexture(\"assets/life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 713,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "6a2be3e6a173b161b9c05da8dc669c34",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。 要實現的功能 讓我們為你的遊戲添加以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\");\n將 lifeImg 添加到資源列表中：\njavascript\nlet heroImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 723,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "a2135bfaab78cd5a93cf54691e127a11",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "\"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。 要實現的功能 讓我們為你的遊戲添加以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 716,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "b301fb7f5d3c513d4fa019d4fc139e72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "\"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ 閱讀更多關於如何在 canvas 上添加文字的內容，並隨意讓你的文字看起來更有特色！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。 要實現的功能 讓我們為你的遊戲添加以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter();\n添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。\n擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞：\njavascript\nenemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 818,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "c5acb780facf6d654a7cdfac0204f1f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "上添加文字的內容，並隨意讓你的文字看起來更有特色！ 生命作為遊戲概念 在遊戲中，生命的概念只是一個數字。在太空遊戲的情境中，通常會分配一組生命值，當你的飛船受到傷害時，生命值會逐一扣減。如果能以圖形化的方式顯示這些生命值，例如小型飛船或心形圖案，而不是單純的數字，會更有趣。 要實現的功能 讓我們為你的遊戲添加以下功能： 遊戲分數：每摧毀一艘敵方飛船，英雄應該獲得一些分數，我們建議每艘飛船 100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => {\nconst heroRect = hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 789,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "149a03cee8800595eb5fadf714eaa4b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "100 分。遊戲分數應顯示在左下角。 生命：你的飛船有三條生命。每當一艘敵方飛船與你相撞時，你會失去一條生命。生命分數應顯示在右下角，並由以下圖形表示 。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject();\nif (intersectRect(heroRect, enemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "d92712a05cccb715c2830f2676bb38d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "。 建議步驟 找到在 your-work 子資料夾中為你創建的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy });\n}\n})\n添加 life 和 points。\n初始化變數。在 Hero 類別中的 this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "5e35a3e42d5dba1c278cd2f680bdde49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "appjs -| packagejson 你可以通過輸入以下指令啟動 your_work 資料夾中的專案： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) 添加 life 和 points。 初始化變數。在 Hero 類別中的 thiscooldown = 0 下，設置生命值和分數：\n```javascript\nthis life = 3;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 445,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "03be6b08f79e2223b47ed97f7e1350fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "npm start 上述指令將在地址 http://localhost:5000 啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址，現在應該可以看到英雄和所有敵人，當你按下左右方向鍵時，英雄會移動並可以擊落敵人。 添加程式碼 複製所需資源 從 solution/assets/ 資料夾中將所需資源複製到 your-work 資料夾中；你將添加一個 lifepng 資源。在 windowonload 函數中添加 lifeImg： javascript lifeImg = await loadTexture(\"assets/lifepng\"); 將 lifeImg 添加到資源列表中： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) 添加 life 和 points。 初始化變數。在 Hero 類別中的 thiscooldown = 0 下，設置生命值和分數： ```javascript this life = 3; thispoints = 0;\n```\n在螢幕上繪製變數。將這些值繪製到螢幕上：\n```javascript\nfunction drawLife() {\n// TODO, 35, 27\nconst START_POS = canvas width - 180;\nfor(let i=0; i < hero life; i++ ) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "0fcbc68d52fe73f8f6130f2d0793278a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "heroImg,lifeImg,eventEmitter = new EventEmitter(); 添加變數。添加表示你的總分數（0）和剩餘生命值（3）的程式碼，並在螢幕上顯示這些分數。 擴展 updateGameObjects() 函數。擴展 updateGameObjects() 函數以處理敵人碰撞： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) 添加 life 和 points。 初始化變數。在 Hero 類別中的 thiscooldown = 0 下，設置生命值和分數： ```javascript this life = 3; thispoints = 0; ``` 在螢幕上繪製變數。將這些值繪製到螢幕上： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvas width - 180; for(let i=0; i < hero life; i++ ) { ctxdrawImage(\nlifeImg,\nSTART_POS + (45 * (i+1) ),\ncanvas height - 37);\n}\n}\nfunction drawPoints() {\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"left\";\ndrawText(\"Points: \" + hero points, 10, canvas height-20);\n}\nfunction drawText(message, x, y) {\nctx fillText(message, x, y);\n}\n```\n將方法添加到遊戲迴圈中。確保將這些函數添加到 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 402,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "5fbc640993323985e687dcb0a2df3b62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvas width - 180; for(let i=0; i < hero life; i++ ) { ctxdrawImage( lifeImg, START_POS + (45 * (i+1) ), canvas height - 37); } } function drawPoints() { ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"left\"; drawText(\"Points: \" + hero points, 10, canvas height-20); } function drawText(message, x, y) { ctx fillText(message, x, y); } ``` 將方法添加到遊戲迴圈中。確保將這些函數添加到 windowonload 函數中的 updateGameObjects() 下：\n```javascript\ndrawPoints();\ndrawLife();\n```\n實現遊戲規則。實現以下遊戲規則：\n每次英雄與敵人碰撞，扣減一條生命。\n擴展 Hero 類別以執行此扣減：\n```javascript\ndecrementLife() {\nthis life--;\nif (this life === 0) {\nthis dead = true;\n}\n}\n```\n每次雷射擊中敵人，遊戲分數增加 100 分。\n擴展 Hero 類別以執行此加分：\n```javascript\nincrementPoints() {\nthis points += 100;\n}\n```\n將這些函數添加到你的碰撞事件觸發器中：\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\n})\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 436,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "91136f2e6b123e5725603e946e79ef68",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第 5 部分：分數與生命",
    "content": "``` 實現遊戲規則。實現以下遊戲規則： 每次英雄與敵人碰撞，扣減一條生命。 擴展 Hero 類別以執行此扣減： ```javascript decrementLife() { this life--; if (this life === 0) { this dead = true; } } ``` 每次雷射擊中敵人，遊戲分數增加 100 分。 擴展 Hero 類別以執行此加分： ```javascript incrementPoints() { this points += 100; } ``` 將這些函數添加到你的碰撞事件觸發器中： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); }) eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; herodecrementLife();\n});\n```\n✅ 做一些研究，了解其他使用 JavaScript/Canvas 創建的遊戲。它們有哪些共同特點？\n完成這些工作後，你應該能在右下角看到小型的“生命”飛船圖示，左下角顯示分數，並且當你與敵人碰撞時，生命值會減少；當你擊中敵人時，分數會增加。做得好！你的遊戲已接近完成。\n🚀 挑戰\n你的程式碼已接近完成。你能想像接下來的步驟嗎？\n課後測驗\n課後測驗\n回顧與自學\n研究一些可以增減遊戲分數和生命值的方法。有一些有趣的遊戲引擎，例如 PlayFab。使用這些引擎如何能提升你的遊戲？\n作業\n建立一個計分遊戲\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7121,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 726,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "48318372fb3a9bb1df19ff680d9ae710",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 708,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\4-collision-detection\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 193,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "aaf9b0609d87679b8e5d47074749444c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\assignment.md",
    "source_type": "git_repo",
    "title": "重新設計您的擴充功能",
    "content": "重新設計您的擴充功能\n指示\n此擴充功能的代碼庫已包含樣式，但您不必使用它們；透過編輯其 CSS 文件，重新設計您的擴充功能，使其成為您自己的風格。\n評分標準\n| 標準     | 卓越表現                                   | 合格表現             | 需要改進          |\n| -------- | ------------------------------------------ | -------------------- | ----------------- |\n|          | 提交的代碼具有功能性的新樣式               | 樣式不完整           | 樣式存在問題      |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1247,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 356,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e0ee3d9dcd34aa6a2dd5b6095f263d76",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
    "source_type": "git_repo",
    "title": "採用一個 API",
    "content": "採用一個 API\n指導說明\nAPI 可以非常有趣，這裡有一個免費 API 的列表。選擇一個 API，並建立一個解決問題的瀏覽器擴充功能。這個問題可以很小，例如缺少足夠的寵物圖片（那麼可以試試 dog CEO API），也可以是更大的問題——盡情享受吧！\n評分標準\n| 評分標準 | 優秀範例                                                                  | 足夠                                 | 需要改進       |\n| -------- | -------------------------------------------------------------------------- | ------------------------------------ | --------------- |\n|          | 使用上述列表中的 API 提交了一個完整的瀏覽器擴充功能                        | 提交了一個部分完成的瀏覽器擴充功能   | 提交的內容有錯誤 |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1630,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "eea566ef2eef54d2d9a22e1fdaf24b19",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 820,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "e9f9c35a2dc5807a73bf8883d369cf97",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 826,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "f627a71b4c0e4ba30c2dbe29752d4248",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 832,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "881d6312d82c8770211f798c682f87a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 837,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "fb0371c07c255b0e152a4defde50c0f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "8167dd76937ffe8ede02bc5576245b10",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 848,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "839b6155bea8d681120b555cb0bfd961",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 853,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "0129b1f717b2a4b691ffc9619fbe8d5d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| packagejson\n在 your_work 文件夾中啟動您的項目，輸入以下指令：\nbash\ncd your-work\nnpm start\n上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。\n提示：為了避免在 Visual Studio Code 中出現警告，編輯 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 989,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "b9734c1d4fa846032e81c1c90c232479",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "建立太空遊戲第六部分：結束與重新開始\n課前測驗\n課前測驗\n在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲：\n摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。\n您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。\n收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。\n完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。\n重新開始\n如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。\n✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。\n要構建的內容\n您將為遊戲添加以下規則：\n贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。\n重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。\n建議步驟\n找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| packagejson\n在 your_work 文件夾中啟動您的項目，輸入以下指令：\nbash\ncd your-work\nnpm start\n上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。\n提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId;\n添加程式碼\n追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數：\n```javascript\nfunction isHeroDead() {\nreturn hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1112,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "76f87f9395b2d9bf0daeeb50fc614521",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "在遊戲中，有多種方式可以表達結束條件。作為遊戲的創作者，您可以決定遊戲為什麼會結束。以下是一些可能的原因，假設我們正在討論您目前正在構建的太空遊戲： 摧毀了 N 艘敵方飛船：如果您將遊戲分為不同的關卡，通常需要摧毀 N 艘敵方飛船才能完成一個關卡。 您的飛船被摧毀：有些遊戲中，如果您的飛船被摧毀，您就會輸掉遊戲。另一種常見的方式是引入生命值的概念。每次飛船被摧毀時，會扣除一條生命值。一旦所有生命值都耗盡，遊戲就結束。 收集了 N 分：另一個常見的結束條件是收集一定的分數。如何獲得分數取決於您，但通常會將分數分配給各種活動，例如摧毀敵方飛船，或者收集敵方飛船被摧毀後掉落的物品。 完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。 重新開始 如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。 ✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。 要構建的內容 您將為遊戲添加以下規則： 贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。 重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。 建議步驟 找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0;\n}\nfunction isEnemiesDead() {\nconst enemies = gameObjects",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1088,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "564720efc46edc179fc6418837ffdb59",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "完成一個關卡：這可能涉及多種條件，例如摧毀 X 艘敵方飛船、收集 Y 分數，或者收集特定的物品。 重新開始 如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。 ✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。 要構建的內容 您將為遊戲添加以下規則： 贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。 重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。 建議步驟 找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 697,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "1a5d4e0781bc361e655150af53c17e5f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "艘敵方飛船、收集 Y 分數，或者收集特定的物品。 重新開始 如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。 ✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。 要構建的內容 您將為遊戲添加以下規則： 贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。 重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。 建議步驟 找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 673,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "1d169d2c3f6f23420b777867276bd94f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "重新開始 如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。 ✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。 要構建的內容 您將為遊戲添加以下規則： 贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。 重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。 建議步驟 找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "1a4c725d7e7cba18dbea527c49fbd925",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "重新開始 如果玩家喜歡您的遊戲，他們可能會想要重玩一次。無論遊戲因為什麼原因結束，您都應該提供重新開始的選項。 ✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。 要構建的內容 您將為遊戲添加以下規則： 贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。 重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。 建議步驟 找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead);\nreturn enemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 651,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "a844620c145ca6ce0e9c2621781654aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "✅ 想一想，您認為遊戲在什麼條件下會結束，然後玩家是如何被提示重新開始的。 要構建的內容 您將為遊戲添加以下規則： 贏得遊戲：當所有敵方飛船被摧毀時，您贏得遊戲。此外，顯示某種勝利訊息。 重新開始：當所有生命值耗盡或遊戲勝利時，您應該提供重新開始遊戲的方式。記住！您需要重新初始化遊戲，並清除之前的遊戲狀態。 建議步驟 找到在 your-work 子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0;\n}\n```\n添加邏輯到訊息處理器：編輯 eventEmitter 以處理這些條件：\n```javascript\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 625,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "b2dfb953a3258bdc70faeb742f78242b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "子文件夾中為您創建的文件。它應該包含以下內容： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson 在 your_work 文件夾中啟動您的項目，輸入以下指令： bash cd your-work npm start 上述指令將在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。您的遊戲應該處於可玩狀態。 提示：為了避免在 Visual Studio Code 中出現警告，編輯 windowonload 函數，直接調用 gameLoopId（不加 let），並在文件頂部獨立聲明 gameLoopId：let gameLoopId; 添加程式碼 追蹤結束條件：添加程式碼來追蹤敵方數量，或者英雄飛船是否被摧毀，通過添加以下兩個函數： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0; } ``` 添加邏輯到訊息處理器：編輯 eventEmitter 以處理這些條件： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero decrementLife();\nif (isHeroDead())  {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "4f3009c041ac730d61a62e9cedec5b7d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0; } ``` 添加邏輯到訊息處理器：編輯 eventEmitter 以處理這些條件： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(MessagesGAME_END_LOSS);\nreturn; // loss before victory\n}\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages GAME_END_WIN, () => {\nendGame(true);\n});\neventEmitter on(Messages GAME_END_LOSS, () => {\nendGame(false);\n});\n```\n添加新的訊息類型：將這些訊息添加到常量對象中：\njavascript\nGAME_END_LOSS: \"GAME_END_LOSS\",\nGAME_END_WIN: \"GAME_END_WIN\",\n添加重新開始的程式碼：編寫在按下選定按鍵時重新開始遊戲的程式碼。\n監聽按鍵 Enter：編輯您的窗口事件監聽器以監聽此按鍵：\njavascript\nelse if(evt key === \"Enter\") {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 379,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "8d2190b96f971a801c8a3ed6d7cf2f90",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "(isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(MessagesGAME_END_LOSS); return; // loss before victory } if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages GAME_END_WIN, () => { endGame(true); }); eventEmitter on(Messages GAME_END_LOSS, () => { endGame(false); }); ``` 添加新的訊息類型：將這些訊息添加到常量對象中： javascript GAME_END_LOSS: \"GAME_END_LOSS\", GAME_END_WIN: \"GAME_END_WIN\", 添加重新開始的程式碼：編寫在按下選定按鍵時重新開始遊戲的程式碼。 監聽按鍵 Enter：編輯您的窗口事件監聽器以監聽此按鍵： javascript else if(evt key === \"Enter\") { eventEmitter emit(MessagesKEY_EVENT_ENTER);\n}\n添加重新開始訊息：將此訊息添加到您的 Messages 常量中：\n```javascript\nKEY_EVENT_ENTER: \"KEY_EVENT_ENTER\",\n```\n實現遊戲規則：實現以下遊戲規則：\n玩家勝利條件：當所有敵方飛船被摧毀時，顯示勝利訊息。\n首先，創建一個 displayMessage() 函數：\njavascript\nfunction displayMessage(message, color = \"red\") {\nctx font = \"30px Arial\";\nctx fillStyle = color;\nctx textAlign = \"center\";\nctx fillText(message, canvas width / 2, canvas height / 2);\n}\n創建一個 endGame() 函數：\n```javascript\nfunction endGame(win) {\nclearInterval(gameLoopId);\n// set a delay so we are sure any paints have finished\nsetTimeout(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "d5047fbcb1759edddbeecf5bdf765342",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "常量中： ```javascript KEY_EVENT_ENTER: \"KEY_EVENT_ENTER\", ``` 實現遊戲規則：實現以下遊戲規則： 玩家勝利條件：當所有敵方飛船被摧毀時，顯示勝利訊息。 首先，創建一個 displayMessage() 函數： javascript function displayMessage(message, color = \"red\") { ctx font = \"30px Arial\"; ctx fillStyle = color; ctx textAlign = \"center\"; ctx fillText(message, canvas width / 2, canvas height / 2); } 創建一個 endGame() 函數： ```javascript function endGame(win) { clearInterval(gameLoopId); // set a delay so we are sure any paints have finished setTimeout(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctxfillRect(0, 0, canvas width, canvas height);\nif (win) {\ndisplayMessage(\n\"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\",\n\"green\"\n);\n} else {\ndisplayMessage(\n\"You died Press [Enter] to start a new game Captain Pew Pew\"\n);\n}\n}, 200)\n}\n```\n重新開始邏輯：當所有生命值耗盡或玩家贏得遊戲時，顯示可以重新開始遊戲的提示。此外，當按下重新開始按鍵時重新開始遊戲（您可以決定哪個按鍵對應於重新開始）。\n創建 resetGame() 函數：\njavascript\nfunction resetGame() {\nif (gameLoopId) {\nclearInterval(gameLoopId);\neventEmitter clear();\ninitGame();\ngameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 469,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "de7fc51b00068e8290d0c4fd006c8d25",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "displayMessage( \"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\", \"green\" ); } else { displayMessage( \"You died Press [Enter] to start a new game Captain Pew Pew\" ); } }, 200) } ``` 重新開始邏輯：當所有生命值耗盡或玩家贏得遊戲時，顯示可以重新開始遊戲的提示。此外，當按下重新開始按鍵時重新開始遊戲（您可以決定哪個按鍵對應於重新開始）。 創建 resetGame() 函數： javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight);\ndrawPoints();\ndrawLife();\nupdateGameObjects();\ndrawGameObjects(ctx);\n}, 100);\n}\n}\n在 initGame() 中添加對 eventEmitter 的調用以重置遊戲：\njavascript\neventEmitter on(Messages KEY_EVENT_ENTER, () => {\nresetGame();\n});\n為 EventEmitter 添加一個 clear() 函數：\njavascript\nclear() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 313,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "9c076b5cae26db5bfdd875bfbfe1a1f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第六部分：結束與重新開始",
    "content": "Pew Pew\" ); } }, 200) } ``` 重新開始邏輯：當所有生命值耗盡或玩家贏得遊戲時，顯示可以重新開始遊戲的提示。此外，當按下重新開始按鍵時重新開始遊戲（您可以決定哪個按鍵對應於重新開始）。 創建 resetGame() 函數： javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight); drawPoints(); drawLife(); updateGameObjects(); drawGameObjects(ctx); }, 100); } } 在 initGame() 中添加對 eventEmitter 的調用以重置遊戲： javascript eventEmitter on(Messages KEY_EVENT_ENTER, () => { resetGame(); }); 為 EventEmitter 添加一個 clear() 函數： javascript clear() { thislisteners = {};\n}\n👽 💥 🚀 恭喜您，船長！您的遊戲已完成！幹得好！🚀 💥 👽\n🚀 挑戰\n添加音效！您能否為遊戲添加音效來增強遊戲體驗，例如當激光擊中、英雄死亡或勝利時？查看這個 sandbox 來學習如何使用 JavaScript 播放音效。\n課後測驗\n課後測驗\n回顧與自學\n您的作業是創建一個全新的樣本遊戲，因此請探索一些有趣的遊戲，看看您可能會構建什麼類型的遊戲。\n作業\n建立一個樣本遊戲\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 690,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "e1ee663b7f509cadaf4c716b43c1468f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
    "source_type": "git_repo",
    "title": "分析網站效能",
    "content": "分析網站效能\n提供一份網站的詳細報告，指出效能問題的區域。分析網站為何速度緩慢，以及可以採取哪些措施來加快速度。不僅僅依賴瀏覽器工具，還要研究其他可以幫助撰寫報告的工具。\n評分標準\n| 評分標準 | 優異                                                                                                      | 合格                        | 有待改進                     |\n| -------- | ---------------------------------------------------------------------------------------------------------- | --------------------------- | ----------------------------- |\n|          | 提供的報告不僅包含來自瀏覽器工具的詳細資訊，還包括（如果有的話）來自第三方工具的資料                       | 提供一份基本的報告          | 提供一份簡略的報告           |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1586,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 431,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "008ad1ab1ea27e83a15eb8a5955365b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切\n手繪筆記由 Wassim Chegham 提供\n課前測驗\n課前測驗\n簡介\n瀏覽器擴充功能為瀏覽器增加了額外的功能。但在你開始構建之前，應該先了解一些關於瀏覽器如何運作的知識。\n關於瀏覽器\n在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴充功能。在這部分，你將了解瀏覽器的運作方式，並搭建瀏覽器擴充功能的基本結構。\n那麼，什麼是瀏覽器呢？它是一種軟體應用程式，允許終端使用者從伺服器訪問內容並將其顯示在網頁上。\n✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。\n一些早期的瀏覽器，圖片來源：Karen McGrane\n當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。\n此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。\n瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。\n需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。\n一個非常有用的網站是 caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 831,
    "chunk_index": 0,
    "total_chunks": 13
  },
  {
    "id": "7f8c5c5083f46cd3bcffe0248b76bf47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切\n手繪筆記由 Wassim Chegham 提供\n課前測驗\n課前測驗\n簡介\n瀏覽器擴充功能為瀏覽器增加了額外的功能。但在你開始構建之前，應該先了解一些關於瀏覽器如何運作的知識。\n關於瀏覽器\n在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴充功能。在這部分，你將了解瀏覽器的運作方式，並搭建瀏覽器擴充功能的基本結構。\n那麼，什麼是瀏覽器呢？它是一種軟體應用程式，允許終端使用者從伺服器訪問內容並將其顯示在網頁上。\n✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。\n一些早期的瀏覽器，圖片來源：Karen McGrane\n當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。\n此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。\n瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。\n需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。\n一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。\n✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。\n瀏覽器擴充功能\n為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。\n開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。\n✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？\n安裝擴充功能\n在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似：\n注意：確保切換到開發者模式並允許來自其他商店的擴充功能。\n基本過程如下：\n使用 npm run build 構建你的擴充功能\n在瀏覽器中通過右上角的「設置及更多」按鈕（",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1409,
    "chunk_index": 1,
    "total_chunks": 13
  },
  {
    "id": "2b161f54fe2f9a947b15712ee9ab8270",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切\n手繪筆記由 Wassim Chegham 提供\n課前測驗\n課前測驗\n簡介\n瀏覽器擴充功能為瀏覽器增加了額外的功能。但在你開始構建之前，應該先了解一些關於瀏覽器如何運作的知識。\n關於瀏覽器\n在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴充功能。在這部分，你將了解瀏覽器的運作方式，並搭建瀏覽器擴充功能的基本結構。\n那麼，什麼是瀏覽器呢？它是一種軟體應用程式，允許終端使用者從伺服器訪問內容並將其顯示在網頁上。\n✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。\n一些早期的瀏覽器，圖片來源：Karen McGrane\n當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。\n此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。\n瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。\n需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。\n一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。\n✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。\n瀏覽器擴充功能\n為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。\n開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。\n✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？\n安裝擴充功能\n在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似：\n注意：確保切換到開發者模式並允許來自其他商店的擴充功能。\n基本過程如下：\n使用 npm run build 構建你的擴充功能\n在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面\n如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能\n或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」\n✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。\n開始動手\n你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。\n你需要：\n一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你\n你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」）\n起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼\nNPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1879,
    "chunk_index": 2,
    "total_chunks": 13
  },
  {
    "id": "cb95c485de2f32cb79d8f0877b2b300b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "在這系列課程中，你將學習如何構建一個可以在 Chrome、Firefox 和 Edge 瀏覽器上運行的瀏覽器擴充功能。在這部分，你將了解瀏覽器的運作方式，並搭建瀏覽器擴充功能的基本結構。 那麼，什麼是瀏覽器呢？它是一種軟體應用程式，允許終端使用者從伺服器訪問內容並將其顯示在網頁上。 ✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。 一些早期的瀏覽器，圖片來源：Karen McGrane 當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。 需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。 一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。 ✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。 瀏覽器擴充功能 為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。 開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。 ✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？ 安裝擴充功能 在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：確保切換到開發者模式並允許來自其他商店的擴充功能。 基本過程如下： 使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用\n✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。\n花點時間瀏覽代碼庫：\ndist\n-|manifest",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1814,
    "chunk_index": 3,
    "total_chunks": 13
  },
  {
    "id": "28c5cb3d89e73a192b7ebee0466f7c5b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "✅ 一點歷史：第一個瀏覽器名為「WorldWideWeb」，由蒂姆·伯納斯-李爵士於 1990 年創建。 一些早期的瀏覽器，圖片來源：Karen McGrane 當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。 需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。 一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。 ✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。 瀏覽器擴充功能 為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。 開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。 ✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？ 安裝擴充功能 在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：確保切換到開發者模式並允許來自其他商店的擴充功能。 基本過程如下： 使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此)\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1642,
    "chunk_index": 4,
    "total_chunks": 13
  },
  {
    "id": "2057197dceb46256949605344b2e2fe9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "1990 年創建。 一些早期的瀏覽器，圖片來源：Karen McGrane 當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。 需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。 一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。 ✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。 瀏覽器擴充功能 為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。 開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。 ✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？ 安裝擴充功能 在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：確保切換到開發者模式並允許來自其他商店的擴充功能。 基本過程如下： 使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此)\n-|background",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1603,
    "chunk_index": 5,
    "total_chunks": 13
  },
  {
    "id": "10df185df7adbfb721b92ebafc382bc5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "當使用者使用 URL（統一資源定位符）地址連接到互聯網時，通常通過 http 或 https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。 需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。 一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。 ✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。 瀏覽器擴充功能 為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。 開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。 ✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？ 安裝擴充功能 在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：確保切換到開發者模式並允許來自其他商店的擴充功能。 基本過程如下： 使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此)\n-|main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1582,
    "chunk_index": 6,
    "total_chunks": 13
  },
  {
    "id": "17c2eedb4874c036a64a4a8b46dd7976",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "https 地址使用超文本傳輸協議，瀏覽器會與網頁伺服器通信並獲取網頁。 此時，瀏覽器的渲染引擎會將網頁顯示在使用者的設備上，這可能是手機、桌面電腦或筆記型電腦。 瀏覽器還具有緩存內容的能力，這樣就不需要每次都從伺服器檢索內容。它們可以記錄使用者的瀏覽歷史，存儲「cookies」（小型數據片段，用於保存使用者的活動信息）等。 需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。 一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。 ✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。 瀏覽器擴充功能 為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。 開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。 ✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？ 安裝擴充功能 在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：確保切換到開發者模式並允許來自其他商店的擴充功能。 基本過程如下： 使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此) -|mainjs (構建後的 JS)\nsrc\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1560,
    "chunk_index": 7,
    "total_chunks": 13
  },
  {
    "id": "75d4de44051ccca47318113d5421280f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "需要特別記住的是，瀏覽器並不完全相同！每個瀏覽器都有其優勢和劣勢，專業的網頁開發人員需要了解如何讓網頁在不同瀏覽器中表現良好。這包括處理像手機這樣的小視窗，以及處理離線使用者。 一個非常有用的網站是 caniusecom。當你構建網頁時，使用 caniuse 提供的技術支持列表可以幫助你更好地支持使用者。 ✅ 如何知道哪些瀏覽器在你的網站使用者中最受歡迎？檢查你的分析數據——你可以在網頁開發過程中安裝各種分析工具，它們會告訴你使用者最常用的瀏覽器。 瀏覽器擴充功能 為什麼要構建瀏覽器擴充功能？當你需要快速訪問經常重複的任務時，這是一個非常方便的工具。例如，如果你經常需要檢查網頁上的顏色，你可以安裝一個顏色選取器擴充功能。如果你難以記住密碼，你可以使用密碼管理擴充功能。 開發瀏覽器擴充功能也很有趣。它們通常專注於執行少量的任務，並且執行得非常出色。 ✅ 你最喜歡的瀏覽器擴充功能是什麼？它們執行哪些任務？ 安裝擴充功能 在開始構建之前，先了解一下構建和部署瀏覽器擴充功能的過程。雖然每個瀏覽器在管理這項任務時略有不同，但在 Chrome 和 Firefox 上的過程與 Edge 上的示例類似： 注意：確保切換到開發者模式並允許來自其他商店的擴充功能。 基本過程如下： 使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此) -|mainjs (構建後的 JS) src -|indexjs (你的 JS 代碼在此)\n✅ 一旦你準備好 API 金鑰和地區代碼，將它們存放在某個筆記中以備未來使用。\n為擴充功能構建 HTML\n這個擴充功能有兩個視圖。一個用於收集 API 金鑰和地區代碼：\n另一個用於顯示地區的碳使用情況：\n我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。\n在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1551,
    "chunk_index": 8,
    "total_chunks": 13
  },
  {
    "id": "31de2033b051bc32edfb3a73331b8c5f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "使用 npm run build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此) -|mainjs (構建後的 JS) src -|indexjs (你的 JS 代碼在此) ✅ 一旦你準備好 API 金鑰和地區代碼，將它們存放在某個筆記中以備未來使用。 為擴充功能構建 HTML 這個擴充功能有兩個視圖。一個用於收集 API 金鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域：\n```HTML\nNew",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 888,
    "chunk_index": 9,
    "total_chunks": 13
  },
  {
    "id": "2684875ab918912f9b7ec911e43153f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "build 構建你的擴充功能 在瀏覽器中通過右上角的「設置及更多」按鈕（圖標）導航到擴充功能頁面 如果是新安裝，選擇「載入未封裝的擴充功能」，從其構建文件夾（在我們的例子中是 /dist）上傳新的擴充功能 或者，如果是重新加載已安裝的擴充功能，點擊「重新加載」 ✅ 這些指令適用於你自己構建的擴充功能；如果要安裝已發布到瀏覽器擴充功能商店的擴充功能，應導航到這些商店並安裝你選擇的擴充功能。 開始動手 你將構建一個顯示你所在地區碳足跡的瀏覽器擴充功能，展示你所在地區的能源使用情況及能源來源。該擴充功能將包含一個表單，用於收集 API 金鑰，以訪問 CO2 Signal 的 API。 你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此) -|mainjs (構建後的 JS) src -|indexjs (你的 JS 代碼在此) ✅ 一旦你準備好 API 金鑰和地區代碼，將它們存放在某個筆記中以備未來使用。 為擴充功能構建 HTML 這個擴充功能有兩個視圖。一個用於收集 API 金鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域： ```HTML NewAdd your Information\nRegion Name\nYour API Key from tmrow\nSubmit\n```\n這是保存信息的表單，輸入的數據將存儲到本地存儲中。\n接下來，創建結果區域；在最後的表單標籤下方添加一些 div：\n```HTML\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 976,
    "chunk_index": 10,
    "total_chunks": 13
  },
  {
    "id": "0e0883b780af1afb6edb6c4fc17d4826",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "你需要： 一個 API 金鑰；在此頁面輸入你的電子郵件，系統會將金鑰發送給你 你的地區代碼，對應於 Electricity Map（例如，在波士頓，我使用「US-NEISO」） 起始代碼。下載 start 文件夾；你將在此文件夾中完成代碼 NPM - NPM 是一個套件管理工具；在本地安裝它，並安裝 packagejson 文件中列出的套件以供網頁資產使用 ✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此) -|mainjs (構建後的 JS) src -|indexjs (你的 JS 代碼在此) ✅ 一旦你準備好 API 金鑰和地區代碼，將它們存放在某個筆記中以備未來使用。 為擴充功能構建 HTML 這個擴充功能有兩個視圖。一個用於收集 API 金鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域： ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` 這是保存信息的表單，輸入的數據將存儲到本地存儲中。 接下來，創建結果區域；在最後的表單標籤下方添加一些 div： ```HTML loadingRegion:\nCarbon Usage:\nFossil Fuel Percentage:\nChange region\n```\n此時，你可以嘗試構建。確保安裝此擴充功能的套件依賴項：\nnpm install\n此命令將使用 npm（Node 套件管理器）來安裝用於擴充功能構建過程的 webpack。你可以通過查看 /dist/main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 715,
    "chunk_index": 11,
    "total_chunks": 13
  },
  {
    "id": "33fb16b0e9c6cbeb2c4be0061f2063cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 1 部分：關於瀏覽器的一切",
    "content": "✅ 在這個優秀的學習模組中了解更多關於套件管理的知識。 花點時間瀏覽代碼庫： dist -|manifestjson (默認設置在此) -|indexhtml (前端 HTML 標記在此) -|backgroundjs (背景 JS 在此) -|mainjs (構建後的 JS) src -|indexjs (你的 JS 代碼在此) ✅ 一旦你準備好 API 金鑰和地區代碼，將它們存放在某個筆記中以備未來使用。 為擴充功能構建 HTML 這個擴充功能有兩個視圖。一個用於收集 API 金鑰和地區代碼： 另一個用於顯示地區的碳使用情況： 我們先從構建表單的 HTML 開始，並用 CSS 進行樣式設計。 在 /dist 文件夾中，你將構建一個表單和一個結果區域。在 indexhtml 文件中，填充表單區域： ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` 這是保存信息的表單，輸入的數據將存儲到本地存儲中。 接下來，創建結果區域；在最後的表單標籤下方添加一些 div： ```HTML loadingRegion: Carbon Usage: Fossil Fuel Percentage: Change region ``` 此時，你可以嘗試構建。確保安裝此擴充功能的套件依賴項： npm install 此命令將使用 npm（Node 套件管理器）來安裝用於擴充功能構建過程的 webpack。你可以通過查看 /dist/mainjs 來看到此過程的輸出——你會看到代碼已被打包。\n目前，擴充功能應該可以構建，並且如果你將其部署到 Edge 作為擴充功能，你會看到一個整齊顯示的表單。\n恭喜你，你已經邁出了構建瀏覽器擴充功能的第一步。在後續課程中，你將使其更加實用和功能強大。\n🚀 挑戰\n瀏覽一個瀏覽器擴充功能商店並安裝一個擴充功能到你的瀏覽器。你可以用有趣的方式檢查它的文件。你發現了什麼？\n課後測驗\n課後測驗\n複習與自學\n在本課中，你學到了一些關於網頁瀏覽器歷史的知識；利用這個機會，通過閱讀更多歷史資料來了解萬維網的發明者如何設想它的用途。一些有用的網站包括：\n網頁瀏覽器的歷史\n網頁的歷史\n蒂姆·伯納斯-李的訪談\n作業\n重新設計你的擴充功能\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9736,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1164,
    "chunk_index": 12,
    "total_chunks": 13
  },
  {
    "id": "ab289859842410c0c4c2761b8c065bac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\README.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴充功能：完成的程式碼",
    "content": "Carbon Trigger 瀏覽器擴充功能：完成的程式碼\n使用 tmrow 的 C02 Signal API 來追蹤電力使用情況，建立一個瀏覽器擴充功能，讓您可以在瀏覽器中即時收到有關您所在區域電力使用負載的提醒。即時使用此擴充功能，能幫助您根據這些資訊對您的活動進行判斷。\n開始使用\n您需要先安裝 npm。將此程式碼下載到您電腦上的一個資料夾中。\n安裝所有所需的套件：\nnpm install\n使用 webpack 建置擴充功能：\nnpm run build\n在 Edge 瀏覽器上安裝時，使用瀏覽器右上角的「三點」選單找到擴充功能面板。從那裡選擇「載入未封裝的擴充功能」來載入新的擴充功能。在提示時打開「dist」資料夾，擴充功能就會載入。要使用此功能，您需要 CO2 Signal API 的 API 金鑰（在此處透過電子郵件獲取 - 在此頁面輸入您的電子郵件）以及對應於 Electricity Map 的 區域代碼（例如，在波士頓，我使用的是「US-NEISO」）。\n一旦在擴充功能介面中輸入了 API 金鑰和區域代碼，瀏覽器擴充功能列中的彩色點應該會改變，反映您所在區域的能源使用情況，並為您提供建議，告訴您哪些高耗能活動適合進行。這個「點」系統的概念來自於 Energy Lollipop 擴充功能，該功能專為加州的碳排放設計。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2427,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 784,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f56463dc0c26da87af8a11f6fe854e4f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\start\\README.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴充功能：入門代碼",
    "content": "Carbon Trigger 瀏覽器擴充功能：入門代碼\n使用 tmrow 的 C02 Signal API 來追蹤電力使用情況，建立一個瀏覽器擴充功能，讓您可以直接在瀏覽器中提醒自己所在區域的電力使用負荷。隨機使用此擴充功能可以幫助您根據這些資訊做出活動的判斷。\n開始使用\n您需要先安裝 npm。將此代碼下載到您電腦上的一個資料夾。\n安裝所有必要的套件：\nnpm install\n使用 webpack 建置擴充功能：\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的「三點」選單找到擴充功能面板。從那裡選擇「載入未封裝」以載入新的擴充功能。在提示時打開「dist」資料夾，擴充功能就會載入。要使用它，您需要 CO2 Signal API 的 API 金鑰（在此處透過電子郵件獲取 - 在此頁面上的框中輸入您的電子郵件）以及對應於 Electricity Map 的區域代碼（例如，在波士頓，我使用「US-NEISO」）代碼查詢。\n一旦在擴充功能介面中輸入 API 金鑰和區域代碼，瀏覽器擴充功能欄中的彩色點應該會改變，以反映您所在區域的能源使用情況，並給您指引哪些高耗能活動適合進行。這個「點」系統的概念是由 Energy Lollipop 擴充功能 提供的，用於加州的排放情況。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2340,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\start\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 750,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "5b07af81daa1153f739e1bd45eb29061",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.es.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能 Carbon Trigger：完整程式碼",
    "content": "瀏覽器擴充功能 Carbon Trigger：完整程式碼\n使用 tmrow 的 C02 信號 API 來追蹤電力使用情況，開發一個瀏覽器擴充功能，讓您可以直接在瀏覽器中獲得有關您所在區域電力消耗的提醒。使用這個即時擴充功能，能幫助您根據這些資訊來決定您的活動。\n開始使用\n您需要安裝 npm。將此程式碼的副本下載到您電腦中的一個資料夾。\n安裝所有必要的套件：\nnpm install\n使用 webpack 建置擴充功能：\nnpm run build\n要在 Edge 中安裝，請使用瀏覽器右上角的「三點」選單，找到「擴充功能」面板。從那裡選擇「載入未封裝的擴充功能」來載入新的擴充功能。當系統提示時，打開「dist」資料夾，擴充功能就會被載入。要使用此功能，您需要一個 CO2 Signal API 的 API 金鑰（在這裡透過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件）以及對應於 電力地圖 的 區域代碼（例如，在波士頓，我使用的是「US-NEISO」）。\n一旦在擴充功能介面中輸入了 API 金鑰和區域代碼，瀏覽器擴充功能列中的顏色點應該會改變，以反映您所在區域的能源使用情況，並為您提供有關高耗能活動是否適合的指標。這個「顏色點」系統的概念靈感來自 Energy Lollipop 擴充功能，該功能用於加州的排放量指標。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2481,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.es.md",
      "source_type": "git_repo"
    },
    "token_count": 797,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "7fe64d2d485b8582b38b36ac19a8610a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.fr.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充套件 Carbon Trigger：完成的程式碼",
    "content": "瀏覽器擴充套件 Carbon Trigger：完成的程式碼\n使用 tmrow 的 C02 Signal API 來追蹤電力消耗，創建一個瀏覽器擴充套件，讓您可以直接在瀏覽器中獲得您所在地區的電力消耗提醒。使用這個即時擴充套件可以幫助您根據這些資訊對您的活動做出判斷。\n開始\n您需要先安裝 npm。將此程式碼的副本下載到您電腦中的一個資料夾。\n安裝所有所需的套件：\nnpm install\n使用 webpack 建置擴充套件：\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的「三點」選單找到擴充套件面板。從那裡選擇「載入未壓縮的擴充套件」以載入新的擴充套件。在提示中打開「dist」資料夾，擴充套件就會被載入。要使用此擴充套件，您需要一個 CO2 Signal API 的 API 金鑰（在此處透過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件）以及對應於 電力地圖 的 地區代碼（例如，在波士頓，我使用「US-NEISO」）。\n當 API 金鑰和地區代碼輸入到擴充套件介面後，瀏覽器擴充套件欄中的彩色點應該會改變，以反映您所在地區的能源消耗，並為您提供指標，幫助您判斷是否適合進行耗能的活動。這個「點」系統的概念是受到 Energy Lollipop 擴充套件 提供的加州排放指標啟發而設計的。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2410,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.fr.md",
      "source_type": "git_repo"
    },
    "token_count": 809,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ef9c461013332079b9a036cdf118ceec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.hi.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴充功能：完整程式碼",
    "content": "Carbon Trigger 瀏覽器擴充功能：完整程式碼\n使用 tmrow 的 C02 Signal API 追蹤電力使用情況，建立一個瀏覽器擴充功能，提醒您所在區域的電力使用情況是否繁重。透過使用此擴充功能，您可以根據這些資訊來決定自己的活動。\n開始使用\n您需要先安裝 npm。將此程式碼下載到您電腦上的一個資料夾中。\n安裝所有必要的套件：\nnpm install\n使用 Webpack 建立擴充功能：\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的「三點」選單找到擴充功能面板。從那裡選擇「載入未封裝的擴充功能」，然後在提示中打開「dist」資料夾，擴充功能就會被載入。要使用此功能，您需要 CO2 Signal 的 API 金鑰（透過電子郵件在此獲取——在該頁面的框中輸入您的電子郵件）以及 您所在區域的代碼（例如，波士頓使用「US-NEISO」）電力地圖。\n當 API 金鑰和區域代碼輸入到擴充功能介面後，瀏覽器擴充功能列中的彩色點應該會根據您所在區域的能源使用情況進行變化，並提供指示，告訴您哪些能源密集型活動適合您的操作表現。這個「點」系統的概念是我從加州排放的 Energy Lollipop 擴充功能 中獲得的靈感。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2341,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.hi.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "dc5bedc102a8f46639fa048be1f8ea29",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.it.md",
    "source_type": "git_repo",
    "title": "碳觸發瀏覽器擴充功能：啟動代碼",
    "content": "碳觸發瀏覽器擴充功能：啟動代碼\n我們將使用 tmrow 的 Signal C02 API 來監控電力使用情況，並創建一個瀏覽器擴充功能，讓您可以直接在瀏覽器中獲得提醒，了解所在區域的電力使用情況。使用這個專門的擴充功能可以幫助您根據這些資訊評估自己的活動。\n開始使用\n需要先安裝 npm。將此代碼下載到電腦中的一個資料夾。\n安裝所有必要的套件：\nnpm install\n使用 webpack 建立擴充功能：\nnpm run build\n要在 Edge 上安裝，請使用瀏覽器右上角的「三點」選單找到擴充功能面板。如果尚未啟用，請啟用開發者模式（左下角）。選擇「載入未壓縮的擴充功能」以載入新的擴充功能。在提示中打開 \"dist\" 資料夾，擴充功能就會被載入。要使用此擴充功能，您需要一個 CO2 Signal API 的 API 金鑰（可以通過電子郵件獲取 - 在該頁面上的框中輸入您的電子郵件）以及對應於電力地圖的區域代碼（例如，在波士頓，區域代碼是 \"US-NEISO\"）。\n當 API 金鑰和區域代碼輸入到擴充功能的介面後，瀏覽器擴充功能欄中的彩色點應該會改變，以反映所在區域的能源使用情況，並提供指引，告訴您哪些高耗能活動適合執行。這個「點」系統的概念是基於加州排放的 Energy Lollipop 擴充功能所提供的想法。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2452,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.it.md",
      "source_type": "git_repo"
    },
    "token_count": 805,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "7934a3034954ba2851875a62af738f6f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.ja.md",
    "source_type": "git_repo",
    "title": "碳觸發瀏覽器擴充功能：完成的程式碼",
    "content": "碳觸發瀏覽器擴充功能：完成的程式碼\n使用 tmrow 的 C02 Signal API 來追蹤電力使用情況，並在瀏覽器中顯示您所在區域的電力使用量作為提醒。透過這個擴充功能，您可以根據這些資訊來判斷自己的活動。\n開始使用\n您需要先安裝 npm。將此程式碼的副本下載到您電腦上的資料夾中。\n安裝所有必要的套件。\nnpm install\n使用 webpack 建置擴充功能。\nnpm run build\n要在 Edge 中安裝，請在瀏覽器右上角的「三個點」選單中找到「擴充功能」面板。從那裡選擇「載入未封裝的擴充功能」，然後載入新的擴充功能。在提示中打開「dist」資料夾，擴充功能就會被載入。要使用此功能，您需要 CO2 Signal API 的 API 金鑰 (透過電子郵件獲取 - 在該頁面的框中輸入您的電子郵件) 和 Electricity Map 對應的 您所在區域的代碼 (例如，在波士頓使用 'US-NEISO')。\n在擴充功能介面中輸入 API 金鑰和區域代碼後，瀏覽器擴充工具列中顯示的彩色圓點會根據您所在區域的能源使用情況進行變化，並提示您進行哪些活動是適合的。這個「圓點」系統的概念是受到加州排放量的 Energy Lollipop 擴充功能 的啟發。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2342,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.ja.md",
      "source_type": "git_repo"
    },
    "token_count": 747,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "497d26f79d0cb6a4bfba6c5b5b733da3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.ms.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger 瀏覽器擴充功能：完整代碼",
    "content": "Carbon Trigger 瀏覽器擴充功能：完整代碼\n使用 tmrow 的 CO2 Signal API 來監測電力使用情況，建立一個瀏覽器擴充功能，讓您可以在瀏覽器中收到有關您所在地區電力使用情況的提醒。使用這個擴充功能可以幫助您根據這些資訊來調整您的活動。\n從這裡開始\n您需要安裝 npm。將此代碼的副本下載到您電腦上的資料夾。\n安裝所有必要的套件：\nnpm install\n使用 webpack 建立擴充功能：\nnpm run build\n要在 Edge 瀏覽器中安裝，請使用瀏覽器右上角的「三點」選單找到擴充功能面板。從那裡選擇「載入未封裝」以加載新的擴充功能。根據要求打開「dist」資料夾，擴充功能就會被加載。要使用它，您需要一個 CO2 Signal API 的 API 金鑰（在這裡通過電子郵件獲取 - 在頁面上的框中輸入您的電子郵件）以及 您的地區代碼，該代碼與 Electricity Map 相對應（例如，在波士頓，我使用的是「US-NEISO」）。\n當 API 金鑰和地區代碼輸入到擴充功能介面後，瀏覽器擴充功能欄中的彩色點將會根據您所在地區的能源使用情況進行變化，並為您提供適合進行的高耗能活動的建議。這個「點」系統的概念是受到 Energy Lollipop 瀏覽器擴充功能 的啟發，該擴充功能專為加州的能源排放設計。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2443,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\solution\\translation\\README.ms.md",
      "source_type": "git_repo"
    },
    "token_count": 790,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "426fbfcf87f90fc02d4da2d4af757ebe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "這是一個佔位符，故意留空\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 707,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 204,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "6a2132f81295d97cfdd31740b576a8c0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\assignment.md",
    "source_type": "git_repo",
    "title": "建立一個新的鍵盤遊戲",
    "content": "建立一個新的鍵盤遊戲\n說明\n創建一個使用鍵盤事件執行任務的小型遊戲。它可以是一種不同類型的打字遊戲，或者是一種藝術型遊戲，透過按鍵在螢幕上繪製像素。發揮創意吧！\n評分標準\n| 評分項目 | 優秀                     | 合格                     | 需要改進           |\n| -------- | ------------------------ | ------------------------ | ----------------- |\n|          | 提供完整的遊戲           | 遊戲非常簡單             | 遊戲有錯誤         |\n|          |                          |                          |                   |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1309,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 394,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3ccd23fd77949e42695ad72fb2875a8d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "瀏覽器擴充功能專案第三部分：了解背景任務與效能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學習了如何建立一個表單以及顯示從 API 獲取的資料區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何處理非同步資料獲取。你的瀏覽器擴充功能幾乎已經完成。\n接下來需要管理一些背景任務，包括刷新擴充功能圖示的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在建立網頁資產時，我們可以從效能的角度來思考這些瀏覽器任務。\n網頁效能基礎\n「網站效能主要關注兩件事：頁面載入速度，以及頁面上的程式碼執行速度。」-- Zack Grossbart\n如何讓你的網站在各種裝置、各種使用者以及各種情境下都能快速運行是一個非常廣泛的主題。以下是一些在建立標準網頁專案或瀏覽器擴充功能時需要注意的要點。\n確保網站高效運行的第一步是收集其效能的相關資料。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點選「設定及更多」按鈕（瀏覽器右上角的三點圖示），然後導航到「更多工具 > 開發者工具」，並打開「效能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「效能」標籤包含一個分析工具。打開一個網站（例如 https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 0,
    "total_chunks": 25
  },
  {
    "id": "46c9f6283ac60b8bcd256864aa6f48a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "瀏覽器擴充功能專案第三部分：了解背景任務與效能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學習了如何建立一個表單以及顯示從 API 獲取的資料區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何處理非同步資料獲取。你的瀏覽器擴充功能幾乎已經完成。\n接下來需要管理一些背景任務，包括刷新擴充功能圖示的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在建立網頁資產時，我們可以從效能的角度來思考這些瀏覽器任務。\n網頁效能基礎\n「網站效能主要關注兩件事：頁面載入速度，以及頁面上的程式碼執行速度。」-- Zack Grossbart\n如何讓你的網站在各種裝置、各種使用者以及各種情境下都能快速運行是一個非常廣泛的主題。以下是一些在建立標準網頁專案或瀏覽器擴充功能時需要注意的要點。\n確保網站高效運行的第一步是收集其效能的相關資料。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點選「設定及更多」按鈕（瀏覽器右上角的三點圖示），然後導航到「更多工具 > 開發者工具」，並打開「效能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「效能」標籤包含一個分析工具。打開一個網站（例如 https://wwwmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 674,
    "chunk_index": 1,
    "total_chunks": 25
  },
  {
    "id": "ef9af0c6b1f2b4c83397cd8cec08e904",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "瀏覽器擴充功能專案第三部分：了解背景任務與效能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學習了如何建立一個表單以及顯示從 API 獲取的資料區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何處理非同步資料獲取。你的瀏覽器擴充功能幾乎已經完成。\n接下來需要管理一些背景任務，包括刷新擴充功能圖示的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在建立網頁資產時，我們可以從效能的角度來思考這些瀏覽器任務。\n網頁效能基礎\n「網站效能主要關注兩件事：頁面載入速度，以及頁面上的程式碼執行速度。」-- Zack Grossbart\n如何讓你的網站在各種裝置、各種使用者以及各種情境下都能快速運行是一個非常廣泛的主題。以下是一些在建立標準網頁專案或瀏覽器擴充功能時需要注意的要點。\n確保網站高效運行的第一步是收集其效能的相關資料。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點選「設定及更多」按鈕（瀏覽器右上角的三點圖示），然後導航到「更多工具 > 開發者工具」，並打開「效能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「效能」標籤包含一個分析工具。打開一個網站（例如 https://wwwmicrosoftcom），點擊「記錄」按鈕，然後刷新網站。隨時停止記錄，你就可以看到生成的例程，包括「腳本」、「渲染」和「繪製」網站的過程：\n✅ 參考 Microsoft 文件 了解 Edge 中的效能面板\n提示：為了獲得網站啟動時間的準確讀數，請清除瀏覽器的快取\n選擇分析時間軸的元素，放大頁面載入過程中的事件。\n透過選擇分析時間軸的一部分並查看摘要面板，獲取頁面效能的快照：\n檢查事件日誌面板，查看是否有任何事件超過 15 毫秒：\n✅ 熟悉你的分析工具！打開本網站的開發者工具，看看是否有任何瓶頸。哪個資產載入最慢？哪個最快？\n分析檢查\n一般來說，所有網頁開發者在建立網站時都應注意一些「問題區域」，以避免在部署到生產環境時出現意外。\n資產大小：近年來，網頁變得「更重」，因此速度也變慢了。其中一部分重量與圖片的使用有關。\n✅ 查看 Internet Archive 了解頁面重量的歷史視圖及更多資訊。\n一個好的做法是確保圖片已經過優化，並以適合使用者的大小和解析度交付。\nDOM 遍歷：瀏覽器需要根據你編寫的程式碼建立其文件物件模型（DOM），因此為了良好的頁面效能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某一頁面使用的樣式不需要包含在主樣式表中。\nJavaScript：每個 JavaScript 開發者都應注意「渲染阻塞」腳本，這些腳本必須在瀏覽器遍歷和繪製 DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。\n✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。\n現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟：\n建立計算顏色的函式\n在 /src/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1560,
    "chunk_index": 2,
    "total_chunks": 25
  },
  {
    "id": "54ea81d47afe2c51e74b505494bf8656",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "瀏覽器擴充功能專案第三部分：了解背景任務與效能\n課前測驗\n課前測驗\n簡介\n在本模組的前兩節課中，你學習了如何建立一個表單以及顯示從 API 獲取的資料區域。這是一種非常標準的方式來建立網頁。你甚至學會了如何處理非同步資料獲取。你的瀏覽器擴充功能幾乎已經完成。\n接下來需要管理一些背景任務，包括刷新擴充功能圖示的顏色，因此這是一個很好的時機來討論瀏覽器如何管理這類任務。在建立網頁資產時，我們可以從效能的角度來思考這些瀏覽器任務。\n網頁效能基礎\n「網站效能主要關注兩件事：頁面載入速度，以及頁面上的程式碼執行速度。」-- Zack Grossbart\n如何讓你的網站在各種裝置、各種使用者以及各種情境下都能快速運行是一個非常廣泛的主題。以下是一些在建立標準網頁專案或瀏覽器擴充功能時需要注意的要點。\n確保網站高效運行的第一步是收集其效能的相關資料。第一個可以查看的地方是網頁瀏覽器的開發者工具。在 Edge 瀏覽器中，你可以點選「設定及更多」按鈕（瀏覽器右上角的三點圖示），然後導航到「更多工具 > 開發者工具」，並打開「效能」標籤。你也可以使用快捷鍵 Ctrl + Shift + I（Windows）或 Option + Command + I（Mac）來打開開發者工具。\n「效能」標籤包含一個分析工具。打開一個網站（例如 https://wwwmicrosoftcom），點擊「記錄」按鈕，然後刷新網站。隨時停止記錄，你就可以看到生成的例程，包括「腳本」、「渲染」和「繪製」網站的過程：\n✅ 參考 Microsoft 文件 了解 Edge 中的效能面板\n提示：為了獲得網站啟動時間的準確讀數，請清除瀏覽器的快取\n選擇分析時間軸的元素，放大頁面載入過程中的事件。\n透過選擇分析時間軸的一部分並查看摘要面板，獲取頁面效能的快照：\n檢查事件日誌面板，查看是否有任何事件超過 15 毫秒：\n✅ 熟悉你的分析工具！打開本網站的開發者工具，看看是否有任何瓶頸。哪個資產載入最慢？哪個最快？\n分析檢查\n一般來說，所有網頁開發者在建立網站時都應注意一些「問題區域」，以避免在部署到生產環境時出現意外。\n資產大小：近年來，網頁變得「更重」，因此速度也變慢了。其中一部分重量與圖片的使用有關。\n✅ 查看 Internet Archive 了解頁面重量的歷史視圖及更多資訊。\n一個好的做法是確保圖片已經過優化，並以適合使用者的大小和解析度交付。\nDOM 遍歷：瀏覽器需要根據你編寫的程式碼建立其文件物件模型（DOM），因此為了良好的頁面效能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某一頁面使用的樣式不需要包含在主樣式表中。\nJavaScript：每個 JavaScript 開發者都應注意「渲染阻塞」腳本，這些腳本必須在瀏覽器遍歷和繪製 DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。\n✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。\n現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟：\n建立計算顏色的函式\n在 /src/indexjs 中，於你設置的一系列 const 變數之後新增一個名為 calculateColor() 的函式，以便訪問 DOM：\n```JavaScript\nfunction calculateColor(value) {\nlet co2Scale = [0, 150, 600, 750, 800];\nlet colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02'];\nlet closestNum = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1671,
    "chunk_index": 3,
    "total_chunks": 25
  },
  {
    "id": "b269b0e95e91c07a64d115475ae41154",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "「效能」標籤包含一個分析工具。打開一個網站（例如 https://wwwmicrosoftcom），點擊「記錄」按鈕，然後刷新網站。隨時停止記錄，你就可以看到生成的例程，包括「腳本」、「渲染」和「繪製」網站的過程： ✅ 參考 Microsoft 文件 了解 Edge 中的效能面板 提示：為了獲得網站啟動時間的準確讀數，請清除瀏覽器的快取 選擇分析時間軸的元素，放大頁面載入過程中的事件。 透過選擇分析時間軸的一部分並查看摘要面板，獲取頁面效能的快照： 檢查事件日誌面板，查看是否有任何事件超過 15 毫秒： ✅ 熟悉你的分析工具！打開本網站的開發者工具，看看是否有任何瓶頸。哪個資產載入最慢？哪個最快？ 分析檢查 一般來說，所有網頁開發者在建立網站時都應注意一些「問題區域」，以避免在部署到生產環境時出現意外。 資產大小：近年來，網頁變得「更重」，因此速度也變慢了。其中一部分重量與圖片的使用有關。 ✅ 查看 Internet Archive 了解頁面重量的歷史視圖及更多資訊。 一個好的做法是確保圖片已經過優化，並以適合使用者的大小和解析度交付。 DOM 遍歷：瀏覽器需要根據你編寫的程式碼建立其文件物件模型（DOM），因此為了良好的頁面效能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某一頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應注意「渲染阻塞」腳本，這些腳本必須在瀏覽器遍歷和繪製 DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。 現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟： 建立計算顏色的函式 在 /src/indexjs 中，於你設置的一系列 const 變數之後新增一個名為 calculateColor() 的函式，以便訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => {\nreturn Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1046,
    "chunk_index": 4,
    "total_chunks": 25
  },
  {
    "id": "8f82a214395914b169a93b34c57ec276",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "文件 了解 Edge 中的效能面板 提示：為了獲得網站啟動時間的準確讀數，請清除瀏覽器的快取 選擇分析時間軸的元素，放大頁面載入過程中的事件。 透過選擇分析時間軸的一部分並查看摘要面板，獲取頁面效能的快照： 檢查事件日誌面板，查看是否有任何事件超過 15 毫秒： ✅ 熟悉你的分析工具！打開本網站的開發者工具，看看是否有任何瓶頸。哪個資產載入最慢？哪個最快？ 分析檢查 一般來說，所有網頁開發者在建立網站時都應注意一些「問題區域」，以避免在部署到生產環境時出現意外。 資產大小：近年來，網頁變得「更重」，因此速度也變慢了。其中一部分重量與圖片的使用有關。 ✅ 查看 Internet Archive 了解頁面重量的歷史視圖及更多資訊。 一個好的做法是確保圖片已經過優化，並以適合使用者的大小和解析度交付。 DOM 遍歷：瀏覽器需要根據你編寫的程式碼建立其文件物件模型（DOM），因此為了良好的頁面效能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某一頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應注意「渲染阻塞」腳本，這些腳本必須在瀏覽器遍歷和繪製 DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。 現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟： 建立計算顏色的函式 在 /src/indexjs 中，於你設置的一系列 const 變數之後新增一個名為 calculateColor() 的函式，以便訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 935,
    "chunk_index": 5,
    "total_chunks": 25
  },
  {
    "id": "72df0d1341257e24a4d11062f68fcb96",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "提示：為了獲得網站啟動時間的準確讀數，請清除瀏覽器的快取 選擇分析時間軸的元素，放大頁面載入過程中的事件。 透過選擇分析時間軸的一部分並查看摘要面板，獲取頁面效能的快照： 檢查事件日誌面板，查看是否有任何事件超過 15 毫秒： ✅ 熟悉你的分析工具！打開本網站的開發者工具，看看是否有任何瓶頸。哪個資產載入最慢？哪個最快？ 分析檢查 一般來說，所有網頁開發者在建立網站時都應注意一些「問題區域」，以避免在部署到生產環境時出現意外。 資產大小：近年來，網頁變得「更重」，因此速度也變慢了。其中一部分重量與圖片的使用有關。 ✅ 查看 Internet Archive 了解頁面重量的歷史視圖及更多資訊。 一個好的做法是確保圖片已經過優化，並以適合使用者的大小和解析度交付。 DOM 遍歷：瀏覽器需要根據你編寫的程式碼建立其文件物件模型（DOM），因此為了良好的頁面效能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某一頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應注意「渲染阻塞」腳本，這些腳本必須在瀏覽器遍歷和繪製 DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。 現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟： 建立計算顏色的函式 在 /src/indexjs 中，於你設置的一系列 const 變數之後新增一個名為 calculateColor() 的函式，以便訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value);\n})[0];\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 933,
    "chunk_index": 6,
    "total_chunks": 25
  },
  {
    "id": "17bd3aacc2668be847693a8f7c40ead4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "15 毫秒： ✅ 熟悉你的分析工具！打開本網站的開發者工具，看看是否有任何瓶頸。哪個資產載入最慢？哪個最快？ 分析檢查 一般來說，所有網頁開發者在建立網站時都應注意一些「問題區域」，以避免在部署到生產環境時出現意外。 資產大小：近年來，網頁變得「更重」，因此速度也變慢了。其中一部分重量與圖片的使用有關。 ✅ 查看 Internet Archive 了解頁面重量的歷史視圖及更多資訊。 一個好的做法是確保圖片已經過優化，並以適合使用者的大小和解析度交付。 DOM 遍歷：瀏覽器需要根據你編寫的程式碼建立其文件物件模型（DOM），因此為了良好的頁面效能，應保持標籤的最小化，只使用和樣式化頁面所需的內容。例如，與頁面相關的多餘 CSS 可以進行優化；僅需在某一頁面使用的樣式不需要包含在主樣式表中。 JavaScript：每個 JavaScript 開發者都應注意「渲染阻塞」腳本，這些腳本必須在瀏覽器遍歷和繪製 DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。 現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟： 建立計算顏色的函式 在 /src/indexjs 中，於你設置的一系列 const 變數之後新增一個名為 calculateColor() 的函式，以便訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum);\nlet num = (element) => element > closestNum;\nlet scaleIndex = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 822,
    "chunk_index": 7,
    "total_chunks": 25
  },
  {
    "id": "9da3bbd0343974e236c625d504ad45de",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "DOM 之前載入。考慮在內嵌腳本中使用 defer（如在 Terrarium 模組中所示）。 ✅ 在 網站速度測試網站 上嘗試一些網站，了解用於判斷網站效能的常見檢查。 現在你已經了解瀏覽器如何渲染你提供的資產，接下來我們來看看完成擴充功能所需的最後幾個步驟： 建立計算顏色的函式 在 /src/indexjs 中，於你設置的一系列 const 變數之後新增一個名為 calculateColor() 的函式，以便訪問 DOM： ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num);\nlet closestColor = colors[scaleIndex];\nconsole log(scaleIndex, closestColor);\nchrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } });\n}\n```\n這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 483,
    "chunk_index": 8,
    "total_chunks": 25
  },
  {
    "id": "357e17df69302eadac98a696d471e8e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "[0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它：\n「使用 chrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 299,
    "chunk_index": 9,
    "total_chunks": 25
  },
  {
    "id": "93b91b3295f4d49b2238779ae94c4981",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」\n✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。\n注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。\n設置預設圖示顏色\n現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色：\nJavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 10,
    "total_chunks": 25
  },
  {
    "id": "0d07c2a7e4f914468ce7a307743f69ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 523,
    "chunk_index": 11,
    "total_chunks": 25
  },
  {
    "id": "f66af2ec9691026d1552a473ffec0897",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({\naction: 'updateIcon',\nvalue: {\ncolor: 'green',\n},\n});\n呼叫函式並執行呼叫\n接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式：\nJavaScript\n//let CO2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 604,
    "chunk_index": 12,
    "total_chunks": 25
  },
  {
    "id": "91e714bccea8f4d6c166efa197515f7e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "closestColor = colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2);\n最後，在 /dist/background",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 585,
    "chunk_index": 13,
    "total_chunks": 25
  },
  {
    "id": "85107b5715d87b1fb668628e06398b55",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "colors[scaleIndex]; console log(scaleIndex, closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫：\n```JavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 611,
    "chunk_index": 14,
    "total_chunks": 25
  },
  {
    "id": "02f5faf7686f44241ed5df3277804baa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 602,
    "chunk_index": 15,
    "total_chunks": 25
  },
  {
    "id": "98520ad90049e9c408884f87eaf68e97",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 604,
    "chunk_index": 16,
    "total_chunks": 25
  },
  {
    "id": "ff29bdfaad869b2d2f1d6e2e01d75816",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "closestColor); chrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) {\nif (msg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 618,
    "chunk_index": 17,
    "total_chunks": 25
  },
  {
    "id": "982fa0de6f1f7e4f6033c380ee426247",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "value: { color: closestColor } }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') {\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 613,
    "chunk_index": 18,
    "total_chunks": 25
  },
  {
    "id": "e99705d4a90f053fe1804f5a90431722",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "} }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserAction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 609,
    "chunk_index": 19,
    "total_chunks": 25
  },
  {
    "id": "605941fe39a883c9271fae473b1ae706",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "} }); } ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 616,
    "chunk_index": 20,
    "total_chunks": 25
  },
  {
    "id": "b62ae5b6c98a3e26db0f787979b96635",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "} ``` 這裡發生了什麼？你傳入一個值（碳強度），該值來自你在上一課完成的 API 呼叫，然後計算其值與顏色陣列中索引的接近程度。接著，你將最接近的顏色值傳送到 chrome runtime。 chromeruntime 擁有 一個 API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) });\n}\n});\n//borrowed from energy lollipop extension, nice feature",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 630,
    "chunk_index": 21,
    "total_chunks": 25
  },
  {
    "id": "fe3b181651a34b7cee08d1add3bfcc28",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "API，可以處理各種背景任務，而你的擴充功能正在利用它： 「使用 chromeruntime API 來檢索背景頁面、返回清單的詳細資訊，並監聽和回應應用程式或擴充功能生命週期中的事件。你也可以使用此 API 將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) {\nlet canvas = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 528,
    "chunk_index": 22,
    "total_chunks": 25
  },
  {
    "id": "19eb141ae4ce11b3ee1ad1ba812ca3e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "將 URL 的相對路徑轉換為完全限定的 URL。」 ✅ 如果你正在為 Edge 開發此瀏覽器擴充功能，可能會驚訝於你正在使用 chrome API。新版 Edge 瀏覽器基於 Chromium 瀏覽器引擎，因此你可以利用這些工具。 注意，如果你想分析瀏覽器擴充功能，請從擴充功能本身內部啟動開發者工具，因為它是獨立的瀏覽器實例。 設置預設圖示顏色 現在，在 init() 函式中，透過再次調用 chrome 的 updateIcon 操作，將圖示設置為預設的綠色： JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas');\nlet context = canvas getContext('2d');\ncontext beginPath();\ncontext fillStyle = value color;\ncontext arc(100, 100, 50, 0, 2 * Math PI);\ncontext fill();\nreturn context",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 23,
    "total_chunks": 25
  },
  {
    "id": "a797433afe6e21ba9410b0e5ad257e76",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第三部分：了解背景任務與效能",
    "content": "action: 'updateIcon', value: { color: 'green', }, }); 呼叫函式並執行呼叫 接下來，透過將其新增到 C02Signal API 返回的 promise 中，呼叫你剛剛建立的函式： JavaScript //let CO2calculateColor(CO2); 最後，在 /dist/backgroundjs 中，新增監聽器以處理這些背景操作呼叫： ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvas getContext('2d'); context beginPath(); context fillStyle = value color; context arc(100, 100, 50, 0, 2 * Math PI); context fill(); return contextgetImageData(50, 50, 100, 100);\n}\n```\n在這段程式碼中，你新增了一個監聽器，用於接收發送到後端任務管理器的任何訊息。如果訊息名稱為 'updateIcon'，則執行接下來的程式碼，使用 Canvas API 繪製適當顏色的圖示。\n✅ 你將在 太空遊戲課程 中學到更多關於 Canvas API 的知識。\n現在，重新建置你的擴充功能（npm run build），刷新並啟動你的擴充功能，觀察顏色變化。是時候去跑腿或洗碗了嗎？現在你知道了！\n恭喜你！你已經建立了一個實用的瀏覽器擴充功能，並且更深入了解瀏覽器的運作方式以及如何分析其效能。\n🚀 挑戰\n調查一些已存在很久的開源網站，根據其 GitHub 歷史，看看是否能判斷它們在效能方面的優化過程。如果有的話，最常見的痛點是什麼？\n課後測驗\n課後測驗\n回顧與自學\n考慮訂閱 效能電子報\n調查瀏覽器透過其網頁工具中的效能標籤來衡量網頁效能的方式。你是否發現任何主要差異？\n作業\n分析網站效能\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9246,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 902,
    "chunk_index": 24,
    "total_chunks": 25
  },
  {
    "id": "1fa1d90a054ebe1763165ee5776f100c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\assignment.md",
    "source_type": "git_repo",
    "title": "練習你的 HTML：建立一個部落格模型",
    "content": "練習你的 HTML：建立一個部落格模型\n指導說明\n想像你正在設計或重新設計你個人的網站。創建一個網站的圖形模型，然後寫下你將用來構建網站各個元素的 HTML 標記。你可以在紙上完成，然後掃描，或者使用你選擇的軟體，但請確保手動編寫 HTML 標記。\n評分標準\n| 評分標準 | 優秀                                                                                   | 合格                                                                           | 需要改進                                                                             |\n| -------- | -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------- |\n|          | 部落格佈局以視覺方式呈現，並顯示至少 10 個標記元素                                      | 部落格佈局以視覺方式呈現，並顯示大約 5 個標記元素                                | 部落格佈局以視覺方式呈現，並顯示最多 3 個標記元素                                    |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1918,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 504,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "18cce0b67518928513f3516e203b20e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲\n課前測驗\n課前測驗\n簡介\n在本課中，您將透過提交瀏覽器擴充功能的表單來呼叫 API，並在擴充功能中顯示結果。此外，您還將學習如何將數據存儲在瀏覽器的本地存儲中，以供未來參考和使用。\n✅ 按照適當文件中的編號段落，了解應將程式碼放置在哪裡。\n設置擴充功能中需要操作的元素：\n到目前為止，您已經為瀏覽器擴充功能建立了表單和結果 <div> 的 HTML。接下來，您需要在 /src/index js 文件中工作，逐步構建您的擴充功能。請參考上一課以了解如何設置專案和構建過程。\n在 index js 文件中，首先建立一些 const 變數來保存與各個欄位相關的值：\n```JavaScript\n// form fields\nconst form = document querySelector(' form-data');\nconst region = document querySelector(' region-name');\nconst apiKey = document querySelector(' api-key');\n// results\nconst errors = document querySelector(' errors');\nconst loading = document querySelector(' loading');\nconst results = document querySelector(' result-container');\nconst usage = document querySelector(' carbon-usage');\nconst fossilfuel = document querySelector(' fossil-fuel');\nconst myregion = document querySelector(' my-region');\nconst clearBtn = document querySelector('",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 0,
    "total_chunks": 38
  },
  {
    "id": "c65dfce9767c4cb5f3a9aa28207ef462",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "的 HTML。接下來，您需要在 /src/index js 文件中工作，逐步構建您的擴充功能。請參考上一課以了解如何設置專案和構建過程。 在 index js 文件中，首先建立一些 const 變數來保存與各個欄位相關的值： ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn');\n```\n這些欄位都是通過其 CSS 類名來引用的，這是在上一課的 HTML 中設置的。\n添加監聽器\n接下來，為表單和重置按鈕添加事件監聽器，這樣當使用者提交表單或點擊重置按鈕時，會觸發相應的操作，並在文件底部添加初始化應用程式的調用：\nJavaScript\nform addEventListener('submit', (e) => handleSubmit(e));\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 362,
    "chunk_index": 1,
    "total_chunks": 38
  },
  {
    "id": "20c0b4f645e47b87b435e402ab6385a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn'); ``` 這些欄位都是通過其 CSS 類名來引用的，這是在上一課的 HTML 中設置的。 添加監聽器 接下來，為表單和重置按鈕添加事件監聽器，這樣當使用者提交表單或點擊重置按鈕時，會觸發相應的操作，並在文件底部添加初始化應用程式的調用： JavaScript form addEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e));\ninit();\n✅ 注意這裡使用的簡寫方式來監聽提交或點擊事件，以及事件如何被傳遞給 handleSubmit 或 reset 函數。您能否用更長的格式來寫出這種簡寫的等效程式碼？您更喜歡哪種方式？\n構建 init() 函數和 reset() 函數：\n現在，您將構建初始化擴充功能的函數，稱為 init()：\n```JavaScript\nfunction init() {\n//if anything is in localStorage, pick it up\nconst storedApiKey = localStorage getItem('apiKey');\nconst storedRegion = localStorage getItem('regionName');\n//set icon to be generic green\n//todo\nif (storedApiKey === null || storedRegion === null) {\n//if we don't have the keys, show the form\nform style display = 'block';\nresults style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 2,
    "total_chunks": 38
  },
  {
    "id": "9ebd81c6316ce043fea40d0fc9f41162",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "addEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e)); init(); ✅ 注意這裡使用的簡寫方式來監聽提交或點擊事件，以及事件如何被傳遞給 handleSubmit 或 reset 函數。您能否用更長的格式來寫出這種簡寫的等效程式碼？您更喜歡哪種方式？ 構建 init() 函數和 reset() 函數： 現在，您將構建初始化擴充功能的函數，稱為 init()： ```JavaScript function init() { //if anything is in localStorage, pick it up const storedApiKey = localStorage getItem('apiKey'); const storedRegion = localStorage getItem('regionName'); //set icon to be generic green //todo if (storedApiKey === null || storedRegion === null) { //if we don't have the keys, show the form form style display = 'block'; results styledisplay = 'none';\nloading style display = 'none';\nclearBtn style display = 'none';\nerrors textContent = '';\n} else {\n//if we have saved keys/regions in localStorage, show results when they load\ndisplayCarbonUsage(storedApiKey, storedRegion);\nresults style display = 'none';\nform style display = 'none';\nclearBtn style display = 'block';\n}\n};\nfunction reset(e) {\ne preventDefault();\n//clear local storage for region only\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 347,
    "chunk_index": 3,
    "total_chunks": 38
  },
  {
    "id": "59ae507a29686897c3bf00412fccbc7a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "don't have the keys, show the form form style display = 'block'; results styledisplay = 'none'; loading style display = 'none'; clearBtn style display = 'none'; errors textContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName');\ninit();\n}\n```\n在這個函數中，有一些有趣的邏輯。閱讀程式碼，您能看出發生了什麼嗎？\n設置了兩個 const 來檢查使用者是否在本地存儲中保存了 APIKey 和地區代碼。\n如果其中任何一個為 null，則通過將表單的樣式更改為 'block' 來顯示表單。\n隱藏結果、加載動畫和 clearBtn，並將任何錯誤訊息設置為空字串。\n如果存在密鑰和地區代碼，則啟動一個例程來：\n呼叫 API 獲取碳使用數據\n隱藏結果區域\n隱藏表單\n顯示重置按鈕\n在繼續之前，了解瀏覽器中一個非常重要的概念是很有幫助的：LocalStorage。LocalStorage 是一種將字串以 key-value 配對形式存儲在瀏覽器中的有用方式。這種網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而另一種網頁存儲 SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。\n注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。\n您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。\n✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。\n注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。\n在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。\n處理表單提交\n建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1053,
    "chunk_index": 4,
    "total_chunks": 38
  },
  {
    "id": "4fae6d1edfbe05679b0c38dc2c951604",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "//clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` 在這個函數中，有一些有趣的邏輯。閱讀程式碼，您能看出發生了什麼嗎？ 設置了兩個 const 來檢查使用者是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，則通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載動畫和 clearBtn，並將任何錯誤訊息設置為空字串。 如果存在密鑰和地區代碼，則啟動一個例程來： 呼叫 API 獲取碳使用數據 隱藏結果區域 隱藏表單 顯示重置按鈕 在繼續之前，了解瀏覽器中一個非常重要的概念是很有幫助的：LocalStorage。LocalStorage 是一種將字串以 key-value 配對形式存儲在瀏覽器中的有用方式。這種網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而另一種網頁存儲 SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。 注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 955,
    "chunk_index": 5,
    "total_chunks": 38
  },
  {
    "id": "1685d00f61759fc74f4f11a08cdf01d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "storage for region only localStorageremoveItem('regionName'); init(); } ``` 在這個函數中，有一些有趣的邏輯。閱讀程式碼，您能看出發生了什麼嗎？ 設置了兩個 const 來檢查使用者是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，則通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載動畫和 clearBtn，並將任何錯誤訊息設置為空字串。 如果存在密鑰和地區代碼，則啟動一個例程來： 呼叫 API 獲取碳使用數據 隱藏結果區域 隱藏表單 顯示重置按鈕 在繼續之前，了解瀏覽器中一個非常重要的概念是很有幫助的：LocalStorage。LocalStorage 是一種將字串以 key-value 配對形式存儲在瀏覽器中的有用方式。這種網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而另一種網頁存儲 SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。 注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。\nJavaScript\nfunction handleSubmit(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 999,
    "chunk_index": 6,
    "total_chunks": 38
  },
  {
    "id": "163ff734679fc78a1a233c8ab6617061",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "} ``` 在這個函數中，有一些有趣的邏輯。閱讀程式碼，您能看出發生了什麼嗎？ 設置了兩個 const 來檢查使用者是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，則通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載動畫和 clearBtn，並將任何錯誤訊息設置為空字串。 如果存在密鑰和地區代碼，則啟動一個例程來： 呼叫 API 獲取碳使用數據 隱藏結果區域 隱藏表單 顯示重置按鈕 在繼續之前，了解瀏覽器中一個非常重要的概念是很有幫助的：LocalStorage。LocalStorage 是一種將字串以 key-value 配對形式存儲在瀏覽器中的有用方式。這種網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而另一種網頁存儲 SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。 注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault();\nsetUpUser(apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 988,
    "chunk_index": 7,
    "total_chunks": 38
  },
  {
    "id": "a264593f719c6f48eb441c0c9ec5948b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "``` 在這個函數中，有一些有趣的邏輯。閱讀程式碼，您能看出發生了什麼嗎？ 設置了兩個 const 來檢查使用者是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，則通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載動畫和 clearBtn，並將任何錯誤訊息設置為空字串。 如果存在密鑰和地區代碼，則啟動一個例程來： 呼叫 API 獲取碳使用數據 隱藏結果區域 隱藏表單 顯示重置按鈕 在繼續之前，了解瀏覽器中一個非常重要的概念是很有幫助的：LocalStorage。LocalStorage 是一種將字串以 key-value 配對形式存儲在瀏覽器中的有用方式。這種網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而另一種網頁存儲 SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。 注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 990,
    "chunk_index": 8,
    "total_chunks": 38
  },
  {
    "id": "5ff374595f94045cdd53ed8a5b84bd4a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "在這個函數中，有一些有趣的邏輯。閱讀程式碼，您能看出發生了什麼嗎？ 設置了兩個 const 來檢查使用者是否在本地存儲中保存了 APIKey 和地區代碼。 如果其中任何一個為 null，則通過將表單的樣式更改為 'block' 來顯示表單。 隱藏結果、加載動畫和 clearBtn，並將任何錯誤訊息設置為空字串。 如果存在密鑰和地區代碼，則啟動一個例程來： 呼叫 API 獲取碳使用數據 隱藏結果區域 隱藏表單 顯示重置按鈕 在繼續之前，了解瀏覽器中一個非常重要的概念是很有幫助的：LocalStorage。LocalStorage 是一種將字串以 key-value 配對形式存儲在瀏覽器中的有用方式。這種網頁存儲可以通過 JavaScript 操作來管理瀏覽器中的數據。LocalStorage 不會過期，而另一種網頁存儲 SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。 注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue);\n}\n✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。\n設置使用者\n接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數：\nJavaScript\nfunction setUpUser(apiKey, regionName) {\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1159,
    "chunk_index": 9,
    "total_chunks": 38
  },
  {
    "id": "2d331ca30634d9daf36f941b48e484a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "SessionStorage 則會在瀏覽器關閉時清除。這些存儲類型在使用上各有優缺點。 注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey);\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 783,
    "chunk_index": 10,
    "total_chunks": 38
  },
  {
    "id": "becae8b9893ccc830914ff315a0c4a43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "注意 - 您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName);\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 750,
    "chunk_index": 11,
    "total_chunks": 38
  },
  {
    "id": "6db93fa82596ffd530dbd4373ac17794",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 12,
    "total_chunks": 38
  },
  {
    "id": "081e7d47a18395c9f105e672c6d750c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "您的瀏覽器擴充功能有其自己的本地存儲；主瀏覽器窗口是不同的實例，行為是分開的。 您可以將 APIKey 設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block';\nerrors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 754,
    "chunk_index": 13,
    "total_chunks": 38
  },
  {
    "id": "ecd1c43d60e739f445acb3f446b41598",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "設置為一個字串值，例如，您可以通過“檢查”網頁（右鍵點擊瀏覽器以檢查）並轉到 Applications 標籤查看存儲來看到它在 Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = '';\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 699,
    "chunk_index": 14,
    "total_chunks": 38
  },
  {
    "id": "c5a8e9170dc98437f01a06e1b6909a7f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 623,
    "chunk_index": 15,
    "total_chunks": 38
  },
  {
    "id": "5c8365761426806a02a1dcccbc90f504",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "Edge 中的設置。 ✅ 思考哪些情況下您不應該將某些數據存儲在 LocalStorage 中。一般來說，將 API 密鑰放在 LocalStorage 中是個壞主意！您能理解為什麼嗎？在我們的案例中，由於我們的應用程式純粹是為了學習，且不會部署到應用商店，因此我們將使用這種方法。 注意，您可以使用 Web API 操作 LocalStorage，通過 getItem()、setItem() 或 removeItem()。它在各個瀏覽器中都得到了廣泛支持。 在構建 displayCarbonUsage() 函數（在 init() 中調用）之前，讓我們先構建處理初始表單提交的功能。 處理表單提交 建立一個名為 handleSubmit 的函數，接受一個事件參數 (e)。阻止事件傳播（在這種情況下，我們希望阻止瀏覽器刷新），並調用一個新函數 setUpUser，傳遞 apiKeyvalue 和 regionvalue 作為參數。通過這種方式，您可以使用初始表單中填寫的兩個值。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 回顧一下記憶 - 您在上一課中設置的 HTML 包含兩個輸入欄位，其 values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block';\n//make initial call\ndisplayCarbonUsage(apiKey, regionName);\n}\n此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！\n顯示碳使用量\n最後，是時候查詢 API 了！\n在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。\n✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？\n這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。\n這裡有一個關於 async 的簡短影片：\n🎥 點擊上方圖片觀看有關 async/await 的影片。\n建立一個新函數來查詢 C02Signal API：\n```JavaScript\nimport axios from '",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1168,
    "chunk_index": 16,
    "total_chunks": 38
  },
  {
    "id": "6cab156f1743a2851a904c3c75115e71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "values 是通過您在文件頂部設置的 const 捕獲的，並且它們都是 required，因此瀏覽器會阻止使用者輸入空值。 設置使用者 接下來是 setUpUser 函數，這裡您將為 apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios';\nasync function displayCarbonUsage(apiKey, region) {\ntry {\nawait axios",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 730,
    "chunk_index": 17,
    "total_chunks": 38
  },
  {
    "id": "2d29f7bf8dcc20c0a611bef74016f3a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://api",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 648,
    "chunk_index": 18,
    "total_chunks": 38
  },
  {
    "id": "0b90e584516a4d53ece715e941dd3d51",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signal",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 651,
    "chunk_index": 19,
    "total_chunks": 38
  },
  {
    "id": "3cb8364e42b21d4a9ce17160f4d7c23e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "apiKey 和 regionName 設置本地存儲值。添加一個新函數： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', {\nparams: {\ncountryCode: region,\n},\nheaders: {\n'auth-token': apiKey,\n},\n})",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 20,
    "total_chunks": 38
  },
  {
    "id": "8ecb975446100fc408925ec92c5e6203",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => {\nlet CO2 = Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 629,
    "chunk_index": 21,
    "total_chunks": 38
  },
  {
    "id": "d9a3e38aa92d1050a6979fddd328304b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 617,
    "chunk_index": 22,
    "total_chunks": 38
  },
  {
    "id": "bb4f67dc261fec795051d1c790090717",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 619,
    "chunk_index": 23,
    "total_chunks": 38
  },
  {
    "id": "d092c0590e29c18147328fcddd186edf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 24,
    "total_chunks": 38
  },
  {
    "id": "bf71fc1702e5494cb0ce88928e255e42",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity);\n//calculateColor(CO2);\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 632,
    "chunk_index": 25,
    "total_chunks": 38
  },
  {
    "id": "e33a7e59cf624e2ff684125a6c4c4e68",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "= 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 26,
    "total_chunks": 38
  },
  {
    "id": "b51e738462126bf079e319ee3c8005a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "= 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none';\nform",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 633,
    "chunk_index": 27,
    "total_chunks": 38
  },
  {
    "id": "ff59135d9bf4510c8771d8996b9d77d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 628,
    "chunk_index": 28,
    "total_chunks": 38
  },
  {
    "id": "68095de47290e5314fb4ea7ce728c13e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "initial call displayCarbonUsage(apiKey, regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none';\nmyregion",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 635,
    "chunk_index": 29,
    "total_chunks": 38
  },
  {
    "id": "9725f76f4c8c57b4fc0dc099a0e5a13e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "regionName); } 此函數設置了一條加載訊息，以在呼叫 API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region;\nusage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 632,
    "chunk_index": 30,
    "total_chunks": 38
  },
  {
    "id": "0067b6b7eac3ae8cac0dfebebc0cd91d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "API 時顯示。到這裡，您已經來到了這個瀏覽器擴充功能中最重要的函數！ 顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent =\nMath",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 31,
    "total_chunks": 38
  },
  {
    "id": "2fbdcc00d657365d361b5c5543f240ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 558,
    "chunk_index": 32,
    "total_chunks": 38
  },
  {
    "id": "f3fae90ea0ac2dcc7fb994e39cbd8c57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 560,
    "chunk_index": 33,
    "total_chunks": 38
  },
  {
    "id": "4b9327e6acb2e2a59441e3c5fa9fffa7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 562,
    "chunk_index": 34,
    "total_chunks": 38
  },
  {
    "id": "048e0109452dacee9c9b93360b9413e7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "顯示碳使用量 最後，是時候查詢 API 了！ 在進一步操作之前，我們應該討論一下 API。API，即應用程式編程介面，是網頁開發人員工具箱中的關鍵元素。它們為程式之間的互動和介面提供了標準方式。例如，如果您正在建立一個需要查詢資料庫的網站，可能有人已經為您建立了一個 API 可以使用。雖然有許多類型的 API，但其中一種最受歡迎的是 REST API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)';\nfossilfuel",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 582,
    "chunk_index": 35,
    "total_chunks": 38
  },
  {
    "id": "d5ca84dbabb3bbc6c8d4517e6b0a9420",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "API。 ✅ “REST” 代表“表述性狀態轉移”，其特點是使用各種配置的 URL 來獲取數據。請稍作研究，了解開發人員可用的各種 API 類型。哪種格式最吸引您？ 這個函數中有一些重要的事情需要注意。首先，注意 async 關鍵字。將函數編寫為異步運行意味著它會等待某個操作（例如數據返回）完成後再繼續。 這裡有一個關於 async 的簡短影片： 🎥 點擊上方圖片觀看有關 async/await 的影片。 建立一個新函數來查詢 C02Signal API： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent =\nresponse data data fossilFuelPercentage toFixed(2) +\n'% (percentage of fossil fuels used to generate electricity)';\nresults style display = 'block';\n});\n} catch (error) {\nconsole log(error);\nloading style display = 'none';\nresults style display = 'none';\nerrors textContent = 'Sorry, we have no data for the region you have requested",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 465,
    "chunk_index": 36,
    "total_chunks": 38
  },
  {
    "id": "bf39186559e9872dba59597d45d72dbd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "瀏覽器擴充功能專案第 2 部分：呼叫 API，使用本地存儲",
    "content": "Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = response data data fossilFuelPercentage toFixed(2) + '% (percentage of fossil fuels used to generate electricity)'; results style display = 'block'; }); } catch (error) { console log(error); loading style display = 'none'; results style display = 'none'; errors textContent = 'Sorry, we have no data for the region you have requested';\n}\n}\n```\n這是一個較大的函數。這裡發生了什麼？\n遵循最佳實踐，您使用 async 關鍵字使此函數異步運行。該函數包含一個 try/catch 區塊，因為當 API 返回數據時，它會返回一個 Promise。由於您無法控制 API 回應的速度（它可能根本不回應！），因此需要通過異步調用來處理這種不確定性。\n您正在查詢 co2signal API 以獲取您地區的數據，使用您的 API 密鑰。要使用該密鑰，您需要在標頭參數中使用一種類型的身份驗證。\n一旦 API 回應，您將其回應數據的各個元素分配給您設置的螢幕部分以顯示這些數據。\n如果出現錯誤或沒有結果，則顯示錯誤訊息。\n✅ 使用異步編程模式是工具箱中另一個非常有用的工具。閱讀有關各種方式配置此類程式碼的資訊。\n恭喜！如果您構建了擴充功能（npm run build）並在擴充功能面板中刷新它，您就擁有了一個可運行的擴充功能！唯一尚未運行的是圖示，您將在下一課中修復它。\n🚀 挑戰\n在這些課程中，我們已經討論了幾種類型的 API。選擇一個網頁 API，深入研究它提供的功能。例如，查看瀏覽器中可用的 API，例如 HTML 拖放 API。在您看來，什麼樣的 API 是優秀的？\n課後測驗\n課後測驗\n回顧與自學\n在本課中，您學習了 LocalStorage 和 API，這兩者對專業網頁開發人員都非常有用。您能想到這兩者如何協同工作嗎？思考一下，您將如何設計一個網站來存儲供 API 使用的項目。\n作業\n採用一個 API\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11878,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1061,
    "chunk_index": 37,
    "total_chunks": 38
  },
  {
    "id": "2ae12d42417769d1f4224d777dd7fa72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\assignment.md",
    "source_type": "git_repo",
    "title": "CSS 重構",
    "content": "CSS 重構\n說明\n使用 Flexbox 或 CSS Grid 重新設計植物箱的樣式，並截圖以顯示您已在多個瀏覽器中進行測試。您可能需要修改標記，因此請創建應用程式的新版本，並將藝術作品放置到位以進行重構。暫時不需要讓元素可拖動；目前僅需重構 HTML 和 CSS。\n評分標準\n| 評分標準 | 優秀                                                         | 合格                      | 需要改進                          |\n| -------- | ------------------------------------------------------------ | ------------------------- | ---------------------------------- |\n|          | 使用 Flexbox 或 CSS Grid 完全重新設計植物箱樣式              | 僅重新設計部分元素樣式    | 未能重新設計植物箱樣式            |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1491,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 431,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c90a5bb9cb686afcff06e0014cb0b617",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "7be5d3b372f65f047272f13689ce9ce1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 584,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "693f95a924d556e7e17da7513eb5bd53",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 589,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "e22d3d1a3dc4a1af89dfcf3ca528c75e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "efd03ca0a972904b270d64628a39ca4c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 596,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "4b05db11c76ff93bfbf34b669f0d269b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，像 https://anysite",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 637,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "294fbf6dcd618632b22a463fa6d1fce9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，像 https://anysitecom/test 這樣的 URL 可能是基於一個名為 test 的資料夾結構，其中包含 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 678,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "d6838628f5231d9ff87e7ca1ec1a30ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，像 https://anysitecom/test 這樣的 URL 可能是基於一個名為 test 的資料夾結構，其中包含 indexhtml；URL 中不一定會顯示 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 691,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "e4ccac01c48d781332313fe994003228",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Terrarium 專案第一部分：HTML 簡介\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n觀看影片\n簡介\nHTML，全名為超文本標記語言（HyperText Markup Language），是網頁的「骨架」。如果說 CSS 是為 HTML「穿上衣服」，JavaScript 則是讓它「活起來」，那麼 HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。\n在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。\n任務\n在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案：\n或者\n使用以下指令在 git bash 中完成：\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml 或 nano indexhtml\nindexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，像 https://anysitecom/test 這樣的 URL 可能是基於一個名為 test 的資料夾結構，其中包含 indexhtml；URL 中不一定會顯示 indexhtml。\nDocType 和 html 標籤\nHTML 檔案的第一行是它的 DocType。這行需要放在檔案的最頂端，雖然看起來有些奇怪，但它告訴舊版瀏覽器需要以標準模式渲染頁面，遵循當前的 HTML 規範。\n提示：在 VS Code 中，你可以將滑鼠懸停在標籤上，查看 MDN 參考指南中關於該標籤的使用資訊。\n第二行應該是 <html> 標籤的開啟標籤，接著是它的關閉標籤 </html>。這些標籤是介面的根元素。\n任務\n在你的 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 925,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "a7107b6e217f9aec0a7a02476d88bc6f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "HTML 就是網頁應用程式的「身體」。HTML 的語法甚至反映了這個概念，因為它包含了「head」、「body」和「footer」標籤。 在這堂課中，我們將使用 HTML 來設計虛擬玻璃花園介面的「骨架」。介面將包含一個標題和三個欄位：左右兩側的欄位放置可拖曳的植物，中間的區域則是玻璃花園的主要部分。在課程結束時，你將能看到植物出現在欄位中，但介面可能看起來有些奇怪；別擔心，下一節課我們會使用 CSS 為介面添加樣式，使其更美觀。 任務 在你的電腦上建立一個名為 'terrarium' 的資料夾，並在其中建立一個名為 'indexhtml' 的檔案。你可以在 Visual Studio Code 中完成這個操作：打開一個新的 VS Code 視窗，點擊「開啟資料夾」，然後導航到新建的資料夾。接著在 Explorer 面板中點擊小型「檔案」按鈕，建立新檔案： 或者 使用以下指令在 git bash 中完成： * mkdir terrarium * cd terrarium * touch indexhtml * code indexhtml 或 nano indexhtml indexhtml 檔案告訴瀏覽器它是資料夾中的預設檔案；例如，像 https://anysitecom/test 這樣的 URL 可能是基於一個名為 test 的資料夾結構，其中包含 indexhtml；URL 中不一定會顯示 indexhtml。 DocType 和 html 標籤 HTML 檔案的第一行是它的 DocType。這行需要放在檔案的最頂端，雖然看起來有些奇怪，但它告訴舊版瀏覽器需要以標準模式渲染頁面，遵循當前的 HTML 規範。 提示：在 VS Code 中，你可以將滑鼠懸停在標籤上，查看 MDN 參考指南中關於該標籤的使用資訊。 第二行應該是 <html> 標籤的開啟標籤，接著是它的關閉標籤 </html>。這些標籤是介面的根元素。 任務 在你的 indexhtml 檔案頂部添加以下內容：\n```HTML\n```\n✅ 有幾種不同的模式可以通過設置 DocType 的查詢字串來確定：Quirks Mode 和 Standards Mode。這些模式曾用於支援非常舊的瀏覽器（如 Netscape Navigator 4 和 Internet Explorer 5），但現在通常不再使用。你可以使用標準的 DocType 宣告。\n文件的 'head'\nHTML 文件的 'head' 區域包含關於網頁的重要資訊，也稱為 metadata。在我們的案例中，我們告訴網頁伺服器以下四件事：\n網頁的標題\n頁面元數據，包括：\n字元集，告訴頁面使用的字元編碼\n瀏覽器資訊，包括 x-ua-compatible，表示支援 IE=edge 瀏覽器\n關於頁面載入時 viewport 的行為資訊。將 viewport 設置為初始比例為 1 可以控制頁面首次載入時的縮放級別。\n任務\n在開啟和關閉的 <html> 標籤之間添加 'head' 區塊。\nhtml\n<head>\n<title>Welcome to my Virtual Terrarium</title>\n<meta charset=\"utf-8\" />\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n</head>\n✅ 如果你像這樣設置 viewport meta 標籤：<meta name=\"viewport\" content=\"width=600\">，會發生什麼？閱讀更多關於 viewport 的資訊。\n文件的 body\nHTML 標籤\n在 HTML 中，你可以在",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1291,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "9da6ad6e2f78ec017f6b0d7cd08bc49c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Mode 和 Standards Mode。這些模式曾用於支援非常舊的瀏覽器（如 Netscape Navigator 4 和 Internet Explorer 5），但現在通常不再使用。你可以使用標準的 DocType 宣告。 文件的 'head' HTML 文件的 'head' 區域包含關於網頁的重要資訊，也稱為 metadata。在我們的案例中，我們告訴網頁伺服器以下四件事： 網頁的標題 頁面元數據，包括： 字元集，告訴頁面使用的字元編碼 瀏覽器資訊，包括 x-ua-compatible，表示支援 IE=edge 瀏覽器 關於頁面載入時 viewport 的行為資訊。將 viewport 設置為初始比例為 1 可以控制頁面首次載入時的縮放級別。 任務 在開啟和關閉的 <html> 標籤之間添加 'head' 區塊。 html <head> <title>Welcome to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ 如果你像這樣設置 viewport meta 標籤：<meta name=\"viewport\" content=\"width=600\">，會發生什麼？閱讀更多關於 viewport 的資訊。 文件的 body HTML 標籤 在 HTML 中，你可以在html 檔案中添加標籤來建立網頁的元素。每個標籤通常都有開啟和關閉標籤，例如 <p>hello</p> 表示一段文字。通過在 <html> 標籤對內添加一組 <body> 標籤來建立介面的主體；你的標記現在看起來像這樣：\n任務\n```html\nWelcome to my Virtual Terrarium\n```\n現在，你可以開始建立你的頁面。通常，你會使用 <div> 標籤來建立頁面中的各個元素。我們將建立一系列 <div> 元素，這些元素將包含圖片。\n圖片\n一個不需要關閉標籤的 HTML 標籤是 <img>，因為它有一個 src 屬性，包含頁面渲染該項目所需的所有資訊。\n在你的應用程式中建立一個名為 images 的資料夾，並將 source code folder 中的所有圖片添加到該資料夾中；（共有 14 張植物圖片）。\n任務\n在 <body></body> 標籤之間添加這些植物圖片到兩個欄位中：\n```html\n```\n注意：Spans vs",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 853,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "f39642cd830582fb7770049664d66c18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ 如果你像這樣設置 viewport meta 標籤：<meta name=\"viewport\" content=\"width=600\">，會發生什麼？閱讀更多關於 viewport 的資訊。 文件的 body HTML 標籤 在 HTML 中，你可以在html 檔案中添加標籤來建立網頁的元素。每個標籤通常都有開啟和關閉標籤，例如 <p>hello</p> 表示一段文字。通過在 <html> 標籤對內添加一組 <body> 標籤來建立介面的主體；你的標記現在看起來像這樣： 任務 ```html Welcome to my Virtual Terrarium ``` 現在，你可以開始建立你的頁面。通常，你會使用 <div> 標籤來建立頁面中的各個元素。我們將建立一系列 <div> 元素，這些元素將包含圖片。 圖片 一個不需要關閉標籤的 HTML 標籤是 <img>，因為它有一個 src 屬性，包含頁面渲染該項目所需的所有資訊。 在你的應用程式中建立一個名為 images 的資料夾，並將 source code folder 中的所有圖片添加到該資料夾中；（共有 14 張植物圖片）。 任務 在 <body></body> 標籤之間添加這些植物圖片到兩個欄位中： ```html ``` 注意：Spans vsDivs。Divs 被認為是「區塊」元素，而 Spans 是「內聯」元素。如果你將這些 divs 轉換為 spans，會發生什麼？\n通過這些標記，植物現在會顯示在螢幕上。它看起來很糟糕，因為尚未使用 CSS 進行樣式設計，我們會在下一節課中完成這部分。\n每張圖片都有 alt 文本，即使你無法看到或渲染圖片，alt 文本也會顯示。這是一個重要的屬性，對於無障礙設計非常重要。在未來的課程中，你將學習更多關於無障礙設計的內容；目前請記住，alt 屬性為圖片提供了替代資訊，當使用者因某些原因無法查看圖片時（例如網路連線緩慢、src 屬性錯誤或使用者使用螢幕閱讀器），alt 屬性會派上用場。\n✅ 你是否注意到每張圖片都有相同的 alt 標籤？這是好的做法嗎？為什麼？你能改進這段程式碼嗎？\n語意化標記\n通常，在撰寫 HTML 時，使用有意義的「語意化」標記是更好的選擇。這意味著你使用 HTML 標籤來表示它們設計用於的數據或交互類型。例如，頁面上的主要標題文字應使用 <h1> 標籤。\n在開啟的 <body> 標籤下方添加以下內容：\n```html\nMy Terrarium\n```\n使用語意化標記，例如將標題設為 <h1>，將無序列表渲染為 <ul>，有助於螢幕閱讀器更好地導航頁面。通常，按鈕應寫為 <button>，列表應寫為 <li>。雖然可以使用帶有點擊處理器的特殊樣式 <span> 元素來模仿按鈕，但對於使用輔助技術的使用者來說，確定頁面上的按鈕位置並與之交互會更方便。因此，盡量使用語意化標記。\n✅ 查看螢幕閱讀器 如何與網頁互動。你能理解為什麼非語意化標記可能會讓使用者感到沮喪嗎？\n玻璃花園\n介面的最後一部分涉及建立將被樣式化為玻璃花園的標記。\n任務：\n在最後一個 </div> 標籤上方添加以下標記：\n```html\n```\n✅ 雖然你已將這些標記添加到螢幕上，但你完全看不到任何渲染。為什麼？\n🚀挑戰\nHTML 中有一些有趣的「舊」標籤，雖然不應在標記中使用已棄用的標籤，例如 這些標籤。不過，你能使用舊的 <marquee> 標籤讓 h1 標題水平滾動嗎？（如果你這麼做，記得之後移除它）\n課後測驗\n課後測驗\n回顧與自學\nHTML 是「經久不衰」的建構系統，幫助網路發展成今天的樣子。通過研究一些舊標籤和新標籤，了解它的歷史。你能弄清楚為什麼某些標籤被棄用，而某些標籤被添加嗎？未來可能會引入哪些標籤？\n了解更多關於為網頁和行動裝置建立網站的內容，請參考 Microsoft Learn。\n作業\n練習你的 HTML：建立部落格模型\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11507,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2031,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "f4c6a6d88d9d8209c91f4789f69d4c78",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
    "source_type": "git_repo",
    "title": "更深入了解 DOM",
    "content": "更深入了解 DOM\n指導說明\n透過「採用」一個 DOM 元素來進一步研究 DOM。造訪 MDN 的 DOM 介面列表，選擇一個介面。在網頁上找到它的使用範例，並撰寫一段解釋說明它是如何被使用的。\n評分標準\n| 評分項目 | 優秀                                           | 合格                                             | 需要改進               |\n| -------- | --------------------------------------------- | ------------------------------------------------ | ----------------------- |\n|          | 提供段落式說明，並附有範例                     | 提供段落式說明，但未附範例                       | 未提供任何說明         |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1495,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 396,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "42bcb64b1e3fc3afc3540160c49e20ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動程式設計\n在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！\n事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。\n我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。\n為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）：\nclick：使用者點擊某個元素，通常是按鈕或超連結\ncontextmenu：使用者點擊右鍵\nselect：使用者選取了一些文字\ninput：使用者輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到需要輸入的一段文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識！\n文件結構\n我們需要三個文件：index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1319,
    "chunk_index": 0,
    "total_chunks": 32
  },
  {
    "id": "6aa633d3343f91e2e399f159a97d3004",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動程式設計\n在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！\n事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。\n我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。\n為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）：\nclick：使用者點擊某個元素，通常是按鈕或超連結\ncontextmenu：使用者點擊右鍵\nselect：使用者選取了一些文字\ninput：使用者輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到需要輸入的一段文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識！\n文件結構\n我們需要三個文件：indexhtml、script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1322,
    "chunk_index": 1,
    "total_chunks": 32
  },
  {
    "id": "e49486bc0d18e92772492fafa13fce01",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動程式設計\n在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！\n事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。\n我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。\n為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）：\nclick：使用者點擊某個元素，通常是按鈕或超連結\ncontextmenu：使用者點擊右鍵\nselect：使用者選取了一些文字\ninput：使用者輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到需要輸入的一段文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1325,
    "chunk_index": 2,
    "total_chunks": 32
  },
  {
    "id": "7ae8191d07599d070d42181db38ffeff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動程式設計\n在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！\n事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。\n我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。\n為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）：\nclick：使用者點擊某個元素，通常是按鈕或超連結\ncontextmenu：使用者點擊右鍵\nselect：使用者選取了一些文字\ninput：使用者輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到需要輸入的一段文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。\n打開終端或控制台窗口，創建一個新文件夾，並執行以下命令：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1428,
    "chunk_index": 3,
    "total_chunks": 32
  },
  {
    "id": "b9d8cb900f9dc91b9cbf586df4f5c0d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動程式設計\n在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！\n事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。\n我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。\n為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）：\nclick：使用者點擊某個元素，通常是按鈕或超連結\ncontextmenu：使用者點擊右鍵\nselect：使用者選取了一些文字\ninput：使用者輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到需要輸入的一段文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。\n打開終端或控制台窗口，創建一個新文件夾，並執行以下命令：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode在 Visual Studio Code 中，向文件夾中添加以下三個文件：\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1447,
    "chunk_index": 4,
    "total_chunks": 32
  },
  {
    "id": "9a9461c59db090fa5eb38b371903baa4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "使用事件創建遊戲\n課前測驗\n課前測驗\n事件驅動程式設計\n在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！\n事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。\n我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。\n為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。\nNOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。\n常見事件\n在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）：\nclick：使用者點擊某個元素，通常是按鈕或超連結\ncontextmenu：使用者點擊右鍵\nselect：使用者選取了一些文字\ninput：使用者輸入了一些文字\n創建遊戲\n我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下：\n玩家點擊開始按鈕，並看到需要輸入的一段文字\n玩家在文本框中盡可能快速地輸入這段文字\n每完成一個單詞，下一個單詞會被高亮顯示\n如果玩家輸入錯誤，文本框會變成紅色\n當玩家完成整段文字時，會顯示成功訊息以及所用時間\n讓我們開始構建遊戲，並學習事件的相關知識！\n文件結構\n我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。\n打開終端或控制台窗口，創建一個新文件夾，並執行以下命令：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\n打開 Visual Studio Code\nbash\ncode在 Visual Studio Code 中，向文件夾中添加以下三個文件：\nindexhtml\nscript",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1450,
    "chunk_index": 5,
    "total_chunks": 32
  },
  {
    "id": "49569a0461acc4a55d9203463bdc7a3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "課前測驗 課前測驗 事件驅動程式設計 在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！ 事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。 我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。 為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。 NOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）： click：使用者點擊某個元素，通常是按鈕或超連結 contextmenu：使用者點擊右鍵 select：使用者選取了一些文字 input：使用者輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到需要輸入的一段文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。 打開終端或控制台窗口，創建一個新文件夾，並執行以下命令： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，向文件夾中添加以下三個文件： indexhtml scriptjs\nstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1433,
    "chunk_index": 6,
    "total_chunks": 32
  },
  {
    "id": "a0c9bb40932ca1942869b41697c92f5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "課前測驗 事件驅動程式設計 在創建基於瀏覽器的應用程式時，我們會提供一個圖形使用者介面（GUI），供使用者與我們構建的內容進行互動。使用者與瀏覽器互動的最常見方式是通過點擊和在各種元素中輸入文字。作為開發者，我們面臨的挑戰是無法預測使用者何時會執行這些操作！ 事件驅動程式設計 是我們需要用來創建 GUI 的程式設計類型。如果我們稍微拆解這個詞組，會發現核心詞是 事件。根據 Merriam-Webster 的定義，事件 是指「某些發生的事情」。這完美地描述了我們的情況。我們知道會有某些事情發生，並希望執行一些程式碼來響應，但我們不知道它會在什麼時候發生。 我們標記希望執行的程式碼部分的方法是創建一個函數。在程序式程式設計中，函數會按照特定順序被調用。在事件驅動程式設計中也是如此，不同之處在於函數的調用方式。 為了處理事件（例如按鈕點擊、輸入文字等），我們需要註冊 事件監聽器。事件監聽器是一個函數，用於監聽事件的發生並執行相應的操作。事件監聽器可以更新 UI、向伺服器發送請求，或者執行其他需要響應使用者操作的任務。我們可以使用 addEventListener 並提供一個函數來添加事件監聽器。 NOTE: 值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）： click：使用者點擊某個元素，通常是按鈕或超連結 contextmenu：使用者點擊右鍵 select：使用者選取了一些文字 input：使用者輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到需要輸入的一段文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。 打開終端或控制台窗口，創建一個新文件夾，並執行以下命令： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，向文件夾中添加以下三個文件： indexhtml scriptjs stylecss\n創建使用者介面\n根據需求，我們知道需要在 HTML 頁面上添加一些元素。這有點像食譜，我們需要一些材料：\n顯示玩家需要輸入的文字的地方\n顯示訊息（例如成功訊息）的地方\n用於輸入文字的文本框\n開始按鈕\n每個元素都需要有 ID，以便我們能在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。\n創建一個名為 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1590,
    "chunk_index": 7,
    "total_chunks": 32
  },
  {
    "id": "f2575709ba751057cb59762a7cff6ede",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "值得注意的是，創建事件監聽器有多種方式。你可以使用匿名函數，也可以創建具名函數。你可以使用各種快捷方式，例如設置 click 屬性，或者使用 addEventListener。在我們的練習中，我們將專注於使用 addEventListener 和匿名函數，因為這是網頁開發者最常用的技術之一。它也是最靈活的，因為 addEventListener 適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）： click：使用者點擊某個元素，通常是按鈕或超連結 contextmenu：使用者點擊右鍵 select：使用者選取了一些文字 input：使用者輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到需要輸入的一段文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。 打開終端或控制台窗口，創建一個新文件夾，並執行以下命令： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，向文件夾中添加以下三個文件： indexhtml scriptjs stylecss 創建使用者介面 根據需求，我們知道需要在 HTML 頁面上添加一些元素。這有點像食譜，我們需要一些材料： 顯示玩家需要輸入的文字的地方 顯示訊息（例如成功訊息）的地方 用於輸入文字的文本框 開始按鈕 每個元素都需要有 ID，以便我們能在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML：\n```html\nTyping game\nTyping game",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1015,
    "chunk_index": 8,
    "total_chunks": 32
  },
  {
    "id": "32366af12d53177652dd3938c6da5a8a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "適用於所有事件，並且事件名稱可以作為參數提供。 常見事件 在創建應用程式時，有數十種事件可供監聽。基本上，使用者在頁面上執行的任何操作都會觸發事件，這使得你可以充分利用這些事件來確保使用者獲得理想的體驗。幸運的是，你通常只需要使用少數幾個事件。以下是一些常見的事件（包括我們在創建遊戲時會使用的兩個事件）： click：使用者點擊某個元素，通常是按鈕或超連結 contextmenu：使用者點擊右鍵 select：使用者選取了一些文字 input：使用者輸入了一些文字 創建遊戲 我們將創建一個遊戲來探索 JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到需要輸入的一段文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。 打開終端或控制台窗口，創建一個新文件夾，並執行以下命令： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，向文件夾中添加以下三個文件： indexhtml scriptjs stylecss 創建使用者介面 根據需求，我們知道需要在 HTML 頁面上添加一些元素。這有點像食譜，我們需要一些材料： 顯示玩家需要輸入的文字的地方 顯示訊息（例如成功訊息）的地方 用於輸入文字的文本框 開始按鈕 每個元素都需要有 ID，以便我們能在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock Holmes",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 873,
    "chunk_index": 9,
    "total_chunks": 32
  },
  {
    "id": "a9726a3dd5deb1e1d5863f6ce077ad18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "JavaScript 中事件的工作原理。我們的遊戲將測試玩家的打字技能，這是所有開發者都應該具備的一項非常重要的技能。我們都應該練習打字！遊戲的基本流程如下： 玩家點擊開始按鈕，並看到需要輸入的一段文字 玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。 打開終端或控制台窗口，創建一個新文件夾，並執行以下命令： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，向文件夾中添加以下三個文件： indexhtml scriptjs stylecss 創建使用者介面 根據需求，我們知道需要在 HTML 頁面上添加一些元素。這有點像食譜，我們需要一些材料： 顯示玩家需要輸入的文字的地方 顯示訊息（例如成功訊息）的地方 用於輸入文字的文本框 開始按鈕 每個元素都需要有 ID，以便我們能在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to begin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 10,
    "total_chunks": 32
  },
  {
    "id": "159271f4370f893d0554e7ab9d2dd03a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "玩家在文本框中盡可能快速地輸入這段文字 每完成一個單詞，下一個單詞會被高亮顯示 如果玩家輸入錯誤，文本框會變成紅色 當玩家完成整段文字時，會顯示成功訊息以及所用時間 讓我們開始構建遊戲，並學習事件的相關知識！ 文件結構 我們需要三個文件：indexhtml、scriptjs 和 stylecss。讓我們先設置好這些文件，讓後續工作更輕鬆。 打開終端或控制台窗口，創建一個新文件夾，並執行以下命令： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` 打開 Visual Studio Code bash code在 Visual Studio Code 中，向文件夾中添加以下三個文件： indexhtml scriptjs stylecss 創建使用者介面 根據需求，我們知道需要在 HTML 頁面上添加一些元素。這有點像食譜，我們需要一些材料： 顯示玩家需要輸入的文字的地方 顯示訊息（例如成功訊息）的地方 用於輸入文字的文本框 開始按鈕 每個元素都需要有 ID，以便我們能在 JavaScript 中操作它們。我們還需要添加對 CSS 和 JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart\n```\n啟動應用程式\n最好以迭代方式開發，隨時查看效果。讓我們啟動應用程式。Visual Studio Code 有一個很棒的擴展名叫 Live Server，它可以在本地托管你的應用程式，並在每次保存時刷新瀏覽器。\n安裝 Live Server，點擊連結並選擇 Install\n瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝\n如果有提示，請重新啟動 Visual Studio Code\n安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板\n輸入 Live Server: Open with Live Server\nLive Server 會開始托管你的應用程式\n打開瀏覽器，並導航到 https://localhost:5500\n你現在應該能看到你創建的頁面！\n讓我們添加一些功能。\n添加 CSS\n創建 HTML 後，讓我們添加核心樣式的 CSS。我們需要高亮玩家應輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來完成這些操作。\n創建一個名為 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 883,
    "chunk_index": 11,
    "total_chunks": 32
  },
  {
    "id": "6895caeb116788ac3f2309e2d18150c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "JavaScript 文件的引用。 創建一個名為 indexhtml 的新文件，並添加以下 HTML： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` 啟動應用程式 最好以迭代方式開發，隨時查看效果。讓我們啟動應用程式。Visual Studio Code 有一個很棒的擴展名叫 Live Server，它可以在本地托管你的應用程式，並在每次保存時刷新瀏覽器。 安裝 Live Server，點擊連結並選擇 Install 瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝 如果有提示，請重新啟動 Visual Studio Code 安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始托管你的應用程式 打開瀏覽器，並導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 讓我們添加一些功能。 添加 CSS 創建 HTML 後，讓我們添加核心樣式的 CSS。我們需要高亮玩家應輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來完成這些操作。 創建一個名為 stylecss 的新文件，並添加以下語法。\n```css\n/ inside style css / highlight {\nbackground-color: yellow;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 12,
    "total_chunks": 32
  },
  {
    "id": "09c016aa87f78169f39b3ad5a454041d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` 啟動應用程式 最好以迭代方式開發，隨時查看效果。讓我們啟動應用程式。Visual Studio Code 有一個很棒的擴展名叫 Live Server，它可以在本地托管你的應用程式，並在每次保存時刷新瀏覽器。 安裝 Live Server，點擊連結並選擇 Install 瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝 如果有提示，請重新啟動 Visual Studio Code 安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始托管你的應用程式 打開瀏覽器，並導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 讓我們添加一些功能。 添加 CSS 創建 HTML 後，讓我們添加核心樣式的 CSS。我們需要高亮玩家應輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來完成這些操作。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error {\nbackground-color: lightcoral;\nborder: red;\n}\n```\n✅ 關於 CSS，你可以按照自己的喜好佈局頁面。花點時間讓頁面更吸引人：\n選擇不同的字體\n為標題添加顏色\n調整元素大小\nJavaScript\n創建完使用者介面後，現在是時候專注於提供邏輯的 JavaScript 了。我們將分成幾個步驟：\n創建常數\n開始遊戲的事件監聽器\n輸入文字的事件監聽器\n首先，創建一個名為 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 627,
    "chunk_index": 13,
    "total_chunks": 32
  },
  {
    "id": "49ce74bec6ed0f517ef40983fbf53969",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Install 瀏覽器會提示你打開 Visual Studio Code，然後 Visual Studio Code 會提示你進行安裝 如果有提示，請重新啟動 Visual Studio Code 安裝完成後，在 Visual Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始托管你的應用程式 打開瀏覽器，並導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 讓我們添加一些功能。 添加 CSS 創建 HTML 後，讓我們添加核心樣式的 CSS。我們需要高亮玩家應輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來完成這些操作。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好佈局頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 創建完使用者介面後，現在是時候專注於提供邏輯的 JavaScript 了。我們將分成幾個步驟： 創建常數 開始遊戲的事件監聽器 輸入文字的事件監聽器 首先，創建一個名為 scriptjs 的新文件。\n創建常數\n我們需要一些項目來讓程式設計更輕鬆。類似於食譜，以下是我們需要的內容：\n包含所有文字的陣列\n用於存儲當前文字的所有單詞的空陣列\n用於存儲玩家當前輸入的單詞索引的空間\n玩家點擊開始的時間\n我們還需要引用使用者介面元素：\n文本框（typed-value）\n顯示文字的元素（quote）\n顯示訊息的元素（message）\njavascript\n// inside script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 14,
    "total_chunks": 32
  },
  {
    "id": "2f7de1348b167a2c5370f8870527c255",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Studio Code 中按 Ctrl-Shift-P（或 Cmd-Shift-P）打開命令面板 輸入 Live Server: Open with Live Server Live Server 會開始托管你的應用程式 打開瀏覽器，並導航到 https://localhost:5500 你現在應該能看到你創建的頁面！ 讓我們添加一些功能。 添加 CSS 創建 HTML 後，讓我們添加核心樣式的 CSS。我們需要高亮玩家應輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來完成這些操作。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好佈局頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 創建完使用者介面後，現在是時候專注於提供邏輯的 JavaScript 了。我們將分成幾個步驟： 創建常數 開始遊戲的事件監聽器 輸入文字的事件監聽器 首先，創建一個名為 scriptjs 的新文件。 創建常數 我們需要一些項目來讓程式設計更輕鬆。類似於食譜，以下是我們需要的內容： 包含所有文字的陣列 用於存儲當前文字的所有單詞的空陣列 用於存儲玩家當前輸入的單詞索引的空間 玩家點擊開始的時間 我們還需要引用使用者介面元素： 文本框（typed-value） 顯示文字的元素（quote） 顯示訊息的元素（message） javascript // inside scriptjs\n// all of our quotes\nconst quotes = [\n'When you have eliminated the impossible, whatever remains, however improbable, must be the truth",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 650,
    "chunk_index": 15,
    "total_chunks": 32
  },
  {
    "id": "96000f4f40489c3b89f7835070b1dfeb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "後，讓我們添加核心樣式的 CSS。我們需要高亮玩家應輸入的單詞，並在輸入錯誤時將文本框顯示為紅色。我們將使用兩個類來完成這些操作。 創建一個名為 stylecss 的新文件，並添加以下語法。 ```css / inside style css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好佈局頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 創建完使用者介面後，現在是時候專注於提供邏輯的 JavaScript 了。我們將分成幾個步驟： 創建常數 開始遊戲的事件監聽器 輸入文字的事件監聽器 首先，創建一個名為 scriptjs 的新文件。 創建常數 我們需要一些項目來讓程式設計更輕鬆。類似於食譜，以下是我們需要的內容： 包含所有文字的陣列 用於存儲當前文字的所有單詞的空陣列 用於存儲玩家當前輸入的單詞索引的空間 玩家點擊開始的時間 我們還需要引用使用者介面元素： 文本框（typed-value） 顯示文字的元素（quote） 顯示訊息的元素（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth',\n'There is nothing more deceptive than an obvious fact",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 16,
    "total_chunks": 32
  },
  {
    "id": "a1f91a6692db9cb89129860848106ee7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "css / highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ 關於 CSS，你可以按照自己的喜好佈局頁面。花點時間讓頁面更吸引人： 選擇不同的字體 為標題添加顏色 調整元素大小 JavaScript 創建完使用者介面後，現在是時候專注於提供邏輯的 JavaScript 了。我們將分成幾個步驟： 創建常數 開始遊戲的事件監聽器 輸入文字的事件監聽器 首先，創建一個名為 scriptjs 的新文件。 創建常數 我們需要一些項目來讓程式設計更輕鬆。類似於食譜，以下是我們需要的內容： 包含所有文字的陣列 用於存儲當前文字的所有單詞的空陣列 用於存儲玩家當前輸入的單詞索引的空間 玩家點擊開始的時間 我們還需要引用使用者介面元素： 文本框（typed-value） 顯示文字的元素（quote） 顯示訊息的元素（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth', 'There is nothing more deceptive than an obvious fact',\n'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation ',\n'I never make exceptions An exception disproves the rule ',\n'What one man can invent another can discover ',\n'Nothing clears up a case so much as stating it to another person",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 17,
    "total_chunks": 32
  },
  {
    "id": "28095e19aceee637484a285ceed1aa1a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "the truth', 'There is nothing more deceptive than an obvious fact', 'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation ', 'I never make exceptions An exception disproves the rule ', 'What one man can invent another can discover ', 'Nothing clears up a case so much as stating it to another person',\n'Education never ends, Watson It is a series of lessons, with the greatest for the last ',\n];\n// store the list of words and the index of the word the player is currently typing\nlet words = [];\nlet wordIndex = 0;\n// the starting time\nlet startTime = Date now();\n// page elements\nconst quoteElement = document getElementById('quote');\nconst messageElement = document getElementById('message');\nconst typedValueElement = document getElementById('typed-value');\n✅ 為你的遊戲添加更多文字\nNOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vue",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 271,
    "chunk_index": 18,
    "total_chunks": 32
  },
  {
    "id": "8cf10fa0c38c3031751b0d05bf2d7761",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "ends, Watson It is a series of lessons, with the greatest for the last ', ]; // store the list of words and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。\n花點時間觀看一段關於使用 const、let 和 var 的影片\n🎥 點擊上方圖片觀看關於變數的影片。\n添加開始邏輯\n為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。\n當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。\n```javascript\n// at the end of script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 519,
    "chunk_index": 19,
    "total_chunks": 32
  },
  {
    "id": "27310148b23ff6c43a2d200f055fe4ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。 花點時間觀看一段關於使用 const、let 和 var 的影片 🎥 點擊上方圖片觀看關於變數的影片。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs\ndocument getElementById('start')",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 20,
    "total_chunks": 32
  },
  {
    "id": "49a88b844b051e75b10894f9fa7aa23b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。 花點時間觀看一段關於使用 const、let 和 var 的影片 🎥 點擊上方圖片觀看關於變數的影片。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs document getElementById('start')addEventListener('click', () => {\n// get a quote\nconst quoteIndex = Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 513,
    "chunk_index": 21,
    "total_chunks": 32
  },
  {
    "id": "37ce5d98dcaf1ec888fd742ca4353333",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。 花點時間觀看一段關於使用 const、let 和 var 的影片 🎥 點擊上方圖片觀看關於變數的影片。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs document getElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 503,
    "chunk_index": 22,
    "total_chunks": 32
  },
  {
    "id": "4c36a8a12618aaa1347ecb48a84a5c08",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。 花點時間觀看一段關於使用 const、let 和 var 的影片 🎥 點擊上方圖片觀看關於變數的影片。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs document getElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quotes",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 23,
    "total_chunks": 32
  },
  {
    "id": "c6f6891787683c7a788145ec324220da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。 花點時間觀看一段關於使用 const、let 和 var 的影片 🎥 點擊上方圖片觀看關於變數的影片。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs document getElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength);\nconst quote = quotes[quoteIndex];\n// Put the quote into an array of words\nwords = quote",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 526,
    "chunk_index": 24,
    "total_chunks": 32
  },
  {
    "id": "0ed3f6b74bd3bd09003791c32616f6c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ 為你的遊戲添加更多文字 NOTE: 我們可以在程式碼中隨時使用 document getElementById 獲取元素。由於我們會經常引用這些元素，因此使用常數可以避免字串文字的拼寫錯誤。像 Vuejs 或 React 這樣的框架可以幫助你更好地集中管理程式碼。 花點時間觀看一段關於使用 const、let 和 var 的影片 🎥 點擊上方圖片觀看關於變數的影片。 添加開始邏輯 為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs document getElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' ');\n// reset the word index for tracking\nwordIndex = 0;\n// UI updates\n// Create an array of span elements so we can set a class\nconst spanWords = words",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 546,
    "chunk_index": 25,
    "total_chunks": 32
  },
  {
    "id": "f64167df993b18ecf16f097f9eb180c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "為了開始遊戲，玩家需要點擊開始按鈕。當然，我們不知道他們什麼時候會點擊開始。這就是 事件監聽器 的作用。事件監聽器允許我們監聽某些事情的發生（事件），並執行相應的程式碼。在我們的情況下，我們希望在使用者點擊開始時執行程式碼。 當使用者點擊 開始 時，我們需要選擇一段文字，設置使用者介面，並設置當前單詞和計時的追蹤。以下是需要添加的 JavaScript；我們在程式碼塊後進行討論。 ```javascript // at the end of scriptjs document getElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' '); // reset the word index for tracking wordIndex = 0; // UI updates // Create an array of span elements so we can set a class const spanWords = wordsmap(function(word) { return <span>${word} </span>});\n// Convert into string and set as innerHTML on quote display\nquoteElement innerHTML = spanWords join('');\n// Highlight the first word\nquoteElement childNodes[0] className = 'highlight';\n// Clear any prior messages\nmessageElement innerText = '';\n// Setup the textbox\n// Clear the textbox\ntypedValueElement value = '';\n// set focus\ntypedValueElement focus();\n// set the event handler\n// Start the timer\nstartTime = new Date() getTime();\n});\n```\n讓我們分解程式碼！\n設置單詞追蹤\n使用 Math floor 和 Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 26,
    "total_chunks": 32
  },
  {
    "id": "46942c3bb38b569cb26120a03d5fb482",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "</span>}); // Convert into string and set as innerHTML on quote display quoteElement innerHTML = spanWords join(''); // Highlight the first word quoteElement childNodes[0] className = 'highlight'; // Clear any prior messages messageElement innerText = ''; // Setup the textbox // Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` 讓我們分解程式碼！ 設置單詞追蹤 使用 Math floor 和 Mathrandom 隨機選擇 quotes 陣列中的一段文字\n將 quote 轉換為 words 陣列，以便追蹤玩家當前輸入的單詞\n將 wordIndex 設置為 0，因為玩家將從第一個單詞開始\n設置使用者介面\n創建 spanWords 陣列，其中包含每個單詞的 span 元素\n這將允許我們在顯示中高亮單詞\n使用 join 創建一個字串，並用於更新 quoteElement 的 innerHTML\n這將向玩家顯示文字\n將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色\n通過設置 messageElement 的 innerText 為 '' 清空訊息\n設置文本框\n清空 typedValueElement 的當前 value\n將焦點設置到 typedValueElement\n通過調用 getTime 開始計時\n添加輸入邏輯\n當玩家輸入時，會觸發 input 事件。此事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。回到 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 27,
    "total_chunks": 32
  },
  {
    "id": "b28ffea7202eebf7c28d1da194429e76",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "set the event handler // Start the timer startTime = new Date() getTime(); }); ``` 讓我們分解程式碼！ 設置單詞追蹤 使用 Math floor 和 Mathrandom 隨機選擇 quotes 陣列中的一段文字 將 quote 轉換為 words 陣列，以便追蹤玩家當前輸入的單詞 將 wordIndex 設置為 0，因為玩家將從第一個單詞開始 設置使用者介面 創建 spanWords 陣列，其中包含每個單詞的 span 元素 這將允許我們在顯示中高亮單詞 使用 join 創建一個字串，並用於更新 quoteElement 的 innerHTML 這將向玩家顯示文字 將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色 通過設置 messageElement 的 innerText 為 '' 清空訊息 設置文本框 清空 typedValueElement 的當前 value 將焦點設置到 typedValueElement 通過調用 getTime 開始計時 添加輸入邏輯 當玩家輸入時，會觸發 input 事件。此事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。回到 scriptjs，在末尾添加以下程式碼。我們稍後會進行分解。\n```javascript\n// at the end of script js\ntypedValueElement addEventListener('input', () => {\n// Get the current word\nconst currentWord = words[wordIndex];\n// get the current value\nconst typedValue = typedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 28,
    "total_chunks": 32
  },
  {
    "id": "670847ddc0caabbc3efebd7173a4b2f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "wordIndex 設置為 0，因為玩家將從第一個單詞開始 設置使用者介面 創建 spanWords 陣列，其中包含每個單詞的 span 元素 這將允許我們在顯示中高亮單詞 使用 join 創建一個字串，並用於更新 quoteElement 的 innerHTML 這將向玩家顯示文字 將第一個 span 元素的 className 設置為 highlight，以高亮顯示為黃色 通過設置 messageElement 的 innerText 為 '' 清空訊息 設置文本框 清空 typedValueElement 的當前 value 將焦點設置到 typedValueElement 通過調用 getTime 開始計時 添加輸入邏輯 當玩家輸入時，會觸發 input 事件。此事件監聽器將檢查玩家是否正確輸入單詞，並處理遊戲的當前狀態。回到 scriptjs，在末尾添加以下程式碼。我們稍後會進行分解。 ```javascript // at the end of script js typedValueElement addEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue;\nif (typedValue === currentWord && wordIndex === words length - 1) {\n// end of sentence\n// Display success\nconst elapsedTime = new Date() getTime() - startTime;\nconst message = CONGRATULATIONS You finished in ${elapsedTime / 1000} seconds ;\nmessageElement innerText = message;\n} else if (typedValue endsWith(' ') && typedValue trim() === currentWord) {\n// end of word\n// clear the typedValueElement for the new word\ntypedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 29,
    "total_chunks": 32
  },
  {
    "id": "d0ee1055a7e0bcc518f608c2a58d5cd8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "get the current value const typedValue = typedValueElementvalue; if (typedValue === currentWord && wordIndex === words length - 1) { // end of sentence // Display success const elapsedTime = new Date() getTime() - startTime; const message = CONGRATULATIONS You finished in ${elapsedTime / 1000} seconds ; messageElement innerText = message; } else if (typedValue endsWith(' ') && typedValue trim() === currentWord) { // end of word // clear the typedValueElement for the new word typedValueElementvalue = '';\n// move to the next word\nwordIndex++;\n// reset the class name for all elements in quote\nfor (const wordElement of quoteElement childNodes) {\nwordElement className = '';\n}\n// highlight the new word\nquoteElement childNodes[wordIndex] className = 'highlight';\n} else if (currentWord startsWith(typedValue)) {\n// currently correct\n// highlight the next word\ntypedValueElement className = '';\n} else {\n// error state\ntypedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 213,
    "chunk_index": 30,
    "total_chunks": 32
  },
  {
    "id": "f3745ff77f620b883bad1e026cd09c42",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "word // clear the typedValueElement for the new word typedValueElementvalue = ''; // move to the next word wordIndex++; // reset the class name for all elements in quote for (const wordElement of quoteElement childNodes) { wordElement className = ''; } // highlight the new word quoteElement childNodes[wordIndex] className = 'highlight'; } else if (currentWord startsWith(typedValue)) { // currently correct // highlight the next word typedValueElement className = ''; } else { // error state typedValueElementclassName = 'error';\n}\n});\n```\n讓我們分解程式碼！我們首先獲取當前單詞和玩家目前輸入的值。接著，我們使用瀑布邏輯檢查文字是否完成、單詞是否完成、單詞是否正確，或者（最後）是否有錯誤。\n文字完成，表示 typedValue 等於 currentWord，且 wordIndex 等於 words 的 length 減一\n通過將當前時間減去 startTime 計算 elapsedTime\n將 elapsedTime 除以 1,000，將毫秒轉換為秒\n顯示成功訊息\n單詞完成，表示 typedValue 以空格結尾（單詞結束），且 typedValue 等於 currentWord\n將 typedElement 的 value 設置為 ''，以便輸入下一個單詞\n增加 wordIndex，移動到下一個單詞\n遍歷 quoteElement 的所有 childNodes，將 className 設置為 ''，恢復默認顯示\n將當前單詞的 className 設置為 highlight，以標記為下一個需要輸入的單詞\n單詞目前輸入正確（但未完成），表示 currentWord 以 typedValue 開頭\n通過清空 className 確保 typedValueElement 顯示為默認狀態\n如果到這裡，表示有錯誤\n將 typedValueElement 的 className 設置為 error\n測試你的應用程式\n你已經完成了！最後一步是確保應用程式正常運作。試試看吧！如果有錯誤，不要擔心；所有開發者都會遇到錯誤。檢查訊息並進行調試。\n點擊 開始，然後開始輸入！它應該看起來像我們之前看到的動畫。\n🚀 挑戰\n添加更多功能\n在完成後禁用 input 事件監聽器，並在按鈕被點擊時重新啟用\n在玩家完成文字後禁用文本框\n顯示一個模態對話框，包含成功訊息\n使用 localStorage 儲存高分紀錄\n課後測驗\n課後測驗\n回顧與自學\n閱讀 所有可用的事件，了解網頁瀏覽器提供給開發者的選項，並思考在什麼情境下會使用每個事件。\n作業\n創建一個新的鍵盤遊戲\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17100,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1072,
    "chunk_index": 31,
    "total_chunks": 32
  },
  {
    "id": "4f760abbd4829021d1b6c96d9a441a8e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\solution\\README.md",
    "source_type": "git_repo",
    "title": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的專案 🌵🌱",
    "content": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的專案 🌵🌱\n一個小型的拖放式程式冥想。只需使用一些 HTML、JS 和 CSS，你就可以建立一個網頁介面，設計它，並添加互動功能。\n致謝\n由 Jen Looper 用 ♥️ 編寫。\n透過 CSS 創建的微型植物園靈感來自 Jakub Mandra 的玻璃罐 codepen。\n藝術作品由 Jen Looper 使用 Procreate 手繪完成。\n部署你的微型植物園\n你可以使用 Azure 靜態網頁應用程式將你的微型植物園部署或發布到網路上。\nFork 此倉庫\n按下這個按鈕\n按照向導步驟建立你的應用程式。請確保將應用程式根目錄設置為 /solution 或你的程式碼庫的根目錄。此應用程式中沒有 API，因此不需要擔心添加它。一個",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2037,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 349,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "7cbfc2b34b517980859a60ba0aff63f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\solution\\README.md",
    "source_type": "git_repo",
    "title": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的專案 🌵🌱",
    "content": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的專案 🌵🌱\n一個小型的拖放式程式冥想。只需使用一些 HTML、JS 和 CSS，你就可以建立一個網頁介面，設計它，並添加互動功能。\n致謝\n由 Jen Looper 用 ♥️ 編寫。\n透過 CSS 創建的微型植物園靈感來自 Jakub Mandra 的玻璃罐 codepen。\n藝術作品由 Jen Looper 使用 Procreate 手繪完成。\n部署你的微型植物園\n你可以使用 Azure 靜態網頁應用程式將你的微型植物園部署或發布到網路上。\nFork 此倉庫\n按下這個按鈕\n按照向導步驟建立你的應用程式。請確保將應用程式根目錄設置為 /solution 或你的程式碼庫的根目錄。此應用程式中沒有 API，因此不需要擔心添加它。一個github 資料夾將會在你 Fork 的倉庫中建立，這將幫助 Azure 靜態網頁應用程式的建置服務建置並發布你的應用程式到一個新的 URL。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2037,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "2f642e40eea2956391de68e84232c3e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\assignment.md",
    "source_type": "git_repo",
    "title": "資料類型練習",
    "content": "資料類型練習\n說明\n假設你正在建立一個購物車系統。撰寫一些關於完成購物體驗所需資料類型的文件。說明你是如何選擇這些資料類型的。\n評分標準\n標準 | 優秀 | 合格 | 需要改進\n--- | --- | --- | --- |\n||列出並詳細探討六種資料類型，並記錄它們的用途|探討四種資料類型|探討兩種資料類型|\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1081,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 384,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "719b2c4e786d783c279c800c582e1b9e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Terrarium Project Part 2: CSS 簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓你的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性，還能讓它更具吸引力；此外，CSS 還能用來創建響應式網頁設計（Responsive Web Design，RWD），使你的應用程式在不同螢幕尺寸下都能保持良好的外觀。CSS 不僅僅是讓應用程式看起來漂亮，它的規範還包括動畫和變形功能，能為應用程式提供更複雜的互動效果。CSS 工作小組負責維護最新的 CSS 規範，你可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 415,
    "chunk_index": 0,
    "total_chunks": 22
  },
  {
    "id": "71b8c2c545b660abdd8d4cb6e9724449",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Terrarium Project Part 2: CSS 簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓你的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性，還能讓它更具吸引力；此外，CSS 還能用來創建響應式網頁設計（Responsive Web Design，RWD），使你的應用程式在不同螢幕尺寸下都能保持良好的外觀。CSS 不僅僅是讓應用程式看起來漂亮，它的規範還包括動畫和變形功能，能為應用程式提供更複雜的互動效果。CSS 工作小組負責維護最新的 CSS 規範，你可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUsecom 檢查你的實現。\n在本課程中，我們將為線上植物箱添加樣式，並深入了解 CSS 的幾個概念：層疊、繼承，以及選擇器的使用、定位和利用 CSS 建立佈局。在此過程中，我們將設計植物箱的佈局並創建實際的植物箱。\n先決條件\n你應該已經完成植物箱的 HTML 建立，並準備好進行樣式設計。\n查看影片\n任務\n在你的植物箱資料夾中，建立一個名為 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 1,
    "total_chunks": 22
  },
  {
    "id": "d758f24629dc2eba410ec6150ac57100",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Terrarium Project Part 2: CSS 簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓你的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性，還能讓它更具吸引力；此外，CSS 還能用來創建響應式網頁設計（Responsive Web Design，RWD），使你的應用程式在不同螢幕尺寸下都能保持良好的外觀。CSS 不僅僅是讓應用程式看起來漂亮，它的規範還包括動畫和變形功能，能為應用程式提供更複雜的互動效果。CSS 工作小組負責維護最新的 CSS 規範，你可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUsecom 檢查你的實現。\n在本課程中，我們將為線上植物箱添加樣式，並深入了解 CSS 的幾個概念：層疊、繼承，以及選擇器的使用、定位和利用 CSS 建立佈局。在此過程中，我們將設計植物箱的佈局並創建實際的植物箱。\n先決條件\n你應該已經完成植物箱的 HTML 建立，並準備好進行樣式設計。\n查看影片\n任務\n在你的植物箱資料夾中，建立一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 區段中：\nhtml\n<link rel=\"stylesheet\" href=\"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 673,
    "chunk_index": 2,
    "total_chunks": 22
  },
  {
    "id": "e753f3e967d55810b30e88b48ada00f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Terrarium Project Part 2: CSS 簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓你的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性，還能讓它更具吸引力；此外，CSS 還能用來創建響應式網頁設計（Responsive Web Design，RWD），使你的應用程式在不同螢幕尺寸下都能保持良好的外觀。CSS 不僅僅是讓應用程式看起來漂亮，它的規範還包括動畫和變形功能，能為應用程式提供更複雜的互動效果。CSS 工作小組負責維護最新的 CSS 規範，你可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUsecom 檢查你的實現。\n在本課程中，我們將為線上植物箱添加樣式，並深入了解 CSS 的幾個概念：層疊、繼承，以及選擇器的使用、定位和利用 CSS 建立佈局。在此過程中，我們將設計植物箱的佈局並創建實際的植物箱。\n先決條件\n你應該已經完成植物箱的 HTML 建立，並準備好進行樣式設計。\n查看影片\n任務\n在你的植物箱資料夾中，建立一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 區段中：\nhtml\n<link rel=\"stylesheet\" href=\"/style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 674,
    "chunk_index": 3,
    "total_chunks": 22
  },
  {
    "id": "c48af2cab7165126f8566b69b19fd2a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Terrarium Project Part 2: CSS 簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓你的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性，還能讓它更具吸引力；此外，CSS 還能用來創建響應式網頁設計（Responsive Web Design，RWD），使你的應用程式在不同螢幕尺寸下都能保持良好的外觀。CSS 不僅僅是讓應用程式看起來漂亮，它的規範還包括動畫和變形功能，能為應用程式提供更複雜的互動效果。CSS 工作小組負責維護最新的 CSS 規範，你可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUsecom 檢查你的實現。\n在本課程中，我們將為線上植物箱添加樣式，並深入了解 CSS 的幾個概念：層疊、繼承，以及選擇器的使用、定位和利用 CSS 建立佈局。在此過程中，我們將設計植物箱的佈局並創建實際的植物箱。\n先決條件\n你應該已經完成植物箱的 HTML 建立，並準備好進行樣式設計。\n查看影片\n任務\n在你的植物箱資料夾中，建立一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 區段中：\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\n層疊\n層疊樣式表的核心概念是樣式的「層疊」，即樣式的應用是根據其優先級來決定的。由網站作者設定的樣式優先於瀏覽器設定的樣式。內嵌樣式的優先級高於外部樣式表中的樣式。\n任務\n在你的 <h1> 標籤中添加內嵌樣式 \"color: red\"：\n```HTML\nMy Terrarium\n```\n接著，將以下程式碼添加到你的 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 871,
    "chunk_index": 4,
    "total_chunks": 22
  },
  {
    "id": "c6da3b034f8c1d963b43ac2854884332",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Terrarium Project Part 2: CSS 簡介\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\nCSS，全名為層疊樣式表（Cascading Style Sheets），解決了網頁開發中的一個重要問題：如何讓你的網站看起來更美觀。為應用程式設計樣式不僅能提升其可用性，還能讓它更具吸引力；此外，CSS 還能用來創建響應式網頁設計（Responsive Web Design，RWD），使你的應用程式在不同螢幕尺寸下都能保持良好的外觀。CSS 不僅僅是讓應用程式看起來漂亮，它的規範還包括動畫和變形功能，能為應用程式提供更複雜的互動效果。CSS 工作小組負責維護最新的 CSS 規範，你可以在 World Wide Web Consortium 的網站上關注他們的工作。\n注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUsecom 檢查你的實現。\n在本課程中，我們將為線上植物箱添加樣式，並深入了解 CSS 的幾個概念：層疊、繼承，以及選擇器的使用、定位和利用 CSS 建立佈局。在此過程中，我們將設計植物箱的佈局並創建實際的植物箱。\n先決條件\n你應該已經完成植物箱的 HTML 建立，並準備好進行樣式設計。\n查看影片\n任務\n在你的植物箱資料夾中，建立一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 區段中：\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\n層疊\n層疊樣式表的核心概念是樣式的「層疊」，即樣式的應用是根據其優先級來決定的。由網站作者設定的樣式優先於瀏覽器設定的樣式。內嵌樣式的優先級高於外部樣式表中的樣式。\n任務\n在你的 <h1> 標籤中添加內嵌樣式 \"color: red\"：\n```HTML\nMy Terrarium\n```\n接著，將以下程式碼添加到你的 stylecss 檔案中：\nCSS\nh1 {\ncolor: blue;\n}\n✅ 你的網頁應用程式中顯示了哪種顏色？為什麼？你能找到覆蓋樣式的方法嗎？什麼情況下你會想要這樣做，或者不想這樣做？\n繼承\n樣式可以從祖先元素繼承到後代元素，嵌套的元素會繼承其父元素的樣式。\n任務\n將 body 的字型設置為指定字型，並檢查嵌套元素的字型：\nCSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\n打開瀏覽器的控制台，進入「Elements」標籤，觀察 H1 的字型。它繼承了 body 的字型，瀏覽器中會顯示這一點：\n✅ 你能讓嵌套樣式繼承不同的屬性嗎？\nCSS 選擇器\n標籤\n目前，你的 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1210,
    "chunk_index": 5,
    "total_chunks": 22
  },
  {
    "id": "010a077ef399febdb0ab26d312ec0280",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Consortium 的網站上關注他們的工作。 注意，CSS 是一種不斷演進的語言，就像網路上的所有事物一樣，並非所有瀏覽器都支援最新的規範。請務必透過 CanIUsecom 檢查你的實現。 在本課程中，我們將為線上植物箱添加樣式，並深入了解 CSS 的幾個概念：層疊、繼承，以及選擇器的使用、定位和利用 CSS 建立佈局。在此過程中，我們將設計植物箱的佈局並創建實際的植物箱。 先決條件 你應該已經完成植物箱的 HTML 建立，並準備好進行樣式設計。 查看影片 任務 在你的植物箱資料夾中，建立一個名為 stylecss 的新檔案。將該檔案匯入到 <head> 區段中： html <link rel=\"stylesheet\" href=\"/stylecss\" /> 層疊 層疊樣式表的核心概念是樣式的「層疊」，即樣式的應用是根據其優先級來決定的。由網站作者設定的樣式優先於瀏覽器設定的樣式。內嵌樣式的優先級高於外部樣式表中的樣式。 任務 在你的 <h1> 標籤中添加內嵌樣式 \"color: red\"： ```HTML My Terrarium ``` 接著，將以下程式碼添加到你的 stylecss 檔案中： CSS h1 { color: blue; } ✅ 你的網頁應用程式中顯示了哪種顏色？為什麼？你能找到覆蓋樣式的方法嗎？什麼情況下你會想要這樣做，或者不想這樣做？ 繼承 樣式可以從祖先元素繼承到後代元素，嵌套的元素會繼承其父元素的樣式。 任務 將 body 的字型設置為指定字型，並檢查嵌套元素的字型： CSS body { font-family: helvetica, arial, sans-serif; } 打開瀏覽器的控制台，進入「Elements」標籤，觀察 H1 的字型。它繼承了 body 的字型，瀏覽器中會顯示這一點： ✅ 你能讓嵌套樣式繼承不同的屬性嗎？ CSS 選擇器 標籤 目前，你的 stylecss 檔案只設置了少量標籤樣式，應用程式看起來有些奇怪：\n```CSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nh1 {\ncolor: #3a241d;\ntext-align: center;\n}\n```\n這種設置標籤樣式的方法能讓你控制獨特的元素，但你需要控制植物箱中許多植物的樣式。為此，你需要利用 CSS 選擇器。\nIds\n為左側和右側容器添加一些樣式。由於標記中只有一個左側容器和一個右側容器，因此它們被賦予了 id。要設置它們的樣式，使用 #：\n```CSS\nleft-container {\nbackground-color: #eee;\nwidth: 15%;\nleft: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\nright-container {\nbackground-color: #eee;\nwidth: 15%;\nright: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\n```\n在這裡，你使用了絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們能適應小型行動裝置螢幕。\n✅ 這段程式碼重複性很高，因此不符合「DRY」（Don't Repeat Yourself）的原則；你能找到更好的方法來設置這些 id 的樣式嗎？或許可以使用 id 和 class 的組合？你需要修改標記並重構 CSS：\n```html\n```\nClasses\n在上述範例中，你設置了螢幕上的兩個獨特元素的樣式。如果你希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。\n注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供稍後添加的 JavaScript 使用，用於操作植物箱中的植物位置。而 class 則為所有植物提供統一的樣式。\n```html\n```\n將以下程式碼添加到你的 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1586,
    "chunk_index": 6,
    "total_chunks": 22
  },
  {
    "id": "74297a7c140e6be014b05029a8f41e72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "CSS 選擇器。 Ids 為左側和右側容器添加一些樣式。由於標記中只有一個左側容器和一個右側容器，因此它們被賦予了 id。要設置它們的樣式，使用 #： ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` 在這裡，你使用了絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們能適應小型行動裝置螢幕。 ✅ 這段程式碼重複性很高，因此不符合「DRY」（Don't Repeat Yourself）的原則；你能找到更好的方法來設置這些 id 的樣式嗎？或許可以使用 id 和 class 的組合？你需要修改標記並重構 CSS： ```html ``` Classes 在上述範例中，你設置了螢幕上的兩個獨特元素的樣式。如果你希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。 注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供稍後添加的 JavaScript 使用，用於操作植物箱中的植物位置。而 class 則為所有植物提供統一的樣式。 ```html ``` 將以下程式碼添加到你的 stylecss 檔案中：\n```CSS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 567,
    "chunk_index": 7,
    "total_chunks": 22
  },
  {
    "id": "c5fac1cc4a1fa7109009784bfd9694ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "Ids 為左側和右側容器添加一些樣式。由於標記中只有一個左側容器和一個右側容器，因此它們被賦予了 id。要設置它們的樣式，使用 #： ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` 在這裡，你使用了絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們能適應小型行動裝置螢幕。 ✅ 這段程式碼重複性很高，因此不符合「DRY」（Don't Repeat Yourself）的原則；你能找到更好的方法來設置這些 id 的樣式嗎？或許可以使用 id 和 class 的組合？你需要修改標記並重構 CSS： ```html ``` Classes 在上述範例中，你設置了螢幕上的兩個獨特元素的樣式。如果你希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。 注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供稍後添加的 JavaScript 使用，用於操作植物箱中的植物位置。而 class 則為所有植物提供統一的樣式。 ```html ``` 將以下程式碼添加到你的 stylecss 檔案中： ```CSSplant-holder {\nposition: relative;\nheight: 13%;\nleft: -10px;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 8,
    "total_chunks": 22
  },
  {
    "id": "177d0a10277e800c423aa5e053608795",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "#eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` 在這裡，你使用了絕對定位將這些容器放置在螢幕的最左側和最右側，並使用百分比設置它們的寬度，以便它們能適應小型行動裝置螢幕。 ✅ 這段程式碼重複性很高，因此不符合「DRY」（Don't Repeat Yourself）的原則；你能找到更好的方法來設置這些 id 的樣式嗎？或許可以使用 id 和 class 的組合？你需要修改標記並重構 CSS： ```html ``` Classes 在上述範例中，你設置了螢幕上的兩個獨特元素的樣式。如果你希望樣式應用於螢幕上的多個元素，可以使用 CSS 類別。為左側和右側容器中的植物設置樣式。 注意，HTML 標記中的每個植物都有 id 和 class 的組合。這裡的 id 是供稍後添加的 JavaScript 使用，用於操作植物箱中的植物位置。而 class 則為所有植物提供統一的樣式。 ```html ``` 將以下程式碼添加到你的 stylecss 檔案中： ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant {\nposition: absolute;\nmax-width: 150%;\nmax-height: 150%;\nz-index: 2;\n}\n```\n此程式碼中值得注意的是相對定位和絕對定位的混合使用，我們會在下一節中詳細介紹。請注意高度是如何以百分比處理的：\n你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。\n你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。\n接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。\n另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。\n✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？\nCSS 定位\n混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。\n絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。\n相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。\n在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。\nplant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。\n✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？\nCSS 佈局\n現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！\n首先，使用 CSS 將",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1313,
    "chunk_index": 9,
    "total_chunks": 22
  },
  {
    "id": "06a8d569644237ea71bd361497fabf30",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "class 的組合。這裡的 id 是供稍後添加的 JavaScript 使用，用於操作植物箱中的植物位置。而 class 則為所有植物提供統一的樣式。 ```html ``` 將以下程式碼添加到你的 stylecss 檔案中： ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼中值得注意的是相對定位和絕對定位的混合使用，我們會在下一節中詳細介紹。請注意高度是如何以百分比處理的： 你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。 你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。 接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形：\n```CSS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 959,
    "chunk_index": 10,
    "total_chunks": 22
  },
  {
    "id": "54aae2ab91dc31dc2b79f39b7a95886d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "是供稍後添加的 JavaScript 使用，用於操作植物箱中的植物位置。而 class 則為所有植物提供統一的樣式。 ```html ``` 將以下程式碼添加到你的 stylecss 檔案中： ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼中值得注意的是相對定位和絕對定位的混合使用，我們會在下一節中詳細介紹。請注意高度是如何以百分比處理的： 你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。 你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。 接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls {\nheight: 80%;\nwidth: 60%;\nbackground: #d1e1df;\nborder-radius: 1rem;\nposition: absolute;\nbottom: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 985,
    "chunk_index": 11,
    "total_chunks": 22
  },
  {
    "id": "11d40dd8fce853c4f6fd820177cb0e6d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼中值得注意的是相對定位和絕對定位的混合使用，我們會在下一節中詳細介紹。請注意高度是如何以百分比處理的： 你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。 你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。 接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 916,
    "chunk_index": 12,
    "total_chunks": 22
  },
  {
    "id": "582b12c803ee880e50385d48c5e804d4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "-10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼中值得注意的是相對定位和絕對定位的混合使用，我們會在下一節中詳細介紹。請注意高度是如何以百分比處理的： 你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。 你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。 接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05;\nz-index: 1;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 915,
    "chunk_index": 13,
    "total_chunks": 22
  },
  {
    "id": "baf9d970f87d62ac3800656281b22b53",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` 此程式碼中值得注意的是相對定位和絕對定位的混合使用，我們會在下一節中詳細介紹。請注意高度是如何以百分比處理的： 你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。 你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。 接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top {\nwidth: 50%;\nheight: 5%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 80",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 938,
    "chunk_index": 14,
    "total_chunks": 22
  },
  {
    "id": "5b2632da07915c9f40624ee8615f5b1a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "你將植物容器的高度設置為 13%，這是一個不錯的數值，能確保所有植物都能顯示在每個垂直容器中，而不需要滾動。 你將植物容器向左移動，使植物在容器中更居中。圖片有大量透明背景，這樣可以使它們更容易拖動，因此需要向左移動以更好地適應螢幕。 接著，植物本身的最大寬度設置為 150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%;\nleft: 25%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 855,
    "chunk_index": 15,
    "total_chunks": 22
  },
  {
    "id": "5d67ea187beb63386701d40cb5feaed3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "150%。這使得它能隨著瀏覽器縮小而縮小。嘗試調整瀏覽器大小，植物會保持在容器中，但會縮小以適應。 另一個值得注意的是 z-index 的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07;\nz-index: 1;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 16,
    "total_chunks": 22
  },
  {
    "id": "0932b6a7c1f51529ca0a57267f288abd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "的使用，它控制元素的相對高度（使植物位於容器之上，看起來像是放在植物箱內）。 ✅ 為什麼需要同時使用植物容器和植物的 CSS 選擇器？ CSS 定位 混合使用定位屬性（包括 static、relative、fixed、absolute 和 sticky）可能有些棘手，但如果使用得當，能很好地控制頁面上的元素。 絕對定位的元素是相對於最近的定位祖先進行定位的，如果沒有定位祖先，則相對於文件的 body 進行定位。 相對定位的元素是根據 CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom {\nwidth: 50%;\nheight: 1%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 0%;\nleft: 25%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 642,
    "chunk_index": 17,
    "total_chunks": 22
  },
  {
    "id": "98808c36cbdb2f5f7b2b6a8cdb92adf7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "CSS 的指示，從其初始位置進行偏移。 在我們的範例中，plant-holder 是一個相對定位的元素，位於一個絕對定位的容器內。其結果是側邊欄容器固定在左側和右側，而 plant-holder 則嵌套在側邊欄內，調整自身位置以在側邊欄內垂直排列植物。 plant 本身也使用了絕對定位，這是使其可拖動的必要條件，你會在下一課中了解更多。 ✅ 嘗試切換側邊容器和 plant-holder 的定位類型。會發生什麼？ CSS 佈局 現在你將使用所學的內容，完全使用 CSS 建立植物箱本身！ 首先，使用 CSS 將terrarium div 的子元素設置為圓角矩形： ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07;\n} dirt {\nwidth: 60%;\nheight: 5%;\nbackground: #3a241d;\nposition: absolute;\nborder-radius: 0 0 1rem 1rem;\nbottom: 1%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 18,
    "total_chunks": 22
  },
  {
    "id": "6b46e1a5a20cbbe4010e9a7f79fcf24c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; } dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07;\nz-index: -1;\n}\n```\n注意此處使用了百分比。如果縮小瀏覽器，你可以看到植物箱也會縮小。還請注意植物箱元素的寬度和高度百分比，以及每個元素如何絕對定位在中心，並固定在視窗底部。\n我們還使用了 rem 作為邊框半徑的單位，這是一種相對於字型大小的長度。可以在 CSS 規範 中了解更多關於這種相對測量的方法。\n✅ 嘗試更改植物箱的顏色和透明度與泥土的顏色和透明度。會發生什麼？為什麼？\n🚀挑戰\n在植物箱的左下角添加一個「氣泡」光澤，使其看起來更像玻璃。你將設置",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 19,
    "total_chunks": 22
  },
  {
    "id": "53ea316e4ea2329ebe7976932b80d74c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; } dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07; z-index: -1; } ``` 注意此處使用了百分比。如果縮小瀏覽器，你可以看到植物箱也會縮小。還請注意植物箱元素的寬度和高度百分比，以及每個元素如何絕對定位在中心，並固定在視窗底部。 我們還使用了 rem 作為邊框半徑的單位，這是一種相對於字型大小的長度。可以在 CSS 規範 中了解更多關於這種相對測量的方法。 ✅ 嘗試更改植物箱的顏色和透明度與泥土的顏色和透明度。會發生什麼？為什麼？ 🚀挑戰 在植物箱的左下角添加一個「氣泡」光澤，使其看起來更像玻璃。你將設置jar-glossy-long 和",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 456,
    "chunk_index": 20,
    "total_chunks": 22
  },
  {
    "id": "0cdc2e23eae69f54bdeda2a83561b3c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Terrarium Project Part 2: CSS 簡介",
    "content": "opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; } dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07; z-index: -1; } ``` 注意此處使用了百分比。如果縮小瀏覽器，你可以看到植物箱也會縮小。還請注意植物箱元素的寬度和高度百分比，以及每個元素如何絕對定位在中心，並固定在視窗底部。 我們還使用了 rem 作為邊框半徑的單位，這是一種相對於字型大小的長度。可以在 CSS 規範 中了解更多關於這種相對測量的方法。 ✅ 嘗試更改植物箱的顏色和透明度與泥土的顏色和透明度。會發生什麼？為什麼？ 🚀挑戰 在植物箱的左下角添加一個「氣泡」光澤，使其看起來更像玻璃。你將設置jar-glossy-long 和jar-glossy-short 的樣式，使其看起來像反射的光澤。完成後效果如下：\n要完成課後測驗，請參考以下 Learn 模組：使用 CSS 為 HTML 應用程式設計樣式\n課後測驗\n課後測驗\n回顧與自學\nCSS 看似簡單，但要為所有瀏覽器和螢幕尺寸完美設計應用程式樣式卻充滿挑戰。CSS-Grid 和 Flexbox 是為了讓這項工作更結構化、更可靠而開發的工具。透過遊玩 Flexbox Froggy 和 Grid Garden 來學習這些工具。\n作業\nCSS 重構\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對於因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 873,
    "chunk_index": 21,
    "total_chunks": 22
  },
  {
    "id": "3f3beaee370be23a086989e93f755b8c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\assignment.md",
    "source_type": "git_repo",
    "title": "玩轉函式",
    "content": "玩轉函式\n說明\n創建不同的函式，包括會返回值的函式和不會返回值的函式。\n試著創建一個同時包含普通參數和帶有預設值參數的函式。\n評分標準\n| 評分標準 | 優秀                                                                                     | 合格                                                         | 需要改進         |\n| -------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------ | ---------------- |\n|          | 提供的解決方案包含兩個或以上運行良好的函式，且參數多樣化                                 | 提供的解決方案包含一個函式，且參數較少                       | 解決方案有錯誤  |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1504,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 395,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "d4cd92a1cf4afe6c04e3a246f39f27a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "JavaScript 基礎：資料型別\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n本課程涵蓋 JavaScript 的基礎知識，這是一種為網頁提供互動性的語言。\n你可以在 Microsoft Learn 上學習本課程！\n🎥 點擊上方圖片觀看有關變數和資料型別的影片\n讓我們從變數和填充它們的資料型別開始吧！\n變數\n變數用來儲存值，這些值可以在程式碼中使用並更改。\n建立和宣告變數的語法為 [關鍵字] [名稱]，由以下兩部分組成：\n關鍵字。關鍵字可以是 let 或 var。\n✅ 關鍵字 let 是在 ES6 中引入的，為變數提供所謂的 區塊作用域。建議使用 let 而非 var。我們將在後續部分更深入地討論區塊作用域。\n- 變數名稱，這是你自己選擇的名稱。\n任務 - 操作變數\n宣告變數。讓我們使用 let 關鍵字宣告一個變數：\njavascript\nlet myVariable;\n現在 myVariable 已使用 let 關鍵字宣告，但目前尚未賦值。\n賦值。使用 = 運算符將值儲存到變數中，後面接著期望的值。\njavascript\nmyVariable = 123;\n注意：在本課程中，= 的使用表示我們使用的是「賦值運算符」，用於將值設定給變數。它並不表示等於。\n現在 myVariable 已被初始化為值 123。\n重構。將你的程式碼替換為以下語句。\njavascript\nlet myVariable = 123;\n上述操作稱為 顯式初始化，即在宣告變數的同時賦值。\n更改變數值。以下列方式更改變數值：\njavascript\nmyVariable = 321;\n一旦變數被宣告，你可以在程式碼中的任何時候使用 = 運算符和新值來更改其值。\n✅ 試試看！你可以直接在瀏覽器中撰寫 JavaScript。打開瀏覽器並進入開發者工具。在主控台中，你會看到一個提示符；輸入 let myVariable = 123，按下回車，然後輸入 myVariable。會發生什麼？注意，你將在後續課程中學到更多相關概念。\n常數\n常數的宣告和初始化與變數的概念相同，但使用 const 關鍵字。常數通常以全大寫字母宣告。\njavascript\nconst MY_VARIABLE = 123;\n常數與變數相似，但有兩個例外：\n必須有值。常數必須初始化，否則執行程式碼時會出錯。\n參考無法更改。常數的參考一旦初始化後無法更改，否則執行程式碼時會出錯。我們來看兩個例子：\n簡單值。以下是不允許的：\njavascript\nconst PI = 3;\nPI = 4; // not allowed\n物件參考受保護。以下是不允許的：\njavascript\nconst obj = { a: 3 };\nobj = { b: 5 } // not allowed\n物件值未受保護。以下是允許的：\njavascript\nconst obj = { a: 3 };\nobj",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1116,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "f8b100547ab5f7e62c509a32773b7257",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "重構。將你的程式碼替換為以下語句。 javascript let myVariable = 123; 上述操作稱為 顯式初始化，即在宣告變數的同時賦值。 更改變數值。以下列方式更改變數值： javascript myVariable = 321; 一旦變數被宣告，你可以在程式碼中的任何時候使用 = 運算符和新值來更改其值。 ✅ 試試看！你可以直接在瀏覽器中撰寫 JavaScript。打開瀏覽器並進入開發者工具。在主控台中，你會看到一個提示符；輸入 let myVariable = 123，按下回車，然後輸入 myVariable。會發生什麼？注意，你將在後續課程中學到更多相關概念。 常數 常數的宣告和初始化與變數的概念相同，但使用 const 關鍵字。常數通常以全大寫字母宣告。 javascript const MY_VARIABLE = 123; 常數與變數相似，但有兩個例外： 必須有值。常數必須初始化，否則執行程式碼時會出錯。 參考無法更改。常數的參考一旦初始化後無法更改，否則執行程式碼時會出錯。我們來看兩個例子： 簡單值。以下是不允許的： javascript const PI = 3; PI = 4; // not allowed 物件參考受保護。以下是不允許的： javascript const obj = { a: 3 }; obj = { b: 5 } // not allowed 物件值未受保護。以下是允許的： javascript const obj = { a: 3 }; obja = 5;  // allowed\n上述範例中，你更改了物件的值，但未更改其參考本身，因此是允許的。\n注意，const 表示參考受到重新賦值的保護。然而，值並非 不可變，尤其是當它是像物件這樣的複雜結構時，值仍然可以更改。\n資料型別\n變數可以儲存多種不同類型的值，例如數字和文字。這些不同類型的值被稱為 資料型別。資料型別是軟體開發中的重要部分，因為它幫助開發者決定程式碼應如何撰寫以及軟體應如何運行。此外，一些資料型別具有獨特的功能，可以幫助轉換或提取值中的額外資訊。\n✅ 資料型別也被稱為 JavaScript 的資料原始型別，因為它們是語言提供的最低層級資料型別。共有 7 種原始型別：string、number、bigint、boolean、undefined、null 和 symbol。花點時間想像這些原始型別各自代表什麼。例如，zebra 是什麼？0 呢？true 呢？\n數字\n在前一部分中，myVariable 的值是一個數字型別。\nlet myVariable = 123;\n變數可以儲存所有類型的數字，包括小數或負數。數字還可以與算術運算符一起使用，這部分內容會在下一節中介紹。\n算術運算符\n在執行算術運算時，有幾種類型的運算符可供使用，以下列出了一些：\n| 符號  | 描述                                   | 範例                              |\n| ------ | -------------------------------------- | --------------------------------- |\n| +    | 加法：計算兩個數字的總和          | 1 + 2 //預期答案是 3            |\n| -    | 減法：計算兩個數字的差            | 1 - 2 //預期答案是 -1           |\n| *    | 乘法：計算兩個數字的乘積          | 1 * 2 //預期答案是 2            |\n| /    | 除法：計算兩個數字的商            | 1 / 2 //預期答案是 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1292,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "a0a7b0c239c0db5dee29fa51e0f17eff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "JavaScript 的資料原始型別，因為它們是語言提供的最低層級資料型別。共有 7 種原始型別：string、number、bigint、boolean、undefined、null 和 symbol。花點時間想像這些原始型別各自代表什麼。例如，zebra 是什麼？0 呢？true 呢？ 數字 在前一部分中，myVariable 的值是一個數字型別。 let myVariable = 123; 變數可以儲存所有類型的數字，包括小數或負數。數字還可以與算術運算符一起使用，這部分內容會在下一節中介紹。 算術運算符 在執行算術運算時，有幾種類型的運算符可供使用，以下列出了一些： | 符號 | 描述 | 範例 | | ------ | -------------------------------------- | --------------------------------- | | + | 加法：計算兩個數字的總和 | 1 + 2 //預期答案是 3 | | - | 減法：計算兩個數字的差 | 1 - 2 //預期答案是 -1 | | * | 乘法：計算兩個數字的乘積 | 1 * 2 //預期答案是 2 | | / | 除法：計算兩個數字的商 | 1 / 2 //預期答案是 05          |\n| %    | 餘數：計算兩個數字相除的餘數      | 1 % 2 //預期答案是 1            |\n✅ 試試看！在瀏覽器的主控台中嘗試一個算術運算。結果是否讓你感到驚訝？\n字串\n字串是一組位於單引號或雙引號之間的字元。\n'這是一個字串'\n\"這也是一個字串\"\nlet myString = '這是一個儲存在變數中的字串值';\n記得在撰寫字串時使用引號，否則 JavaScript 會假設它是一個變數名稱。\n格式化字串\n字串是文字型的，有時需要進行格式化。\n要串接兩個或更多字串（即將它們連接在一起），可以使用 + 運算符。\n```javascript\nlet myString1 = \"Hello\";\nlet myString2 = \"World\";\nmyString1 + myString2 + \"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 727,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "1193911e19fb0722adcb7bafdebf66b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "| - | 減法：計算兩個數字的差 | 1 - 2 //預期答案是 -1 | | * | 乘法：計算兩個數字的乘積 | 1 * 2 //預期答案是 2 | | / | 除法：計算兩個數字的商 | 1 / 2 //預期答案是 05 | | % | 餘數：計算兩個數字相除的餘數 | 1 % 2 //預期答案是 1 | ✅ 試試看！在瀏覽器的主控台中嘗試一個算術運算。結果是否讓你感到驚訝？ 字串 字串是一組位於單引號或雙引號之間的字元。 '這是一個字串' \"這也是一個字串\" let myString = '這是一個儲存在變數中的字串值'; 記得在撰寫字串時使用引號，否則 JavaScript 會假設它是一個變數名稱。 格式化字串 字串是文字型的，有時需要進行格式化。 要串接兩個或更多字串（即將它們連接在一起），可以使用 + 運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "9bebf2f299e8c96c93b0bf422c5c93a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "/ | 除法：計算兩個數字的商 | 1 / 2 //預期答案是 05 | | % | 餘數：計算兩個數字相除的餘數 | 1 % 2 //預期答案是 1 | ✅ 試試看！在瀏覽器的主控台中嘗試一個算術運算。結果是否讓你感到驚訝？ 字串 字串是一組位於單引號或雙引號之間的字元。 '這是一個字串' \"這也是一個字串\" let myString = '這是一個儲存在變數中的字串值'; 記得在撰寫字串時使用引號，否則 JavaScript 會假設它是一個變數名稱。 格式化字串 字串是文字型的，有時需要進行格式化。 要串接兩個或更多字串（即將它們連接在一起），可以使用 + 運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World```\n✅ 為什麼在 JavaScript 中 1 + 1 = 2，但 '1' + '1' = 11？想一想。那 '1' + 1 呢？\n模板字串是格式化字串的另一種方式，不同於引號，模板字串使用反引號。任何非純文字的內容必須放在 ${ } 區塊中，包括可能是字串的變數。\n```javascript\nlet myString1 = \"Hello\";\nlet myString2 = \"World\";\n${myString1} ${myString2}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 520,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "c6b41262762226441fc688e9f57df6a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "會假設它是一個變數名稱。 格式化字串 字串是文字型的，有時需要進行格式化。 要串接兩個或更多字串（即將它們連接在一起），可以使用 + 運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World``` ✅ 為什麼在 JavaScript 中 1 + 1 = 2，但 '1' + '1' = 11？想一想。那 '1' + 1 呢？ 模板字串是格式化字串的另一種方式，不同於引號，模板字串使用反引號。任何非純文字的內容必須放在 ${ } 區塊中，包括可能是字串的變數。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; ${myString1} ${myString2}//Hello World ${myString1}, ${myString2} //Hello, World",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 311,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "57d6caa224b9fa82d61ccae7a078a634",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：資料型別",
    "content": "運算符。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World``` ✅ 為什麼在 JavaScript 中 1 + 1 = 2，但 '1' + '1' = 11？想一想。那 '1' + 1 呢？ 模板字串是格式化字串的另一種方式，不同於引號，模板字串使用反引號。任何非純文字的內容必須放在 ${ } 區塊中，包括可能是字串的變數。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; ${myString1} ${myString2}//Hello World ${myString1}, ${myString2} //Hello, World```\n你可以使用任一方法來實現格式化目標，但模板字串會保留任何空格和換行。\n✅ 什麼時候會使用模板字串而非普通字串？\n布林值\n布林值只有兩個值：true 或 false。布林值可以幫助決定在特定條件滿足時應執行哪些程式碼。在許多情況下，運算符 有助於設定布林值，並且你會經常注意到變數在初始化或更新其值時使用運算符。\nlet myTrueBool = true\nlet myFalseBool = false\n✅ 如果一個變數被認為是「真值」，則它會評估為布林值 true。有趣的是，在 JavaScript 中，所有值都是真值，除非被定義為假值。\n🚀 挑戰\nJavaScript 因其在處理資料型別時偶爾令人驚訝的方式而聞名。進行一些研究，了解這些「陷阱」。例如：大小寫敏感可能會讓你吃虧！在主控台中試試看：let age = 1; let Age = 2; age == Age（結果為 false——為什麼？）。你還能找到哪些其他的陷阱？\n課後測驗\n課後測驗\n複習與自學\n查看這份 JavaScript 練習清單並嘗試其中一個。你學到了什麼？\n作業\n資料型別練習\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9231,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 909,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "46424df771dfac36c50be19c35f54473",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\assignment.md",
    "source_type": "git_repo",
    "title": "運算子",
    "content": "運算子\n說明\n試著使用運算子。以下是一個可以實現的程式建議：\n你有一組來自兩個不同評分系統的學生。\n第一個評分系統\n第一個評分系統的分數範圍是1到5，其中3分及以上表示通過課程。\n第二個評分系統\n另一個評分系統的分數包括 A, A-, B, B-, C, C-，其中 A 是最高分，C 是最低的及格分數。\n任務\n給定以下陣列 allStudents，表示所有學生及其分數，構造一個新的陣列 studentsWhoPass，包含所有通過的學生。\nTIP，使用 for 迴圈、if",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 233,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "01296f3a7945bb6ad01d82377ccce5fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\assignment.md",
    "source_type": "git_repo",
    "title": "運算子",
    "content": "運算子\n說明\n試著使用運算子。以下是一個可以實現的程式建議：\n你有一組來自兩個不同評分系統的學生。\n第一個評分系統\n第一個評分系統的分數範圍是1到5，其中3分及以上表示通過課程。\n第二個評分系統\n另一個評分系統的分數包括 A, A-, B, B-, C, C-，其中 A 是最高分，C 是最低的及格分數。\n任務\n給定以下陣列 allStudents，表示所有學生及其分數，構造一個新的陣列 studentsWhoPass，包含所有通過的學生。\nTIP，使用 for 迴圈、ifelse 和比較運算子：\n```javascript\nlet allStudents = [\n'A',\n'B-',\n1,\n4,\n5,\n2\n]\nlet studentsWhoPass = [];\n```\n評分標準\n| 評分項目 | 優秀表現                     | 合格表現                     | 需要改進                     |\n| -------- | ---------------------------- | ---------------------------- | ---------------------------- |\n|          | 提供完整的解決方案           | 提供部分解決方案             | 提供有錯誤的解決方案         |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 557,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "bd617f13272705e4478da72cb74caf43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "JavaScript 基礎：方法與函式\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n在撰寫程式碼時，我們總是希望程式碼易於閱讀。雖然這聽起來有些矛盾，但事實上程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函式，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函式的影片。\n您可以在 Microsoft Learn 上學習本課程！\n函式\n函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！\n同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。\n建立與呼叫函式\n函式的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函式來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 581,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "96ec7082783dbbce2c5d1a76bf45205e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "JavaScript 基礎：方法與函式\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n在撰寫程式碼時，我們總是希望程式碼易於閱讀。雖然這聽起來有些矛盾，但事實上程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函式，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函式的影片。\n您可以在 Microsoft Learn 上學習本課程！\n函式\n函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！\n同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。\n建立與呼叫函式\n函式的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函式來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 586,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "5de613b94033238344cde2f131712ce9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "JavaScript 基礎：方法與函式\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n在撰寫程式碼時，我們總是希望程式碼易於閱讀。雖然這聽起來有些矛盾，但事實上程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函式，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函式的影片。\n您可以在 Microsoft Learn 上學習本課程！\n函式\n函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！\n同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。\n建立與呼叫函式\n函式的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函式來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 732,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "186d694b434bac420496d69ea6aca3ff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "JavaScript 基礎：方法與函式\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n在撰寫程式碼時，我們總是希望程式碼易於閱讀。雖然這聽起來有些矛盾，但事實上程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函式，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函式的影片。\n您可以在 Microsoft Learn 上學習本課程！\n函式\n函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！\n同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。\n建立與呼叫函式\n函式的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函式來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函式的不同之處在於，方法附加在物件上（例如我們的例子中的 console），而函式則是獨立的。您會發現許多開發者會交替使用這些術語。\n函式的最佳實踐\n在建立函式時，有一些最佳實踐需要記住：\n一如既往，使用描述性的名稱，讓您知道函式的用途\n使用 camelCasing 來結合多個單字\n讓函式專注於特定的任務\n傳遞資訊給函式\n為了讓函式更具重用性，您通常需要向函式傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 996,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "b9b99bd2a25d727547f552f782595392",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "JavaScript 基礎：方法與函式\n繪圖筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n在撰寫程式碼時，我們總是希望程式碼易於閱讀。雖然這聽起來有些矛盾，但事實上程式碼被閱讀的次數遠多於被撰寫的次數。開發者工具箱中的一個核心工具就是 函式，它能幫助我們確保程式碼的可維護性。\n🎥 點擊上方圖片觀看有關方法與函式的影片。\n您可以在 Microsoft Learn 上學習本課程！\n函式\n函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！\n同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。\n建立與呼叫函式\n函式的語法如下所示：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n如果我想建立一個函式來顯示問候語，它可能看起來像這樣：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函式的不同之處在於，方法附加在物件上（例如我們的例子中的 console），而函式則是獨立的。您會發現許多開發者會交替使用這些術語。\n函式的最佳實踐\n在建立函式時，有一些最佳實踐需要記住：\n一如既往，使用描述性的名稱，讓您知道函式的用途\n使用 camelCasing 來結合多個單字\n讓函式專注於特定的任務\n傳遞資訊給函式\n為了讓函式更具重用性，您通常需要向函式傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個非常有用的函式。如果我們想讓它更靈活，例如允許指定要問候的人的名字，我們可以添加一個 參數。參數（有時也稱為 引數）是傳遞給函式的額外資訊。\n參數列在定義部分的括號內，並用逗號分隔，如下所示：\n```javascript\nfunction name(param, param2, param3) {\n}\n```\n我們可以更新 displayGreeting 以接受名字並顯示該名字。\njavascript\nfunction displayGreeting(name) {\nconst message = `Hello, ${name}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1193,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "11f8adf710b8c2d88b190d3c02f20be1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "上學習本課程！ 函式 函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！ 同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。 建立與呼叫函式 函式的語法如下所示： javascript function nameOfFunction() { // function definition // function definition/body } 如果我想建立一個函式來顯示問候語，它可能看起來像這樣： javascript function displayGreeting() { consolelog('Hello, world'); } 每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函式的不同之處在於，方法附加在物件上（例如我們的例子中的 console），而函式則是獨立的。您會發現許多開發者會交替使用這些術語。 函式的最佳實踐 在建立函式時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，讓您知道函式的用途 使用 camelCasing 來結合多個單字 讓函式專注於特定的任務 傳遞資訊給函式 為了讓函式更具重用性，您通常需要向函式傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個非常有用的函式。如果我們想讓它更靈活，例如允許指定要問候的人的名字，我們可以添加一個 參數。參數（有時也稱為 引數）是傳遞給函式的額外資訊。 參數列在定義部分的括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 以接受名字並顯示該名字。 javascript function displayGreeting(name) { const message = `Hello, ${name}`;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 968,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "606ec06c855d573331639536f89e4eb5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "函式 函式的核心是一段可以按需執行的程式碼。這非常適合需要多次執行相同任務的情境；與其在多個地方重複邏輯（這會在需要更新時變得困難），我們可以將邏輯集中在一個地方，並在需要執行操作時呼叫它——甚至可以從其他函式中呼叫函式！ 同樣重要的是為函式命名的能力。雖然這看起來微不足道，但名稱提供了一種快速記錄程式碼片段的方式。您可以將其視為按鈕上的標籤。如果我點擊一個標有「取消計時器」的按鈕，我就知道它會停止時鐘的運行。 建立與呼叫函式 函式的語法如下所示： javascript function nameOfFunction() { // function definition // function definition/body } 如果我想建立一個函式來顯示問候語，它可能看起來像這樣： javascript function displayGreeting() { consolelog('Hello, world'); } 每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函式的不同之處在於，方法附加在物件上（例如我們的例子中的 console），而函式則是獨立的。您會發現許多開發者會交替使用這些術語。 函式的最佳實踐 在建立函式時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，讓您知道函式的用途 使用 camelCasing 來結合多個單字 讓函式專注於特定的任務 傳遞資訊給函式 為了讓函式更具重用性，您通常需要向函式傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個非常有用的函式。如果我們想讓它更靈活，例如允許指定要問候的人的名字，我們可以添加一個 參數。參數（有時也稱為 引數）是傳遞給函式的額外資訊。 參數列在定義部分的括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 以接受名字並顯示該名字。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message);\n}\n當我們想要呼叫函式並傳遞參數時，我們在括號內指定它。\njavascript\ndisplayGreeting('Christopher');\n// displays \"Hello, Christopher",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1019,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "a9035b71ec361ae2210a4b84edb7ec45",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "{ // function definition // function definition/body } 如果我想建立一個函式來顯示問候語，它可能看起來像這樣： javascript function displayGreeting() { consolelog('Hello, world'); } 每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函式的不同之處在於，方法附加在物件上（例如我們的例子中的 console），而函式則是獨立的。您會發現許多開發者會交替使用這些術語。 函式的最佳實踐 在建立函式時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，讓您知道函式的用途 使用 camelCasing 來結合多個單字 讓函式專注於特定的任務 傳遞資訊給函式 為了讓函式更具重用性，您通常需要向函式傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個非常有用的函式。如果我們想讓它更靈活，例如允許指定要問候的人的名字，我們可以添加一個 參數。參數（有時也稱為 引數）是傳遞給函式的額外資訊。 參數列在定義部分的括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 以接受名字並顯示該名字。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message); } 當我們想要呼叫函式並傳遞參數時，我們在括號內指定它。 javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" when run\n預設值\n我們可以通過添加更多參數使函式更加靈活。但如果我們不希望每個值都必須指定呢？以問候語的例子為例，我們可以將名字設為必填（我們需要知道要問候誰），但希望允許問候語根據需要進行自定義。如果有人不想自定義，我們提供一個預設值。要為參數提供預設值，我們可以像為變數設置值一樣進行設置——parameterName = 'defaultValue'。完整示例如下：\njavascript\nfunction displayGreeting(name, salutation='Hello') {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 947,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "8331a0430b38c2e5323b7cdc0c9307e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "{ consolelog('Hello, world'); } 每當我們想要呼叫（或執行）函式時，我們使用函式名稱後加上 ()。值得注意的是，我們的函式可以在呼叫之前或之後定義；JavaScript 編譯器會幫您找到它。 javascript // calling our function displayGreeting(); NOTE: 有一種特殊類型的函式稱為 方法，您已經在使用了！事實上，我們在上面的示例中使用 consolelog 時就看到了這一點。方法與函式的不同之處在於，方法附加在物件上（例如我們的例子中的 console），而函式則是獨立的。您會發現許多開發者會交替使用這些術語。 函式的最佳實踐 在建立函式時，有一些最佳實踐需要記住： 一如既往，使用描述性的名稱，讓您知道函式的用途 使用 camelCasing 來結合多個單字 讓函式專注於特定的任務 傳遞資訊給函式 為了讓函式更具重用性，您通常需要向函式傳遞資訊。如果我們考慮上面的 displayGreeting 示例，它只會顯示 Hello, world。這並不是一個非常有用的函式。如果我們想讓它更靈活，例如允許指定要問候的人的名字，我們可以添加一個 參數。參數（有時也稱為 引數）是傳遞給函式的額外資訊。 參數列在定義部分的括號內，並用逗號分隔，如下所示： ```javascript function name(param, param2, param3) { } ``` 我們可以更新 displayGreeting 以接受名字並顯示該名字。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message); } 當我們想要呼叫函式並傳遞參數時，我們在括號內指定它。 javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" when run 預設值 我們可以通過添加更多參數使函式更加靈活。但如果我們不希望每個值都必須指定呢？以問候語的例子為例，我們可以將名字設為必填（我們需要知道要問候誰），但希望允許問候語根據需要進行自定義。如果有人不想自定義，我們提供一個預設值。要為參數提供預設值，我們可以像為變數設置值一樣進行設置——parameterName = 'defaultValue'。完整示例如下： javascript function displayGreeting(name, salutation='Hello') { consolelog(`${salutation}, ${name}`);\n}\n當我們呼叫函式時，可以決定是否要為 salutation 設置值。\n```javascript\ndisplayGreeting('Christopher');\n// displays \"Hello, Christopher\"\ndisplayGreeting('Christopher', 'Hi');\n// displays \"Hi, Christopher\"\n```\n回傳值\n到目前為止，我們建立的函式會始終輸出到 console。有時這正是我們所需要的，特別是當我們建立的函式會呼叫其他服務時。但如果我想建立一個輔助函式來執行計算並將值回傳以便在其他地方使用呢？\n我們可以通過使用 回傳值 來實現。回傳值由函式回傳，並可以像存儲字串或數字等靜態值一樣存儲在變數中。\n如果函式確實回傳某些內容，則使用關鍵字 return。return 關鍵字需要一個值或引用作為回傳內容，如下所示：\njavascript\nreturn myVariable;\n我們可以建立一個函式來建立問候語訊息並將值回傳給呼叫者。\njavascript\nfunction createGreetingMessage(name) {\nconst message = `Hello, ${name}`;\nreturn message;\n}\n呼叫此函式時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。\njavascript\nconst greetingMessage = createGreetingMessage('Christopher');\n函式作為函式的參數\n隨著您在程式設計職業生涯中的進步，您會遇到接受函式作為參數的函式。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要執行某個操作作為響應。\n例如，setTimeout 開始一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函式的完美工作！\n如果您執行以下程式碼，3 秒後您會看到訊息 3 seconds has elapsed。\njavascript\nfunction displayDone() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1616,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "a96f1fd549dad5d04718bfd5951c87d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "= 'defaultValue'。完整示例如下： javascript function displayGreeting(name, salutation='Hello') { consolelog(`${salutation}, ${name}`); } 當我們呼叫函式時，可以決定是否要為 salutation 設置值。 ```javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" displayGreeting('Christopher', 'Hi'); // displays \"Hi, Christopher\" ``` 回傳值 到目前為止，我們建立的函式會始終輸出到 console。有時這正是我們所需要的，特別是當我們建立的函式會呼叫其他服務時。但如果我想建立一個輔助函式來執行計算並將值回傳以便在其他地方使用呢？ 我們可以通過使用 回傳值 來實現。回傳值由函式回傳，並可以像存儲字串或數字等靜態值一樣存儲在變數中。 如果函式確實回傳某些內容，則使用關鍵字 return。return 關鍵字需要一個值或引用作為回傳內容，如下所示： javascript return myVariable; 我們可以建立一個函式來建立問候語訊息並將值回傳給呼叫者。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } 呼叫此函式時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。 javascript const greetingMessage = createGreetingMessage('Christopher'); 函式作為函式的參數 隨著您在程式設計職業生涯中的進步，您會遇到接受函式作為參數的函式。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要執行某個操作作為響應。 例如，setTimeout 開始一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函式的完美工作！ 如果您執行以下程式碼，3 秒後您會看到訊息 3 seconds has elapsed。 javascript function displayDone() { consolelog('3 seconds has elapsed');\n}\n// timer value is in milliseconds\nsetTimeout(displayDone, 3000);\n匿名函式\n讓我們再看看我們建立的內容。我們建立了一個有名稱的函式，但它只會被使用一次。隨著應用程式變得更加複雜，我們可能會建立許多只會被呼叫一次的函式。這並不理想。事實證明，我們並不總是需要提供名稱！\n當我們將函式作為參數傳遞時，可以跳過事先建立函式，而是在參數中直接建立它。我們使用相同的 function 關鍵字，但將其作為參數的一部分來建立。\n讓我們重寫上面的程式碼以使用匿名函式：\njavascript\nsetTimeout(function() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1030,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "44640949b00bb5755d40d45dbfaa65bc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "displays \"Hi, Christopher\" ``` 回傳值 到目前為止，我們建立的函式會始終輸出到 console。有時這正是我們所需要的，特別是當我們建立的函式會呼叫其他服務時。但如果我想建立一個輔助函式來執行計算並將值回傳以便在其他地方使用呢？ 我們可以通過使用 回傳值 來實現。回傳值由函式回傳，並可以像存儲字串或數字等靜態值一樣存儲在變數中。 如果函式確實回傳某些內容，則使用關鍵字 return。return 關鍵字需要一個值或引用作為回傳內容，如下所示： javascript return myVariable; 我們可以建立一個函式來建立問候語訊息並將值回傳給呼叫者。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } 呼叫此函式時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。 javascript const greetingMessage = createGreetingMessage('Christopher'); 函式作為函式的參數 隨著您在程式設計職業生涯中的進步，您會遇到接受函式作為參數的函式。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要執行某個操作作為響應。 例如，setTimeout 開始一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函式的完美工作！ 如果您執行以下程式碼，3 秒後您會看到訊息 3 seconds has elapsed。 javascript function displayDone() { consolelog('3 seconds has elapsed'); } // timer value is in milliseconds setTimeout(displayDone, 3000); 匿名函式 讓我們再看看我們建立的內容。我們建立了一個有名稱的函式，但它只會被使用一次。隨著應用程式變得更加複雜，我們可能會建立許多只會被呼叫一次的函式。這並不理想。事實證明，我們並不總是需要提供名稱！ 當我們將函式作為參數傳遞時，可以跳過事先建立函式，而是在參數中直接建立它。我們使用相同的 function 關鍵字，但將其作為參數的一部分來建立。 讓我們重寫上面的程式碼以使用匿名函式： javascript setTimeout(function() { consolelog('3 seconds has elapsed');\n}, 3000);\n如果您執行我們的新程式碼，您會注意到結果相同。我們建立了一個函式，但不需要給它命名！\nFat Arrow 函式\n許多程式語言（包括 JavaScript）中常見的一個快捷方式是使用所謂的 箭頭 或 Fat Arrow 函式。它使用特殊的指示符 =>，看起來像一個箭頭——因此得名！通過使用 =>，我們可以跳過 function 關鍵字。\n讓我們再一次重寫程式碼以使用 Fat Arrow 函式：\njavascript\nsetTimeout(() => {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1132,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "21f9c89fc7038d015eaf494ef96905cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：方法與函式",
    "content": "呼叫此函式時，我們會將值存儲在變數中。這與我們將變數設置為靜態值（例如 const name = 'Christopher'）的方式非常相似。 javascript const greetingMessage = createGreetingMessage('Christopher'); 函式作為函式的參數 隨著您在程式設計職業生涯中的進步，您會遇到接受函式作為參數的函式。這個巧妙的技巧通常用於我們不知道某件事何時會發生或完成，但我們知道需要執行某個操作作為響應。 例如，setTimeout 開始一個計時器並在完成時執行程式碼。我們需要告訴它我們想執行什麼程式碼。聽起來這正是函式的完美工作！ 如果您執行以下程式碼，3 秒後您會看到訊息 3 seconds has elapsed。 javascript function displayDone() { consolelog('3 seconds has elapsed'); } // timer value is in milliseconds setTimeout(displayDone, 3000); 匿名函式 讓我們再看看我們建立的內容。我們建立了一個有名稱的函式，但它只會被使用一次。隨著應用程式變得更加複雜，我們可能會建立許多只會被呼叫一次的函式。這並不理想。事實證明，我們並不總是需要提供名稱！ 當我們將函式作為參數傳遞時，可以跳過事先建立函式，而是在參數中直接建立它。我們使用相同的 function 關鍵字，但將其作為參數的一部分來建立。 讓我們重寫上面的程式碼以使用匿名函式： javascript setTimeout(function() { consolelog('3 seconds has elapsed'); }, 3000); 如果您執行我們的新程式碼，您會注意到結果相同。我們建立了一個函式，但不需要給它命名！ Fat Arrow 函式 許多程式語言（包括 JavaScript）中常見的一個快捷方式是使用所謂的 箭頭 或 Fat Arrow 函式。它使用特殊的指示符 =>，看起來像一個箭頭——因此得名！通過使用 =>，我們可以跳過 function 關鍵字。 讓我們再一次重寫程式碼以使用 Fat Arrow 函式： javascript setTimeout(() => { consolelog('3 seconds has elapsed');\n}, 3000);\n何時使用每種策略\n您現在已經看到我們有三種方式將函式作為參數傳遞，可能會想知道何時使用哪一種。如果您知道函式會被多次使用，請正常建立它。如果只會在一個地方使用，通常最好使用匿名函式。至於使用 Fat Arrow 函式還是更傳統的 function 語法，則取決於您，但您會注意到大多數現代開發者更喜歡使用 =>。\n🚀 挑戰\n您能否用一句話說明函式與方法的區別？試試看！\n課後測驗\n課後測驗\n複習與自學\n值得深入了解箭頭函式，因為它們在程式碼中越來越常用。練習撰寫一個函式，然後使用此語法重寫它。\n作業\n函式的趣味練習\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9395,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1306,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "75495218d16a0df62a51b785c8623ee3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "JavaScript 基礎：做出決策\nSketchnote by Tomomi Imura\n課前測驗\n課前測驗\n做出決策並控制程式碼執行的順序可以讓你的程式碼更具重用性和穩健性。本章節涵蓋了在 JavaScript 中控制資料流的語法，以及它在使用布林值時的重要性。\n🎥 點擊上方圖片觀看有關做出決策的影片。\n你可以在 Microsoft Learn 上學習這堂課！\n布林值簡介\n布林值只有兩個可能的值：true 或 false。布林值幫助我們決定在特定條件下哪些程式碼行應該執行。\n你可以像這樣設定布林值為 true 或 false：\nlet myTrueBool = true\nlet myFalseBool = false\n✅ 布林值的名稱來自英國數學家、哲學家和邏輯學家 George Boole (1815–1864)。\n比較運算子與布林值\n運算子用於通過比較來評估條件，並生成布林值。以下是常用運算子的列表。\n| 符號   | 描述                                                                                                                                                   | 範例                |\n| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- |\n| <    | 小於：比較兩個值，若左側值小於右側值，則返回 true 布林值                                                                                         | 5 < 6 // true     |\n| <=   | 小於或等於：比較兩個值，若左側值小於或等於右側值，則返回 true 布林值                                                                             | 5 <= 6 // true    |\n| >    | 大於：比較兩個值，若左側值大於右側值，則返回 true 布林值                                                                                         | 5 > 6 // false    |\n| >=   | 大於或等於：比較兩個值，若左側值大於或等於右側值，則返回 true 布林值                                                                             | 5 >= 6 // false   |\n| ===  | 嚴格相等：比較兩個值，若左右兩側的值相等且資料型別相同，則返回 true 布林值                                                                       | 5 === 6 // false  |\n|",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 713,
    "chunk_index": 0,
    "total_chunks": 8
  },
  {
    "id": "01783b3a2ee5fb3b4dfeaa5b4ad6f8c0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "| 範例 | | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- | | < | 小於：比較兩個值，若左側值小於右側值，則返回 true 布林值 | 5 < 6 // true | | <= | 小於或等於：比較兩個值，若左側值小於或等於右側值，則返回 true 布林值 | 5 <= 6 // true | | > | 大於：比較兩個值，若左側值大於右側值，則返回 true 布林值 | 5 > 6 // false | | >= | 大於或等於：比較兩個值，若左側值大於或等於右側值，則返回 true 布林值 | 5 >= 6 // false | | === | 嚴格相等：比較兩個值，若左右兩側的值相等且資料型別相同，則返回 true 布林值 | 5 === 6 // false | |==  | 不相等：比較兩個值，返回與嚴格相等運算子相反的布林值                                                                                               | 5 == 6 // true   |\n✅ 在瀏覽器的控制台中寫一些比較來檢查你的知識。返回的資料是否有讓你感到驚訝？\nIf 語句\nIf 語句會在條件為 true 時執行其區塊中的程式碼。\njavascript\nif (condition) {\n//Condition is true Code in this block will run",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 458,
    "chunk_index": 1,
    "total_chunks": 8
  },
  {
    "id": "476645364b75b57dd2732781ae0b3b60",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "5 <= 6 // true | | > | 大於：比較兩個值，若左側值大於右側值，則返回 true 布林值 | 5 > 6 // false | | >= | 大於或等於：比較兩個值，若左側值大於或等於右側值，則返回 true 布林值 | 5 >= 6 // false | | === | 嚴格相等：比較兩個值，若左右兩側的值相等且資料型別相同，則返回 true 布林值 | 5 === 6 // false | |== | 不相等：比較兩個值，返回與嚴格相等運算子相反的布林值 | 5 == 6 // true | ✅ 在瀏覽器的控制台中寫一些比較來檢查你的知識。返回的資料是否有讓你感到驚訝？ If 語句 If 語句會在條件為 true 時執行其區塊中的程式碼。 javascript if (condition) { //Condition is true Code in this block will run}\n邏輯運算子通常用於形成條件。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nif (currentMoney >= laptopPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n}\n```\nIf Else 語句\nelse 語句會在條件為 false 時執行其區塊中的程式碼。它是 if 語句的可選部分。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nif (currentMoney >= laptopPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n} else {\n//Condition is false",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 2,
    "total_chunks": 8
  },
  {
    "id": "9db7564ab09200a1af8ebdd2c081808c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "is true Code in this block will run} 邏輯運算子通常用於形成條件。 ```javascript let currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } ``` If Else 語句 else 語句會在條件為 false 時執行其區塊中的程式碼。它是 if 語句的可選部分。 ```javascript let currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } else { //Condition is falseCode in this block will run console log(\"Can't afford a new laptop, yet \");\n}\n```\n✅ 在瀏覽器控制台中執行這段程式碼以及以下程式碼來測試你的理解。更改 currentMoney 和 laptopPrice 變數的值以改變返回的 console log()。\nSwitch 語句\nswitch 語句用於根據不同條件執行不同的操作。使用 switch 語句選擇要執行的多個程式碼區塊之一。\njavascript\nswitch (expression) {\ncase x:\n// code block\nbreak;\ncase y:\n// code block\nbreak;\ndefault:\n// code block\n}\n```javascript\n// program using switch statement\nlet a = 2;\nswitch (a) {\ncase 1:\na = \"one\";\nbreak;\ncase 2:\na = \"two\";\nbreak;\ndefault:\na = \"not found\";\nbreak;\n}\nconsole log(The value is ${a});\n```\n✅ 在瀏覽器控制台中執行這段程式碼以及以下程式碼來測試你的理解。更改變數 a 的值以改變返回的 console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 476,
    "chunk_index": 3,
    "total_chunks": 8
  },
  {
    "id": "896ad30c6de411533f1406eb1d66ad88",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "currentMoney 和 laptopPrice 變數的值以改變返回的 console log()。 Switch 語句 switch 語句用於根據不同條件執行不同的操作。使用 switch 語句選擇要執行的多個程式碼區塊之一。 javascript switch (expression) { case x: // code block break; case y: // code block break; default: // code block } ```javascript // program using switch statement let a = 2; switch (a) { case 1: a = \"one\"; break; case 2: a = \"two\"; break; default: a = \"not found\"; break; } console log(The value is ${a}); ``` ✅ 在瀏覽器控制台中執行這段程式碼以及以下程式碼來測試你的理解。更改變數 a 的值以改變返回的 consolelog()。\n邏輯運算子與布林值\n決策可能需要多個比較，可以使用邏輯運算子串聯起來以生成布林值。\n| 符號   | 描述                                                                                     | 範例                                                                 |\n| ------ | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |\n| &&   | 邏輯 AND：比較兩個布林表達式。僅當兩側都為 true 時返回 true                          | (5 > 6) && (5 < 6 ) //一側為 false，另一側為 true。返回 false      |\n| \\|\\| | 邏輯 OR：比較兩個布林表達式。若至少一側為 true 則返回 true                           | (5 > 6) \\|\\| (5 < 6) //一側為 false，另一側為 true。返回 true      |\n|",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 4,
    "total_chunks": 8
  },
  {
    "id": "d1f61703a562f2d116d235fcff1172e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "= \"not found\"; break; } console log(The value is ${a}); ``` ✅ 在瀏覽器控制台中執行這段程式碼以及以下程式碼來測試你的理解。更改變數 a 的值以改變返回的 consolelog()。 邏輯運算子與布林值 決策可能需要多個比較，可以使用邏輯運算子串聯起來以生成布林值。 | 符號 | 描述 | 範例 | | ------ | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------- | | && | 邏輯 AND：比較兩個布林表達式。僅當兩側都為 true 時返回 true | (5 > 6) && (5 < 6 ) //一側為 false，另一側為 true。返回 false | | \\|\\| | 邏輯 OR：比較兩個布林表達式。若至少一側為 true 則返回 true | (5 > 6) \\|\\| (5 < 6) //一側為 false，另一側為 true。返回 true | || 邏輯 NOT：返回布林表達式的相反值                                                     | (5 > 6) // 5 不大於 6，但 \" \" 會返回 true                        |\n使用邏輯運算子的條件與決策\n邏輯運算子可以用於在 if else 語句中形成條件。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nlet laptopDiscountPrice = laptopPrice - laptopPrice * 0 2; //Laptop price at 20 percent off\nif (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n} else {\n//Condition is true",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 5,
    "total_chunks": 8
  },
  {
    "id": "b500b31fdbaf45af034179d543c53eea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "//一側為 false，另一側為 true。返回 true | || 邏輯 NOT：返回布林表達式的相反值 | (5 > 6) // 5 不大於 6，但 \" \" 會返回 true | 使用邏輯運算子的條件與決策 邏輯運算子可以用於在 if else 語句中形成條件。 ```javascript let currentMoney; let laptopPrice; let laptopDiscountPrice = laptopPrice - laptopPrice * 0 2; //Laptop price at 20 percent off if (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } else { //Condition is trueCode in this block will run console log(\"Can't afford a new laptop, yet \");\n}\n```\n否定運算子\n到目前為止，你已經看到如何使用 if else 語句來創建條件邏輯。任何進入 if 的內容都需要評估為 true 或 false。通過使用 運算子，你可以否定表達式。它看起來像這樣：\njavascript\nif ( condition) {\n// runs if condition is false\n} else {\n// runs if condition is true\n}\n三元運算式\nif else 不是表達決策邏輯的唯一方式。你還可以使用一種稱為三元運算子的方式。其語法如下：\njavascript\nlet variable = condition <return this if true> : <return this if false>\n以下是一個更具體的例子：\njavascript\nlet firstNumber = 20;\nlet secondNumber = 10;\nlet biggestNumber = firstNumber > secondNumber",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 460,
    "chunk_index": 6,
    "total_chunks": 8
  },
  {
    "id": "fedb60da9cdac07e432c02d37d3c4845",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：做出決策",
    "content": "console log(\"Can't afford a new laptop, yet \"); } ``` 否定運算子 到目前為止，你已經看到如何使用 if else 語句來創建條件邏輯。任何進入 if 的內容都需要評估為 true 或 false。通過使用 運算子，你可以否定表達式。它看起來像這樣： javascript if ( condition) { // runs if condition is false } else { // runs if condition is true } 三元運算式 if else 不是表達決策邏輯的唯一方式。你還可以使用一種稱為三元運算子的方式。其語法如下： javascript let variable = condition <return this if true> : <return this if false> 以下是一個更具體的例子： javascript let firstNumber = 20; let secondNumber = 10; let biggestNumber = firstNumber > secondNumberfirstNumber : secondNumber;\n✅ 花點時間多讀幾遍這段程式碼。你理解這些運算子是如何工作的嗎？\n上述程式碼表示：\n如果 firstNumber 大於 secondNumber\n則將 firstNumber 賦值給 biggestNumber\n否則將 secondNumber 賦值給 biggestNumber。\n三元運算式只是以下程式碼的簡潔寫法：\njavascript\nlet biggestNumber;\nif (firstNumber > secondNumber) {\nbiggestNumber = firstNumber;\n} else {\nbiggestNumber = secondNumber;\n}\n🚀 挑戰\n創建一個程式，首先使用邏輯運算子編寫，然後使用三元運算式重寫。你更喜歡哪種語法？\n課後測驗\n課後測驗\n複習與自學\n閱讀更多有關使用者可用的運算子的資訊：MDN。\n瀏覽 Josh Comeau 的精彩 運算子查詢工具！\n作業\n運算子\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。儘管我們努力確保翻譯的準確性，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9140,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 745,
    "chunk_index": 7,
    "total_chunks": 8
  },
  {
    "id": "bd8c57e056a93e47b04d79e906fc129d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\assignment.md",
    "source_type": "git_repo",
    "title": "遍歷陣列",
    "content": "遍歷陣列\n說明\n建立一個程式，列出1到20之間每隔3個數字的數字，並將其輸出到控制台。\nTIP: 使用 for 迴圈並修改迭代表達式\n評分標準\n| 評分標準 | 表現優異                               | 表現尚可                 | 需要改進                      |\n| -------- | --------------------------------------- | ------------------------ | ------------------------------ |\n|          | 程式運行正確且有註解                   | 程式沒有註解            | 程式不完整或有錯誤            |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤讀概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 360,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "eb3eb601659223099881e571316ed66b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\assignment.md",
    "source_type": "git_repo",
    "title": "閱讀文件",
    "content": "閱讀文件\n說明\n有許多網頁開發人員可能需要的工具可以在 MDN 文件中的客戶端工具 中找到。選擇 3 個課程中未涵蓋的工具，解釋為什麼網頁開發人員會使用它，並搜尋屬於此類別的工具，分享其文件。請勿使用 MDN 文件中的相同工具範例。\n評分標準\n卓越 | 合格 | 需要改進\n--- | --- | -- |\n|解釋了為什麼網頁開發人員會使用該工具| 解釋了如何使用，但未說明為什麼開發人員會使用該工具| 未提及開發人員如何或為什麼使用該工具  |\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1381,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "427e4ef896f6e56bc8a448c3dfbfe708",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "JavaScript 基礎：陣列與迴圈\n由 Tomomi Imura 繪製的筆記圖\n課前測驗\n課前測驗\n本課程涵蓋 JavaScript 的基礎知識，這是一種為網頁提供互動性的語言。在這堂課中，你將學習如何使用陣列與迴圈來操作資料。\n🎥 點擊上方圖片觀看有關陣列與迴圈的影片。\n你可以在 Microsoft Learn 上學習這堂課！\n陣列\n處理資料是任何程式語言中常見的任務，而當資料以結構化的格式（如陣列）組織起來時，這項任務會變得更加簡單。使用陣列時，資料會以類似清單的結構儲存。陣列的一大優點是你可以在一個陣列中儲存不同類型的資料。\n✅ 陣列無處不在！你能想到一個現實生活中的陣列例子嗎？例如太陽能板陣列？\n陣列的語法是使用一對方括號。\njavascript\nlet myArray = [];\n這是一個空的陣列，但陣列也可以在宣告時就已經填入資料。陣列中的多個值以逗號分隔。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\n陣列中的值會被分配一個稱為 索引 的唯一值，這是一個根據其與陣列開頭的距離分配的整數。在上面的例子中，字串值 \"Chocolate\" 的索引是 0，而 \"Rocky Road\" 的索引是 4。使用方括號和索引可以檢索、更改或插入陣列中的值。\n✅ 你是否對陣列的索引從 0 開始感到驚訝？在某些程式語言中，索引是從 1 開始的。這背後有一段有趣的歷史，你可以在 維基百科 上閱讀相關內容。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\niceCreamFlavors[2]; //\"Vanilla\"\n你可以利用索引來更改一個值，如下所示：\njavascript\niceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\"\n你也可以在指定的索引位置插入一個新值，如下所示：\njavascript\niceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\"\n✅ 更常見的方式是使用像 array",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "6b6356f7ec58d32e82a77a8e2a2c7dae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "上學習這堂課！ 陣列 處理資料是任何程式語言中常見的任務，而當資料以結構化的格式（如陣列）組織起來時，這項任務會變得更加簡單。使用陣列時，資料會以類似清單的結構儲存。陣列的一大優點是你可以在一個陣列中儲存不同類型的資料。 ✅ 陣列無處不在！你能想到一個現實生活中的陣列例子嗎？例如太陽能板陣列？ 陣列的語法是使用一對方括號。 javascript let myArray = []; 這是一個空的陣列，但陣列也可以在宣告時就已經填入資料。陣列中的多個值以逗號分隔。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; 陣列中的值會被分配一個稱為 索引 的唯一值，這是一個根據其與陣列開頭的距離分配的整數。在上面的例子中，字串值 \"Chocolate\" 的索引是 0，而 \"Rocky Road\" 的索引是 4。使用方括號和索引可以檢索、更改或插入陣列中的值。 ✅ 你是否對陣列的索引從 0 開始感到驚訝？在某些程式語言中，索引是從 1 開始的。這背後有一段有趣的歷史，你可以在 維基百科 上閱讀相關內容。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" 你可以利用索引來更改一個值，如下所示： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" 你也可以在指定的索引位置插入一個新值，如下所示： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 更常見的方式是使用像 arraypush() 這樣的陣列操作符來新增值。\n要知道陣列中有多少項目，可以使用 length 屬性。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\niceCreamFlavors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 752,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "97382d3a59ef98f014cc5c275e941515",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "= [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; 陣列中的值會被分配一個稱為 索引 的唯一值，這是一個根據其與陣列開頭的距離分配的整數。在上面的例子中，字串值 \"Chocolate\" 的索引是 0，而 \"Rocky Road\" 的索引是 4。使用方括號和索引可以檢索、更改或插入陣列中的值。 ✅ 你是否對陣列的索引從 0 開始感到驚訝？在某些程式語言中，索引是從 1 開始的。這背後有一段有趣的歷史，你可以在 維基百科 上閱讀相關內容。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" 你可以利用索引來更改一個值，如下所示： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" 你也可以在指定的索引位置插入一個新值，如下所示： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 更常見的方式是使用像 arraypush() 這樣的陣列操作符來新增值。 要知道陣列中有多少項目，可以使用 length 屬性。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5\n✅ 試試看！使用瀏覽器的控制台來創建並操作一個你自己設計的陣列。\n迴圈\n迴圈讓我們能夠執行重複或 迭代 的任務，這可以節省大量的時間和程式碼。每次迭代可以有不同的變數、值和條件。在 JavaScript 中有不同類型的迴圈，它們之間有些微差異，但基本上都做相同的事情：遍歷資料。\nFor 迴圈\nfor 迴圈需要三個部分來進行迭代：\n- counter 一個變數，通常初始化為一個數字，用來計算迭代次數\n- condition 一個使用比較運算符的表達式，當結果為 false 時迴圈停止\n- iteration-expression 在每次迭代結束時執行，通常用來改變計數器的值\njavascript\n// Counting up to 10\nfor (let i = 0; i < 10; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 794,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "3496459e52b6ddb347853096ea61a1dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "\"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" 你也可以在指定的索引位置插入一個新值，如下所示： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 更常見的方式是使用像 arraypush() 這樣的陣列操作符來新增值。 要知道陣列中有多少項目，可以使用 length 屬性。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5 ✅ 試試看！使用瀏覽器的控制台來創建並操作一個你自己設計的陣列。 迴圈 迴圈讓我們能夠執行重複或 迭代 的任務，這可以節省大量的時間和程式碼。每次迭代可以有不同的變數、值和條件。在 JavaScript 中有不同類型的迴圈，它們之間有些微差異，但基本上都做相同的事情：遍歷資料。 For 迴圈 for 迴圈需要三個部分來進行迭代： - counter 一個變數，通常初始化為一個數字，用來計算迭代次數 - condition 一個使用比較運算符的表達式，當結果為 false 時迴圈停止 - iteration-expression 在每次迭代結束時執行，通常用來改變計數器的值 javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i);\n}\n✅ 在瀏覽器控制台中執行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒數，創建一個倒計時嗎？\nWhile 迴圈\n與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值（如計數器），並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外部創建，並且任何滿足條件的表達式（包括更改計數器）都必須在迴圈內部維護。\njavascript\n//Counting up to 10\nlet i = 0;\nwhile (i < 10) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 764,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "5034200947ef4d1da7bf3b15435bd243",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5 ✅ 試試看！使用瀏覽器的控制台來創建並操作一個你自己設計的陣列。 迴圈 迴圈讓我們能夠執行重複或 迭代 的任務，這可以節省大量的時間和程式碼。每次迭代可以有不同的變數、值和條件。在 JavaScript 中有不同類型的迴圈，它們之間有些微差異，但基本上都做相同的事情：遍歷資料。 For 迴圈 for 迴圈需要三個部分來進行迭代： - counter 一個變數，通常初始化為一個數字，用來計算迭代次數 - condition 一個使用比較運算符的表達式，當結果為 false 時迴圈停止 - iteration-expression 在每次迭代結束時執行，通常用來改變計數器的值 javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ 在瀏覽器控制台中執行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒數，創建一個倒計時嗎？ While 迴圈 與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值（如計數器），並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外部創建，並且任何滿足條件的表達式（包括更改計數器）都必須在迴圈內部維護。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i);\ni++;\n}\n✅ 你會在什麼情況下選擇使用 for 迴圈而不是 while 迴圈？17K 名讀者在 StackOverflow 上有相同的疑問，其中一些意見可能會 引起你的興趣。\n迴圈與陣列\n陣列經常與迴圈一起使用，因為大多數條件需要依賴陣列的長度來停止迴圈，而索引也可以作為計數器的值。\n```javascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\nfor (let i = 0; i < iceCreamFlavors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "00cd3983d022bbfd42a15763b4ac9d15",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "在每次迭代結束時執行，通常用來改變計數器的值 javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ 在瀏覽器控制台中執行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒數，創建一個倒計時嗎？ While 迴圈 與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值（如計數器），並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外部創建，並且任何滿足條件的表達式（包括更改計數器）都必須在迴圈內部維護。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i); i++; } ✅ 你會在什麼情況下選擇使用 for 迴圈而不是 while 迴圈？17K 名讀者在 StackOverflow 上有相同的疑問，其中一些意見可能會 引起你的興趣。 迴圈與陣列 陣列經常與迴圈一起使用，因為大多數條件需要依賴陣列的長度來停止迴圈，而索引也可以作為計數器的值。 ```javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; for (let i = 0; i < iceCreamFlavorslength; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 547,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "a62b1070fe941ac082ddcf26e8424a09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎：陣列與迴圈",
    "content": "Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ 在瀏覽器控制台中執行這段程式碼。當你對計數器、條件或迭代表達式進行小改動時會發生什麼？你能讓它倒數，創建一個倒計時嗎？ While 迴圈 與 for 迴圈的語法不同，while 迴圈只需要一個條件，當條件變為 false 時迴圈停止。迴圈中的條件通常依賴於其他值（如計數器），並且必須在迴圈中進行管理。計數器的初始值必須在迴圈外部創建，並且任何滿足條件的表達式（包括更改計數器）都必須在迴圈內部維護。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i); i++; } ✅ 你會在什麼情況下選擇使用 for 迴圈而不是 while 迴圈？17K 名讀者在 StackOverflow 上有相同的疑問，其中一些意見可能會 引起你的興趣。 迴圈與陣列 陣列經常與迴圈一起使用，因為大多數條件需要依賴陣列的長度來停止迴圈，而索引也可以作為計數器的值。 ```javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; for (let i = 0; i < iceCreamFlavorslength; i++) { consolelog(iceCreamFlavors[i]);\n} //Ends when all flavors are printed\n```\n✅ 在瀏覽器的控制台中嘗試用迴圈遍歷一個你自己創建的陣列。\n🚀 挑戰\n除了 for 和 while 迴圈之外，還有其他方式可以遍歷陣列，例如 forEach、for-of 和 map。試著用這些技術之一重寫你的陣列迴圈。\n課後測驗\n課後測驗\n複習與自學\nJavaScript 中的陣列有許多附加的方法，這些方法對於資料操作非常有用。閱讀這些方法 並嘗試在你自己創建的陣列上使用一些方法（例如 push、pop、slice 和 splice）。\n作業\n遍歷陣列\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6872,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 942,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "ec9421cf4c66dbd774869d5741d6d2da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "玻璃花園專案第 3 部分：DOM 操作與閉包\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n操作 DOM（文件物件模型）是網頁開發中的一個關鍵部分。根據 MDN 的定義：「文件物件模型 (DOM) 是一種數據表示形式，用於描述構成網頁結構和內容的物件。」由於操作 DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！\n此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。\nJavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。\n我們將使用閉包來操作 DOM。\n可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。\nDOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui\n在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。\n前置條件\n你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。\n任務\n在你的玻璃花園資料夾中，建立一個名為 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 768,
    "chunk_index": 0,
    "total_chunks": 50
  },
  {
    "id": "ff79a0d7b55a90ef6c39c01921977075",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "玻璃花園專案第 3 部分：DOM 操作與閉包\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n操作 DOM（文件物件模型）是網頁開發中的一個關鍵部分。根據 MDN 的定義：「文件物件模型 (DOM) 是一種數據表示形式，用於描述構成網頁結構和內容的物件。」由於操作 DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！\n此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。\nJavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。\n我們將使用閉包來操作 DOM。\n可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。\nDOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui\n在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。\n前置條件\n你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。\n任務\n在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案：\nhtml\n<script src=\"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 801,
    "chunk_index": 1,
    "total_chunks": 50
  },
  {
    "id": "866d6f31af05307ccbd822f9b0037f67",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "玻璃花園專案第 3 部分：DOM 操作與閉包\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n操作 DOM（文件物件模型）是網頁開發中的一個關鍵部分。根據 MDN 的定義：「文件物件模型 (DOM) 是一種數據表示形式，用於描述構成網頁結構和內容的物件。」由於操作 DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！\n此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。\nJavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。\n我們將使用閉包來操作 DOM。\n可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。\nDOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui\n在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。\n前置條件\n你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。\n任務\n在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案：\nhtml\n<script src=\"/script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 802,
    "chunk_index": 2,
    "total_chunks": 50
  },
  {
    "id": "a70069863424d6886f61d3e9b6e41339",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "玻璃花園專案第 3 部分：DOM 操作與閉包\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n操作 DOM（文件物件模型）是網頁開發中的一個關鍵部分。根據 MDN 的定義：「文件物件模型 (DOM) 是一種數據表示形式，用於描述構成網頁結構和內容的物件。」由於操作 DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！\n此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。\nJavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。\n我們將使用閉包來操作 DOM。\n可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。\nDOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui\n在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。\n前置條件\n你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。\n任務\n在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案：\nhtml\n<script src=\"/scriptjs\" defer></script>\n> 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。\nDOM 元素\n首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。\n任務\nhtml\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 993,
    "chunk_index": 3,
    "total_chunks": 50
  },
  {
    "id": "ec3352e6769f4d115e2bd8f4d537014d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "(DOM) 是一種數據表示形式，用於描述構成網頁結構和內容的物件。」由於操作 DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 894,
    "chunk_index": 4,
    "total_chunks": 50
  },
  {
    "id": "45214ec9421781ae4229c078597c29b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "是一種數據表示形式，用於描述構成網頁結構和內容的物件。」由於操作 DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 900,
    "chunk_index": 5,
    "total_chunks": 50
  },
  {
    "id": "3fb55d5c6e70a22f167d1d5ddcd66615",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "DOM 的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 865,
    "chunk_index": 6,
    "total_chunks": 50
  },
  {
    "id": "60ac85ba9e8fe18bac0b30a0f9ddddda",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "的挑戰，許多開發者選擇使用 JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 873,
    "chunk_index": 7,
    "total_chunks": 50
  },
  {
    "id": "53a5169818a81c21220484f4838cc280",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "JavaScript 框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 863,
    "chunk_index": 8,
    "total_chunks": 50
  },
  {
    "id": "392e5a91bde28b056d0945f3a032333a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "框架來取代原生 JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 870,
    "chunk_index": 9,
    "total_chunks": 50
  },
  {
    "id": "08d67498d816471f058b9893d4258a16",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "JavaScript 進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 869,
    "chunk_index": 10,
    "total_chunks": 50
  },
  {
    "id": "998425d19fb0667835c5b6110d9f12a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "進行 DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 876,
    "chunk_index": 11,
    "total_chunks": 50
  },
  {
    "id": "942c98da0d8e960d98f056274cdc7d48",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "DOM 管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 882,
    "chunk_index": 12,
    "total_chunks": 50
  },
  {
    "id": "ca81b8171e46db32dac2fbefc38644ca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "管理，但我們這次將自己動手完成！ 此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 887,
    "chunk_index": 13,
    "total_chunks": 50
  },
  {
    "id": "cbce4b351dfbd573736bc9bb0cca1b3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "此外，本課程還會介紹 JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 877,
    "chunk_index": 14,
    "total_chunks": 50
  },
  {
    "id": "ea353edab997a19dcb9f1e431a67a935",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "JavaScript 閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 872,
    "chunk_index": 15,
    "total_chunks": 50
  },
  {
    "id": "41056b94effdfb968c7ff9266cd118a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "閉包 的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 880,
    "chunk_index": 16,
    "total_chunks": 50
  },
  {
    "id": "6c071e1351e664931fa8b114e63591d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "的概念。你可以將閉包理解為一個被另一個函式包裹的函式，內部函式可以訪問外部函式的作用域。 JavaScript 閉包是一個廣泛且複雜的主題。本課程僅涉及最基本的概念：在這個玻璃花園的程式碼中，你會發現一個閉包——一個內部函式和一個外部函式的結構，讓內部函式可以訪問外部函式的作用域。若想深入了解其運作方式，請參考 詳細文檔。 我們將使用閉包來操作 DOM。 可以將 DOM 想像成一棵樹，代表了網頁文件可以被操作的所有方式。各種 API（應用程式介面）被設計出來，讓程式員可以使用自己選擇的程式語言來訪問 DOM，並進行編輯、修改、重組或其他管理操作。 DOM 和對應的 HTML 標記的表示圖。來源：Olfa Nasraoui 在本課程中，我們將完成互動式玻璃花園專案，通過 JavaScript 讓使用者能夠操作頁面上的植物。 前置條件 你應該已經完成了玻璃花園的 HTML 和 CSS 部分。在本課程結束時，你將能夠通過拖放功能將植物移入或移出玻璃花園。 任務 在你的玻璃花園資料夾中，建立一個名為 scriptjs 的新檔案，並在 <head> 區域中引入該檔案： html <script src=\"/scriptjs\" defer></script> > 注意：在將外部 JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14'));\n這裡發生了什麼？你正在引用文件，並在其 DOM 中尋找具有特定 Id 的元素。還記得我們在 HTML 課程中為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些 Id。識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函式（稍後會建立）。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。\n✅ 為什麼我們通過 Id 引用元素？為什麼不使用它們的 CSS 類別？你可以回顧之前的 CSS 課程來回答這個問題。\n閉包\n現在你可以建立 dragElement 閉包了，這是一個外部函式，包裹了一個或多個內部函式（在我們的案例中是三個）。\n當一個或多個函式需要訪問外部函式的作用域時，閉包非常有用。以下是一個範例：\njavascript\nfunction displayCandy(){\nlet candy = ['jellybeans'];\nfunction addCandy(candyType) {\ncandy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1261,
    "chunk_index": 17,
    "total_chunks": 50
  },
  {
    "id": "ad5430c241ba3f85e9049af69f65e162",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "JavaScript 檔案引入 HTML 時，使用 defer 屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 這裡發生了什麼？你正在引用文件，並在其 DOM 中尋找具有特定 Id 的元素。還記得我們在 HTML 課程中為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些 Id。識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函式（稍後會建立）。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不使用它們的 CSS 類別？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你可以建立 dragElement 閉包了，這是一個外部函式，包裹了一個或多個內部函式（在我們的案例中是三個）。 當一個或多個函式需要訪問外部函式的作用域時，閉包非常有用。以下是一個範例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType)\n}\naddCandy('gumdrops');\n}\ndisplayCandy();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 698,
    "chunk_index": 18,
    "total_chunks": 50
  },
  {
    "id": "b975ce5c570ca4d7831448032418819b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "屬性，這樣可以確保 JavaScript 在 HTML 完全加載後才執行。你也可以使用 async 屬性，允許腳本在 HTML 解析時執行，但在我們的案例中，確保 HTML 元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 這裡發生了什麼？你正在引用文件，並在其 DOM 中尋找具有特定 Id 的元素。還記得我們在 HTML 課程中為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些 Id。識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函式（稍後會建立）。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不使用它們的 CSS 類別？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你可以建立 dragElement 閉包了，這是一個外部函式，包裹了一個或多個內部函式（在我們的案例中是三個）。 當一個或多個函式需要訪問外部函式的作用域時，閉包非常有用。以下是一個範例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy)\n在這個範例中，displayCandy 函式包裹了一個函式，該函式將新的糖果類型推入已存在於函式中的陣列。如果你執行這段程式碼，candy 陣列將是未定義的，因為它是閉包的區域變數。\n✅ 如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。\n任務\n在 script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 880,
    "chunk_index": 19,
    "total_chunks": 50
  },
  {
    "id": "70ab5f50ebe6ce5f16ad40d7570cc7f1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "元素完全可用以進行拖放操作是很重要的。 DOM 元素 首先，你需要在 DOM 中建立對要操作的元素的引用。在我們的案例中，這些元素是目前位於側邊欄的 14 個植物。 任務 html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); 這裡發生了什麼？你正在引用文件，並在其 DOM 中尋找具有特定 Id 的元素。還記得我們在 HTML 課程中為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些 Id。識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函式（稍後會建立）。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不使用它們的 CSS 類別？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你可以建立 dragElement 閉包了，這是一個外部函式，包裹了一個或多個內部函式（在我們的案例中是三個）。 當一個或多個函式需要訪問外部函式的作用域時，閉包非常有用。以下是一個範例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在這個範例中，displayCandy 函式包裹了一個函式，該函式將新的糖果類型推入已存在於函式中的陣列。如果你執行這段程式碼，candy 陣列將是未定義的，因為它是閉包的區域變數。 ✅ 如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。 任務 在 scriptjs 中的元素聲明下方，建立一個函式：\njavascript\nfunction dragElement(terrariumElement) {\n//set 4 positions for positioning on the screen\nlet pos1 = 0,\npos2 = 0,\npos3 = 0,\npos4 = 0;\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 879,
    "chunk_index": 20,
    "total_chunks": 50
  },
  {
    "id": "6b3283086c3d1935af3521dfe3b3c94f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "Id 的元素。還記得我們在 HTML 課程中為每個植物圖片分配了唯一的 Id（例如 id=\"plant1\"）嗎？現在你將利用這些 Id。識別每個元素後，你將該項目傳遞給一個名為 dragElement 的函式（稍後會建立）。因此，HTML 中的元素現在已啟用拖動功能，或者即將啟用。 ✅ 為什麼我們通過 Id 引用元素？為什麼不使用它們的 CSS 類別？你可以回顧之前的 CSS 課程來回答這個問題。 閉包 現在你可以建立 dragElement 閉包了，這是一個外部函式，包裹了一個或多個內部函式（在我們的案例中是三個）。 當一個或多個函式需要訪問外部函式的作用域時，閉包非常有用。以下是一個範例： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在這個範例中，displayCandy 函式包裹了一個函式，該函式將新的糖果類型推入已存在於函式中的陣列。如果你執行這段程式碼，candy 陣列將是未定義的，因為它是閉包的區域變數。 ✅ 如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。 任務 在 scriptjs 中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag;\n}\ndragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。\n此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。\n✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。\nPointerdrag 函式\nterrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1089,
    "chunk_index": 21,
    "total_chunks": 50
  },
  {
    "id": "5bd37029d4d145fb77b602209983b425",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) 在這個範例中，displayCandy 函式包裹了一個函式，該函式將新的糖果類型推入已存在於函式中的陣列。如果你執行這段程式碼，candy 陣列將是未定義的，因為它是閉包的區域變數。 ✅ 如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。 任務 在 scriptjs 中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;：\n任務\njavascript\nfunction pointerDrag(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 22,
    "total_chunks": 50
  },
  {
    "id": "5deea7351b37e72c01c0dc35880114ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "在這個範例中，displayCandy 函式包裹了一個函式，該函式將新的糖果類型推入已存在於函式中的陣列。如果你執行這段程式碼，candy 陣列將是未定義的，因為它是閉包的區域變數。 ✅ 如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。 任務 在 scriptjs 中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 745,
    "chunk_index": 23,
    "total_chunks": 50
  },
  {
    "id": "102bdadba4ab2c20087f499c49cca64c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "函式包裹了一個函式，該函式將新的糖果類型推入已存在於函式中的陣列。如果你執行這段程式碼，candy 陣列將是未定義的，因為它是閉包的區域變數。 ✅ 如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。 任務 在 scriptjs 中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e);\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 24,
    "total_chunks": 50
  },
  {
    "id": "ebc5c85336153b5eaacf03815de8b09b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "如何讓 candy 陣列可訪問？嘗試將它移到閉包之外。這樣，該陣列將變為全域變數，而不是僅限於閉包的區域作用域。 任務 在 scriptjs 中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 651,
    "chunk_index": 25,
    "total_chunks": 50
  },
  {
    "id": "dae1abb12eaffe1ea531c435a457bc81",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "任務 在 scriptjs 中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY;\n}\n這裡發生了幾件事。首先，你通過使用 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 599,
    "chunk_index": 26,
    "total_chunks": 50
  },
  {
    "id": "57227774e3544a6d212352e7b98d888a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "中的元素聲明下方，建立一個函式： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。\n當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 673,
    "chunk_index": 27,
    "total_chunks": 50
  },
  {
    "id": "6c6d7975338ac44ed7d820062d44f7fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "//set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？\n其次，打開瀏覽器中的 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 674,
    "chunk_index": 28,
    "total_chunks": 50
  },
  {
    "id": "794f10551fbd4d5b0f37a3edf7215925",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！\n接下來，注意如何將區域變數 pos3 和 pos4 設置為 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 777,
    "chunk_index": 29,
    "total_chunks": 50
  },
  {
    "id": "dc3c64f47ed2aa6d0b30ff66442a483b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElement 從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。\n✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？\n完成初始函式，通過在 pos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 965,
    "chunk_index": 30,
    "total_chunks": 50
  },
  {
    "id": "05a57e2a419569a992831d9831fc3836",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "從腳本頂部的聲明中獲取其 terrariumElement 物件。然後，你為傳遞到函式的物件設置了一些初始位置，這些位置的值為 0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作：\nhtml\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 954,
    "chunk_index": 31,
    "total_chunks": 50
  },
  {
    "id": "fb1949eeaa92ee63cd866233a8fb078d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "0。這些是區域變數，將在閉包內部為每個元素添加拖放功能時進行操作。玻璃花園將由這些被拖動的元素填充，因此應用程式需要跟蹤它們的放置位置。 此外，傳遞給該函式的 terrariumElement 被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 896,
    "chunk_index": 32,
    "total_chunks": 50
  },
  {
    "id": "e3bf0dc4f19a031e692aff656b47fbd5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "被分配了一個 pointerdown 事件，這是 web API 的一部分，旨在幫助管理 DOM。onpointerdown 事件在按下按鈕時觸發，或者在我們的案例中，當觸摸一個可拖動的元素時觸發。該事件處理器適用於 網頁和行動瀏覽器，但有少數例外。 ✅ 事件處理器 onclick 在跨瀏覽器方面有更廣泛的支援；為什麼不在這裡使用它？想一想你希望在這裡創建的精確螢幕互動類型。 Pointerdrag 函式 terrariumElement 現在已準備好被拖動；當觸發 onpointerdown 事件時，函式 pointerDrag 被調用。在這行程式碼下方新增該函式：terrariumElementonpointerdown = pointerDrag;： 任務 javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag;\n現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。\nelementDrag 和 stopElementDrag 函式\n你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。\n任務\n在 pointerDrag 的結尾大括號後新增 elementDrag 函式：\njavascript\nfunction elementDrag(e) {\npos1 = pos3 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1119,
    "chunk_index": 33,
    "total_chunks": 50
  },
  {
    "id": "a5532b3245ba7a3d17d3d0aa55d40d80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "= eclientY; } 這裡發生了幾件事。首先，你通過使用 epreventDefault(); 阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX;\npos2 = pos4 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 820,
    "chunk_index": 34,
    "total_chunks": 50
  },
  {
    "id": "6cd832cbe2759432a10dee0e5de84fa8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "阻止了 pointerdown 事件的預設行為。這樣你可以更好地控制介面的行為。 當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY;\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 794,
    "chunk_index": 35,
    "total_chunks": 50
  },
  {
    "id": "af949bf58f3b51eaa9c1064e28072907",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "當你完全建立腳本檔案後，回到這行程式碼並嘗試移除 epreventDefault()——會發生什麼？ 其次，打開瀏覽器中的 indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 761,
    "chunk_index": 36,
    "total_chunks": 50
  },
  {
    "id": "258fe17364f8cadb14c481a5fcd312b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "indexhtml，檢查介面。當你點擊一個植物時，你可以看到如何捕獲 'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 700,
    "chunk_index": 37,
    "total_chunks": 50
  },
  {
    "id": "c9bf5d085ed93f3883a4328721d8d1cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "'e' 事件。深入檢查該事件，看看在一次 pointerdown 事件中收集了多少資訊！ 接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4);\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 38,
    "total_chunks": 50
  },
  {
    "id": "56ac222732c2c55f802e9e8fb2ea3fd6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 641,
    "chunk_index": 39,
    "total_chunks": 50
  },
  {
    "id": "5bbdea45049fe779bc60c99c23f3b4de",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "接下來，注意如何將區域變數 pos3 和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 40,
    "total_chunks": 50
  },
  {
    "id": "4744438a11c85a4b650b95423fbd3a1b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "和 pos4 設置為 eclientX。你可以在檢查面板中找到 e 的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px';\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 638,
    "chunk_index": 41,
    "total_chunks": 50
  },
  {
    "id": "6d3fdff41d28e359e559a16486e815ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 612,
    "chunk_index": 42,
    "total_chunks": 50
  },
  {
    "id": "c4fa36bfa4c881dea77bb1fc926f6de2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "的值。這些值捕獲了你點擊或觸摸植物時的 x 和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 617,
    "chunk_index": 43,
    "total_chunks": 50
  },
  {
    "id": "1d1a31e71094d464ff94e40288c10f09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "和 y 座標。由於你需要對植物的拖動行為進行精細控制，因此需要跟蹤它們的座標。 ✅ 現在是否更清楚為什麼整個應用程式是用一個大的閉包構建的？如果不是閉包，你將如何為 14 個可拖動的植物維持作用域？ 完成初始函式，通過在 pos4 = eclientY 下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px';\n}\n在這個函式中，你對先前在外部函式中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？\n當你拖動時，你通過將 pos3（之前設置為 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 682,
    "chunk_index": 44,
    "total_chunks": 50
  },
  {
    "id": "02cebc34b92cd33a463c5f09fcff6b64",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "下方新增兩個指針事件操作： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函式中，你對先前在外部函式中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 536,
    "chunk_index": 45,
    "total_chunks": 50
  },
  {
    "id": "a4a67f38d21360251804d21fd7b28a66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; 現在你正在指示希望植物隨著指針移動，並在取消選擇植物時停止拖動。onpointermove 和 onpointerup 都是與 onpointerdown 相同 API 的一部分。介面現在會拋出錯誤，因為你尚未定義 elementDrag 和 stopElementDrag 函式，因此接下來建立這些函式。 elementDrag 和 stopElementDrag 函式 你將通過新增兩個內部函式來完成閉包，這些函式將處理拖動植物和停止拖動時的行為。你希望的行為是，隨時可以拖動任何植物，並將其放置在螢幕上的任何位置。這個介面非常自由（例如，沒有放置區域），讓你可以自由設計玻璃花園，隨意新增、移除和重新定位植物。 任務 在 pointerDrag 的結尾大括號後新增 elementDrag 函式： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函式中，你對先前在外部函式中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 eclientX 值來重新分配 pos1。對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重設為元素的新 X 和 Y 座標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據這些新位置計算植物的上方和左側 X 和 Y 座標，並設置其新位置。\noffsetTop 和 offsetLeft 是 CSS 屬性，用於根據父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。\n所有這些位置的重新計算讓你可以微調玻璃花園和植物的行為。\n任務\n完成介面的最後一步是在 elementDrag 的結尾大括號後新增 stopElementDrag 函式：\njavascript\nfunction stopElementDrag() {\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 795,
    "chunk_index": 46,
    "total_chunks": 50
  },
  {
    "id": "41f0b421cdf15d35639115baef9fd400",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函式中，你對先前在外部函式中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 eclientX 值來重新分配 pos1。對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重設為元素的新 X 和 Y 座標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據這些新位置計算植物的上方和左側 X 和 Y 座標，並設置其新位置。 offsetTop 和 offsetLeft 是 CSS 屬性，用於根據父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。 所有這些位置的重新計算讓你可以微調玻璃花園和植物的行為。 任務 完成介面的最後一步是在 elementDrag 的結尾大括號後新增 stopElementDrag 函式： javascript function stopElementDrag() { documentonpointerup = null;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 459,
    "chunk_index": 47,
    "total_chunks": 50
  },
  {
    "id": "4a99d94ce0d67beaaa5baa6b721e3058",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } 在這個函式中，你對先前在外部函式中設置的初始位置 1-4 進行了大量編輯。這裡發生了什麼？ 當你拖動時，你通過將 pos3（之前設置為 eclientX）減去當前的 eclientX 值來重新分配 pos1。對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重設為元素的新 X 和 Y 座標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據這些新位置計算植物的上方和左側 X 和 Y 座標，並設置其新位置。 offsetTop 和 offsetLeft 是 CSS 屬性，用於根據父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。 所有這些位置的重新計算讓你可以微調玻璃花園和植物的行為。 任務 完成介面的最後一步是在 elementDrag 的結尾大括號後新增 stopElementDrag 函式： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null;\n}\n這個小函式重設了 onpointerup 和 onpointermove 事件，這樣你可以重新開始拖動植物，或者開始拖動新的植物。\n✅ 如果你不將這些事件設置為 null，會發生什麼？\n現在你已經完成了專案！\n🥇恭喜！你已經完成了美麗的玻璃花園！\n🚀挑戰\n為你的閉包新增一個事件處理器，讓植物可以執行更多操作；例如，雙擊植物將其移到最前面。發揮創意吧！\n課後測驗\n課後測驗\n複習與自學\n雖然在螢幕上拖動元素看起來很簡單，但根據你想要的效果，有許多方法可以實現，並且可能會遇到許多陷阱。事實上，有一整套 拖放 API 可供嘗試。我們在本模組中沒有使用該 API，因為我們想要的效果有些不同，但你可以在自己的專案中嘗試這個 API，看看能實現什麼。\n在 W3C 文檔 和 MDN 網頁文檔 上找到更多關於指針事件的資訊。\n隨時使用 CanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 898,
    "chunk_index": 48,
    "total_chunks": 50
  },
  {
    "id": "469e0dd70433915bc85eb8adf292d477",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "玻璃花園專案第 3 部分：DOM 操作與閉包",
    "content": "eclientX）減去當前的 eclientX 值來重新分配 pos1。對 pos2 進行了類似的操作。然後，你將 pos3 和 pos4 重設為元素的新 X 和 Y 座標。你可以在拖動時在控制台中觀察這些變化。接著，你操作植物的 CSS 樣式，根據這些新位置計算植物的上方和左側 X 和 Y 座標，並設置其新位置。 offsetTop 和 offsetLeft 是 CSS 屬性，用於根據父元素設置元素的位置；其父元素可以是任何非 static 定位的元素。 所有這些位置的重新計算讓你可以微調玻璃花園和植物的行為。 任務 完成介面的最後一步是在 elementDrag 的結尾大括號後新增 stopElementDrag 函式： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null; } 這個小函式重設了 onpointerup 和 onpointermove 事件，這樣你可以重新開始拖動植物，或者開始拖動新的植物。 ✅ 如果你不將這些事件設置為 null，會發生什麼？ 現在你已經完成了專案！ 🥇恭喜！你已經完成了美麗的玻璃花園！ 🚀挑戰 為你的閉包新增一個事件處理器，讓植物可以執行更多操作；例如，雙擊植物將其移到最前面。發揮創意吧！ 課後測驗 課後測驗 複習與自學 雖然在螢幕上拖動元素看起來很簡單，但根據你想要的效果，有許多方法可以實現，並且可能會遇到許多陷阱。事實上，有一整套 拖放 API 可供嘗試。我們在本模組中沒有使用該 API，因為我們想要的效果有些不同，但你可以在自己的專案中嘗試這個 API，看看能實現什麼。 在 W3C 文檔 和 MDN 網頁文檔 上找到更多關於指針事件的資訊。 隨時使用 CanIUsecom 檢查瀏覽器的支援能力。\n作業\n進一步操作 DOM\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而產生的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12489,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 956,
    "chunk_index": 49,
    "total_chunks": 50
  },
  {
    "id": "1b5e49144df8c00a565781140eb2c8ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "程式語言與工具介紹\n本課程涵蓋程式語言的基礎知識。這些主題適用於當今大多數現代程式語言。在「工具介紹」部分，您將學習一些對開發者有幫助的實用軟體。\n手繪筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將討論：\n什麼是程式設計？\n程式語言的種類\n程式的基本元素\n專業開發者常用的實用軟體與工具\n您可以在 Microsoft Learn 上學習本課程！\n什麼是程式設計？\n程式設計（也稱為編碼）是為電腦或行動裝置等設備撰寫指令的過程。我們使用程式語言來撰寫這些指令，然後由設備解讀這些指令。這些指令集可能有不同的名稱，例如 程式、電腦程式、應用程式（app） 和 可執行檔 等。\n程式 可以是任何用程式碼撰寫的東西；網站、遊戲和手機應用程式都是程式。雖然可以在不撰寫程式碼的情況下創建程式，但其底層邏輯仍需由設備解讀，而這些邏輯很可能是用程式碼撰寫的。一個正在 執行 或 運行 程式碼的程式正在執行指令。您正在使用的設備正運行一個程式，將這篇課程顯示在您的螢幕上。\n✅ 做一些研究：誰被認為是世界上第一位電腦程式設計師？\n程式語言\n程式語言使開發者能夠為設備撰寫指令。設備只能理解二進位（1 和 0），而對於 大多數 開發者來說，這並不是一種高效的溝通方式。程式語言是人類與電腦之間的溝通工具。\n程式語言有不同的格式，可能用於不同的目的。例如，JavaScript 主要用於網頁應用程式，而 Bash 主要用於作業系統。\n低階語言 通常比 高階語言 需要更少的步驟來讓設備解讀指令。然而，高階語言因其可讀性和支援性而受到歡迎。JavaScript 被認為是一種高階語言。\n以下程式碼展示了使用高階語言（JavaScript）與低階語言（ARM 組合語言）的差異。\n```javascript\nlet number = 10\nlet n1 = 0, n2 = 1, nextTerm;\nfor (let i = 1; i <= number; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11894,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 969,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "da6f3c723f0b8f10db3f4d9b269b4a34",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "程式語言與工具介紹\n本課程涵蓋程式語言的基礎知識。這些主題適用於當今大多數現代程式語言。在「工具介紹」部分，您將學習一些對開發者有幫助的實用軟體。\n手繪筆記由 Tomomi Imura 提供\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將討論：\n什麼是程式設計？\n程式語言的種類\n程式的基本元素\n專業開發者常用的實用軟體與工具\n您可以在 Microsoft Learn 上學習本課程！\n什麼是程式設計？\n程式設計（也稱為編碼）是為電腦或行動裝置等設備撰寫指令的過程。我們使用程式語言來撰寫這些指令，然後由設備解讀這些指令。這些指令集可能有不同的名稱，例如 程式、電腦程式、應用程式（app） 和 可執行檔 等。\n程式 可以是任何用程式碼撰寫的東西；網站、遊戲和手機應用程式都是程式。雖然可以在不撰寫程式碼的情況下創建程式，但其底層邏輯仍需由設備解讀，而這些邏輯很可能是用程式碼撰寫的。一個正在 執行 或 運行 程式碼的程式正在執行指令。您正在使用的設備正運行一個程式，將這篇課程顯示在您的螢幕上。\n✅ 做一些研究：誰被認為是世界上第一位電腦程式設計師？\n程式語言\n程式語言使開發者能夠為設備撰寫指令。設備只能理解二進位（1 和 0），而對於 大多數 開發者來說，這並不是一種高效的溝通方式。程式語言是人類與電腦之間的溝通工具。\n程式語言有不同的格式，可能用於不同的目的。例如，JavaScript 主要用於網頁應用程式，而 Bash 主要用於作業系統。\n低階語言 通常比 高階語言 需要更少的步驟來讓設備解讀指令。然而，高階語言因其可讀性和支援性而受到歡迎。JavaScript 被認為是一種高階語言。\n以下程式碼展示了使用高階語言（JavaScript）與低階語言（ARM 組合語言）的差異。\n```javascript\nlet number = 10\nlet n1 = 0, n2 = 1, nextTerm;\nfor (let i = 1; i <= number; i++) {\nconsolelog(n1);\nnextTerm = n1 + n2;\nn1 = n2;\nn2 = nextTerm;\n}\n```\nc\narea ascen,code,readonly\nentry\ncode32\nadr r0,thumb+1\nbx r0\ncode16\nthumb\nmov r0,#00\nsub r0,r0,#01\nmov r1,#01\nmov r4,#10\nldr r2,=0x40000000\nback add r0,r1\nstr r0,[r2]\nadd r2,#04\nmov r3,r0\nmov r0,r1\nmov r1,r3\nsub r4,#01\ncmp r4,#00\nbne back\nend\n相信或不相信，它們都在做同一件事：列印前 10 個 Fibonacci 數列。\n✅ Fibonacci 數列被定義為一組數字，其中每個數字是前兩個數字的總和，從 0 和 1 開始。前 10 個 Fibonacci 數列為 0, 1, 1, 2, 3, 5, 8, 13, 21 和 34。\n程式的基本元素\n程式中的單一指令稱為 語句，通常會有一個字符或行間距來標記指令的結束，稱為 終止符。程式如何終止因語言而異。\n程式中的語句可能依賴用戶或其他地方提供的數據來執行指令。數據可以改變程式的行為，因此程式語言提供了一種臨時存儲數據的方法，以便稍後使用。這些稱為 變數。變數是指令，指示設備將數據存儲在其記憶體中。程式中的變數類似於代數中的變數，它們有唯一的名稱，其值可能隨時間改變。\n某些語句可能不會被設備執行。這通常是開發者設計的結果，或者是意外錯誤導致的。這種對應用程式的控制使其更具穩定性和可維護性。通常，這些控制的變化發生在滿足某些條件時。if",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11894,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1641,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "953be7d56600955ad80bff1aec6d2461",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "``` c area ascen,code,readonly entry code32 adr r0,thumb+1 bx r0 code16 thumb mov r0,#00 sub r0,r0,#01 mov r1,#01 mov r4,#10 ldr r2,=0x40000000 back add r0,r1 str r0,[r2] add r2,#04 mov r3,r0 mov r0,r1 mov r1,r3 sub r4,#01 cmp r4,#00 bne back end 相信或不相信，它們都在做同一件事：列印前 10 個 Fibonacci 數列。 ✅ Fibonacci 數列被定義為一組數字，其中每個數字是前兩個數字的總和，從 0 和 1 開始。前 10 個 Fibonacci 數列為 0, 1, 1, 2, 3, 5, 8, 13, 21 和 34。 程式的基本元素 程式中的單一指令稱為 語句，通常會有一個字符或行間距來標記指令的結束，稱為 終止符。程式如何終止因語言而異。 程式中的語句可能依賴用戶或其他地方提供的數據來執行指令。數據可以改變程式的行為，因此程式語言提供了一種臨時存儲數據的方法，以便稍後使用。這些稱為 變數。變數是指令，指示設備將數據存儲在其記憶體中。程式中的變數類似於代數中的變數，它們有唯一的名稱，其值可能隨時間改變。 某些語句可能不會被設備執行。這通常是開發者設計的結果，或者是意外錯誤導致的。這種對應用程式的控制使其更具穩定性和可維護性。通常，這些控制的變化發生在滿足某些條件時。ifelse 語句是現代程式設計中常用來控制程式運行方式的語句。\n✅ 您將在後續課程中學習更多關於這種類型語句的內容。\n工具介紹\n🎥 點擊上方圖片觀看有關工具的影片\n在本節中，您將學習一些在開始專業開發旅程時可能非常有用的軟體。\n開發環境 是開發者在撰寫軟體時經常使用的一組獨特工具和功能。其中一些工具已根據開發者的特定需求進行了自訂，並可能隨著開發者的工作重點、個人項目或使用不同程式語言而改變。開發環境如同開發者本身一樣獨特。\n編輯器\n編輯器是軟體開發中最重要的工具之一。編輯器是您撰寫程式碼的地方，有時也是您運行程式碼的地方。\n開發者依賴編輯器的幾個額外原因包括：\n除錯 幫助逐行檢查程式碼以發現錯誤。一些編輯器具有除錯功能；它們可以針對特定程式語言進行自訂和添加。\n語法高亮 為程式碼添加顏色和文字格式，使其更易於閱讀。大多數編輯器允許自訂語法高亮。\n擴展與整合 是為開發者設計的專用工具，這些工具並未內建於基礎編輯器中。例如，許多開發者會為程式碼添加文件說明，解釋其工作原理。他們可能會安裝拼寫檢查擴展來幫助發現文件中的拼寫錯誤。大多數擴展是針對特定編輯器設計的，而大多數編輯器都提供了搜尋可用擴展的方法。\n自訂化 使開發者能夠創建符合其需求的獨特開發環境。大多數編輯器都高度可自訂，並且可能允許開發者創建自訂擴展。\n常見編輯器與網頁開發擴展\nVisual Studio Code\nCode Spell Checker\nLive Share\nPrettier - Code formatter\nAtom\nspell-check\nteletype\natom-beautify\nSublimetext\nemmet\nSublimeLinter\n瀏覽器\n另一個重要工具是瀏覽器。網頁開發者依賴瀏覽器來檢視其程式碼在網頁上的運行效果。瀏覽器還用於顯示在編輯器中撰寫的網頁元素，例如 HTML。\n許多瀏覽器內建 開發者工具（DevTools），其中包含一組有用的功能和資訊，幫助開發者收集和捕捉有關其應用程式的重要資訊。例如：如果網頁出現錯誤，了解錯誤發生的時間有時會很有幫助。瀏覽器中的開發者工具可以配置以捕捉這些資訊。\n常見瀏覽器與開發者工具\nEdge\nChrome\nFirefox\n命令列工具\n一些開發者偏好使用較少圖形化的界面來完成日常任務，並依賴命令列來實現這一點。撰寫程式碼需要大量的打字工作，一些開發者偏好不打斷鍵盤上的工作流程。他們會使用鍵盤快捷鍵在桌面窗口之間切換、處理不同文件以及使用工具。大多數任務可以用滑鼠完成，但使用命令列的一個好處是可以在不切換滑鼠和鍵盤的情況下完成許多操作。命令列的另一個好處是它們可以配置，您可以保存自訂配置，稍後更改，並將其匯入其他開發機器。由於開發環境對每個開發者來說都是獨特的，有些人會完全避免使用命令列，有些人會完全依賴它，而有些人則偏好兩者結合。\n常見命令列選項\n命令列選項會根據您使用的作業系統而有所不同。\n💻 = 作業系統預裝。\nWindows\nPowershell 💻\nCommand Line（也稱為 CMD）💻\nWindows Terminal\nmintty\nMacOS\nTerminal 💻\niTerm\nPowershell\nLinux\nBash 💻\nKDE Konsole\nPowershell\n常見命令列工具\nGit（大多數作業系統預裝 💻）\nNPM\nYarn\n文件\n當開發者想學習新事物時，他們很可能會查閱文件以了解如何使用它。開發者經常依賴文件來指導他們正確使用工具和語言，並深入了解其工作原理。\n常見網頁開發文件\nMozilla Developer Network (MDN)，由 Firefox 瀏覽器的發行商 Mozilla 提供\nFrontend Masters\nWeb",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11894,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2342,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "d287eb21e4fe0ae261715d82f1e174d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "程式語言與工具介紹",
    "content": "使開發者能夠創建符合其需求的獨特開發環境。大多數編輯器都高度可自訂，並且可能允許開發者創建自訂擴展。 常見編輯器與網頁開發擴展 Visual Studio Code Code Spell Checker Live Share Prettier - Code formatter Atom spell-check teletype atom-beautify Sublimetext emmet SublimeLinter 瀏覽器 另一個重要工具是瀏覽器。網頁開發者依賴瀏覽器來檢視其程式碼在網頁上的運行效果。瀏覽器還用於顯示在編輯器中撰寫的網頁元素，例如 HTML。 許多瀏覽器內建 開發者工具（DevTools），其中包含一組有用的功能和資訊，幫助開發者收集和捕捉有關其應用程式的重要資訊。例如：如果網頁出現錯誤，了解錯誤發生的時間有時會很有幫助。瀏覽器中的開發者工具可以配置以捕捉這些資訊。 常見瀏覽器與開發者工具 Edge Chrome Firefox 命令列工具 一些開發者偏好使用較少圖形化的界面來完成日常任務，並依賴命令列來實現這一點。撰寫程式碼需要大量的打字工作，一些開發者偏好不打斷鍵盤上的工作流程。他們會使用鍵盤快捷鍵在桌面窗口之間切換、處理不同文件以及使用工具。大多數任務可以用滑鼠完成，但使用命令列的一個好處是可以在不切換滑鼠和鍵盤的情況下完成許多操作。命令列的另一個好處是它們可以配置，您可以保存自訂配置，稍後更改，並將其匯入其他開發機器。由於開發環境對每個開發者來說都是獨特的，有些人會完全避免使用命令列，有些人會完全依賴它，而有些人則偏好兩者結合。 常見命令列選項 命令列選項會根據您使用的作業系統而有所不同。 💻 = 作業系統預裝。 Windows Powershell 💻 Command Line（也稱為 CMD）💻 Windows Terminal mintty MacOS Terminal 💻 iTerm Powershell Linux Bash 💻 KDE Konsole Powershell 常見命令列工具 Git（大多數作業系統預裝 💻） NPM Yarn 文件 當開發者想學習新事物時，他們很可能會查閱文件以了解如何使用它。開發者經常依賴文件來指導他們正確使用工具和語言，並深入了解其工作原理。 常見網頁開發文件 Mozilla Developer Network (MDN)，由 Firefox 瀏覽器的發行商 Mozilla 提供 Frontend Masters Webdev，由 Chrome 的發行商 Google 提供\nMicrosoft 的開發者文件，適用於 Microsoft Edge\nW3 Schools\n✅ 做一些研究：現在您已了解網頁開發者的環境，試著將其與網頁設計師的環境進行比較和對比。\n🚀 挑戰\n比較一些程式語言。JavaScript 與 Java 有哪些獨特的特性？COBOL 與 Go 又如何？\n課後測驗\n課後測驗\n複習與自學\n學習程式設計師可用的不同語言。嘗試用一種語言撰寫一行程式碼，然後用另外兩種語言重寫它。您學到了什麼？\n作業\n閱讀文件\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於關鍵資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11894,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1447,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "ad134582714ce72c0f6a16de290f37b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\assignment.md",
    "source_type": "git_repo",
    "title": "分析一個無法訪問的網站",
    "content": "分析一個無法訪問的網站\n指導說明\n找出一個您認為無法訪問的網站，並制定一個行動計劃來改善其可訪問性。\n您的第一個任務是識別這個網站，詳細說明您認為它無法訪問的方式（不使用分析工具），然後提交給 Lighthouse 進行分析。將此分析的結果保存為 PDF，並列出一個包含至少十點的詳細計劃，說明如何改進該網站。\n測試網站可訪問性的表格\n| 標準     | 優秀       | 足夠       | 需要改進         |\n|----------|-----------|----------|----------------|\n|          | 缺少不到 10% 的要求 | 缺少 20% 的要求  | 缺少 50% 的要求  |\n學生報告：包括關於網站無法訪問程度的段落、以 PDF 保存的 Lighthouse 報告、一份包含十點改進建議的清單，以及如何改進的詳細說明\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對於因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1565,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 538,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0eba306f018860453149454a507cccf6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\1-getting-started-lessons\\README.md",
    "source_type": "git_repo",
    "title": "Introdução ao Desenvolvimento Web",
    "content": "Introdução ao Desenvolvimento Web\nNesta secção do currículo, será apresentado a conceitos não baseados em projetos que são importantes para se tornar um programador profissional.\nTópicos\nIntrodução às Linguagens de Programação e Ferramentas do Ofício\nIntrodução ao GitHub\nNoções Básicas de Acessibilidade\nCréditos\nIntrodução às Linguagens de Programação e Ferramentas do Ofício foi escrito com ♥️ por Jasmine Greenaway\nIntrodução ao GitHub foi escrito com ♥️ por Floor Drees\nNoções Básicas de Acessibilidade foi escrito com ♥️ por Christopher Harrison\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se a tradução profissional humana. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1653,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\1-getting-started-lessons\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 270,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "405d0d06e175712c15e5a88d7c537bf5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\2-js-basics\\README.md",
    "source_type": "git_repo",
    "title": "Introdução ao JavaScript",
    "content": "Introdução ao JavaScript\nJavaScript é a linguagem da web. Nestes quatro módulos, vais aprender os seus conceitos básicos.\nTópicos\nVariáveis e Tipos de Dados\nFunções e Métodos\nTomar Decisões com JavaScript\nArrays e Ciclos\nCréditos\nEstes módulos foram escritos com ♥️ por Jasmine Greenaway, Christopher Harrison e Chris Noring\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1417,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\2-js-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 218,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0fa5ade4c9757d7441f1d1dd6ac2fe50",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\README.md",
    "source_type": "git_repo",
    "title": "O Meu Terrário: Um projeto para aprender sobre HTML, CSS e manipulação do DOM usando JavaScript 🌵🌱",
    "content": "O Meu Terrário: Um projeto para aprender sobre HTML, CSS e manipulação do DOM usando JavaScript 🌵🌱\nUm pequeno exercício de arrastar e soltar para meditação com código. Com um pouco de HTML, JS e CSS, será possível criar uma interface web, estilizar e até adicionar várias interações à sua escolha.\nLições\nIntrodução ao HTML\nIntrodução ao CSS\nIntrodução ao DOM e Fechos em JS\nCréditos\nEscrito com ♥️ por Jen Looper\nO terrário criado via CSS foi inspirado no frasco de vidro de Jakub Mandra codepen.\nAs ilustrações foram desenhadas à mão por Jen Looper com a ajuda do Procreate.\nPublique o seu Terrário\nPode publicar o seu terrário na web utilizando o Azure Static Web Apps.\nFaça um fork deste repositório\nClique neste botão\nSiga o assistente para criar a sua aplicação. Certifique-se de que define a raiz da aplicação como /solution ou a raiz da sua base de código. Não há API nesta aplicação, por isso não se preocupe em adicionar isso. Uma pasta do GitHub será criada no repositório que fez fork e ajudará os serviços de build do Azure Static Web Apps a construir e publicar a sua aplicação para um novo URL.\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2516,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 431,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "700ff41e96fcc28504950017a97441c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\4-typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Programação Orientada a Eventos - Crie um Jogo de Digitação",
    "content": "Programação Orientada a Eventos - Crie um Jogo de Digitação\nIntrodução\nDigitar é uma das habilidades mais subestimadas de um programador. A capacidade de transferir rapidamente pensamentos da sua cabeça para o editor permite que a criatividade flua livremente. Uma das melhores formas de aprender é jogando!\nEntão, vamos criar um jogo de digitação!\nVocê vai usar as habilidades de JavaScript, HTML e CSS que desenvolveu até agora para criar um jogo de digitação. O jogo apresentará ao jogador uma citação aleatória (estamos usando citações de Sherlock Holmes) e medirá quanto tempo o jogador leva para digitá-la com precisão. Você vai usar as habilidades de JavaScript, HTML e CSS que desenvolveu até agora para criar um jogo de digitação.\nPré-requisitos\nEsta lição pressupõe que você está familiarizado com os seguintes conceitos:\nCriar controles de entrada de texto e botões\nCSS e definição de estilos usando classes\nNoções básicas de JavaScript\nCriar um array\nGerar um número aleatório\nObter o horário atual\nLição\nCriação de um jogo de digitação usando programação orientada a eventos\nCréditos\nEscrito com ♥️ por Christopher Harrison\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2245,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\4-typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 417,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "11b0695f64d62904b3715f83345a28b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma extensão de navegador",
    "content": "Criar uma extensão de navegador\nCriar extensões de navegador é uma forma divertida e interessante de pensar sobre o desempenho das suas aplicações enquanto desenvolve um tipo diferente de recurso web Este módulo inclui lições sobre como os navegadores funcionam, como implementar uma extensão de navegador, como criar um formulário, chamar uma API, usar armazenamento local e como avaliar o desempenho do seu site e melhorá-lo Você irá criar uma extensão de navegador que funciona no Edge, Chrome e Firefox Esta extensão, que é como um mini site web adaptado para uma tarefa muito específica, verifica a API CO2 Signal para o uso de eletricidade e intensidade de carbono de uma determinada região e retorna uma leitura sobre a pegada de carbono dessa região Esta extensão pode ser chamada sob demanda por um utilizador, após inserir uma chave de API e um código de região num formulário, para determinar o uso local de eletricidade e, assim, oferecer dados que podem influenciar as decisões de consumo de eletricidade do utilizador Por exemplo, pode ser preferível adiar o uso de uma máquina de secar roupa (uma atividade com alta intensidade de carbono) durante um período de elevado consumo de eletricidade na sua região Tópicos\nSobre o navegador\nFormulários e armazenamento local\nTarefas em segundo plano e desempenho\nCréditos\nCréditos\nA ideia para este gatilho de carbono web foi sugerida por Asim Hussain, líder na Microsoft da equipa de Green Cloud Advocacy e autor dos Green Principles Originalmente, era um projeto de site web A estrutura da extensão de navegador foi influenciada pela extensão COVID de Adebola Adeniran O conceito por trás do sistema de ícones 'dot' foi inspirado pela estrutura de ícones da extensão de navegador Energy Lollipop para emissões na Califórnia Estas lições foram escritas com ♥️ por Jen Looper\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3188,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "10186c5d5efdbd47061cd1d449589d23",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma extensão de navegador",
    "content": "Advocacy e autor dos Green Principles Originalmente, era um projeto de site web A estrutura da extensão de navegador foi influenciada pela extensão COVID de Adebola Adeniran O conceito por trás do sistema de ícones 'dot' foi inspirado pela estrutura de ícones da extensão de navegador Energy Lollipop para emissões na Califórnia Estas lições foram escritas com ♥️ por Jen Looper Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op TranslatorEmbora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3188,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 221,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "5829ee72ca64422c06366a4e016254c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "Crie um Jogo Espacial",
    "content": "Crie um Jogo Espacial\nUm jogo espacial para ensinar fundamentos mais avançados de JavaScript\nNesta lição, vais aprender a criar o teu próprio jogo espacial. Se já jogaste o jogo \"Space Invaders\", este jogo tem a mesma ideia: controlar uma nave espacial e disparar contra monstros que descem do topo. Aqui está como o jogo finalizado irá parecer:\nNestes seis módulos vais aprender o seguinte:\nInteragir com o elemento Canvas para desenhar coisas no ecrã\nCompreender o sistema de coordenadas cartesianas\nAprender o padrão Pub-Sub para criar uma arquitetura de jogo sólida, mais fácil de manter e expandir\nUtilizar Async/Await para carregar recursos do jogo\nLidar com eventos de teclado\nVisão Geral\nTeoria\nIntrodução à criação de jogos com JavaScript\nPrática\nDesenhar no canvas\nMover elementos pelo ecrã\nDeteção de colisões\nManter a pontuação\nTerminar e reiniciar o jogo\nCréditos\nOs recursos utilizados para este projeto vieram de https://www.kenney.nl/.\nSe estás interessado em criar jogos, estes são recursos realmente bons. Muitos são gratuitos e alguns são pagos.\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2273,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 425,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "fdb53e6c5059fd02a44229a7d277a0a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\README.md",
    "source_type": "git_repo",
    "title": ":dollar: Construir um Banco",
    "content": ":dollar: Construir um Banco\nNeste projeto, vais aprender a construir um banco fictício. Estas lições incluem instruções sobre como estruturar uma aplicação web e fornecer rotas, criar formulários, gerir estado e obter dados de uma API da qual podes buscar os dados do banco.\n|  |  |\n|-------------------------------|-------------------------------|\nLições\nTemplates HTML e Rotas numa Aplicação Web\nCriar um Formulário de Login e Registo\nMétodos para Obter e Utilizar Dados\nConceitos de Gestão de Estado\nCréditos\nEstas lições foram escritas com :hearts: por Yohan Lasorsa.\nSe estiveres interessado em aprender como construir a API do servidor utilizada nestas lições, podes seguir esta série de vídeos (em particular os vídeos 17 a 21).\nTambém podes dar uma vista de olhos a este tutorial interativo do Learn.\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2038,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 338,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c7aa6227a53874bd1236aa0349b00cb8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\docs\\_navbar.md",
    "source_type": "git_repo",
    "title": "_navbar",
    "content": "Traduções\nEnglish (United States)\nবাংলা\n中文(中国)\n中文(台湾)\nEspañol\nFrançais\nΕλληνικά\nहिन्दी\nBahasa Melayu\nമലയാളം\nதமிழ்\nతెలుగు\nBahasa Indonesia\nItaliano\n日本語\nNederlands\nनेपाली\nPortuguês\nРусский\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1716,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\docs\\_navbar.md",
      "source_type": "git_repo"
    },
    "token_count": 253,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "13821c7fd7071e067f9172a8ff94c1fb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\docs\\_sidebar.md",
    "source_type": "git_repo",
    "title": "_sidebar",
    "content": "Introdução\n1\n2\n3\nFundamentos de JS\n4\n5\n6\n7\nHTML, CSS, JS\n8\n9\n10\nJogo de digitação\n11\nExtensão para navegador\n12\n13\n14\nJogo Espacial\n15\n16\n17\n18\n19\n20\nProjeto Bancário\n21\n22\n23\n24\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2356,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\docs\\_sidebar.md",
      "source_type": "git_repo"
    },
    "token_count": 215,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "eabfa8a7b8272c873d34ec24c4cd3cc7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\lesson-template\\assignment.md",
    "source_type": "git_repo",
    "title": "[Nome da Tarefa]",
    "content": "[Nome da Tarefa]\nInstruções\nRubrica\n| Critérios | Exemplar | Adequado | Necessita de Melhorias |\n| --------- | -------- | -------- | ---------------------- |\n|           |          |          |                        |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, é importante notar que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes da utilização desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1072,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\lesson-template\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 182,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "8c8d0b5e581a69168c4a806db63b8ab2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "建立無障礙的網頁\n由 Tomomi Imura 繪製的手繪筆記\n課前測驗\n課前測驗\n網路的力量在於它的普及性。無論是否有障礙，讓每個人都能使用是其核心要素。\n- 提姆·伯納斯-李爵士，W3C 主席暨全球資訊網發明者\n這句話完美地突顯了建立無障礙網站的重要性。一個無法讓所有人使用的應用程式，本質上就是排他的。作為網頁開發者，我們應該始終將無障礙性放在心上。從一開始就專注於此，將幫助你確保每個人都能訪問你創建的頁面。在本課中，你將學習如何使用工具來確保你的網頁資產是無障礙的，以及如何以無障礙性為核心進行設計。\n你可以在 Microsoft Learn 上學習本課！\n可用工具\n螢幕閱讀器\n最知名的無障礙工具之一是螢幕閱讀器。\n螢幕閱讀器 是視障人士常用的工具。當我們花時間確保瀏覽器能正確傳遞我們想分享的資訊時，我們也必須確保螢幕閱讀器能做到同樣的事情。\n最基本的螢幕閱讀器會從上到下以語音方式讀取頁面內容。如果你的頁面全是文字，閱讀器會以類似瀏覽器的方式傳遞資訊。然而，網頁很少僅包含文字；它們通常還包含連結、圖片、顏色和其他視覺元素。我們需要確保這些資訊能被螢幕閱讀器正確讀取。\n每位網頁開發者都應該熟悉螢幕閱讀器。正如上文所述，這是你的使用者會使用的工具。就像你熟悉瀏覽器的運作方式一樣，你也應該了解螢幕閱讀器的運作方式。幸運的是，大多數作業系統都內建了螢幕閱讀器。\n一些瀏覽器也內建了工具和擴充功能，可以朗讀文字，甚至提供一些基本的導航功能，例如 這些專注於無障礙性的 Edge 瀏覽器工具。這些工具也是重要的無障礙工具，但它們的功能與螢幕閱讀器非常不同，不能將它們視為螢幕閱讀器測試工具。\n✅ 試用螢幕閱讀器和瀏覽器的文字朗讀功能。在 Windows 上，Narrator 是預設內建的，還可以安裝 JAWS 和 NVDA。在 macOS 和 iOS 上，VoiceOver 是預設內建的。\n放大功能\n另一個視障人士常用的工具是放大功能。最基本的放大方式是靜態放大，可以透過 Control + 加號 (+) 或降低螢幕解析度來實現。這種放大方式會使整個頁面重新調整大小，因此使用 響應式設計 對於在高放大級別下提供良好的使用者體驗非常重要。\n另一種放大方式依賴於專門的軟體來放大螢幕的一個區域並進行平移，就像使用真正的放大鏡一樣。在 Windows 上，Magnifier 是內建的，而 ZoomText 是一款第三方放大軟體，功能更多且用戶群更大。在 macOS 和 iOS 上，有一款內建的放大軟體叫 Zoom。\n對比檢查工具\n網站上的顏色需要仔細選擇，以滿足色盲使用者或難以辨識低對比顏色的人的需求。\n✅ 使用瀏覽器擴充功能（例如 WCAG 的顏色檢查工具）測試你喜歡的網站的顏色使用情況。你學到了什麼？\nLighthouse\n在瀏覽器的開發者工具區域，你會找到 Lighthouse 工具。這個工具對於初步檢視網站的無障礙性（以及其他分析）非常重要。雖然不應完全依賴 Lighthouse，但 100% 的分數作為基準是非常有幫助的。\n✅ 在瀏覽器的開發者工具面板中找到 Lighthouse，並對任何網站進行分析。你發現了什麼？\n無障礙設計\n無障礙性是一個相對廣泛的主題。為了幫助你，有許多資源可供使用。\nAccessible U - 明尼蘇達大學\n雖然我們無法涵蓋建立無障礙網站的每個方面，但以下是一些你需要實施的核心原則。從一開始就設計無障礙頁面總是比事後修改現有頁面更容易。\n良好的顯示原則\n安全的色彩調色盤\n每個人看世界的方式都不同，包括對顏色的感知。在為你的網站選擇配色方案時，你應確保它對所有人都是無障礙的。一個很棒的 生成調色盤的工具是 Color Safe。\n✅ 找出一個在顏色使用上非常有問題的網站。為什麼？\n使用正確的 HTML\n透過 CSS 和 JavaScript，可以讓任何元素看起來像任何類型的控制項。例如，<span> 可以用來創建 <button>，而 <b> 可以變成超連結。雖然這樣可能更容易設計，但對螢幕閱讀器來說毫無意義。在頁面上創建控制項時，應使用適當的 HTML。如果你需要一個超連結，請使用 <a>。使用正確的 HTML 創建控制項被稱為使用語義化 HTML。\n✅ 打開任何網站，檢查設計師和開發者是否正確使用了 HTML。你能找到應該是連結但卻是按鈕的例子嗎？提示：右鍵點擊並選擇「檢視頁面原始碼」來查看底層代碼。\n創建描述性的標題層次結構\n螢幕閱讀器使用者非常依賴標題來尋找資訊並導航頁面。撰寫描述性的標題內容並使用語義化的標題標籤，對於為螢幕閱讀器使用者創建易於導航的網站非常重要。\n使用良好的視覺提示\nCSS 提供了對頁面上任何元素外觀的完全控制。你可以創建沒有邊框的文字框或沒有底線的超連結。不幸的是，移除這些提示可能會讓依賴它們的人更難辨識控制項的類型。\n超連結文字的重要性\n超連結是網路導航的核心。因此，確保螢幕閱讀器能正確讀取連結，讓所有使用者都能導航你的網站。\n螢幕閱讀器與連結\n正如你所預期的，螢幕閱讀器會像讀取頁面上的其他文字一樣讀取連結文字。考慮到這一點，以下示例中的文字可能看起來完全可以接受。\n小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。點擊這裡 獲取更多資訊。\n小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。訪問 https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2670,
    "chunk_index": 0,
    "total_chunks": 8
  },
  {
    "id": "dbc2ea42eb85167bd2867d695778ab22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "或降低螢幕解析度來實現。這種放大方式會使整個頁面重新調整大小，因此使用 響應式設計 對於在高放大級別下提供良好的使用者體驗非常重要。 另一種放大方式依賴於專門的軟體來放大螢幕的一個區域並進行平移，就像使用真正的放大鏡一樣。在 Windows 上，Magnifier 是內建的，而 ZoomText 是一款第三方放大軟體，功能更多且用戶群更大。在 macOS 和 iOS 上，有一款內建的放大軟體叫 Zoom。 對比檢查工具 網站上的顏色需要仔細選擇，以滿足色盲使用者或難以辨識低對比顏色的人的需求。 ✅ 使用瀏覽器擴充功能（例如 WCAG 的顏色檢查工具）測試你喜歡的網站的顏色使用情況。你學到了什麼？ Lighthouse 在瀏覽器的開發者工具區域，你會找到 Lighthouse 工具。這個工具對於初步檢視網站的無障礙性（以及其他分析）非常重要。雖然不應完全依賴 Lighthouse，但 100% 的分數作為基準是非常有幫助的。 ✅ 在瀏覽器的開發者工具面板中找到 Lighthouse，並對任何網站進行分析。你發現了什麼？ 無障礙設計 無障礙性是一個相對廣泛的主題。為了幫助你，有許多資源可供使用。 Accessible U - 明尼蘇達大學 雖然我們無法涵蓋建立無障礙網站的每個方面，但以下是一些你需要實施的核心原則。從一開始就設計無障礙頁面總是比事後修改現有頁面更容易。 良好的顯示原則 安全的色彩調色盤 每個人看世界的方式都不同，包括對顏色的感知。在為你的網站選擇配色方案時，你應確保它對所有人都是無障礙的。一個很棒的 生成調色盤的工具是 Color Safe。 ✅ 找出一個在顏色使用上非常有問題的網站。為什麼？ 使用正確的 HTML 透過 CSS 和 JavaScript，可以讓任何元素看起來像任何類型的控制項。例如，<span> 可以用來創建 <button>，而 <b> 可以變成超連結。雖然這樣可能更容易設計，但對螢幕閱讀器來說毫無意義。在頁面上創建控制項時，應使用適當的 HTML。如果你需要一個超連結，請使用 <a>。使用正確的 HTML 創建控制項被稱為使用語義化 HTML。 ✅ 打開任何網站，檢查設計師和開發者是否正確使用了 HTML。你能找到應該是連結但卻是按鈕的例子嗎？提示：右鍵點擊並選擇「檢視頁面原始碼」來查看底層代碼。 創建描述性的標題層次結構 螢幕閱讀器使用者非常依賴標題來尋找資訊並導航頁面。撰寫描述性的標題內容並使用語義化的標題標籤，對於為螢幕閱讀器使用者創建易於導航的網站非常重要。 使用良好的視覺提示 CSS 提供了對頁面上任何元素外觀的完全控制。你可以創建沒有邊框的文字框或沒有底線的超連結。不幸的是，移除這些提示可能會讓依賴它們的人更難辨識控制項的類型。 超連結文字的重要性 超連結是網路導航的核心。因此，確保螢幕閱讀器能正確讀取連結，讓所有使用者都能導航你的網站。 螢幕閱讀器與連結 正如你所預期的，螢幕閱讀器會像讀取頁面上的其他文字一樣讀取連結文字。考慮到這一點，以下示例中的文字可能看起來完全可以接受。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。點擊這裡 獲取更多資訊。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。訪問 https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1621,
    "chunk_index": 1,
    "total_chunks": 8
  },
  {
    "id": "b5449e4aefde726221444eaae7f0fe21",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "或降低螢幕解析度來實現。這種放大方式會使整個頁面重新調整大小，因此使用 響應式設計 對於在高放大級別下提供良好的使用者體驗非常重要。 另一種放大方式依賴於專門的軟體來放大螢幕的一個區域並進行平移，就像使用真正的放大鏡一樣。在 Windows 上，Magnifier 是內建的，而 ZoomText 是一款第三方放大軟體，功能更多且用戶群更大。在 macOS 和 iOS 上，有一款內建的放大軟體叫 Zoom。 對比檢查工具 網站上的顏色需要仔細選擇，以滿足色盲使用者或難以辨識低對比顏色的人的需求。 ✅ 使用瀏覽器擴充功能（例如 WCAG 的顏色檢查工具）測試你喜歡的網站的顏色使用情況。你學到了什麼？ Lighthouse 在瀏覽器的開發者工具區域，你會找到 Lighthouse 工具。這個工具對於初步檢視網站的無障礙性（以及其他分析）非常重要。雖然不應完全依賴 Lighthouse，但 100% 的分數作為基準是非常有幫助的。 ✅ 在瀏覽器的開發者工具面板中找到 Lighthouse，並對任何網站進行分析。你發現了什麼？ 無障礙設計 無障礙性是一個相對廣泛的主題。為了幫助你，有許多資源可供使用。 Accessible U - 明尼蘇達大學 雖然我們無法涵蓋建立無障礙網站的每個方面，但以下是一些你需要實施的核心原則。從一開始就設計無障礙頁面總是比事後修改現有頁面更容易。 良好的顯示原則 安全的色彩調色盤 每個人看世界的方式都不同，包括對顏色的感知。在為你的網站選擇配色方案時，你應確保它對所有人都是無障礙的。一個很棒的 生成調色盤的工具是 Color Safe。 ✅ 找出一個在顏色使用上非常有問題的網站。為什麼？ 使用正確的 HTML 透過 CSS 和 JavaScript，可以讓任何元素看起來像任何類型的控制項。例如，<span> 可以用來創建 <button>，而 <b> 可以變成超連結。雖然這樣可能更容易設計，但對螢幕閱讀器來說毫無意義。在頁面上創建控制項時，應使用適當的 HTML。如果你需要一個超連結，請使用 <a>。使用正確的 HTML 創建控制項被稱為使用語義化 HTML。 ✅ 打開任何網站，檢查設計師和開發者是否正確使用了 HTML。你能找到應該是連結但卻是按鈕的例子嗎？提示：右鍵點擊並選擇「檢視頁面原始碼」來查看底層代碼。 創建描述性的標題層次結構 螢幕閱讀器使用者非常依賴標題來尋找資訊並導航頁面。撰寫描述性的標題內容並使用語義化的標題標籤，對於為螢幕閱讀器使用者創建易於導航的網站非常重要。 使用良好的視覺提示 CSS 提供了對頁面上任何元素外觀的完全控制。你可以創建沒有邊框的文字框或沒有底線的超連結。不幸的是，移除這些提示可能會讓依賴它們的人更難辨識控制項的類型。 超連結文字的重要性 超連結是網路導航的核心。因此，確保螢幕閱讀器能正確讀取連結，讓所有使用者都能導航你的網站。 螢幕閱讀器與連結 正如你所預期的，螢幕閱讀器會像讀取頁面上的其他文字一樣讀取連結文字。考慮到這一點，以下示例中的文字可能看起來完全可以接受。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。點擊這裡 獲取更多資訊。 小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。訪問 https://enwikipediaorg/wiki/Little_penguin 獲取更多資訊。\nNOTE 如你即將閱讀的內容，永遠不要像上面那樣創建連結。\n記住，螢幕閱讀器是一種與瀏覽器不同的介面，具有不同的功能集。\n使用 URL 的問題\n螢幕閱讀器會讀取文字。如果文字中出現 URL，螢幕閱讀器會讀取該 URL。一般來說，URL 並不能傳遞有意義的資訊，並且聽起來可能很煩人。如果你的手機曾經語音讀取過帶有 URL 的簡訊，你可能會有這樣的體驗。\n使用「點擊這裡」的問題\n螢幕閱讀器也能只讀取頁面上的超連結，就像視力正常的人會掃描頁面尋找連結一樣。如果連結文字總是「點擊這裡」，使用者聽到的將是「點擊這裡，點擊這裡，點擊這裡，點擊這裡，點擊這裡，……」所有連結現在都無法區分。\n良好的連結文字\n良好的連結文字應簡要描述連結的內容。在上面關於小企鵝的例子中，連結指向該物種的維基百科頁面。「小企鵝」這個短語作為連結文字非常合適，因為它清楚地表明點擊連結後可以學到什麼——小企鵝。\n小企鵝，有時被稱為仙女企鵝，是世界上最小的企鵝。\n✅ 瀏覽網路幾分鐘，找出使用模糊連結策略的頁面。將它們與其他連結更好的網站進行比較。你學到了什麼？\n搜尋引擎的注意事項\n確保網站對所有人無障礙的額外好處是，你也會幫助搜尋引擎更好地導航你的網站。搜尋引擎使用連結文字來了解頁面的主題。因此，使用良好的連結文字對每個人都有幫助！\nARIA\n想像以下頁面：\n| 產品          | 描述              | 訂購              |\n| ------------- | ----------------- | ----------------- |\n| Widget        | 描述       |\n| Super widget  | 描述       |\n在這個例子中，對於使用瀏覽器的人來說，重複「描述」和「訂購」的文字是有意義的。然而，使用螢幕閱讀器的人只會聽到「描述」和「訂購」重複出現，沒有上下文。\n為了支援這類情境，HTML 支援一組稱為 無障礙豐富網際網路應用程式 (ARIA) 的屬性。這些屬性允許你為螢幕閱讀器提供額外的資訊。\nNOTE：與 HTML 的許多方面一樣，瀏覽器和螢幕閱讀器的支援可能會有所不同。然而，大多數主流客戶端都支援 ARIA 屬性。\n你可以使用 aria-label 來描述連結，當頁面的格式不允許你這麼做時。例如，Widget 的描述可以設置為：\nhtml\n<a href=\"#\" aria-label=\"Widget description\">description</a>\n✅ 一般來說，使用上述的語義化標記比使用 ARIA 更優先，但有時某些 HTML 元件並沒有語義化的對應。例如樹狀結構。HTML 中沒有樹狀結構的對應標籤，因此你需要為這個通用的 <div> 元素指定適當的角色和 ARIA 值。MDN 上的 ARIA 文件 包含更多有用的資訊。\n```html\nFile Viewer\nUploads\n```\n圖片\n不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片是無障礙的並不需要太多工作——這正是 alt 屬性的用途所在。所有有意義的圖片都應該有一個 alt 屬性來描述它們的內容。\n純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。\n✅ 正如你可能預期的，搜尋引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保你的頁面是無障礙的還能帶來額外的好處！\n鍵盤\n有些使用者無法使用滑鼠或觸控板，而是依賴鍵盤操作來從一個元素切換到下一個元素。確保你的網站以邏輯順序呈現內容，讓鍵盤使用者可以按順序訪問每個互動元素。如果你使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，你的網站應該是可用鍵盤導航的，但手動測試這一點仍然很重要。了解更多 鍵盤導航策略。\n✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些部分有效，哪些無效？為什麼？\n總結\n一個僅對部分人無障礙的網路，並不是真正的「全球資訊網」。確保你創建的網站是無障礙的最佳方式，是從一開始就將無障礙性最佳實踐納入設計中。雖然這需要額外的步驟，但現在將這些技能融入你的工作流程，意味著你創建的所有頁面都將是無障礙的。\n🚀 挑戰\n將以下 HTML 重寫為盡可能無障礙，運用你學到的策略。\n```html\nExample\nTurtle Ipsum\nThe World's Premier Turtle Fan Club\nResources\n\"I like turtles\"\nBasic Turtle Info\nChocolate Turtles\nWelcome to Turtle Ipsum",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 3711,
    "chunk_index": 2,
    "total_chunks": 8
  },
  {
    "id": "5f00dc4b329f2834dbb4fb4a2d1a9c9c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "的描述可以設置為： html <a href=\"#\" aria-label=\"Widget description\">description</a> ✅ 一般來說，使用上述的語義化標記比使用 ARIA 更優先，但有時某些 HTML 元件並沒有語義化的對應。例如樹狀結構。HTML 中沒有樹狀結構的對應標籤，因此你需要為這個通用的 <div> 元素指定適當的角色和 ARIA 值。MDN 上的 ARIA 文件 包含更多有用的資訊。 ```html File Viewer Uploads ``` 圖片 不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片是無障礙的並不需要太多工作——這正是 alt 屬性的用途所在。所有有意義的圖片都應該有一個 alt 屬性來描述它們的內容。 純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。 ✅ 正如你可能預期的，搜尋引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保你的頁面是無障礙的還能帶來額外的好處！ 鍵盤 有些使用者無法使用滑鼠或觸控板，而是依賴鍵盤操作來從一個元素切換到下一個元素。確保你的網站以邏輯順序呈現內容，讓鍵盤使用者可以按順序訪問每個互動元素。如果你使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，你的網站應該是可用鍵盤導航的，但手動測試這一點仍然很重要。了解更多 鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些部分有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網路，並不是真正的「全球資訊網」。確保你創建的網站是無障礙的最佳方式，是從一開始就將無障礙性最佳實踐納入設計中。雖然這需要額外的步驟，但現在將這些技能融入你的工作流程，意味著你創建的所有頁面都將是無障礙的。 🚀 挑戰 將以下 HTML 重寫為盡可能無障礙，運用你學到的策略。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn more",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 951,
    "chunk_index": 3,
    "total_chunks": 8
  },
  {
    "id": "54501c51e2922dcc265e742aae519767",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "aria-label=\"Widget description\">description</a> ✅ 一般來說，使用上述的語義化標記比使用 ARIA 更優先，但有時某些 HTML 元件並沒有語義化的對應。例如樹狀結構。HTML 中沒有樹狀結構的對應標籤，因此你需要為這個通用的 <div> 元素指定適當的角色和 ARIA 值。MDN 上的 ARIA 文件 包含更多有用的資訊。 ```html File Viewer Uploads ``` 圖片 不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片是無障礙的並不需要太多工作——這正是 alt 屬性的用途所在。所有有意義的圖片都應該有一個 alt 屬性來描述它們的內容。 純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。 ✅ 正如你可能預期的，搜尋引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保你的頁面是無障礙的還能帶來額外的好處！ 鍵盤 有些使用者無法使用滑鼠或觸控板，而是依賴鍵盤操作來從一個元素切換到下一個元素。確保你的網站以邏輯順序呈現內容，讓鍵盤使用者可以按順序訪問每個互動元素。如果你使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，你的網站應該是可用鍵盤導航的，但手動測試這一點仍然很重要。了解更多 鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些部分有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網路，並不是真正的「全球資訊網」。確保你創建的網站是無障礙的最佳方式，是從一開始就將無障礙性最佳實踐納入設計中。雖然這需要額外的步驟，但現在將這些技能融入你的工作流程，意味著你創建的所有頁面都將是無障礙的。 🚀 挑戰 將以下 HTML 重寫為盡可能無障礙，運用你學到的策略。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 958,
    "chunk_index": 4,
    "total_chunks": 8
  },
  {
    "id": "ff41c097cd6404b9a542a05fd0a15a48",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "File Viewer Uploads ``` 圖片 不用說，螢幕閱讀器無法自動讀取圖片中的內容。確保圖片是無障礙的並不需要太多工作——這正是 alt 屬性的用途所在。所有有意義的圖片都應該有一個 alt 屬性來描述它們的內容。 純裝飾性的圖片應將其 alt 屬性設置為空字串：alt=\"\"。這樣可以防止螢幕閱讀器不必要地宣讀裝飾性圖片。 ✅ 正如你可能預期的，搜尋引擎也無法理解圖片中的內容。它們也使用 alt 文本。因此，再次確保你的頁面是無障礙的還能帶來額外的好處！ 鍵盤 有些使用者無法使用滑鼠或觸控板，而是依賴鍵盤操作來從一個元素切換到下一個元素。確保你的網站以邏輯順序呈現內容，讓鍵盤使用者可以按順序訪問每個互動元素。如果你使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，你的網站應該是可用鍵盤導航的，但手動測試這一點仍然很重要。了解更多 鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些部分有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網路，並不是真正的「全球資訊網」。確保你創建的網站是無障礙的最佳方式，是從一開始就將無障礙性最佳實踐納入設計中。雖然這需要額外的步驟，但現在將這些技能融入你的工作流程，意味著你創建的所有頁面都將是無障礙的。 🚀 挑戰 將以下 HTML 重寫為盡可能無障礙，運用你學到的策略。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliquaUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 810,
    "chunk_index": 5,
    "total_chunks": 8
  },
  {
    "id": "b2224ae1546b62f1eb47e78fd206c494",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "文本。因此，再次確保你的頁面是無障礙的還能帶來額外的好處！ 鍵盤 有些使用者無法使用滑鼠或觸控板，而是依賴鍵盤操作來從一個元素切換到下一個元素。確保你的網站以邏輯順序呈現內容，讓鍵盤使用者可以按順序訪問每個互動元素。如果你使用語義化標記構建網頁，並使用 CSS 設計其視覺佈局，你的網站應該是可用鍵盤導航的，但手動測試這一點仍然很重要。了解更多 鍵盤導航策略。 ✅ 打開任何網站，嘗試僅使用鍵盤進行導航。哪些部分有效，哪些無效？為什麼？ 總結 一個僅對部分人無障礙的網路，並不是真正的「全球資訊網」。確保你創建的網站是無障礙的最佳方式，是從一開始就將無障礙性最佳實踐納入設計中。雖然這需要額外的步驟，但現在將這些技能融入你的工作流程，意味著你創建的所有頁面都將是無障礙的。 🚀 挑戰 將以下 HTML 重寫為盡可能無障礙，運用你學到的策略。 ```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliquaUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequatDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 609,
    "chunk_index": 6,
    "total_chunks": 8
  },
  {
    "id": "0b525e49ea8f43246a576cd002dbb993",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "Example",
    "content": "```html Example Turtle Ipsum The World's Premier Turtle Fan Club Resources \"I like turtles\" Basic Turtle Info Chocolate Turtles Welcome to Turtle IpsumClick here to learn moreTurtle ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliquaUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequatDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariaturExcepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\nSign up for turtle news\nInternal Pages\nIndex\nSemantic Example\n© 2016 Instrument\n```\n課後測驗\n課後測驗\n複習與自學\n許多政府對於無障礙需求有相關法律。請了解您所在國家的無障礙法律。哪些內容被涵蓋，哪些未被涵蓋？例如：這個政府網站。\n作業\n分析一個無障礙性不足的網站\n來源: Turtle Ipsum by Instrument\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 471,
    "chunk_index": 7,
    "total_chunks": 8
  },
  {
    "id": "e8958e54bc2745341d1e13da73e1210b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\lesson-template\\README.md",
    "source_type": "git_repo",
    "title": "[Tópico da Aula]",
    "content": "[Tópico da Aula]\nQuestionário pré-aula\n[Descreva o que iremos aprender]\nIntrodução\nDescreva o que será abordado\nNotas\nPré-requisitos\nQue passos devem ter sido concluídos antes desta aula?\nPreparação\nPassos preparatórios para começar esta aula\n[Avance pelo conteúdo em blocos]\n[Tópico 1]\nTarefa:\nTrabalhem juntos para melhorar progressivamente a vossa base de código e construir o projeto com código partilhado:\nhtml\ncode blocks\n✅ Verificação de Conhecimento - aproveite este momento para expandir o conhecimento dos alunos com perguntas abertas\n[Tópico 2]\n[Tópico 3]\n🚀 Desafio: Adicione um desafio para os alunos trabalharem colaborativamente em aula para melhorar o projeto\nOpcional: adicione uma captura de ecrã da interface do utilizador da aula concluída, se apropriado\nQuestionário pós-aula\nRevisão e Estudo Autónomo\nEntrega do Trabalho [MM/AA]: Nome do Trabalho\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1998,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\lesson-template\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 398,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "9be94d0d4358102ced8e93c523e7ab74",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "GitHub 簡介\n本課程涵蓋 GitHub 的基礎知識，這是一個用於託管和管理程式碼變更的平台。\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將探討：\n如何追蹤你在電腦上的工作\n如何與他人合作完成專案\n如何為開源軟體做出貢獻\n先決條件\n在開始之前，你需要檢查是否已安裝 Git。在終端機輸入：\ngit --version\n如果尚未安裝 Git，請下載 Git。然後，在終端機中設定你的本地 Git 配置檔案：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要檢查 Git 是否已配置，可以輸入：\ngit config --list\n你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。\n前往 github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 342,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "3fb24bad152787b66c6256d651fbf06a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "GitHub 簡介\n本課程涵蓋 GitHub 的基礎知識，這是一個用於託管和管理程式碼變更的平台。\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將探討：\n如何追蹤你在電腦上的工作\n如何與他人合作完成專案\n如何為開源軟體做出貢獻\n先決條件\n在開始之前，你需要檢查是否已安裝 Git。在終端機輸入：\ngit --version\n如果尚未安裝 Git，請下載 Git。然後，在終端機中設定你的本地 Git 配置檔案：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要檢查 Git 是否已配置，可以輸入：\ngit config --list\n你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。\n前往 githubcom 建立帳戶（如果尚未建立），或登入並填寫你的個人資料。\n✅ GitHub 不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。\n準備工作\n你需要在本地電腦（筆記型電腦或 PC）上準備一個包含程式碼專案的資料夾，以及一個 GitHub 上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。\n程式碼管理\n假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。\n任務：建立儲存庫並提交程式碼\n查看影片\n在 GitHub 上建立儲存庫。在 GitHub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 737,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "29f88533d7f0eec2041c9d44f28586ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "GitHub 簡介\n本課程涵蓋 GitHub 的基礎知識，這是一個用於託管和管理程式碼變更的平台。\nTomomi Imura 的手繪筆記\n課前測驗\n課前測驗\n簡介\n在本課程中，我們將探討：\n如何追蹤你在電腦上的工作\n如何與他人合作完成專案\n如何為開源軟體做出貢獻\n先決條件\n在開始之前，你需要檢查是否已安裝 Git。在終端機輸入：\ngit --version\n如果尚未安裝 Git，請下載 Git。然後，在終端機中設定你的本地 Git 配置檔案：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\n要檢查 Git 是否已配置，可以輸入：\ngit config --list\n你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。\n前往 githubcom 建立帳戶（如果尚未建立），或登入並填寫你的個人資料。\n✅ GitHub 不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。\n準備工作\n你需要在本地電腦（筆記型電腦或 PC）上準備一個包含程式碼專案的資料夾，以及一個 GitHub 上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。\n程式碼管理\n假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。\n任務：建立儲存庫並提交程式碼\n查看影片\n在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。\n為你的儲存庫（資料夾）命名\n選擇 create repository。\n導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入：\nbash\ncd [name of your folder]\n初始化 Git 儲存庫。在你的專案中輸入：\nbash\ngit init\n檢查狀態。要檢查儲存庫的狀態，輸入：\nbash\ngit status\n輸出的內容可能如下所示：\n```output\nChanges not staged for commit:\n(use \"git add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 970,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "3442072952d8a18bbca165066658d939",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "config --global user email \"your-email\" 要檢查 Git 是否已配置，可以輸入： git config --list 你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。 前往 githubcom 建立帳戶（如果尚未建立），或登入並填寫你的個人資料。 ✅ GitHub 不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記型電腦或 PC）上準備一個包含程式碼專案的資料夾，以及一個 GitHub 上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出的內容可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed)\n(use \"git checkout --",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 729,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "dfcc6e2e2d818453401c19bae6e4200a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "--list 你還需要一個 GitHub 帳戶、一個程式碼編輯器（例如 Visual Studio Code），並打開你的終端機（或命令提示符）。 前往 githubcom 建立帳戶（如果尚未建立），或登入並填寫你的個人資料。 ✅ GitHub 不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記型電腦或 PC）上準備一個包含程式碼專案的資料夾，以及一個 GitHub 上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出的內容可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory)\nmodified:   file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 713,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "93ef0d59ed2d54422714c9afe14c5458",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "githubcom 建立帳戶（如果尚未建立），或登入並填寫你的個人資料。 ✅ GitHub 不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記型電腦或 PC）上準備一個包含程式碼專案的資料夾，以及一個 GitHub 上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出的內容可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt\nmodified:   file2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 658,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "077b57d640a31309e33326f2bef444a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "✅ GitHub 不是世界上唯一的程式碼儲存庫；還有其他選擇，但 GitHub 是最知名的。 準備工作 你需要在本地電腦（筆記型電腦或 PC）上準備一個包含程式碼專案的資料夾，以及一個 GitHub 上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出的內容可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt\n```\n通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。\n添加所有檔案進行追蹤\n這也稱為暫存檔案/將檔案添加到暫存區。\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "58ff37944279cd18b9fd29b3090cca39",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "上的公共儲存庫，這將作為如何為他人專案做出貢獻的示例。 程式碼管理 假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出的內容可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 628,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "4a439bcf12bca417303f8cddaaa750a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "假設你在本地有一個包含程式碼專案的資料夾，並希望使用 Git（版本控制系統）來追蹤你的進度。有些人將使用 Git 比喻為寫給未來自己的情書。幾天、幾週或幾個月後閱讀你的提交訊息時，你能回憶起為什麼做出某個決定，或者「回滾」某個更改——前提是你寫了好的「提交訊息」。 任務：建立儲存庫並提交程式碼 查看影片 在 GitHub 上建立儲存庫。在 GitHubcom 的儲存庫標籤中，或從右上角的導航欄找到 new repo 按鈕。 為你的儲存庫（資料夾）命名 選擇 create repository。 導航到你的工作資料夾。在終端機中，切換到你希望開始追蹤的資料夾（也稱為目錄）。輸入： bash cd [name of your folder] 初始化 Git 儲存庫。在你的專案中輸入： bash git init 檢查狀態。要檢查儲存庫的狀態，輸入： bash git status 輸出的內容可能如下所示： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示所有檔案和更改都將被追蹤。\n選擇性添加檔案進行追蹤\nbash\ngit add [file or folder name]\n當你不希望一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。\n取消暫存所有檔案\nbash\ngit reset\n此命令幫助我們一次取消暫存所有檔案。\n取消暫存特定檔案\nbash\ngit reset [file or folder name]\n此命令幫助我們僅取消暫存特定檔案，避免將其包含在下一次提交中。\n保存你的工作。此時你已將檔案添加到所謂的暫存區，Git 正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交：\nbash\ngit commit -m \"first commit\"\n此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。\n將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令：\n注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1160,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "1dde83354421cca49f552c1e3c8e2456",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "--\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示所有檔案和更改都將被追蹤。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不希望一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令幫助我們僅取消暫存特定檔案，避免將其包含在下一次提交中。 保存你的工作。此時你已將檔案添加到所謂的暫存區，Git 正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交： bash git commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 717,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "b4e61e4d15f50240b4af75e529833c4e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "--\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示所有檔案和更改都將被追蹤。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不希望一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令幫助我們僅取消暫存特定檔案，避免將其包含在下一次提交中。 保存你的工作。此時你已將檔案添加到所謂的暫存區，Git 正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交： bash git commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。\nbash\ngit remote add origin https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 739,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "29a37703c2521ad8281ec8b140616403",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示所有檔案和更改都將被追蹤。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不希望一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令幫助我們僅取消暫存特定檔案，避免將其包含在下一次提交中。 保存你的工作。此時你已將檔案添加到所謂的暫存區，Git 正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交： bash git commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 730,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "67d974cea24382c15f3b2d128773435e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "modified: file2txt ``` 通常，git status 命令會告訴你哪些檔案已準備好保存到儲存庫，或者哪些檔案有更改需要持久化。 添加所有檔案進行追蹤 這也稱為暫存檔案/將檔案添加到暫存區。 bash git addgit add 加上參數表示所有檔案和更改都將被追蹤。 選擇性添加檔案進行追蹤 bash git add [file or folder name] 當你不希望一次提交所有檔案時，這可以幫助我們僅添加選定的檔案到暫存區。 取消暫存所有檔案 bash git reset 此命令幫助我們一次取消暫存所有檔案。 取消暫存特定檔案 bash git reset [file or folder name] 此命令幫助我們僅取消暫存特定檔案，避免將其包含在下一次提交中。 保存你的工作。此時你已將檔案添加到所謂的暫存區，Git 正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交： bash git commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit\n此命令建立了一個名為「origin」的遠端連接，指向你之前建立的 GitHub 儲存庫。\n將本地檔案推送到 GitHub。到目前為止，你已建立本地儲存庫與 GitHub 儲存庫之間的連接。接下來使用 git push 命令將檔案推送到 GitHub，如下所示：\n注意，你的分支名稱可能與 main 不同。\nbash\ngit push -u origin main\n此命令將你的「main」分支中的提交推送到 GitHub。\n添加更多更改。如果你希望繼續進行更改並推送到 GitHub，只需使用以下三個命令：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 938,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "5d755763297cbfc7437215f0f7289e37",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "取消暫存特定檔案 bash git reset [file or folder name] 此命令幫助我們僅取消暫存特定檔案，避免將其包含在下一次提交中。 保存你的工作。此時你已將檔案添加到所謂的暫存區，Git 正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交： bash git commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 此命令建立了一個名為「origin」的遠端連接，指向你之前建立的 GitHub 儲存庫。 將本地檔案推送到 GitHub。到目前為止，你已建立本地儲存庫與 GitHub 儲存庫之間的連接。接下來使用 git push 命令將檔案推送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 不同。 bash git push -u origin main 此命令將你的「main」分支中的提交推送到 GitHub。 添加更多更改。如果你希望繼續進行更改並推送到 GitHub，只需使用以下三個命令： bash git addgit commit -m \"type your commit message here\"\ngit push\n提示，你可能還希望採用",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 707,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "8c49976a24ca4542e0c50b3a9a0bcc39",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "正在追蹤你的檔案。要使更改永久化，你需要提交檔案。提交代表儲存庫歷史中的一個保存點。輸入以下命令來建立提交： bash git commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 此命令建立了一個名為「origin」的遠端連接，指向你之前建立的 GitHub 儲存庫。 將本地檔案推送到 GitHub。到目前為止，你已建立本地儲存庫與 GitHub 儲存庫之間的連接。接下來使用 git push 命令將檔案推送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 不同。 bash git push -u origin main 此命令將你的「main」分支中的提交推送到 GitHub。 添加更多更改。如果你希望繼續進行更改並推送到 GitHub，只需使用以下三個命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能還希望採用gitignore 檔案，以防止你不希望追蹤的檔案出現在 GitHub 上——例如存放在同一資料夾中的筆記檔案，但不適合放在公共儲存庫中。你可以在",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 689,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "a24916f4f3634e579be70bbf1a5b787a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "commit -m \"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 此命令建立了一個名為「origin」的遠端連接，指向你之前建立的 GitHub 儲存庫。 將本地檔案推送到 GitHub。到目前為止，你已建立本地儲存庫與 GitHub 儲存庫之間的連接。接下來使用 git push 命令將檔案推送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 不同。 bash git push -u origin main 此命令將你的「main」分支中的提交推送到 GitHub。 添加更多更改。如果你希望繼續進行更改並推送到 GitHub，只需使用以下三個命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能還希望採用gitignore 檔案，以防止你不希望追蹤的檔案出現在 GitHub 上——例如存放在同一資料夾中的筆記檔案，但不適合放在公共儲存庫中。你可以在gitignore templates 找到",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "9b052fef2262fdac136e461215876fab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "\"first commit\" 此命令提交所有檔案，並添加訊息「first commit」。未來的提交訊息應更具描述性，以傳達你所做的更改類型。 將本地 Git 儲存庫連接到 GitHub。本地的 Git 儲存庫很好，但某些時候你可能希望將檔案備份到某個地方，並邀請其他人與你合作。一個很好的地方就是 GitHub。記得我們已在 GitHub 上建立了一個儲存庫，因此唯一需要做的就是將本地 Git 儲存庫與 GitHub 連接。git remote add 命令可以完成此操作。輸入以下命令： 注意，在輸入命令之前，前往你的 GitHub 儲存庫頁面以找到儲存庫 URL。你將在以下命令中使用它。將 https://githubcom/username/repository_namegit 替換為你的 GitHub URL。 bash git remote add origin https://githubcom/username/repository_namegit 此命令建立了一個名為「origin」的遠端連接，指向你之前建立的 GitHub 儲存庫。 將本地檔案推送到 GitHub。到目前為止，你已建立本地儲存庫與 GitHub 儲存庫之間的連接。接下來使用 git push 命令將檔案推送到 GitHub，如下所示： 注意，你的分支名稱可能與 main 不同。 bash git push -u origin main 此命令將你的「main」分支中的提交推送到 GitHub。 添加更多更改。如果你希望繼續進行更改並推送到 GitHub，只需使用以下三個命令： bash git addgit commit -m \"type your commit message here\" git push 提示，你可能還希望採用gitignore 檔案，以防止你不希望追蹤的檔案出現在 GitHub 上——例如存放在同一資料夾中的筆記檔案，但不適合放在公共儲存庫中。你可以在gitignore templates 找到gitignore 檔案的範本。\n提交訊息\n一個好的 Git 提交主題行應完成以下句子：\n如果應用，這次提交將 <你的主題行>\n主題行使用命令式現在時態：「change」而不是「changed」或「changes」。\n在主題行中，以及在正文（可選）中，也使用命令式現在時態。正文應包括更改的動機，並與之前的行為形成對比。你是在解釋「為什麼」，而不是「如何」。\n✅ 花幾分鐘瀏覽 GitHub。你能找到一個非常好的提交訊息嗎？你能找到一個非常簡略的嗎？你認為在提交訊息中最重要和最有用的信息是什麼？\n任務：合作\n將內容放到 GitHub 上的主要原因是讓其他開發者能夠合作。\n與他人合作專案\n查看影片\n在你的儲存庫中，導航到 Insights > Community，查看你的專案如何符合推薦的社群標準。\n以下是一些可以改善 GitHub 儲存庫的事項：\n- 描述。你是否為專案添加了描述？\n- README。你是否添加了 README？GitHub 提供了撰寫 README 的指導。\n- 貢獻指南。你的專案是否有 貢獻指南？\n- 行為準則。是否有 行為準則？\n- 授權條款。或許最重要的是，授權條款？\n所有這些資源都將有助於新團隊成員的加入。而這些通常是新貢獻者在查看你的程式碼之前會先看的內容，以了解你的專案是否值得他們投入時間。\n✅ README 檔案雖然需要時間準備，但常常被忙碌的維護者忽略。你能找到一個特別詳細的 README 示例嗎？注意：有一些工具可以幫助建立好的 README，你可能會想試試。\n任務：合併程式碼\n貢獻文件幫助人們為專案做出貢獻。它解釋了你希望的貢獻類型以及流程如何運作。貢獻者需要完成一系列步驟才能為你的 GitHub 儲存庫做出貢獻：\n分叉你的儲存庫。你可能希望人們分叉你的專案。分叉意味著在他們的 GitHub 個人檔案中建立你的儲存庫的副本。\n克隆。接著他們會將專案克隆到本地電腦。\n建立分支。你會希望他們為自己的工作建立一個分支。\n專注於一個區域的更改。要求貢獻者一次專注於一件事——這樣你合併他們工作的可能性更高。想像他們修復了一個錯誤、添加了一個新功能並更新了幾個測試——如果你只想實施其中的 2 個或 1 個更改，該怎麼辦？\n✅ 想像一個情境，分支對於撰寫和交付良好的程式碼特別重要。你能想到哪些使用案例？\n注意，成為你希望看到的改變，為自己的工作也建立分支。你所做的任何提交都將在你目前「檢出」的分支上進行。使用 git status 查看當前的分支。\n讓我們來看看貢獻者的工作流程。假設貢獻者已經分叉並克隆了儲存庫，因此他們在本地電腦上有一個準備好工作的 Git 儲存庫：\n建立分支。使用 git branch 命令建立一個分支，該分支將包含他們打算貢獻的更改：\nbash\ngit branch [branch-name]\n切換到工作分支。使用 git switch 切換到指定分支並更新工作目錄：\nbash\ngit switch [branch-name]\n進行工作。此時你可以添加更改。不要忘記使用以下命令告訴 Git：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1990,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "e22d847d8d2c2866654caa11bbbb84f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "與他人合作專案 查看影片 在你的儲存庫中，導航到 Insights > Community，查看你的專案如何符合推薦的社群標準。 以下是一些可以改善 GitHub 儲存庫的事項： - 描述。你是否為專案添加了描述？ - README。你是否添加了 README？GitHub 提供了撰寫 README 的指導。 - 貢獻指南。你的專案是否有 貢獻指南？ - 行為準則。是否有 行為準則？ - 授權條款。或許最重要的是，授權條款？ 所有這些資源都將有助於新團隊成員的加入。而這些通常是新貢獻者在查看你的程式碼之前會先看的內容，以了解你的專案是否值得他們投入時間。 ✅ README 檔案雖然需要時間準備，但常常被忙碌的維護者忽略。你能找到一個特別詳細的 README 示例嗎？注意：有一些工具可以幫助建立好的 README，你可能會想試試。 任務：合併程式碼 貢獻文件幫助人們為專案做出貢獻。它解釋了你希望的貢獻類型以及流程如何運作。貢獻者需要完成一系列步驟才能為你的 GitHub 儲存庫做出貢獻： 分叉你的儲存庫。你可能希望人們分叉你的專案。分叉意味著在他們的 GitHub 個人檔案中建立你的儲存庫的副本。 克隆。接著他們會將專案克隆到本地電腦。 建立分支。你會希望他們為自己的工作建立一個分支。 專注於一個區域的更改。要求貢獻者一次專注於一件事——這樣你合併他們工作的可能性更高。想像他們修復了一個錯誤、添加了一個新功能並更新了幾個測試——如果你只想實施其中的 2 個或 1 個更改，該怎麼辦？ ✅ 想像一個情境，分支對於撰寫和交付良好的程式碼特別重要。你能想到哪些使用案例？ 注意，成為你希望看到的改變，為自己的工作也建立分支。你所做的任何提交都將在你目前「檢出」的分支上進行。使用 git status 查看當前的分支。 讓我們來看看貢獻者的工作流程。假設貢獻者已經分叉並克隆了儲存庫，因此他們在本地電腦上有一個準備好工作的 Git 儲存庫： 建立分支。使用 git branch 命令建立一個分支，該分支將包含他們打算貢獻的更改： bash git branch [branch-name] 切換到工作分支。使用 git switch 切換到指定分支並更新工作目錄： bash git switch [branch-name] 進行工作。此時你可以添加更改。不要忘記使用以下命令告訴 Git： bash git addgit commit -m \"my changes\"\n確保你為提交取一個好的名稱，這對你自己以及你幫助的儲存庫維護者都很重要。\n將你的工作與 main 分支合併。某個時候你完成了工作，並希望將你的工作與 main 分支的工作合併。main 分支可能在此期間發生了更改，因此請確保首先使用以下命令更新到最新版本：\nbash\ngit switch main\ngit pull\n此時你需要確保任何「衝突」（Git 無法輕易合併的情況）發生在你的工作分支中。因此，執行以下命令：\nbash\ngit switch [branch_name]\ngit merge main\n這將把 main 分支的所有更改帶入你的分支，希望你可以繼續。如果不能，VS Code 會告訴你 Git「困惑」的地方，你只需修改受影響的檔案，指出哪個內容最準確。\n將你的工作推送到 GitHub。將你的工作推送到 GitHub 意味著兩件事。將你的分支推送到你的儲存庫，然後開啟一個 PR（Pull Request）。\nbash\ngit push --set-upstream origin [branch-name]\n上述命令會在你的分叉儲存庫中建立分支。\n開啟 PR。接下來，你需要開啟一個 PR。你可以在 GitHub 上導航到分叉的儲存庫。你會看到 GitHub 上的提示，詢問是否要建立新的 PR，點擊它後你會進入一個介面，可以更改提交訊息標題，並給出更合適的描述。現在你分叉的儲存庫維護者會看到這個 PR，並希望他們欣賞並合併你的 PR。你現在是一名貢獻者，恭喜！\n清理。成功合併 PR 後，清理工作被認為是良好的做法。你需要清理本地分支以及推送到 GitHub 的分支。首先，使用以下命令在本地刪除分支：\nbash\ngit branch -d [branch-name]\n確保接下來到 GitHub 頁面，找到你剛剛推送的遠端分支並將其刪除。\nPull request 似乎是一個有點奇怪的術語，因為實際上你是希望將你的更改推送到專案中。但維護者（專案擁有者）或核心團隊需要在合併到專案的 \"main\" 分支之前考慮你的更改，因此你實際上是在向維護者請求一個更改的決策。\nPull request 是一個用來比較和討論分支中引入的差異的地方，並且可以進行審查、評論、整合測試等。一個好的 Pull request 大致遵循與提交訊息相同的規則。例如，當你的工作解決了一個問題時，你可以在問題追蹤器中添加一個引用。這可以通過使用 # 後跟問題編號來完成，例如 #97。\n🤞希望所有檢查都通過，並且專案擁有者將你的更改合併到專案中🤞\n更新你當前的本地工作分支，將 GitHub 上對應的遠端分支中的所有新提交拉取下來：\ngit pull\n如何貢獻開源\n首先，讓我們在 GitHub 上找到一個你感興趣並希望貢獻更改的倉庫（或 repo）。你需要將其內容複製到你的電腦上。\n✅ 找到「適合初學者」的倉庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。\n有幾種複製程式碼的方法。一種方法是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」倉庫的內容。\n打開你的終端機並像這樣克隆倉庫：\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2373,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "1083641b7b2a280e691d585c5340749a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "Git「困惑」的地方，你只需修改受影響的檔案，指出哪個內容最準確。 將你的工作推送到 GitHub。將你的工作推送到 GitHub 意味著兩件事。將你的分支推送到你的儲存庫，然後開啟一個 PR（Pull Request）。 bash git push --set-upstream origin [branch-name] 上述命令會在你的分叉儲存庫中建立分支。 開啟 PR。接下來，你需要開啟一個 PR。你可以在 GitHub 上導航到分叉的儲存庫。你會看到 GitHub 上的提示，詢問是否要建立新的 PR，點擊它後你會進入一個介面，可以更改提交訊息標題，並給出更合適的描述。現在你分叉的儲存庫維護者會看到這個 PR，並希望他們欣賞並合併你的 PR。你現在是一名貢獻者，恭喜！ 清理。成功合併 PR 後，清理工作被認為是良好的做法。你需要清理本地分支以及推送到 GitHub 的分支。首先，使用以下命令在本地刪除分支： bash git branch -d [branch-name] 確保接下來到 GitHub 頁面，找到你剛剛推送的遠端分支並將其刪除。 Pull request 似乎是一個有點奇怪的術語，因為實際上你是希望將你的更改推送到專案中。但維護者（專案擁有者）或核心團隊需要在合併到專案的 \"main\" 分支之前考慮你的更改，因此你實際上是在向維護者請求一個更改的決策。 Pull request 是一個用來比較和討論分支中引入的差異的地方，並且可以進行審查、評論、整合測試等。一個好的 Pull request 大致遵循與提交訊息相同的規則。例如，當你的工作解決了一個問題時，你可以在問題追蹤器中添加一個引用。這可以通過使用 # 後跟問題編號來完成，例如 #97。 🤞希望所有檢查都通過，並且專案擁有者將你的更改合併到專案中🤞 更新你當前的本地工作分支，將 GitHub 上對應的遠端分支中的所有新提交拉取下來： git pull 如何貢獻開源 首先，讓我們在 GitHub 上找到一個你感興趣並希望貢獻更改的倉庫（或 repo）。你需要將其內容複製到你的電腦上。 ✅ 找到「適合初學者」的倉庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。 有幾種複製程式碼的方法。一種方法是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」倉庫的內容。 打開你的終端機並像這樣克隆倉庫： git clone https://githubcom/ProjectURL\n要開始專案工作，切換到正確的資料夾：\ncd ProjectURL\n你也可以使用 Codespaces（GitHub 的嵌入式程式碼編輯器/雲端開發環境）或 GitHub Desktop 打開整個專案。\n最後，你也可以下載壓縮檔案形式的程式碼。\n關於 GitHub 的一些有趣事\n你可以對 GitHub 上的任何公共倉庫進行加星、關注或「fork」。你可以在右上角的下拉選單中找到你加星的倉庫。這就像為程式碼加書籤。\n專案通常有一個問題追蹤器，大多數情況下在 GitHub 的 \"Issues\" 標籤中，除非另有說明，人們在這裡討論與專案相關的問題。而 \"Pull Requests\" 標籤則是人們討論和審查正在進行的更改的地方。\n專案可能還有論壇、郵件列表或像 Slack、Discord 或 IRC 這樣的聊天頻道進行討論。\n✅ 瀏覽一下你的新 GitHub 倉庫，嘗試一些操作，比如編輯設定、向倉庫添加資訊，或者創建一個專案（例如看板）。你可以做很多事情！\n🚀 挑戰\n與朋友配對，共同合作彼此的程式碼。一起創建專案，fork 程式碼，創建分支並合併更改。\n課後測驗\n課後測驗\n回顧與自學\n閱讀更多關於 如何貢獻開源軟體。\nGit 速查表。\n多練習，多嘗試。GitHub 提供了很棒的學習路徑：skills",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1612,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "e20eeb33eaf19d7b9701e6cd5227531f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "request 大致遵循與提交訊息相同的規則。例如，當你的工作解決了一個問題時，你可以在問題追蹤器中添加一個引用。這可以通過使用 # 後跟問題編號來完成，例如 #97。 🤞希望所有檢查都通過，並且專案擁有者將你的更改合併到專案中🤞 更新你當前的本地工作分支，將 GitHub 上對應的遠端分支中的所有新提交拉取下來： git pull 如何貢獻開源 首先，讓我們在 GitHub 上找到一個你感興趣並希望貢獻更改的倉庫（或 repo）。你需要將其內容複製到你的電腦上。 ✅ 找到「適合初學者」的倉庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。 有幾種複製程式碼的方法。一種方法是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」倉庫的內容。 打開你的終端機並像這樣克隆倉庫： git clone https://githubcom/ProjectURL 要開始專案工作，切換到正確的資料夾： cd ProjectURL 你也可以使用 Codespaces（GitHub 的嵌入式程式碼編輯器/雲端開發環境）或 GitHub Desktop 打開整個專案。 最後，你也可以下載壓縮檔案形式的程式碼。 關於 GitHub 的一些有趣事 你可以對 GitHub 上的任何公共倉庫進行加星、關注或「fork」。你可以在右上角的下拉選單中找到你加星的倉庫。這就像為程式碼加書籤。 專案通常有一個問題追蹤器，大多數情況下在 GitHub 的 \"Issues\" 標籤中，除非另有說明，人們在這裡討論與專案相關的問題。而 \"Pull Requests\" 標籤則是人們討論和審查正在進行的更改的地方。 專案可能還有論壇、郵件列表或像 Slack、Discord 或 IRC 這樣的聊天頻道進行討論。 ✅ 瀏覽一下你的新 GitHub 倉庫，嘗試一些操作，比如編輯設定、向倉庫添加資訊，或者創建一個專案（例如看板）。你可以做很多事情！ 🚀 挑戰 與朋友配對，共同合作彼此的程式碼。一起創建專案，fork 程式碼，創建分支並合併更改。 課後測驗 課後測驗 回顧與自學 閱讀更多關於 如何貢獻開源軟體。 Git 速查表。 多練習，多嘗試。GitHub 提供了很棒的學習路徑：skillsgithub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 979,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "a622a301f79ec5526861856b58df98e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHub 簡介",
    "content": "request 大致遵循與提交訊息相同的規則。例如，當你的工作解決了一個問題時，你可以在問題追蹤器中添加一個引用。這可以通過使用 # 後跟問題編號來完成，例如 #97。 🤞希望所有檢查都通過，並且專案擁有者將你的更改合併到專案中🤞 更新你當前的本地工作分支，將 GitHub 上對應的遠端分支中的所有新提交拉取下來： git pull 如何貢獻開源 首先，讓我們在 GitHub 上找到一個你感興趣並希望貢獻更改的倉庫（或 repo）。你需要將其內容複製到你的電腦上。 ✅ 找到「適合初學者」的倉庫的一個好方法是 透過標籤 'good-first-issue' 進行搜尋。 有幾種複製程式碼的方法。一種方法是使用 HTTPS、SSH 或 GitHub CLI（命令列介面）來「克隆」倉庫的內容。 打開你的終端機並像這樣克隆倉庫： git clone https://githubcom/ProjectURL 要開始專案工作，切換到正確的資料夾： cd ProjectURL 你也可以使用 Codespaces（GitHub 的嵌入式程式碼編輯器/雲端開發環境）或 GitHub Desktop 打開整個專案。 最後，你也可以下載壓縮檔案形式的程式碼。 關於 GitHub 的一些有趣事 你可以對 GitHub 上的任何公共倉庫進行加星、關注或「fork」。你可以在右上角的下拉選單中找到你加星的倉庫。這就像為程式碼加書籤。 專案通常有一個問題追蹤器，大多數情況下在 GitHub 的 \"Issues\" 標籤中，除非另有說明，人們在這裡討論與專案相關的問題。而 \"Pull Requests\" 標籤則是人們討論和審查正在進行的更改的地方。 專案可能還有論壇、郵件列表或像 Slack、Discord 或 IRC 這樣的聊天頻道進行討論。 ✅ 瀏覽一下你的新 GitHub 倉庫，嘗試一些操作，比如編輯設定、向倉庫添加資訊，或者創建一個專案（例如看板）。你可以做很多事情！ 🚀 挑戰 與朋友配對，共同合作彼此的程式碼。一起創建專案，fork 程式碼，創建分支並合併更改。 課後測驗 課後測驗 回顧與自學 閱讀更多關於 如何貢獻開源軟體。 Git 速查表。 多練習，多嘗試。GitHub 提供了很棒的學習路徑：skillsgithubcom:\nGitHub 的第一週\n你還可以找到更多進階課程。\n作業\n完成 GitHub 的第一週課程。\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原始語言的文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對於因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16432,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\tw\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1199,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "be0b6a59320569f3a5f36a60e5a0834b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "Aplicação de Quiz",
    "content": "Aplicação de Quiz\nEstes quizzes são os quizzes pré e pós-aula para o currículo de ciência de dados em https://aka ms/webdev-beginners\nAdicionar um conjunto de quizzes traduzido\nAdicione uma tradução de quiz criando estruturas de quizzes correspondentes nas pastas assets/translations Os quizzes originais estão em assets/translations/en Os quizzes estão divididos em vários grupos Certifique-se de alinhar a numeração com a seção correta do quiz Existem 40 quizzes no total neste currículo, começando a contagem em 0 Aqui está o formato de um ficheiro de tradução:\n```\n[\n{\n\"title\": \"A title\",\n\"complete\": \"A complete button title\",\n\"error\": \"An error message upon selecting the wrong answer\",\n\"quizzes\": [\n{\n\"id\": 1,\n\"title\": \"Title\",\n\"quiz\": [\n{\n\"questionText\": \"The question asked\",\n\"answerOptions\": [\n{\n\"answerText\": \"Option 1 title\",\n\"isCorrect\": true\n},\n{\n\"answerText\": \"Option 2 title\",\n\"isCorrect\": false\n}\n]\n}\n]\n}\n]\n}\n]\n```\nDepois de editar as traduções, edite o ficheiro index js na pasta de tradução para importar todos os ficheiros seguindo as convenções em en Edite o ficheiro index js em assets/translations para importar os novos ficheiros traduzidos Por exemplo, se o seu JSON de tradução estiver em ex json, use 'ex' como a chave de localização e insira-o conforme mostrado abaixo para o importar:\nindex js\n```\nimport ex from \" /ex json\";\n// if 'ex' is localization key then enter it like so in `messages` to expose it\nconst messages = {\nex: ex[0],\n};\nexport default messages;\n```\nExecutar a aplicação de Quiz localmente\nPré-requisitos\nUma conta no GitHub\nNode js e Git\nInstalar & Configurar\nCrie um repositório a partir deste template\nClone o seu novo repositório e navegue até à pasta quiz-app\nbash\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6784,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 470,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "3df3380029af0d21ef42f6a0885cfd60",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "Aplicação de Quiz",
    "content": "index js ``` import ex from \" /ex json\"; // if 'ex' is localization key then enter it like so in `messages` to expose it const messages = { ex: ex[0], }; export default messages; ``` Executar a aplicação de Quiz localmente Pré-requisitos Uma conta no GitHub Node js e Git Instalar & Configurar Crie um repositório a partir deste template Clone o seu novo repositório e navegue até à pasta quiz-app bash git clone https://githubcom/your-github-organization/repo-name\ncd repo-name/quiz-app\nInstale os pacotes npm e dependências\nbash\nnpm install\nConstruir a aplicação\nPara construir a solução, execute:\nbash\nnpm run build\nIniciar a aplicação\nPara executar a solução, execute:\nbash\nnpm run dev\n[Opcional] Linting\nPara garantir que o código está formatado corretamente, execute:\nbash\nnpm run lint\nDesplegar a aplicação de Quiz no Azure\nPré-requisitos\nUma subscrição do Azure Registe-se gratuitamente aqui Estimativa de custo para desplegar esta aplicação de quiz: GRATUITO\nDepois de iniciar sessão no Azure através do link acima, selecione uma subscrição e um grupo de recursos, e então:\nDetalhes da aplicação web estática: Forneça um nome e selecione um plano de alojamento\nLogin no GitHub: Defina a sua fonte de deployment como GitHub, depois inicie sessão e preencha os campos necessários no formulário:\nOrganização – Escolha a sua organização Repositório – Selecione o repositório do currículo Web Dev for Beginners Ramo - Selecione um ramo (main)\nPresets de construção: O Azure Static Web Apps usa um algoritmo de deteção para identificar o framework usado na sua aplicação Localização da aplicação - /quiz-app\nLocalização da API -\nLocalização de saída - dist\nDeployment: Clique em 'Review + Create', depois 'Create'\nUma vez desplegado, um ficheiro de workflow será criado no diretório github do seu repositório",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6784,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "4a35d3f39f1b492332450c4128de31ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "Aplicação de Quiz",
    "content": "organização Repositório – Selecione o repositório do currículo Web Dev for Beginners Ramo - Selecione um ramo (main) Presets de construção: O Azure Static Web Apps usa um algoritmo de deteção para identificar o framework usado na sua aplicação Localização da aplicação - /quiz-app Localização da API - Localização de saída - dist Deployment: Clique em 'Review + Create', depois 'Create' Uma vez desplegado, um ficheiro de workflow será criado no diretório github do seu repositórioEste ficheiro de workflow contém instruções sobre eventos que irão desencadear um novo deployment da aplicação no Azure, por exemplo, um push no ramo main, etc Exemplo de ficheiro de workflow\nAqui está um exemplo de como o ficheiro de workflow do GitHub Actions pode parecer:\nname: Azure Static Web Apps CI/CD\n```\non:\npush:\nbranches:\n- main\npull_request:\ntypes: [opened, synchronize, reopened, closed]\nbranches:\n- main\njobs:\nbuild_and_deploy_job:\nruns-on: ubuntu-latest\nname: Build and Deploy Job\nsteps:\n- uses: actions/checkout@v2\n- name: Build And Deploy\nid: builddeploy\nuses: Azure/static-web-apps-deploy@v1\nwith:\nazure_static_web_apps_api_token: ${{ secrets AZURE_STATIC_WEB_APPS_API_TOKEN }}\nrepo_token: ${{ secrets GITHUB_TOKEN }}\naction: \"upload\"\napp_location: \"quiz-app\" # App source code path\napi_location: \"\"API source code path optional\noutput_location: \"dist\" #Built app content directory - optional\n```\nPós-Deployment: Após o deployment estar concluído, clique em 'Go to Deployment' e depois 'View app in browser' Depois de o seu GitHub Action (workflow) ser executado com sucesso, atualize a página ao vivo para visualizar a sua aplicação Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6784,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "527cc4fcc8d43d1fd5de6a561d7a79ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "Aplicação de Quiz",
    "content": "'Go to Deployment' e depois 'View app in browser' Depois de o seu GitHub Action (workflow) ser executado com sucesso, atualize a página ao vivo para visualizar a sua aplicação Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritáriaPara informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6784,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 164,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "0723ca67d7f69567f8e661f79bcb48f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\assignment.md",
    "source_type": "git_repo",
    "title": "Melhorar o encaminhamento",
    "content": "Melhorar o encaminhamento\nInstruções\nA declaração de rotas atualmente contém apenas o ID do modelo a ser usado. No entanto, ao exibir uma nova página, às vezes é necessário um pouco mais. Vamos melhorar a nossa implementação de encaminhamento com duas funcionalidades adicionais:\nAtribuir títulos a cada modelo e atualizar o título da janela com este novo título quando o modelo mudar.\nAdicionar uma opção para executar algum código após a mudança do modelo. Queremos imprimir 'Dashboard is shown' na consola do programador sempre que a página do dashboard for exibida.\nRubrica\n| Critérios | Exemplar                                                                                                                          | Adequado                                                                                                                                                                                  | Necessita Melhorias                                    |\n| --------- | ---------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |\n|           | As duas funcionalidades estão implementadas e a funcionar. A adição de título e código também funciona para uma nova rota adicionada na declaração de routes.           | As duas funcionalidades funcionam, mas o comportamento está codificado e não é configurável através da declaração de routes. Adicionar uma terceira rota com título e código não funciona ou funciona parcialmente. | Uma das funcionalidades está ausente ou não funciona corretamente. |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2740,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 419,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "74cbd816c091f7547319014e6c2551bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "O Teu Nome Aqui!",
    "content": "Criar um site de currículo usando vscode dev\nQue incrível seria se um recrutador pedisse o teu currículo e tu enviasses um URL 😎\nObjetivos\nApós esta tarefa, vais aprender a:\nCriar um site para apresentar o teu currículo\nPré-requisitos\nUma conta no GitHub Acede a GitHub e cria uma conta, caso ainda não tenhas uma Passos\nPasso 1: Cria um novo repositório no GitHub e dá-lhe o nome my-resume\nPasso 2: Cria um ficheiro index html no teu repositório Vamos adicionar pelo menos um ficheiro diretamente no github com, porque não é possível abrir um repositório vazio no vscode dev Clica no link creating a new file, escreve o nome index html e seleciona o botão Commit new file Passo 3: Abre VSCode dev e seleciona o botão Open Remote Repository Copia o URL do repositório que acabaste de criar para o teu site de currículo e cola-o na caixa de entrada:\nSubstitui your-username pelo teu nome de utilizador do GitHub\nhttps://github com/your-username/my-resume\n✅ Se for bem-sucedido, vais ver o teu projeto e o ficheiro index html abertos no editor de texto no navegador Passo 4: Abre o ficheiro index html, cola o código abaixo na área de código e guarda Código HTML responsável pelo conteúdo do teu site de currículo O Teu Nome Aqui O Teu Nome Aqui A Tua Função CONTACTO\nEscreve aqui o teu email\nEscreve aqui o teu nome de utilizador Escreve aqui o teu nome de utilizador COMPETÊNCIAS\nCompetência 1 Competência 2 Competência 3 Competência 4 FORMAÇÃO\nEscreve aqui o teu curso Escreve aqui a tua instituição Data de início - Data de fim\nSOBRE\nEscreve uma breve descrição sobre ti EXPERIÊNCIA PROFISSIONAL\nTítulo do Cargo\nNome da Organização Aqui | Mês de Início – Mês de Fim\nTarefa 1 - Escreve o que fizeste",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10664,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "2634224f8fd0de2cb4468a226f8a2aa8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "O Teu Nome Aqui!",
    "content": "aqui o teu email Escreve aqui o teu nome de utilizador Escreve aqui o teu nome de utilizador COMPETÊNCIAS Competência 1 Competência 2 Competência 3 Competência 4 FORMAÇÃO Escreve aqui o teu curso Escreve aqui a tua instituição Data de início - Data de fim SOBRE Escreve uma breve descrição sobre ti EXPERIÊNCIA PROFISSIONAL Título do Cargo Nome da Organização Aqui | Mês de Início – Mês de Fim Tarefa 1 - Escreve o que fizesteTarefa 2 - Escreve o que fizeste Escreve os resultados/impacto da tua contribuição\nTítulo do Cargo 2\nNome da Organização Aqui | Mês de Início – Mês de Fim\nTarefa 1 - Escreve o que fizeste Tarefa 2 - Escreve o que fizeste Escreve os resultados/impacto da tua contribuição\nAdiciona os detalhes do teu currículo para substituir o texto de exemplo no código HTML Passo 5: Passa o cursor sobre a pasta My-Resume, clica no ícone New File e cria 2 novos ficheiros no teu projeto: style css e codeswing json Passo 6: Abre o ficheiro style css, cola o código abaixo e guarda Código CSS para formatar o layout do site body {\nfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\nfont-size: 16px;\nmax-width: 960px;\nmargin: auto;\n}\nh1 {\nfont-size: 3em;\nletter-spacing: 6em;\npadding-top: 1em;\npadding-bottom: 1em;\n}\nh2 {\nfont-size: 1 5em;\npadding-bottom: 1em;\n}\nh3 {\nfont-size: 1em;\npadding-bottom: 1em;\n}\nmain {\ndisplay: grid;\ngrid-template-columns: 40% 60%;\nmargin-top: 3em;\n}\nheader {\ntext-align: center;\nmargin: auto 2em;\n}\nsection {\nmargin: auto 1em 4em 2em;\n}\ni {\nmargin-right: 5em;\n}\np {\nmargin:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10664,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "222ea12185719e422ddf76e0a4d7a885",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "O Teu Nome Aqui!",
    "content": "body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing: 6em; padding-top: 1em; padding-bottom: 1em; } h2 { font-size: 1 5em; padding-bottom: 1em; } h3 { font-size: 1em; padding-bottom: 1em; } main { display: grid; grid-template-columns: 40% 60%; margin-top: 3em; } header { text-align: center; margin: auto 2em; } section { margin: auto 1em 4em 2em; } i { margin-right: 5em; } p { margin:2em auto\n}\nhr {\nborder: none;\nbackground-color: lightgray;\nheight: 1px;\n}\nh1, h2, h3 {\nfont-weight: 100;\nmargin-bottom: 0;\n}\n#mainLeft {\nborder-right: 1px solid lightgray;\n}\nPasso 6: Abre o ficheiro codeswing json, cola o código abaixo e guarda {\n\"scripts\": [],\n\"styles\": []\n}\nPasso 7: Instala a extensão Codeswing para visualizar o site do currículo na área de código Clica no ícone Extensions na barra de atividades e escreve Codeswing Clica no botão azul de instalação na barra de atividades expandida para instalar ou usa o botão de instalação que aparece na área de código ao selecionar a extensão para carregar informações adicionais Assim que instalares a extensão, observa as mudanças no teu projeto na área de código 😃 Isto é o que vais ver no teu ecrã após instalar a extensão Se estiveres satisfeito com as alterações feitas, passa o cursor sobre a pasta Changes e clica no botão + para preparar as alterações Escreve uma mensagem de commit (Uma descrição das alterações feitas no projeto) e confirma as alterações clicando no check",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10664,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "d03f24c288420c0e1e35f661cfb497bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "O Teu Nome Aqui!",
    "content": "extensão para carregar informações adicionais Assim que instalares a extensão, observa as mudanças no teu projeto na área de código 😃 Isto é o que vais ver no teu ecrã após instalar a extensão Se estiveres satisfeito com as alterações feitas, passa o cursor sobre a pasta Changes e clica no botão + para preparar as alterações Escreve uma mensagem de commit (Uma descrição das alterações feitas no projeto) e confirma as alterações clicando no checkQuando terminares de trabalhar no teu projeto, seleciona o ícone do menu hambúrguer no canto superior esquerdo para voltar ao repositório no GitHub Parabéns 🎉 Acabaste de criar o teu site de currículo usando vscode dev em poucos passos 🚀 Desafio\nAbre um repositório remoto onde tens permissões para fazer alterações e atualiza alguns ficheiros Em seguida, tenta criar um novo ramo com as tuas alterações e faz um Pull Request Revisão e Autoestudo\nLê mais sobre VSCode dev e algumas das suas outras funcionalidades Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, é importante notar que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10664,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 386,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "624fdc1b965b4fdbc25d1b1f8acc18a6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "Estiliza a tua aplicação bancária",
    "content": "Estiliza a tua aplicação bancária\nInstruções\nCria um novo ficheiro styles.css e adiciona um link para ele no teu ficheiro index.html atual. No ficheiro CSS que acabaste de criar, adiciona algum estilo para que as páginas de Login e Dashboard fiquem agradáveis e organizadas. Tenta criar um esquema de cores para dar à tua aplicação uma identidade própria.\nDica: podes modificar o HTML e adicionar novos elementos e classes, se necessário.\nCritérios de Avaliação\n| Critérios | Exemplar                                                                                                               | Adequado                                                                       | Necessita de Melhorias                                                                       |\n| --------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------- |\n|           | Todas as páginas estão limpas e legíveis, com um esquema de cores consistente e as diferentes secções bem destacadas. | As páginas estão estilizadas, mas sem um tema ou com secções não claramente delimitadas. | As páginas carecem de estilo, as secções parecem desorganizadas e a informação é difícil de ler. |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2303,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 373,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "634bcfb9fb5dc365a5ea6f9b8044a23b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "Usar um editor de código",
    "content": "Usar um editor de código\nEsta lição aborda os conceitos básicos de utilização do VSCode dev, um editor de código baseado na web, para que possa fazer alterações no seu código e contribuir para um projeto sem instalar nada no seu computador Objetivos de aprendizagem\nNesta lição, irá aprender a:\nUtilizar um editor de código num projeto de programação\nAcompanhar alterações com controlo de versão\nPersonalizar o editor para desenvolvimento\nPré-requisitos\nAntes de começar, precisará de criar uma conta no GitHub Navegue até GitHub e crie uma conta, caso ainda não tenha uma Introdução\nUm editor de código é uma ferramenta essencial para escrever programas e colaborar em projetos de programação existentes Assim que compreender os conceitos básicos de um editor e como utilizar as suas funcionalidades, poderá aplicá-los ao escrever código Começar com o VSCode dev\nVSCode dev é um editor de código na web Não precisa de instalar nada para utilizá-lo, tal como abrir qualquer outro site Para começar a usar o editor, abra o seguinte link: https://vscode dev Se não estiver autenticado no GitHub, siga as instruções para iniciar sessão ou criar uma nova conta e, em seguida, autentique-se Depois de carregar, deverá parecer semelhante a esta imagem:\nExistem três secções principais, começando da esquerda para a direita:\nA barra de atividades, que inclui alguns ícones, como a lupa 🔎, a engrenagem ⚙️, e outros A barra de atividades expandida, que por padrão é o Explorador, chamada de barra lateral E, finalmente, a área de código à direita Clique em cada um dos ícones para exibir um menu diferente Quando terminar, clique no Explorador para voltar ao ponto de partida Quando começar a criar ou modificar código existente, isso acontecerá na maior área à direita Utilizará esta área para visualizar código existente também, o que fará a seguir",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11370,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 478,
    "chunk_index": 0,
    "total_chunks": 6
  },
  {
    "id": "6d3211887830e3e0f155989724c0f0bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "Usar um editor de código",
    "content": "⚙️, e outros A barra de atividades expandida, que por padrão é o Explorador, chamada de barra lateral E, finalmente, a área de código à direita Clique em cada um dos ícones para exibir um menu diferente Quando terminar, clique no Explorador para voltar ao ponto de partida Quando começar a criar ou modificar código existente, isso acontecerá na maior área à direita Utilizará esta área para visualizar código existente também, o que fará a seguirAbrir um repositório GitHub\nA primeira coisa que precisará é abrir um repositório GitHub Existem várias formas de abrir um repositório Nesta secção, verá duas maneiras diferentes de abrir um repositório para começar a trabalhar nas alterações 1 Com o editor\nUtilize o próprio editor para abrir um repositório remoto Se for ao VSCode dev, verá um botão \"Open Remote Repository\":\nTambém pode usar o command palette O command palette é uma caixa de entrada onde pode digitar qualquer palavra que faça parte de um comando ou ação para encontrar o comando certo a executar Utilize o menu no canto superior esquerdo, selecione View e, em seguida, escolha Command Palette, ou utilize o seguinte atalho de teclado: Ctrl-Shift-P (no MacOS seria Command-Shift-P) Depois de abrir o menu, digite open remote repository e selecione a primeira opção Vários repositórios dos quais faz parte ou que abriu recentemente aparecerão Também pode usar um URL completo do GitHub para selecionar um Utilize o seguinte URL e cole na caixa:\nhttps://github com/microsoft/Web-Dev-For-Beginners\n✅ Se for bem-sucedido, verá todos os ficheiros deste repositório carregados no editor de texto 2 Usando o URL\nTambém pode usar diretamente um URL para carregar um repositório Por exemplo, o URL completo do repositório atual é https://github com/microsoft/Web-Dev-For-Beginners, mas pode substituir o domínio do GitHub por VSCode dev/github e carregar o repositório diretamente O URL resultante seria https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11370,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 1,
    "total_chunks": 6
  },
  {
    "id": "5c2bd077f196535f8a1a69459f57ce65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "Usar um editor de código",
    "content": "completo do GitHub para selecionar um Utilize o seguinte URL e cole na caixa: https://github com/microsoft/Web-Dev-For-Beginners ✅ Se for bem-sucedido, verá todos os ficheiros deste repositório carregados no editor de texto 2 Usando o URL Também pode usar diretamente um URL para carregar um repositório Por exemplo, o URL completo do repositório atual é https://github com/microsoft/Web-Dev-For-Beginners, mas pode substituir o domínio do GitHub por VSCode dev/github e carregar o repositório diretamente O URL resultante seria https://vscodedev/github/microsoft/Web-Dev-For-Beginners Editar ficheiros\nDepois de abrir o repositório no navegador/vscode dev, o próximo passo será fazer atualizações ou alterações no projeto 1 Criar um novo ficheiro\nPode criar um ficheiro dentro de uma pasta existente ou na diretoria/pasta raiz Para criar um novo ficheiro, abra um local/diretoria onde deseja guardar o ficheiro e selecione o ícone 'New file ' na barra de atividades (à esquerda), dê-lhe um nome e pressione Enter 2 Editar e guardar um ficheiro no repositório\nUsar o vscode dev é útil sempre que quiser fazer atualizações rápidas ao seu projeto sem precisar de carregar qualquer software localmente Para atualizar o seu código, clique no ícone 'Explorer', também localizado na barra de atividades, para visualizar os ficheiros e pastas no repositório Selecione um ficheiro para abri-lo na área de código, faça as alterações e guarde Depois de terminar de atualizar o seu projeto, selecione o ícone source control, que contém todas as novas alterações feitas ao repositório Para visualizar as alterações feitas ao projeto, selecione os ficheiros na pasta Changes na barra de atividades expandida Isto abrirá um 'Working Tree' para que possa ver visualmente as alterações feitas ao ficheiro Vermelho indica uma omissão no projeto, enquanto verde significa uma adição",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11370,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 2,
    "total_chunks": 6
  },
  {
    "id": "ef29c4e1cc68830efe5a28bfd8006dda",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "Usar um editor de código",
    "content": "abri-lo na área de código, faça as alterações e guarde Depois de terminar de atualizar o seu projeto, selecione o ícone source control, que contém todas as novas alterações feitas ao repositório Para visualizar as alterações feitas ao projeto, selecione os ficheiros na pasta Changes na barra de atividades expandida Isto abrirá um 'Working Tree' para que possa ver visualmente as alterações feitas ao ficheiro Vermelho indica uma omissão no projeto, enquanto verde significa uma adiçãoSe estiver satisfeito com as alterações feitas, passe o cursor sobre a pasta Changes e clique no botão + para preparar as alterações Preparar significa simplesmente preparar as alterações para serem enviadas ao GitHub Se, no entanto, não estiver confortável com algumas alterações e quiser descartá-las, passe o cursor sobre a pasta Changes e selecione o ícone undo Depois, escreva uma commit message (Uma descrição das alterações feitas ao projeto), clique no ícone de verificação para confirmar e enviar as alterações Quando terminar de trabalhar no projeto, selecione o ícone do menu hambúrguer no canto superior esquerdo para voltar ao repositório no github com Usar extensões\nInstalar extensões no VSCode permite adicionar novas funcionalidades e opções de personalização ao ambiente de desenvolvimento no editor, melhorando o fluxo de trabalho Estas extensões também ajudam a adicionar suporte para várias linguagens de programação e são frequentemente extensões genéricas ou baseadas em linguagens Para navegar pela lista de todas as extensões disponíveis, clique no ícone Extensions na barra de atividades e comece a digitar o nome da extensão no campo de texto rotulado 'Search Extensions in Marketplace' Verá uma lista de extensões, cada uma contendo o nome da extensão, o nome do editor, uma descrição de uma frase, número de downloads e uma classificação por estrelas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11370,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 459,
    "chunk_index": 3,
    "total_chunks": 6
  },
  {
    "id": "b8b9160879d26cabdda34f89cde92044",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "Usar um editor de código",
    "content": "várias linguagens de programação e são frequentemente extensões genéricas ou baseadas em linguagens Para navegar pela lista de todas as extensões disponíveis, clique no ícone Extensions na barra de atividades e comece a digitar o nome da extensão no campo de texto rotulado 'Search Extensions in Marketplace' Verá uma lista de extensões, cada uma contendo o nome da extensão, o nome do editor, uma descrição de uma frase, número de downloads e uma classificação por estrelasTambém pode visualizar todas as extensões previamente instaladas expandindo a pasta Installed, extensões populares usadas pela maioria dos programadores na pasta Popular e extensões recomendadas para si, seja por utilizadores no mesmo espaço de trabalho ou com base nos ficheiros recentemente abertos, na pasta Recommended 1 Instalar Extensões\nPara instalar uma extensão, digite o nome da extensão no campo de pesquisa e clique nela para visualizar informações adicionais sobre a extensão na área de código, assim que aparecer na barra de atividades expandida Pode clicar no botão azul de instalação na barra de atividades expandida para instalar ou usar o botão de instalação que aparece na área de código ao selecionar a extensão para carregar informações adicionais 2 Personalizar Extensões\nDepois de instalar a extensão, pode precisar de modificar o seu comportamento e personalizá-la com base nas suas preferências Para fazer isso, selecione o ícone Extensions e, desta vez, a sua extensão aparecerá na pasta Installed Clique no ícone de engrenagem e navegue até Extensions Setting 3 Gerir Extensões\nDepois de instalar e usar a sua extensão, o vscode dev oferece opções para gerir a extensão com base em diferentes necessidades",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11370,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 423,
    "chunk_index": 4,
    "total_chunks": 6
  },
  {
    "id": "c1b075f22d200fc7f23ab9959860c0e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "Usar um editor de código",
    "content": "informações adicionais 2 Personalizar Extensões Depois de instalar a extensão, pode precisar de modificar o seu comportamento e personalizá-la com base nas suas preferências Para fazer isso, selecione o ícone Extensions e, desta vez, a sua extensão aparecerá na pasta Installed Clique no ícone de engrenagem e navegue até Extensions Setting 3 Gerir Extensões Depois de instalar e usar a sua extensão, o vscode dev oferece opções para gerir a extensão com base em diferentes necessidadesPor exemplo, pode optar por:\nDesativar: (Pode desativar temporariamente uma extensão quando não precisar dela, mas não quer desinstalá-la completamente)\nSelecione a extensão instalada na barra de atividades expandida > clique no ícone de engrenagem > selecione 'Disable' ou 'Disable (Workspace)' OU abra a extensão na área de código e clique no botão azul Disable Desinstalar: Selecione a extensão instalada na barra de atividades expandida > clique no ícone de engrenagem > selecione 'Uninstall' OU abra a extensão na área de código e clique no botão azul Uninstall Tarefa\nCriar um site de currículo usando vscode dev\nRevisão & Autoestudo\nLeia mais sobre VSCode dev e algumas das suas outras funcionalidades Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11370,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 441,
    "chunk_index": 5,
    "total_chunks": 6
  },
  {
    "id": "ac2dd2177f9d434f5f5a59c32bc04793",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "Refatora e comenta o teu código",
    "content": "Refatora e comenta o teu código\nInstruções\nÀ medida que a tua base de código cresce, é importante refatorar o código frequentemente para mantê-lo legível e fácil de manter ao longo do tempo. Adiciona comentários e refatora o teu app.js para melhorar a qualidade do código:\nExtrai constantes, como a URL base da API do servidor\nFactoriza código semelhante: por exemplo, podes criar uma função sendRequest() para agrupar o código usado tanto em createAccount() como em getAccount()\nReorganiza o código para torná-lo mais fácil de ler e adiciona comentários\nRubrica\n| Critérios | Exemplar                                                                                                                                                     | Adequado                                                                                          | Precisa de Melhorias                                                                     |\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |\n|           | O código está comentado, bem organizado em diferentes secções e fácil de ler. As constantes foram extraídas e uma função sendRequest() foi criada e factorizada. | O código está limpo, mas ainda pode ser melhorado com mais comentários, extração de constantes ou factorização. | O código está desorganizado, sem comentários, as constantes não foram extraídas e o código não foi factorizado. |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, tenha em atenção que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes da utilização desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2618,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 412,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "30a97819fd367c5bde8c3ab145dd7130",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "Criar uma App Bancária Parte 1: Modelos HTML e Rotas numa Aplicação Web\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nDesde o surgimento do JavaScript nos navegadores, os websites tornaram-se mais interativos e complexos do que nunca As tecnologias web são agora frequentemente utilizadas para criar aplicações totalmente funcionais que correm diretamente num navegador, conhecidas como aplicações web Como as aplicações web são altamente interativas, os utilizadores não querem esperar por um recarregamento completo da página sempre que uma ação é realizada Por isso, o JavaScript é usado para atualizar o HTML diretamente através do DOM, proporcionando uma experiência de utilizador mais fluida Nesta lição, vamos estabelecer as bases para criar uma aplicação bancária web, utilizando modelos HTML para criar múltiplos ecrãs que podem ser exibidos e atualizados sem necessidade de recarregar a página HTML inteira Pré-requisitos\nPrecisas de um servidor web local para testar a aplicação web que vamos construir nesta lição Se não tens um, podes instalar o Node js e usar o comando npx lite-server a partir da tua pasta de projeto Isto criará um servidor web local e abrirá a tua aplicação num navegador Preparação\nNo teu computador, cria uma pasta chamada bank com um ficheiro chamado index html dentro dela Vamos começar com este boilerplate HTML:\n```html\nBank App\n```\nModelos HTML\nSe quiseres criar múltiplos ecrãs para uma página web, uma solução seria criar um ficheiro HTML para cada ecrã que desejas exibir No entanto, esta solução apresenta alguns inconvenientes:\nTens de recarregar todo o HTML ao mudar de ecrã, o que pode ser lento É difícil partilhar dados entre os diferentes ecrãs Outra abordagem é ter apenas um ficheiro HTML e definir múltiplos modelos HTML usando o elemento <template> Um modelo é um bloco HTML reutilizável que não é exibido pelo navegador e precisa de ser instanciado em tempo de execução usando JavaScript",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 0,
    "total_chunks": 9
  },
  {
    "id": "5e811b47abcf2def8217c7065d9065a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "cada ecrã que desejas exibir No entanto, esta solução apresenta alguns inconvenientes: Tens de recarregar todo o HTML ao mudar de ecrã, o que pode ser lento É difícil partilhar dados entre os diferentes ecrãs Outra abordagem é ter apenas um ficheiro HTML e definir múltiplos modelos HTML usando o elemento <template> Um modelo é um bloco HTML reutilizável que não é exibido pelo navegador e precisa de ser instanciado em tempo de execução usando JavaScriptTarefa\nVamos criar uma aplicação bancária com dois ecrãs: a página de login e o painel de controlo Primeiro, adicionemos no corpo do HTML um elemento de espaço reservado que usaremos para instanciar os diferentes ecrãs da nossa aplicação:\n```html\nLoading ```\nEstamos a atribuir-lhe um id para facilitar a sua localização com JavaScript mais tarde Dica: como o conteúdo deste elemento será substituído, podemos colocar uma mensagem ou indicador de carregamento que será exibido enquanto a aplicação está a carregar A seguir, adicionemos abaixo o modelo HTML para a página de login Por agora, colocaremos apenas um título e uma secção contendo um link que usaremos para realizar a navegação ```html\nLogin\n```\nDepois, adicionaremos outro modelo HTML para a página do painel de controlo Esta página conterá diferentes secções:\nUm cabeçalho com um título e um link para logout\nO saldo atual da conta bancária\nUma lista de transações, exibida numa tabela\n```html\nBalance: 100$\nTransactions\nDate\nObject\nAmount\n```\nDica: ao criar modelos HTML, se quiseres ver como eles ficarão, podes comentar as linhas <template> e </template> envolvendo-as com < -- --> ✅ Porque achas que usamos atributos id nos modelos Poderíamos usar algo como classes Exibir modelos com JavaScript\nSe experimentares o teu ficheiro HTML atual num navegador, verás que ele fica preso a exibir Loading Isso acontece porque precisamos adicionar algum código JavaScript para instanciar e exibir os modelos HTML",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 1,
    "total_chunks": 9
  },
  {
    "id": "0deb1656551c68e7dfd317ce35dd66fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "Object Amount ``` Dica: ao criar modelos HTML, se quiseres ver como eles ficarão, podes comentar as linhas <template> e </template> envolvendo-as com < -- --> ✅ Porque achas que usamos atributos id nos modelos Poderíamos usar algo como classes Exibir modelos com JavaScript Se experimentares o teu ficheiro HTML atual num navegador, verás que ele fica preso a exibir Loading Isso acontece porque precisamos adicionar algum código JavaScript para instanciar e exibir os modelos HTMLInstanciar um modelo geralmente é feito em 3 passos:\nRecuperar o elemento do modelo no DOM, por exemplo, usando document getElementById Clonar o elemento do modelo, usando cloneNode Anexá-lo ao DOM sob um elemento visível, por exemplo, usando appendChild ✅ Porque precisamos clonar o modelo antes de anexá-lo ao DOM O que achas que aconteceria se saltássemos este passo Tarefa\nCria um novo ficheiro chamado app js na tua pasta de projeto e importa esse ficheiro na secção <head> do teu HTML:\n```html\n```\nAgora, em app js, vamos criar uma nova função updateRoute:\njs\nfunction updateRoute(templateId) {\nconst template = document getElementById(templateId);\nconst view = template content cloneNode(true);\nconst app = document getElementById('app');\napp innerHTML = '';\napp appendChild(view);\n}\nO que fazemos aqui são exatamente os 3 passos descritos acima Instanciamos o modelo com o id templateId e colocamos o seu conteúdo clonado dentro do nosso espaço reservado da aplicação Nota que precisamos usar cloneNode(true) para copiar toda a subárvore do modelo Agora chama esta função com um dos modelos e observa o resultado js\nupdateRoute('login');\n✅ Qual é o propósito deste código app innerHTML = ''; O que acontece sem ele Criar rotas\nQuando falamos de uma aplicação web, chamamos Routing à intenção de mapear URLs para ecrãs específicos que devem ser exibidos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 471,
    "chunk_index": 2,
    "total_chunks": 9
  },
  {
    "id": "6730c82b2fbe0bfd8bc13faabff3b8ee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "colocamos o seu conteúdo clonado dentro do nosso espaço reservado da aplicação Nota que precisamos usar cloneNode(true) para copiar toda a subárvore do modelo Agora chama esta função com um dos modelos e observa o resultado js updateRoute('login'); ✅ Qual é o propósito deste código app innerHTML = ''; O que acontece sem ele Criar rotas Quando falamos de uma aplicação web, chamamos Routing à intenção de mapear URLs para ecrãs específicos que devem ser exibidosNum website com múltiplos ficheiros HTML, isto é feito automaticamente, pois os caminhos dos ficheiros refletem-se no URL Por exemplo, com estes ficheiros na tua pasta de projeto:\nmywebsite/index html\nmywebsite/login html\nmywebsite/admin/index html\nSe criares um servidor web com mywebsite como raiz, o mapeamento de URLs será:\nhttps://site com            --> mywebsite/index html\nhttps://site com/login html --> mywebsite/login html\nhttps://site com/admin/     --> mywebsite/admin/index html\nNo entanto, para a nossa aplicação web, estamos a usar um único ficheiro HTML contendo todos os ecrãs, por isso este comportamento padrão não nos será útil Temos de criar este mapeamento manualmente e atualizar o modelo exibido usando JavaScript Tarefa\nUsaremos um simples objeto para implementar um mapa entre caminhos de URL e os nossos modelos Adiciona este objeto no topo do teu ficheiro app js js\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard' },\n};\nAgora vamos modificar um pouco a função updateRoute Em vez de passar diretamente o templateId como argumento, queremos recuperá-lo primeiro olhando para o URL atual e, em seguida, usar o nosso mapa para obter o valor correspondente do templateId Podemos usar window location pathname para obter apenas a secção do caminho do URL ```js\nfunction updateRoute() {\nconst path = window location pathname;\nconst route = routes[path];\nconst template = document getElementById(route templateId);\nconst view = template content cloneNode(true);\nconst app = document getElementById('app');\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 3,
    "total_chunks": 9
  },
  {
    "id": "94ca5016d68f5eef94b776a2a76ad7b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "vez de passar diretamente o templateId como argumento, queremos recuperá-lo primeiro olhando para o URL atual e, em seguida, usar o nosso mapa para obter o valor correspondente do templateId Podemos usar window location pathname para obter apenas a secção do caminho do URL ```js function updateRoute() { const path = window location pathname; const route = routes[path]; const template = document getElementById(route templateId); const view = template content cloneNode(true); const app = document getElementById('app'); appinnerHTML = '';\napp appendChild(view);\n}\n```\nAqui mapeamos as rotas que declaramos para o modelo correspondente Podes testar que funciona corretamente alterando o URL manualmente no teu navegador ✅ O que acontece se introduzires um caminho desconhecido no URL Como poderíamos resolver isso Adicionar navegação\nO próximo passo para a nossa aplicação é adicionar a possibilidade de navegar entre páginas sem ter de alterar o URL manualmente Isto implica duas coisas:\nAtualizar o URL atual\nAtualizar o modelo exibido com base no novo URL\nJá tratámos da segunda parte com a função updateRoute, por isso temos de descobrir como atualizar o URL atual Teremos de usar JavaScript e, mais especificamente, o history pushState, que permite atualizar o URL e criar uma nova entrada no histórico de navegação, sem recarregar o HTML Nota: Embora o elemento âncora HTML <a href> possa ser usado sozinho para criar hiperligações para diferentes URLs, ele fará com que o navegador recarregue o HTML por padrão É necessário evitar este comportamento ao lidar com rotas usando JavaScript personalizado, utilizando a função preventDefault() no evento de clique Tarefa\nVamos criar uma nova função que possamos usar para navegar na nossa aplicação:\njs\nfunction navigate(path) {\nwindow history pushState({}, path, path);\nupdateRoute();\n}\nEste método primeiro atualiza o URL atual com base no caminho fornecido e, em seguida, atualiza o modelo A propriedade window location origin retorna a raiz do URL, permitindo-nos reconstruir um URL completo a partir de um caminho fornecido",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 4,
    "total_chunks": 9
  },
  {
    "id": "e0ac2b84513efc94268dbbe363dd34b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "rotas usando JavaScript personalizado, utilizando a função preventDefault() no evento de clique Tarefa Vamos criar uma nova função que possamos usar para navegar na nossa aplicação: js function navigate(path) { window history pushState({}, path, path); updateRoute(); } Este método primeiro atualiza o URL atual com base no caminho fornecido e, em seguida, atualiza o modelo A propriedade window location origin retorna a raiz do URL, permitindo-nos reconstruir um URL completo a partir de um caminho fornecidoAgora que temos esta função, podemos resolver o problema que temos se um caminho não corresponder a nenhuma rota definida Vamos modificar a função updateRoute adicionando um fallback para uma das rotas existentes, caso não consigamos encontrar uma correspondência ```js\nfunction updateRoute() {\nconst path = window location pathname;\nconst route = routes[path];\nif ( route) {\nreturn navigate('/login');\n} ```\nSe uma rota não puder ser encontrada, agora redirecionaremos para a página de login Agora vamos criar uma função para obter o URL quando um link é clicado e evitar o comportamento padrão do navegador para links:\njs\nfunction onLinkClick(event) {\nevent preventDefault();\nnavigate(event target href);\n}\nVamos completar o sistema de navegação adicionando ligações aos nossos links de Login e Logout no HTML html\n<a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a> <a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a>\nO objeto event acima captura o evento de click e passa-o para a nossa função onLinkClick Usando o atributo onclick, vincula o evento de click ao código JavaScript, aqui a chamada para a função navigate() Experimenta clicar nestes links, agora deverás conseguir navegar entre os diferentes ecrãs da tua aplicação ✅ O método history pushState faz parte do padrão HTML5 e está implementado em todos os navegadores modernos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 434,
    "chunk_index": 5,
    "total_chunks": 9
  },
  {
    "id": "385113806de261bae1ff99d8ce1057d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a> <a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> O objeto event acima captura o evento de click e passa-o para a nossa função onLinkClick Usando o atributo onclick, vincula o evento de click ao código JavaScript, aqui a chamada para a função navigate() Experimenta clicar nestes links, agora deverás conseguir navegar entre os diferentes ecrãs da tua aplicação ✅ O método history pushState faz parte do padrão HTML5 e está implementado em todos os navegadores modernosSe estiveres a construir uma aplicação web para navegadores mais antigos, há um truque que podes usar em vez desta API: utilizando um hash (#) antes do caminho, podes implementar rotas que funcionam com navegação regular de âncoras e não recarregam a página, já que o propósito do hash era criar links internos dentro de uma página Lidar com os botões de retroceder e avançar do navegador\nUsar o history pushState cria novas entradas no histórico de navegação do navegador Podes verificar isso ao manter pressionado o botão voltar do teu navegador, ele deverá exibir algo como isto:\nSe tentares clicar no botão voltar algumas vezes, verás que o URL atual muda e o histórico é atualizado, mas o mesmo modelo continua a ser exibido Isso acontece porque a aplicação não sabe que precisamos de chamar updateRoute() sempre que o histórico muda Se consultares a documentação de history pushState, podes ver que, se o estado mudar - ou seja, se nos movermos para um URL diferente - o evento popstate é acionado Vamos usar isso para corrigir o problema Tarefa\nPara garantir que o modelo exibido é atualizado quando o histórico do navegador muda, vamos anexar uma nova função que chama updateRoute() Faremos isso no final do nosso ficheiro app js:\njs\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 457,
    "chunk_index": 6,
    "total_chunks": 9
  },
  {
    "id": "73040cab2da2dea0b990ab6fa70fbb51",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "sempre que o histórico muda Se consultares a documentação de history pushState, podes ver que, se o estado mudar - ou seja, se nos movermos para um URL diferente - o evento popstate é acionado Vamos usar isso para corrigir o problema Tarefa Para garantir que o modelo exibido é atualizado quando o histórico do navegador muda, vamos anexar uma nova função que chama updateRoute() Faremos isso no final do nosso ficheiro app js: js windowonpopstate = () => updateRoute();\nupdateRoute();\nNota: usamos uma função de seta aqui para declarar o nosso manipulador de eventos popstate pela sua concisão, mas uma função regular funcionaria da mesma forma Aqui está um vídeo de revisão sobre funções de seta:\n🎥 Clica na imagem acima para um vídeo sobre funções de seta Agora tenta usar os botões de retroceder e avançar do teu navegador e verifica se a rota exibida é atualizada corretamente desta vez 🚀 Desafio\nAdiciona um novo modelo e rota para uma terceira página que mostre os créditos desta aplicação Questionário Pós-Aula\nQuestionário pós-aula\nRevisão e Autoestudo\nO roteamento é uma das partes surpreendentemente complicadas do desenvolvimento web, especialmente à medida que a web se move de comportamentos de atualização de página para atualizações de página em Aplicações de Página Única Lê um pouco sobre como o serviço Azure Static Web App lida com o roteamento Consegues explicar porque algumas das decisões descritas nesse documento são necessárias Tarefa\nMelhora o roteamento\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 478,
    "chunk_index": 7,
    "total_chunks": 9
  },
  {
    "id": "e76c13c0c9ad92ab9a39fec060b82d90",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "Static Web App lida com o roteamento Consegues explicar porque algumas das decisões descritas nesse documento são necessárias Tarefa Melhora o roteamento Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 159,
    "chunk_index": 8,
    "total_chunks": 9
  },
  {
    "id": "3360a147ccbe4bd8ecc58c3564e06819",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\assignment.md",
    "source_type": "git_repo",
    "title": "Implementar o diálogo \"Adicionar transação\"",
    "content": "Implementar o diálogo \"Adicionar transação\"\nInstruções\nA nossa aplicação bancária ainda está a faltar uma funcionalidade importante: a possibilidade de introduzir novas transações.\nUsando tudo o que aprendeste nas quatro lições anteriores, implementa um diálogo \"Adicionar transação\":\nAdiciona um botão \"Adicionar transação\" na página do painel de controlo.\nCria uma nova página com um modelo HTML ou utiliza JavaScript para mostrar/ocultar o HTML do diálogo sem sair da página do painel de controlo (podes usar a propriedade hidden para isso, ou classes CSS).\nGarante que tratas da acessibilidade para teclado e leitores de ecrã no diálogo.\nImplementa um formulário HTML para receber os dados de entrada.\nCria dados JSON a partir dos dados do formulário e envia-os para a API.\nAtualiza a página do painel de controlo com os novos dados.\nConsulta as especificações da API do servidor para ver qual API precisas de chamar e qual é o formato JSON esperado.\nAqui está um exemplo do resultado após completares a tarefa:\nRubrica\n| Critérios | Exemplar                                                                                         | Adequado                                                                                                               | Necessita de Melhorias                      |\n| --------- | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |\n|           | Adicionar uma transação está completamente implementado seguindo todas as boas práticas vistas nas lições. | Adicionar uma transação está implementado, mas não segue as boas práticas vistas nas lições ou funciona apenas parcialmente. | Adicionar uma transação não funciona de todo. |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3161,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "317ca6f8f95b7fc270b997f837a14ea7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nEm quase todas as aplicações web modernas, é possível criar uma conta para ter um espaço privado Como múltiplos utilizadores podem aceder a uma aplicação web ao mesmo tempo, é necessário um mecanismo para armazenar os dados pessoais de cada utilizador separadamente e selecionar quais informações exibir Não vamos abordar como gerir identidade de utilizador de forma segura, pois é um tópico extenso por si só, mas garantiremos que cada utilizador possa criar uma (ou mais) conta bancária na nossa aplicação Nesta parte, utilizaremos formulários HTML para adicionar login e registo à nossa aplicação web Veremos como enviar os dados para uma API de servidor programaticamente e, por fim, como definir regras básicas de validação para os dados inseridos pelos utilizadores Pré-requisitos\nÉ necessário ter concluído a parte de templates HTML e rotas da aplicação web para esta lição Também é necessário instalar o Node js e executar a API do servidor localmente para poder enviar dados e criar contas Nota importante\nTerás dois terminais a funcionar ao mesmo tempo, conforme listado abaixo:\n1 Para a aplicação bancária principal que construímos na lição de templates HTML e rotas\n2 Para a API do servidor da aplicação bancária que acabámos de configurar acima É necessário que ambos os servidores estejam ativos para seguir o resto da lição Eles estão a ouvir em portas diferentes (porta 3000 e porta 5000), por isso tudo deve funcionar corretamente Podes testar se o servidor está a funcionar corretamente executando este comando num terminal:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0 0\" as a result\n```\nFormulário e controlos\nO elemento <form> encapsula uma secção de um documento HTML onde o utilizador pode inserir e enviar dados através de controlos interativos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 0,
    "total_chunks": 11
  },
  {
    "id": "90165b0d798d172eeaa36862e204909f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "o resto da lição Eles estão a ouvir em portas diferentes (porta 3000 e porta 5000), por isso tudo deve funcionar corretamente Podes testar se o servidor está a funcionar corretamente executando este comando num terminal: ```sh curl http://localhost:5000/api -> should return \"Bank API v1 0 0\" as a result ``` Formulário e controlos O elemento <form> encapsula uma secção de um documento HTML onde o utilizador pode inserir e enviar dados através de controlos interativosExistem vários tipos de controlos de interface de utilizador (UI) que podem ser usados dentro de um formulário, sendo os mais comuns os elementos <input> e <button> Existem muitos tipos diferentes de <input> Por exemplo, para criar um campo onde o utilizador pode inserir o seu nome de utilizador, podes usar:\nhtml\n<input id=\"username\" name=\"username\" type=\"text\">\nO atributo name será usado como o nome da propriedade quando os dados do formulário forem enviados O atributo id é usado para associar um <label> ao controlo do formulário Consulta a lista completa de tipos de <input> e outros controlos de formulário para teres uma ideia de todos os elementos de UI nativos que podes usar ao construir a tua interface ✅ Nota que <input> é um elemento vazio no qual não deves adicionar uma tag de encerramento correspondente No entanto, podes usar a notação de autoencerramento <input/>, mas não é obrigatório O elemento <button> dentro de um formulário é um pouco especial Se não especificares o atributo type, ele automaticamente enviará os dados do formulário para o servidor quando pressionado Aqui estão os valores possíveis para o atributo type:\nsubmit: O padrão dentro de um <form>, o botão aciona a ação de envio do formulário reset: O botão redefine todos os controlos do formulário para os seus valores iniciais button: Não atribui um comportamento padrão ao botão quando pressionado Podes então atribuir ações personalizadas usando JavaScript Tarefa\nVamos começar por adicionar um formulário ao template de login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 1,
    "total_chunks": 11
  },
  {
    "id": "45c5aaad19a9493569ecff02bffdf6c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "os dados do formulário para o servidor quando pressionado Aqui estão os valores possíveis para o atributo type: submit: O padrão dentro de um <form>, o botão aciona a ação de envio do formulário reset: O botão redefine todos os controlos do formulário para os seus valores iniciais button: Não atribui um comportamento padrão ao botão quando pressionado Podes então atribuir ações personalizadas usando JavaScript Tarefa Vamos começar por adicionar um formulário ao template de loginPrecisaremos de um campo para o nome de utilizador e um botão de Login ```html\nLogin\nUsername\nLogin\n```\nSe olhares mais de perto, podes notar que também adicionámos um elemento <label> aqui Os elementos <label> são usados para adicionar um nome aos controlos de UI, como o nosso campo de nome de utilizador Os rótulos são importantes para a legibilidade dos formulários, mas também trazem benefícios adicionais:\nAo associar um rótulo a um controlo de formulário, ajuda os utilizadores que utilizam tecnologias assistivas (como leitores de ecrã) a entender que dados devem fornecer Podes clicar no rótulo para colocar diretamente o foco no controlo associado, facilitando o acesso em dispositivos com ecrã tátil Acessibilidade na web é um tópico muito importante que muitas vezes é negligenciado Graças aos elementos HTML semânticos, não é difícil criar conteúdo acessível se os utilizares corretamente Podes ler mais sobre acessibilidade para evitar erros comuns e tornar-te um programador responsável Agora vamos adicionar um segundo formulário para o registo, logo abaixo do anterior:\n```html\nRegister\nUsername\nCurrency\nDescription\nCurrent balance\nRegister\n```\nUsando o atributo value, podemos definir um valor padrão para um determinado campo Repara também que o campo para balance tem o tipo number Parece diferente dos outros campos Experimenta interagir com ele ✅ Consegues navegar e interagir com os formulários usando apenas o teclado Como o farias",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 2,
    "total_chunks": 11
  },
  {
    "id": "fdc125a817329c3a604ef544ea96faa4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "comuns e tornar-te um programador responsável Agora vamos adicionar um segundo formulário para o registo, logo abaixo do anterior: ```html Register Username Currency Description Current balance Register ``` Usando o atributo value, podemos definir um valor padrão para um determinado campo Repara também que o campo para balance tem o tipo number Parece diferente dos outros campos Experimenta interagir com ele ✅ Consegues navegar e interagir com os formulários usando apenas o teclado Como o fariasEnviar dados para o servidor\nAgora que temos uma interface funcional, o próximo passo é enviar os dados para o servidor Vamos fazer um teste rápido usando o nosso código atual: o que acontece se clicares no botão Login ou Register Notaste a mudança na secção de URL do navegador A ação padrão de um <form> é enviar os dados do formulário para o URL atual do servidor usando o método GET, anexando os dados do formulário diretamente ao URL No entanto, este método tem algumas limitações:\nOs dados enviados são muito limitados em tamanho (cerca de 2000 caracteres)\nOs dados são visíveis diretamente no URL (não é ideal para senhas)\nNão funciona com uploads de ficheiros\nPor isso, podes alterá-lo para usar o método POST, que envia os dados do formulário para o servidor no corpo da requisição HTTP, sem as limitações anteriores Embora o POST seja o método mais utilizado para enviar dados, em alguns cenários específicos é preferível usar o método GET, como ao implementar um campo de pesquisa Tarefa\nAdiciona as propriedades action e method ao formulário de registo:\n```html\n```\nAgora tenta registar uma nova conta com o teu nome Após clicares no botão *Register*, deverás ver algo como isto: [Janela do navegador no endereço localhost:5000/api/accounts, mostrando uma string JSON com os dados do utilizador]( / / / /7-bank-project/2-forms/images/form-post png)\nSe tudo correr bem, o servidor deverá responder à tua requisição com uma resposta [JSON](https://www json org/json-en html) contendo os dados da conta que foi criada ✅ Tenta registar novamente com o mesmo nome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 3,
    "total_chunks": 11
  },
  {
    "id": "c18f828242a1c8a53255b5fa67bcf772",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "```html ``` Agora tenta registar uma nova conta com o teu nome Após clicares no botão *Register*, deverás ver algo como isto: [Janela do navegador no endereço localhost:5000/api/accounts, mostrando uma string JSON com os dados do utilizador]( / / / /7-bank-project/2-forms/images/form-post png) Se tudo correr bem, o servidor deverá responder à tua requisição com uma resposta [JSON](https://www json org/json-en html) contendo os dados da conta que foi criada ✅ Tenta registar novamente com o mesmo nomeO que acontece ## Enviar dados sem recarregar a página\nComo provavelmente notaste, há um pequeno problema com a abordagem que acabámos de usar: ao enviar o formulário, saímos da nossa aplicação e o navegador redireciona para o URL do servidor Estamos a tentar evitar todos os recarregamentos de página na nossa aplicação web, já que estamos a criar uma [Aplicação de Página Única (SPA)](https://en wikipedia org/wiki/Single-page_application) Para enviar os dados do formulário para o servidor sem forçar um recarregamento da página, temos de usar código JavaScript Em vez de colocar um URL na propriedade `action` de um elemento ``, podes usar qualquer código JavaScript precedido pela string `javascript:` para realizar uma ação personalizada Usar isto também significa que terás de implementar algumas tarefas que anteriormente eram feitas automaticamente pelo navegador:\n- Recuperar os dados do formulário\n- Converter e codificar os dados do formulário num formato adequado\n- Criar a requisição HTTP e enviá-la para o servidor\n### Tarefa\nSubstitui o `action` do formulário de registo por:\n```html\n```\nAbre o `app js` e adiciona uma nova função chamada `register`:\n```js\nfunction register() {\nconst registerForm = document getElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst data = Object fromEntries(formData);\nconst jsonData = JSON stringify(data);\n}\n```\nAqui recuperamos o elemento do formulário usando `getElementById()` e utilizamos o auxiliar [`FormData`](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 4,
    "total_chunks": 11
  },
  {
    "id": "779e01b71289c42be707aeb66fbc2d05",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "num formato adequado - Criar a requisição HTTP e enviá-la para o servidor ### Tarefa Substitui o `action` do formulário de registo por: ```html ``` Abre o `app js` e adiciona uma nova função chamada `register`: ```js function register() { const registerForm = document getElementById('registerForm'); const formData = new FormData(registerForm); const data = Object fromEntries(formData); const jsonData = JSON stringify(data); } ``` Aqui recuperamos o elemento do formulário usando `getElementById()` e utilizamos o auxiliar [`FormData`](https://developer mozillaorg/docs/Web/API/FormData) para extrair os valores dos controlos do formulário como um conjunto de pares chave/valor Depois, convertemos os dados para um objeto regular usando [`Object fromEntries()`](https://developer mozilla org/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) e, finalmente, serializamos os dados para [JSON](https://www json org/json-en html), um formato comumente usado para troca de dados na web Os dados estão agora prontos para serem enviados ao servidor Cria uma nova função chamada `createAccount`:\n```js\nasync function createAccount(account) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts', {\nmethod: 'POST',\nheaders: { 'Content-Type': 'application/json' },\nbody: account\n});\nreturn await response json();\n} catch (error) {\nreturn { error: error message || 'Unknown error' };\n}\n}\n```\nO que esta função faz Primeiro, repara na palavra-chave `async` aqui Isto significa que a função contém código que será executado [**assincronamente**](https://developer mozilla org/docs/Web/JavaScript/Reference/Statements/async_function) Quando usada juntamente com a palavra-chave `await`, permite esperar que o código assíncrono seja executado - como esperar pela resposta do servidor aqui - antes de continuar Aqui está um vídeo rápido sobre o uso de `async/await`:\n[ [Async e Await para gerir promessas](https://img youtube com/vi/YwmlRkrxvkk/0 jpg)](https://youtube com/watch",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 5,
    "total_chunks": 11
  },
  {
    "id": "c0dbc402d8d4924560e53a6f10ddbdfe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "}; } } ``` O que esta função faz Primeiro, repara na palavra-chave `async` aqui Isto significa que a função contém código que será executado [**assincronamente**](https://developer mozilla org/docs/Web/JavaScript/Reference/Statements/async_function) Quando usada juntamente com a palavra-chave `await`, permite esperar que o código assíncrono seja executado - como esperar pela resposta do servidor aqui - antes de continuar Aqui está um vídeo rápido sobre o uso de `async/await`: [ [Async e Await para gerir promessas](https://img youtube com/vi/YwmlRkrxvkk/0 jpg)](https://youtube com/watchv=YwmlRkrxvkk \"Async e Await para gerir promessas\")\n> 🎥 Clica na imagem acima para um vídeo sobre async/await Utilizamos a API `fetch()` para enviar dados JSON ao servidor Este método aceita 2 parâmetros:\n- O URL do servidor, por isso colocamos `//localhost:5000/api/accounts` aqui - As configurações da requisição É aqui que definimos o método como `POST` e fornecemos o `body` para a requisição Como estamos a enviar dados JSON ao servidor, também precisamos definir o cabeçalho `Content-Type` como `application/json` para que o servidor saiba como interpretar o conteúdo Como o servidor responderá à requisição com JSON, podemos usar `await response json()` para analisar o conteúdo JSON e retornar o objeto resultante Nota que este método é assíncrono, por isso usamos a palavra-chave `await` aqui antes de retornar para garantir que quaisquer erros durante a análise também sejam capturados Agora adiciona algum código à função `register` para chamar `createAccount()`:\n```js\nconst result = await createAccount(jsonData);\n```\nComo usamos a palavra-chave `await` aqui, precisamos adicionar a palavra-chave `async` antes da função register:\n```js\nasync function register() {\n```\nPor fim, vamos adicionar alguns logs para verificar o resultado A função final deve ficar assim:\n```js\nasync function register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 492,
    "chunk_index": 6,
    "total_chunks": 11
  },
  {
    "id": "602fa21d5ce5126ae8dcae4c81b46d6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "de retornar para garantir que quaisquer erros durante a análise também sejam capturados Agora adiciona algum código à função `register` para chamar `createAccount()`: ```js const result = await createAccount(jsonData); ``` Como usamos a palavra-chave `await` aqui, precisamos adicionar a palavra-chave `async` antes da função register: ```js async function register() { ``` Por fim, vamos adicionar alguns logs para verificar o resultado A função final deve ficar assim: ```js async function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst jsonData = JSON stringify(Object fromEntries(formData));\nconst result = await createAccount(jsonData);\nif (result error) {\nreturn console log('An error occurred:', result error);\n}\nconsole log('Account created ', result);\n}\n```\nFoi um pouco longo, mas chegámos lá Se abrires as [ferramentas de desenvolvimento do navegador](https://developer mozilla org/docs/Learn/Common_questions/What_are_browser_developer_tools) e tentares registar uma nova conta, não deverás ver nenhuma mudança na página web, mas uma mensagem aparecerá na consola confirmando que tudo está a funcionar [Captura de ecrã mostrando uma mensagem de log na consola do navegador]( / / / /7-bank-project/2-forms/images/browser-console png)\n✅ Achas que os dados são enviados ao servidor de forma segura E se alguém conseguir intercetar a requisição Podes ler sobre [HTTPS](https://en wikipedia org/wiki/HTTPS) para saber mais sobre comunicação segura de dados ## Validação de dados\nSe tentares registar uma nova conta sem definir primeiro um nome de utilizador, podes ver que o servidor retorna um erro com o código de estado [400 (Bad Request)](https://developer mozilla org/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing) ) Antes de enviar dados para um servidor, é uma boa prática [validar os dados do formulário](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 7,
    "total_chunks": 11
  },
  {
    "id": "650620609408f95ac85b7dbbd7f3ccdf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "forma segura E se alguém conseguir intercetar a requisição Podes ler sobre [HTTPS](https://en wikipedia org/wiki/HTTPS) para saber mais sobre comunicação segura de dados ## Validação de dados Se tentares registar uma nova conta sem definir primeiro um nome de utilizador, podes ver que o servidor retorna um erro com o código de estado [400 (Bad Request)](https://developer mozilla org/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing) ) Antes de enviar dados para um servidor, é uma boa prática [validar os dados do formulário](https://developer mozillaorg/docs/Learn/Forms/Form_validation) previamente, sempre que possível, para garantir que envias uma requisição válida Os controlos de formulário HTML5 fornecem validação integrada usando vários atributos:\n- `required`: o campo precisa ser preenchido, caso contrário o formulário não pode ser enviado - `minlength` e `maxlength`: define o número mínimo e máximo de caracteres em campos de texto - `min` e `max`: define o valor mínimo e máximo de um campo numérico - `type`: define o tipo de dados esperado, como `number`, `email`, `file` ou [outros tipos integrados](https://developer mozilla org/docs/Web/HTML/Element/input) Este atributo também pode alterar a renderização visual do controlo do formulário - `pattern`: permite definir um padrão de [expressão regular](https://developer mozilla org/docs/Web/JavaScript/Guide/Regular_Expressions) para testar se os dados inseridos são válidos ou não > Dica: pode personalizar o aspeto dos seus controlos de formulário dependendo se são válidos ou não, utilizando as pseudo-classes CSS `:valid` e `:invalid` ### Tarefa\nExistem 2 campos obrigatórios para criar uma nova conta válida: o nome de utilizador e a moeda Os outros campos são opcionais Atualize o HTML do formulário, utilizando tanto o atributo `required` como texto no rótulo do campo para que:\n```html\nUsername (required)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 8,
    "total_chunks": 11
  },
  {
    "id": "dad4cd8884afa455173668ba2467ecd9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "os dados inseridos são válidos ou não > Dica: pode personalizar o aspeto dos seus controlos de formulário dependendo se são válidos ou não, utilizando as pseudo-classes CSS `:valid` e `:invalid` ### Tarefa Existem 2 campos obrigatórios para criar uma nova conta válida: o nome de utilizador e a moeda Os outros campos são opcionais Atualize o HTML do formulário, utilizando tanto o atributo `required` como texto no rótulo do campo para que: ```html Username (required)Currency (required)\n```\nEmbora esta implementação específica do servidor não imponha limites específicos no comprimento máximo dos campos, é sempre uma boa prática definir limites razoáveis para qualquer entrada de texto do utilizador Adicione um atributo `maxlength` aos campos de texto:\n```html ```\nAgora, se pressionar o botão *Registar* e algum campo não respeitar uma regra de validação que definimos, deverá ver algo como isto: [Captura de ecrã mostrando o erro de validação ao tentar submeter o formulário]( / / / /7-bank-project/2-forms/images/validation-error png)\nA validação como esta, realizada *antes* de enviar qualquer dado para o servidor, é chamada de validação **do lado do cliente** Mas note que nem sempre é possível realizar todas as verificações sem enviar os dados Por exemplo, não podemos verificar aqui se já existe uma conta com o mesmo nome de utilizador sem enviar um pedido ao servidor Validações adicionais realizadas no servidor são chamadas de validação **do lado do servidor** Normalmente, ambas precisam de ser implementadas, e enquanto a validação do lado do cliente melhora a experiência do utilizador ao fornecer feedback instantâneo, a validação do lado do servidor é crucial para garantir que os dados do utilizador que manipula são válidos e seguros ---\n## 🚀 Desafio\nMostre uma mensagem de erro no HTML se o utilizador já existir Aqui está um exemplo de como a página de login final pode parecer após um pouco de estilização: [Captura de ecrã da página de login após adicionar estilos CSS]( / / /",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 492,
    "chunk_index": 9,
    "total_chunks": 11
  },
  {
    "id": "951bbdb0adb26a621cbbd9aebec82b24",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 2: Criar um Formulário de Login e Registo",
    "content": "experiência do utilizador ao fornecer feedback instantâneo, a validação do lado do servidor é crucial para garantir que os dados do utilizador que manipula são válidos e seguros --- ## 🚀 Desafio Mostre uma mensagem de erro no HTML se o utilizador já existir Aqui está um exemplo de como a página de login final pode parecer após um pouco de estilização: [Captura de ecrã da página de login após adicionar estilos CSS]( / / //7-bank-project/2-forms/images/result png)\n## Questionário Pós-Aula\n[Questionário pós-aula](https://ashy-river-0debb7803 1 azurestaticapps net/quiz/44)\n## Revisão e Autoestudo\nOs programadores têm sido muito criativos nos seus esforços de construção de formulários, especialmente no que diz respeito a estratégias de validação Aprenda sobre diferentes fluxos de formulários explorando [CodePen](https://codepen com); consegue encontrar alguns formulários interessantes e inspiradores ## Tarefa\n[Estilize a sua aplicação bancária](assignment md)\n**Aviso Legal**:\nEste documento foi traduzido utilizando o serviço de tradução por IA [Co-op Translator](https://github com/Azure/co-op-translator) Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 391,
    "chunk_index": 10,
    "total_chunks": 11
  },
  {
    "id": "6b57a1013d153df3e2a7af6d1ed2b42f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "API do Banco",
    "content": "API do Banco\nAPI do Banco construída com Node js + Express A API já está construída para si e não faz parte do exercício No entanto, se estiver interessado em aprender como construir uma API como esta, pode seguir esta série de vídeos: https://aka ms/NodeBeginner (os vídeos 17 a 21 cobrem exatamente esta API) Também pode dar uma vista de olhos neste tutorial interativo: https://aka ms/learn/express-api\nExecutar o servidor\nCertifique-se de que tem Node js instalado Faça um clone deste repositório The Web-Dev-For-Beginners Abra o seu terminal e navegue até à pasta Web-Dev-For-Beginners/7-bank-project/api Execute npm install e aguarde que os pacotes sejam instalados (pode demorar algum tempo, dependendo da qualidade da sua ligação à internet) Quando a instalação terminar, execute npm start e está pronto para começar O servidor deverá começar a ouvir na porta 5000 Este servidor será executado juntamente com o terminal do servidor principal da aplicação do banco (a ouvir na porta 3000), não o feche Nota: todas as entradas são armazenadas em memória e não são persistidas, por isso, quando o servidor é parado, todos os dados são perdidos Detalhes da API\nRota                                         | Descrição\n---------------------------------------------|------------------------------------\nGET    /api/                                 | Obter informações do servidor\nPOST   /api/accounts/                        | Criar uma conta, ex: { user: 'Yohan', description: 'O meu orçamento', currency: 'EUR', balance: 100 }\nGET    /api/accounts/:user                   | Obter todos os dados da conta especificada\nDELETE /api/accounts/:user                   | Remover a conta especificada\nPOST   /api/accounts/:user/transactions      | Adicionar uma transação, ex: { date: '2020-07-23T18:25:43 511Z', object: 'Comprei um livro', amount: -20 }\nDELETE  /api/accounts/:user/transactions/:id | Remover a transação especificada\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2994,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "2cfb8d3ba334b2dfd5c6b59b1e9ea8aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "API do Banco",
    "content": "POST /api/accounts/ | Criar uma conta, ex: { user: 'Yohan', description: 'O meu orçamento', currency: 'EUR', balance: 100 } GET /api/accounts/:user | Obter todos os dados da conta especificada DELETE /api/accounts/:user | Remover a conta especificada POST /api/accounts/:user/transactions | Adicionar uma transação, ex: { date: '2020-07-23T18:25:43 511Z', object: 'Comprei um livro', amount: -20 } DELETE /api/accounts/:user/transactions/:id | Remover a transação especificada Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op TranslatorEmbora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se a tradução profissional humana Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2994,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 256,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "8741174b59caabef24402462ccc95c09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\solution\\README.md",
    "source_type": "git_repo",
    "title": "Aplicação bancária",
    "content": "Aplicação bancária\nSolução de exemplo para o projeto de aplicação bancária, construída com HTML5, CSS e JavaScript puro (sem frameworks ou bibliotecas).\nExecutar a aplicação\nPrimeiro, certifique-se de que tem o servidor API em funcionamento.\nQualquer servidor web pode ser utilizado para executar a aplicação, mas como deverá ter o Node.js instalado para executar a API, pode:\nClonar este repositório com Git.\nAbrir um terminal, navegar até este diretório e executar npx lite-server .. Isto iniciará um servidor web de desenvolvimento na porta 3000.\nAbrir http://localhost:3000 num navegador para executar a aplicação.\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1544,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 283,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "b63cf9fa282033015abb6e23c584e51c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nNo núcleo de cada aplicação web está dados Os dados podem assumir muitas formas, mas o seu principal objetivo é sempre exibir informações ao utilizador Com as aplicações web a tornarem-se cada vez mais interativas e complexas, a forma como o utilizador acede e interage com as informações tornou-se uma parte essencial do desenvolvimento web Nesta lição, veremos como obter dados de um servidor de forma assíncrona e utilizá-los para exibir informações numa página web sem recarregar o HTML Pré-requisitos\nÉ necessário ter construído a Formulário de Login e Registo da aplicação web para esta lição Também é necessário instalar o Node js e executar a API do servidor localmente para obter os dados da conta Pode testar se o servidor está a funcionar corretamente executando este comando num terminal:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0 0\" as a result\n```\nAJAX e obtenção de dados\nOs sites tradicionais atualizam o conteúdo exibido quando o utilizador seleciona um link ou submete dados através de um formulário, recarregando a página HTML completa Sempre que novos dados precisam de ser carregados, o servidor web retorna uma nova página HTML que precisa de ser processada pelo navegador, interrompendo a ação atual do utilizador e limitando as interações durante o recarregamento Este fluxo de trabalho também é chamado de Aplicação Multi-Página ou MPA Quando as aplicações web começaram a tornar-se mais complexas e interativas, surgiu uma nova técnica chamada AJAX (JavaScript e XML Assíncronos) Esta técnica permite que as aplicações web enviem e obtenham dados de um servidor de forma assíncrona usando JavaScript, sem ter de recarregar a página HTML, resultando em atualizações mais rápidas e interações mais suaves",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 482,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "c88dfc5bee074c4251560bd5543003d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "utilizador e limitando as interações durante o recarregamento Este fluxo de trabalho também é chamado de Aplicação Multi-Página ou MPA Quando as aplicações web começaram a tornar-se mais complexas e interativas, surgiu uma nova técnica chamada AJAX (JavaScript e XML Assíncronos) Esta técnica permite que as aplicações web enviem e obtenham dados de um servidor de forma assíncrona usando JavaScript, sem ter de recarregar a página HTML, resultando em atualizações mais rápidas e interações mais suavesQuando novos dados são recebidos do servidor, a página HTML atual também pode ser atualizada com JavaScript usando a API DOM Com o tempo, esta abordagem evoluiu para o que agora é chamado de Aplicação de Página Única ou SPA Quando o AJAX foi introduzido pela primeira vez, a única API disponível para obter dados de forma assíncrona era XMLHttpRequest Mas os navegadores modernos agora também implementam a mais conveniente e poderosa Fetch API, que utiliza promessas e é mais adequada para manipular dados JSON Embora todos os navegadores modernos suportem a Fetch API, se quiser que a sua aplicação web funcione em navegadores antigos ou desatualizados, é sempre uma boa ideia verificar a tabela de compatibilidade em caniuse com primeiro Tarefa\nNa lição anterior implementámos o formulário de registo para criar uma conta Agora vamos adicionar código para fazer login usando uma conta existente e obter os seus dados Abra o ficheiro app js e adicione uma nova função login:\njs\nasync function login() {\nconst loginForm = document getElementById('loginForm')\nconst user = loginForm user value;\n}\nAqui começamos por obter o elemento do formulário com getElementById(), e depois obtemos o nome de utilizador do campo de entrada com loginForm user value Cada controlo de formulário pode ser acedido pelo seu nome (definido no HTML usando o atributo name) como uma propriedade do formulário",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 458,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "56317f560c03e24d3c5a758331620fad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "dados Abra o ficheiro app js e adicione uma nova função login: js async function login() { const loginForm = document getElementById('loginForm') const user = loginForm user value; } Aqui começamos por obter o elemento do formulário com getElementById(), e depois obtemos o nome de utilizador do campo de entrada com loginForm user value Cada controlo de formulário pode ser acedido pelo seu nome (definido no HTML usando o atributo name) como uma propriedade do formulárioDe forma semelhante ao que fizemos para o registo, vamos criar outra função para realizar uma solicitação ao servidor, mas desta vez para obter os dados da conta:\njs\nasync function getAccount(user) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));\nreturn await response json();\n} catch (error) {\nreturn { error: error message || 'Unknown error' };\n}\n}\nUtilizamos a API fetch para solicitar os dados de forma assíncrona ao servidor, mas desta vez não precisamos de parâmetros adicionais além do URL a ser chamado, pois estamos apenas a consultar dados Por padrão, fetch cria uma solicitação HTTP GET, que é o que procuramos aqui ✅ encodeURIComponent() é uma função que escapa caracteres especiais para URLs Que problemas poderíamos ter se não chamássemos esta função e utilizássemos diretamente o valor de user no URL Agora vamos atualizar a nossa função login para usar getAccount:\n```js\nasync function login() {\nconst loginForm = document getElementById('loginForm')\nconst user = loginForm user value;\nconst data = await getAccount(user);\nif (data error) {\nreturn console log('loginError', data error);\n}\naccount = data;\nnavigate('/dashboard');\n}\n```\nPrimeiro, como getAccount é uma função assíncrona, precisamos de combiná-la com a palavra-chave await para aguardar o resultado do servidor Como em qualquer solicitação ao servidor, também temos de lidar com casos de erro Por enquanto, vamos apenas adicionar uma mensagem de log para exibir o erro e voltar a ele mais tarde",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 468,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "c11eed2d482088c14567568e3649b98c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "user value; const data = await getAccount(user); if (data error) { return console log('loginError', data error); } account = data; navigate('/dashboard'); } ``` Primeiro, como getAccount é uma função assíncrona, precisamos de combiná-la com a palavra-chave await para aguardar o resultado do servidor Como em qualquer solicitação ao servidor, também temos de lidar com casos de erro Por enquanto, vamos apenas adicionar uma mensagem de log para exibir o erro e voltar a ele mais tardeDepois, temos de armazenar os dados em algum lugar para que possamos utilizá-los posteriormente para exibir as informações do painel Como a variável account ainda não existe, vamos criar uma variável global para ela no topo do nosso ficheiro:\njs\nlet account = null;\nDepois de os dados do utilizador serem guardados numa variável, podemos navegar da página de login para o dashboard usando a função navigate() que já temos Finalmente, precisamos de chamar a nossa função login quando o formulário de login for submetido, modificando o HTML:\n```html\n```\nTeste se tudo está a funcionar corretamente registando uma nova conta e tentando fazer login com a mesma conta Antes de avançar para a próxima parte, também podemos completar a função `register` adicionando isto no final da função:\n```js\naccount = result;\nnavigate('/dashboard');\n```\n✅ Sabia que, por padrão, só pode chamar APIs de servidor a partir do *mesmo domínio e porta* da página web que está a visualizar Este é um mecanismo de segurança imposto pelos navegadores Mas espere, a nossa aplicação web está a funcionar em `localhost:3000`, enquanto a API do servidor está a funcionar em `localhost:5000` Por que funciona Usando uma técnica chamada [Cross-Origin Resource Sharing (CORS)](https://developer mozilla org/docs/Web/HTTP/CORS), é possível realizar solicitações HTTP entre origens diferentes se o servidor adicionar cabeçalhos especiais à resposta, permitindo exceções para domínios específicos > Saiba mais sobre APIs ao fazer esta [lição](https://docs microsoft com/learn/modules/use-apis-discover-museum-art/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "7d606d776296bdb08940969ee44b92de",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "visualizar Este é um mecanismo de segurança imposto pelos navegadores Mas espere, a nossa aplicação web está a funcionar em `localhost:3000`, enquanto a API do servidor está a funcionar em `localhost:5000` Por que funciona Usando uma técnica chamada [Cross-Origin Resource Sharing (CORS)](https://developer mozilla org/docs/Web/HTTP/CORS), é possível realizar solicitações HTTP entre origens diferentes se o servidor adicionar cabeçalhos especiais à resposta, permitindo exceções para domínios específicos > Saiba mais sobre APIs ao fazer esta [lição](https://docs microsoft com/learn/modules/use-apis-discover-museum-art/WT mc_id=academic-77807-sagibbon)\n## Atualizar HTML para exibir dados\nAgora que temos os dados do utilizador, temos de atualizar o HTML existente para exibi-los Já sabemos como obter um elemento do DOM usando, por exemplo, `document getElementById()` Depois de ter um elemento base, aqui estão algumas APIs que pode usar para modificá-lo ou adicionar elementos filhos:\n- Usando a propriedade [`textContent`](https://developer mozilla org/docs/Web/API/Node/textContent), pode alterar o texto de um elemento Note que alterar este valor remove todos os filhos do elemento (se houver) e substitui-os pelo texto fornecido Assim, também é um método eficiente para remover todos os filhos de um determinado elemento ao atribuir uma string vazia `''` a ele - Usando [`document createElement()`](https://developer mozilla org/docs/Web/API/Document/createElement) juntamente com o método [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append), pode criar e anexar um ou mais novos elementos filhos ✅ Usando a propriedade [`innerHTML`](https://developer mozilla org/docs/Web/API/Element/innerHTML) de um elemento, também é possível alterar os seus conteúdos HTML, mas esta deve ser evitada, pois é vulnerável a ataques de [cross-site scripting (XSS)](https://developer mozilla org/docs/Glossary/Cross-site_scripting)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "20389fe8d15e998008d5857c2d61747c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "método eficiente para remover todos os filhos de um determinado elemento ao atribuir uma string vazia `''` a ele - Usando [`document createElement()`](https://developer mozilla org/docs/Web/API/Document/createElement) juntamente com o método [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append), pode criar e anexar um ou mais novos elementos filhos ✅ Usando a propriedade [`innerHTML`](https://developer mozilla org/docs/Web/API/Element/innerHTML) de um elemento, também é possível alterar os seus conteúdos HTML, mas esta deve ser evitada, pois é vulnerável a ataques de [cross-site scripting (XSS)](https://developer mozilla org/docs/Glossary/Cross-site_scripting)### Tarefa\nAntes de avançar para o ecrã do painel (*dashboard*), há mais uma coisa que devemos fazer na página de *login* Atualmente, se tentar fazer login com um nome de utilizador que não existe, uma mensagem é exibida na consola, mas para um utilizador normal nada muda e não sabe o que está a acontecer Vamos adicionar um elemento de espaço reservado no formulário de login onde podemos exibir uma mensagem de erro, se necessário Um bom lugar seria logo antes do botão de login ``:\n```html Login ```\nEste elemento `` está vazio, o que significa que nada será exibido no ecrã até adicionarmos algum conteúdo a ele Também damos-lhe um `id` para que possamos recuperá-lo facilmente com JavaScript Volte ao ficheiro `app js` e crie uma nova função auxiliar `updateElement`:\n```js\nfunction updateElement(id, text) {\nconst element = document getElementById(id);\nelement textContent = text;\n}\n```\nEsta função é bastante simples: dado um *id* de elemento e um *texto*, ela atualizará o conteúdo de texto do elemento DOM com o `id` correspondente Vamos usar este método no lugar da mensagem de erro anterior na função `login`:\n```js\nif (data error) {\nreturn updateElement('loginError', data error);\n}\n```\nAgora, se tentar fazer login com uma conta inválida, deverá ver algo como isto:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "4ebff45a716eae4bff899ac62ccb779f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "const element = document getElementById(id); element textContent = text; } ``` Esta função é bastante simples: dado um *id* de elemento e um *texto*, ela atualizará o conteúdo de texto do elemento DOM com o `id` correspondente Vamos usar este método no lugar da mensagem de erro anterior na função `login`: ```js if (data error) { return updateElement('loginError', data error); } ``` Agora, se tentar fazer login com uma conta inválida, deverá ver algo como isto:[Captura de ecrã mostrando a mensagem de erro exibida durante o login]( / / / /7-bank-project/3-data/images/login-error png)\nAgora temos texto de erro que aparece visualmente, mas se tentar com um leitor de ecrã, notará que nada é anunciado Para que o texto adicionado dinamicamente a uma página seja anunciado por leitores de ecrã, será necessário usar algo chamado [Região Viva](https://developer mozilla org/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) Aqui vamos usar um tipo específico de região viva chamado alerta:\n```html\n```\nImplemente o mesmo comportamento para os erros da função `register` (não se esqueça de atualizar o HTML) ## Exibir informações no painel (*dashboard*)\nUsando as mesmas técnicas que acabámos de ver, também vamos tratar de exibir as informações da conta na página do painel",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 329,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "e006c5442bb24a0c08d2cabcd97af724",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "dinamicamente a uma página seja anunciado por leitores de ecrã, será necessário usar algo chamado [Região Viva](https://developer mozilla org/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) Aqui vamos usar um tipo específico de região viva chamado alerta: ```html ``` Implemente o mesmo comportamento para os erros da função `register` (não se esqueça de atualizar o HTML) ## Exibir informações no painel (*dashboard*) Usando as mesmas técnicas que acabámos de ver, também vamos tratar de exibir as informações da conta na página do painelEste é o aspeto de um objeto de conta recebido do servidor:\n```json\n{\n\"user\": \"test\",\n\"currency\": \"$\",\n\"description\": \"Test account\",\n\"balance\": 75,\n\"transactions\": [\n{ \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 },\n{ \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 },\n{ \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 }\n],\n}\n```\n> Nota: para facilitar a sua vida, pode usar a conta `test` pré-existente que já está preenchida com dados ### Tarefa\nVamos começar por substituir a secção \"Saldo\" no HTML para adicionar elementos de espaço reservado:\n```html\nBalance:\n```\nTambém vamos adicionar uma nova secção logo abaixo para exibir a descrição da conta:\n```html\n```\n✅ Como a descrição da conta funciona como um título para o conteúdo abaixo dela, está marcada semanticamente como um cabeçalho Saiba mais sobre como a [estrutura de cabeçalhos](https://www nomensa com/blog/2017/how-structure-headings-web-accessibility) é importante para a acessibilidade e analise criticamente a página para determinar o que mais poderia ser um cabeçalho Em seguida, vamos criar uma nova função em `app js` para preencher o espaço reservado:\n```js\nfunction updateDashboard() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "1b44ec4c68683d3958c977720e4feddb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "descrição da conta: ```html ``` ✅ Como a descrição da conta funciona como um título para o conteúdo abaixo dela, está marcada semanticamente como um cabeçalho Saiba mais sobre como a [estrutura de cabeçalhos](https://www nomensa com/blog/2017/how-structure-headings-web-accessibility) é importante para a acessibilidade e analise criticamente a página para determinar o que mais poderia ser um cabeçalho Em seguida, vamos criar uma nova função em `app js` para preencher o espaço reservado: ```js function updateDashboard() { if (account) {\nreturn navigate('/login');\n}\nupdateElement('description', account description);\nupdateElement('balance', account balance toFixed(2));\nupdateElement('currency', account currency);\n}\n```\nPrimeiro, verificamos se temos os dados da conta de que precisamos antes de prosseguir Depois, usamos a função `updateElement()` que criámos anteriormente para atualizar o HTML > Para tornar a exibição do saldo mais bonita, usamos o método [`toFixed(2)`](https://developer mozilla org/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) para forçar a exibição do valor com 2 dígitos após o ponto decimal Agora precisamos de chamar a nossa função `updateDashboard()` sempre que o painel for carregado Se já terminou o [exercício da lição 1]( /1-template-route/assignment md), isto deve ser simples, caso contrário pode usar a seguinte implementação Adicione este código ao final da função `updateRoute()`:\n```js\nif (typeof route init === 'function') {\nroute init();\n}\n```\nE atualize a definição das rotas com:\n```js\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: updateDashboard }\n};\n```\nCom esta alteração, sempre que a página do painel for exibida, a função `updateDashboard()` será chamada Após um login, deverá então conseguir ver o saldo da conta, a moeda e a descrição ## Criar linhas de tabela dinamicamente com modelos HTML\nNa [primeira lição]( /1-template-route/README",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "84dc6a3a3c93411a6017243a5fd38fc4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "{ route init(); } ``` E atualize a definição das rotas com: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` Com esta alteração, sempre que a página do painel for exibida, a função `updateDashboard()` será chamada Após um login, deverá então conseguir ver o saldo da conta, a moeda e a descrição ## Criar linhas de tabela dinamicamente com modelos HTML Na [primeira lição]( /1-template-route/READMEmd), usamos modelos HTML juntamente com o método [`appendChild()`](https://developer mozilla org/docs/Web/API/Node/appendChild) para implementar a navegação na nossa aplicação Os modelos também podem ser menores e usados para preencher partes repetitivas de uma página de forma dinâmica Vamos usar uma abordagem semelhante para exibir a lista de transações na tabela HTML ### Tarefa\nAdicione um novo modelo no `` do HTML:\n```html\n```\nEste modelo representa uma única linha de tabela, com as 3 colunas que queremos preencher: *data*, *objeto* e *quantia* de uma transação Depois, adicione esta propriedade `id` ao elemento `` da tabela dentro do modelo do painel para facilitar a sua localização usando JavaScript:\n```html\n```\nO nosso HTML está pronto, vamos mudar para o código JavaScript e criar uma nova função `createTransactionRow`:\n```js\nfunction createTransactionRow(transaction) {\nconst template = document getElementById('transaction');\nconst transactionRow = template content cloneNode(true);\nconst tr = transactionRow querySelector('tr');\ntr children[0] textContent = transaction date;\ntr children[1] textContent = transaction object;\ntr children[2] textContent = transaction amount toFixed(2);\nreturn transactionRow;\n}\n```\nEsta função faz exatamente o que o seu nome indica: usando o modelo que criámos anteriormente, cria uma nova linha de tabela e preenche os seus conteúdos usando os dados da transação Vamos usá-la na nossa função `updateDashboard()` para preencher a tabela:\n```js\nconst transactionsRows = document createDocumentFragment();\nfor (const transaction of account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 501,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "175dac85a296672abdec3b0ccda5f1b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "tr children[0] textContent = transaction date; tr children[1] textContent = transaction object; tr children[2] textContent = transaction amount toFixed(2); return transactionRow; } ``` Esta função faz exatamente o que o seu nome indica: usando o modelo que criámos anteriormente, cria uma nova linha de tabela e preenche os seus conteúdos usando os dados da transação Vamos usá-la na nossa função `updateDashboard()` para preencher a tabela: ```js const transactionsRows = document createDocumentFragment(); for (const transaction of accounttransactions) {\nconst transactionRow = createTransactionRow(transaction);\ntransactionsRows appendChild(transactionRow);\n}\nupdateElement('transactions', transactionsRows);\n```\nAqui usamos o método [`document createDocumentFragment()`](https://developer mozilla org/docs/Web/API/Document/createDocumentFragment), que cria um novo fragmento DOM no qual podemos trabalhar antes de finalmente anexá-lo à nossa tabela HTML Ainda há mais uma coisa que temos de fazer antes que este código funcione, já que a nossa função `updateElement()` atualmente suporta apenas conteúdo de texto Vamos alterar o seu código um pouco:\n```js\nfunction updateElement(id, textOrNode) {\nconst element = document getElementById(id);\nelement textContent = ''; // Removes all children\nelement append(textOrNode);\n}\n```\nUsamos o método [`append()`](https://developer mozilla org/docs/Web/API/ParentNode/append), pois permite anexar texto ou [Nodos DOM](https://developer mozilla org/docs/Web/API/Node) a um elemento pai, o que é perfeito para todos os nossos casos de uso Se tentar usar a conta `test` para iniciar sessão, deverá agora ver uma lista de transações no painel 🎉 ---\n## 🚀 Desafio\nTrabalhem juntos para fazer com que a página do painel se pareça com uma aplicação bancária real Se já estilizou a sua aplicação, tente usar [media queries](https://developer mozilla org/docs/Web/CSS/Media_Queries) para criar um [design responsivo](https://developer mozilla org/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) que funcione bem tanto em dispositivos desktop como móveis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "777d9b7e32fd46348d091f7b7d579d23",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "Construir uma App Bancária Parte 3: Métodos de Obtenção e Utilização de Dados",
    "content": "perfeito para todos os nossos casos de uso Se tentar usar a conta `test` para iniciar sessão, deverá agora ver uma lista de transações no painel 🎉 --- ## 🚀 Desafio Trabalhem juntos para fazer com que a página do painel se pareça com uma aplicação bancária real Se já estilizou a sua aplicação, tente usar [media queries](https://developer mozilla org/docs/Web/CSS/Media_Queries) para criar um [design responsivo](https://developer mozilla org/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks) que funcione bem tanto em dispositivos desktop como móveisAqui está um exemplo de uma página de painel estilizada: [Captura de ecrã de um exemplo do resultado do painel após estilização]( / / / /7-bank-project/images/screen2 png)\n## Questionário Pós-Aula\n[Questionário pós-aula](https://ashy-river-0debb7803 1 azurestaticapps net/quiz/46)\n## Tarefa\n[Refatore e comente o seu código](assignment md)\n**Aviso Legal**:\nEste documento foi traduzido utilizando o serviço de tradução por IA [Co-op Translator](https://github com/Azure/co-op-translator) Embora nos esforcemos para garantir a precisão, é importante notar que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 386,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "ad6cbf7345f8266f88e234e9d036549a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\assignment.md",
    "source_type": "git_repo",
    "title": "Criar um protótipo de jogo",
    "content": "Criar um protótipo de jogo\nInstruções\nUsando os exemplos de código apresentados na lição, escreva uma representação de um jogo que goste. Deve ser um jogo simples, mas o objetivo é utilizar o padrão de classe ou composição e o padrão pub/sub para demonstrar como um jogo pode ser iniciado. Seja criativo!\nCritérios de Avaliação\n| Critério | Exemplar                                               | Adequado                                              | Necessita Melhorias                                 |\n| -------- | ------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------- |\n|          | Três elementos são colocados no ecrã e manipulados      | Dois elementos são colocados no ecrã e manipulados    | Um elemento é colocado no ecrã e manipulado        |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1735,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 297,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "23c2211d4579fc79f63bf38f2f69d34c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\assignment.md",
    "source_type": "git_repo",
    "title": "Explora a API Canvas",
    "content": "Explora a API Canvas\nInstruções\nEscolhe um elemento da API Canvas e cria algo interessante com ele. Consegues criar uma pequena galáxia de estrelas repetidas? Consegues criar uma textura interessante de linhas coloridas? Podes procurar inspiração no CodePen (mas não copies).\nCritérios de Avaliação\n| Critério  | Exemplar                                                  | Adequado                           | Precisa de Melhorias  |\n| --------- | --------------------------------------------------------- | ---------------------------------- | --------------------- |\n|           | O código submetido mostra uma textura ou forma interessante | O código é submetido, mas não funciona | O código não é submetido |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1589,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 278,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "5baf917faa729d9f683fc88e0bb66f0c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 1: Introdução",
    "content": "Construir um Jogo Espacial Parte 1: Introdução\nQuestionário Pré-Aula\nQuestionário pré-aula\nHerança e Composição no desenvolvimento de jogos\nNas lições anteriores, não havia muita necessidade de se preocupar com a arquitetura de design dos aplicativos que você criou, pois os projetos eram muito pequenos em escopo No entanto, à medida que suas aplicações crescem em tamanho e complexidade, as decisões arquiteturais tornam-se uma preocupação maior Existem duas abordagens principais para criar aplicações maiores em JavaScript: composição ou herança Ambas têm prós e contras, mas vamos explicá-las no contexto de um jogo ✅ Um dos livros mais famosos sobre programação trata de padrões de design Em um jogo, você tem objetos de jogo, que são objetos que existem na tela Isso significa que eles têm uma localização em um sistema de coordenadas cartesianas, caracterizada por ter uma coordenada x e y À medida que você desenvolve um jogo, perceberá que todos os seus objetos de jogo têm uma propriedade padrão, comum a todos os jogos que você cria, ou seja, elementos que são:\nbaseados em localização A maioria, senão todos, os elementos de jogo são baseados em localização Isso significa que eles têm uma localização, um x e um y móveis Estes são objetos que podem se mover para uma nova localização Normalmente, é um herói, um monstro ou um NPC (personagem não jogável), mas não, por exemplo, um objeto estático como uma árvore autodestrutivos Estes objetos existem apenas por um período de tempo definido antes de serem configurados para exclusão Geralmente, isso é representado por um booleano morto ou destruído, que sinaliza ao motor do jogo que este objeto não deve mais ser renderizado tempo de espera 'Tempo de espera' é uma propriedade típica entre objetos de curta duração Um exemplo típico é um pedaço de texto ou efeito gráfico, como uma explosão, que deve ser visto apenas por alguns milissegundos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9948,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 0,
    "total_chunks": 6
  },
  {
    "id": "2060a30280251783194928b3b8d43686",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 1: Introdução",
    "content": "objetos existem apenas por um período de tempo definido antes de serem configurados para exclusão Geralmente, isso é representado por um booleano morto ou destruído, que sinaliza ao motor do jogo que este objeto não deve mais ser renderizado tempo de espera 'Tempo de espera' é uma propriedade típica entre objetos de curta duração Um exemplo típico é um pedaço de texto ou efeito gráfico, como uma explosão, que deve ser visto apenas por alguns milissegundos✅ Pense em um jogo como Pac-Man Consegue identificar os quatro tipos de objetos listados acima neste jogo Expressando comportamento\nTudo o que descrevemos acima são comportamentos que os objetos de jogo podem ter Então, como codificamos isso Podemos expressar esse comportamento como métodos associados a classes ou objetos Classes\nA ideia é usar classes em conjunto com herança para adicionar um determinado comportamento a uma classe ✅ Herança é um conceito importante para entender Saiba mais no artigo da MDN sobre herança Expressado em código, um objeto de jogo pode tipicamente parecer assim:\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthis x = x;\nthis y = y;\nthis type = type;\n}\n}\n//this class will extend the GameObject's inherent class properties\nclass Movable extends GameObject {\nconstructor(x,y, type) {\nsuper(x,y, type)\n}\n//this movable object can be moved on the screen\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits\nclass Hero extends Movable {\nconstructor(x,y) {\nsuper(x,y, 'Hero')\n}\n}\n//this class, on the other hand, only inherits the GameObject properties\nclass Tree extends GameObject {\nconstructor(x,y) {\nsuper(x,y, 'Tree')\n}\n}\n//a hero can move const hero = new Hero();\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9948,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 447,
    "chunk_index": 1,
    "total_chunks": 6
  },
  {
    "id": "e31624005e44d8861087cc4bcb689ff4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 1: Introdução",
    "content": "{ this x = x; this y = y; } } //this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits class Hero extends Movable { constructor(x,y) { super(x,y, 'Hero') } } //this class, on the other hand, only inherits the GameObject properties class Tree extends GameObject { constructor(x,y) { super(x,y, 'Tree') } } //a hero can move const hero = new Hero(); heromoveTo(5,5);\n//but a tree cannot\nconst tree = new Tree();\n```\n✅ Reserve alguns minutos para imaginar um herói do Pac-Man (Inky, Pinky ou Blinky, por exemplo) e como ele seria escrito em JavaScript Composição\nUma maneira diferente de lidar com herança de objetos é usando Composição Então, os objetos expressam seu comportamento assim:\n```javascript\n//create a constant gameObject\nconst gameObject = {\nx: 0,\ny: 0,\ntype: ''\n};\n// and a constant movable\nconst movable = {\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//then the constant movableObject is composed of the gameObject and movable constants\nconst movableObject = { gameObject, movable};\n//then create a function to create a new Hero who inherits the movableObject properties\nfunction createHero(x, y) {\nreturn { movableObject,\nx,\ny,\ntype: 'Hero'\n}\n}\n// and a static object that inherits only the gameObject properties\nfunction createStatic(x, y, type) {\nreturn { gameObject\nx,\ny,\ntype\n}\n}\n//create the hero and move it\nconst hero = createHero(10,10);\nhero moveTo(5,5);\n//and create a static tree which only stands around\nconst tree = createStatic(0,0, 'Tree');\n```\nQual padrão devo usar A escolha do padrão depende de você O JavaScript suporta ambos os paradigmas --\nOutro padrão comum no desenvolvimento de jogos aborda o problema de lidar com a experiência do usuário e o desempenho do jogo",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9948,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 461,
    "chunk_index": 2,
    "total_chunks": 6
  },
  {
    "id": "0dc0273ab943a6f8b1937439f5281cdb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 1: Introdução",
    "content": "{ return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); hero moveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` Qual padrão devo usar A escolha do padrão depende de você O JavaScript suporta ambos os paradigmas -- Outro padrão comum no desenvolvimento de jogos aborda o problema de lidar com a experiência do usuário e o desempenho do jogoPadrão Pub/Sub\n✅ Pub/Sub significa 'publicar-assinar'\nEste padrão aborda a ideia de que as partes distintas da sua aplicação não devem saber umas das outras Por quê Isso torna muito mais fácil entender o que está acontecendo em geral se as várias partes estiverem separadas Também facilita mudar o comportamento repentinamente, se necessário Como conseguimos isso Fazemos isso estabelecendo alguns conceitos:\nmensagem: Uma mensagem geralmente é uma string de texto acompanhada por uma carga opcional (um pedaço de dados que esclarece sobre o que é a mensagem) Uma mensagem típica em um jogo pode ser KEY_PRESSED_ENTER publicador: Este elemento publica uma mensagem e a envia para todos os assinantes assinante: Este elemento ouve mensagens específicas e realiza alguma tarefa como resultado de receber essa mensagem, como disparar um laser A implementação é bastante pequena em tamanho, mas é um padrão muito poderoso Veja como pode ser implementado:\n```javascript\n//set up an EventEmitter class that contains listeners\nclass EventEmitter {\nconstructor() {\nthis listeners = {};\n}\n//when a message is received, let the listener to handle its payload\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\n//when a message is sent, send it to a listener with some payload\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9948,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 454,
    "chunk_index": 3,
    "total_chunks": 6
  },
  {
    "id": "6580910004b6497e09c3bfc42b0e7dcc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 1: Introdução",
    "content": "como pode ser implementado: ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { this listeners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if ( this listeners[message]) { this listeners[message] = []; } this listeners[message] push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (this listeners[message]) { this listeners[message]forEach(l => l(message, payload))\n}\n}\n}\n```\nPara usar o código acima, podemos criar uma implementação muito pequena:\n```javascript\n//set up a message structure\nconst Messages = {\nHERO_MOVE_LEFT: 'HERO_MOVE_LEFT'\n};\n//invoke the eventEmitter you set up above\nconst eventEmitter = new EventEmitter();\n//set up a hero\nconst hero = createHero(0,0);\n//let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero move(5,0);\n});\n//set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left\nwindow addEventListener('keyup', (evt) => {\nif (evt key === 'ArrowLeft') {\neventEmitter emit(Messages HERO_MOVE_LEFT)\n}\n});\n```\nAcima, conectamos um evento de teclado, ArrowLeft, e enviamos a mensagem HERO_MOVE_LEFT Ouvimos essa mensagem e movemos o herói como resultado A força desse padrão é que o ouvinte de eventos e o herói não sabem um do outro Você pode remapear o ArrowLeft para a tecla A Além disso, seria possível fazer algo completamente diferente no ArrowLeft fazendo algumas edições na função on do eventEmitter:\njavascript\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero move(5,0);\n});\nÀ medida que as coisas ficam mais complicadas com o crescimento do seu jogo, este padrão mantém a mesma complexidade e o seu código permanece limpo É realmente recomendado adotar este padrão 🚀 Desafio\nPense em como o padrão pub-sub pode melhorar um jogo",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9948,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 4,
    "total_chunks": 6
  },
  {
    "id": "8c3f8475251402918251d8332d3fa5b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 1: Introdução",
    "content": "para a tecla A Além disso, seria possível fazer algo completamente diferente no ArrowLeft fazendo algumas edições na função on do eventEmitter: javascript eventEmitter on(Messages HERO_MOVE_LEFT, () => { hero move(5,0); }); À medida que as coisas ficam mais complicadas com o crescimento do seu jogo, este padrão mantém a mesma complexidade e o seu código permanece limpo É realmente recomendado adotar este padrão 🚀 Desafio Pense em como o padrão pub-sub pode melhorar um jogoQuais partes devem emitir eventos e como o jogo deve reagir a eles Agora é a sua chance de ser criativo, pensando em um novo jogo e como suas partes podem se comportar Questionário Pós-Aula\nQuestionário pós-aula\nRevisão e Estudo Individual\nSaiba mais sobre Pub/Sub lendo sobre isso Tarefa\nCrie um protótipo de jogo\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9948,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 326,
    "chunk_index": 5,
    "total_chunks": 6
  },
  {
    "id": "fd361d6d3d66e51c43c961963762abc4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "Comente o Seu Código",
    "content": "Comente o Seu Código\nInstruções\nRevise o ficheiro /app.js na pasta do seu jogo e procure maneiras de comentá-lo e organizá-lo. É muito fácil o código ficar desorganizado, e agora é uma boa oportunidade para adicionar comentários e garantir que o código seja legível para que possa utilizá-lo mais tarde.\nRubrica\n| Critérios | Exemplar                                                          | Adequado                              | Precisa de Melhorias                                           |\n| --------- | ----------------------------------------------------------------- | ------------------------------------- | -------------------------------------------------------------- |\n|           | O código de app.js está totalmente comentado e organizado em blocos lógicos | O código de app.js está adequadamente comentado | O código de app.js está um pouco desorganizado e carece de bons comentários |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1798,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 299,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "d0bde256e7a36ce2fd6c46f01a8d8b19",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 2: Desenhar Herói e Monstros no Canvas",
    "content": "Construir um Jogo Espacial Parte 2: Desenhar Herói e Monstros no Canvas\nQuestionário Pré-Aula\nQuestionário pré-aula\nO Canvas\nO canvas é um elemento HTML que, por padrão, não tem conteúdo; é como uma tela em branco É necessário desenhar nele para adicionar conteúdo ✅ Leia mais sobre a API Canvas no MDN Aqui está como ele é normalmente declarado, como parte do corpo da página:\n```html\n```\nAcima, estamos a definir o id, width e height id: defina isto para obter uma referência quando precisar interagir com o canvas width: esta é a largura do elemento height: esta é a altura do elemento Desenhar formas geométricas simples\nO Canvas utiliza um sistema de coordenadas cartesianas para desenhar Assim, usa um eixo x e um eixo y para expressar onde algo está localizado A localização 0,0 é o canto superior esquerdo, e o canto inferior direito corresponde à largura (WIDTH) e altura (HEIGHT) que definiu para o canvas Imagem de MDN\nPara desenhar no elemento canvas, precisará seguir os seguintes passos:\nObter uma referência ao elemento Canvas Obter uma referência ao elemento Context que está no canvas Executar uma operação de desenho usando o elemento Context O código para os passos acima geralmente é assim:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = document getElementById(\"myCanvas\");\n//2 set the context to 2D to draw basic shapes\nctx = canvas getContext(\"2d\");\n//3 fill it with the color red\nctx fillStyle = 'red';\n//4 and draw a rectangle with these parameters, setting location and size\nctx fillRect(0,0, 200, 200) // x,y,width, height\n```\n✅ A API Canvas foca-se principalmente em formas 2D, mas também pode desenhar elementos 3D num site; para isso, pode usar a API WebGL",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 458,
    "chunk_index": 0,
    "total_chunks": 5
  },
  {
    "id": "d7566ef44b4a57968ea2ff7936354d90",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 2: Desenhar Herói e Monstros no Canvas",
    "content": "the canvas reference canvas = document getElementById(\"myCanvas\"); //2 set the context to 2D to draw basic shapes ctx = canvas getContext(\"2d\"); //3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctx fillRect(0,0, 200, 200) // x,y,width, height ``` ✅ A API Canvas foca-se principalmente em formas 2D, mas também pode desenhar elementos 3D num site; para isso, pode usar a API WebGLPode desenhar vários tipos de coisas com a API Canvas, como:\nFormas geométricas: já mostramos como desenhar um retângulo, mas há muito mais que pode desenhar Texto: pode desenhar texto com qualquer fonte e cor que desejar Imagens: pode desenhar uma imagem a partir de um ficheiro, como um jpg ou png, por exemplo ✅ Experimente Já sabe como desenhar um retângulo, consegue desenhar um círculo numa página Veja alguns desenhos interessantes feitos com Canvas no CodePen Aqui está um exemplo particularmente impressionante Carregar e desenhar um recurso de imagem\nPode carregar um recurso de imagem criando um objeto Image e definindo a sua propriedade src Depois, ouve o evento load para saber quando está pronto para ser usado O código é assim:\nCarregar recurso\njavascript\nconst img = new Image();\nimg src = 'path/to/my/image png';\nimg onload = () => {\n// image loaded and ready to be used\n}\nPadrão para carregar recurso\nRecomenda-se encapsular o código acima numa estrutura como esta, para que seja mais fácil de usar e só tente manipulá-lo quando estiver totalmente carregado:\n```javascript\nfunction loadAsset(path) {\nreturn new Promise((resolve) => {\nconst img = new Image();\nimg src = path;\nimg onload = () => {\n// image loaded and ready to be used\nresolve(img);\n}\n})\n}\n// use like so\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 483,
    "chunk_index": 1,
    "total_chunks": 5
  },
  {
    "id": "784bf87306d184767ecfe928e50535cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 2: Desenhar Herói e Monstros no Canvas",
    "content": "código acima numa estrutura como esta, para que seja mais fácil de usar e só tente manipulá-lo quando estiver totalmente carregado: ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); img src = path; img onload = () => { // image loaded and ready to be used resolve(img); } }) } // use like so async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monsterpng')\n}\n```\nPara desenhar recursos de jogo no ecrã, o seu código seria assim:\n```javascript\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster png')\ncanvas = document getElementById(\"myCanvas\");\nctx = canvas getContext(\"2d\");\nctx drawImage(heroImg, canvas width/2,canvas height/2);\nctx drawImage(monsterImg, 0,0);\n}\n```\nAgora é hora de começar a construir o seu jogo\nO que construir\nVai criar uma página web com um elemento Canvas Deve renderizar um ecrã preto de 1024*768 Fornecemos-lhe duas imagens:\nNave do herói\n5*5 monstros\nPassos recomendados para começar o desenvolvimento\nLocalize os ficheiros que foram criados para si na subpasta your-work Deve conter o seguinte:\nbash\n-| assets\n-| enemyShip png\n-| player png\n-| index html\n-| app js\n-| package json\nAbra a cópia desta pasta no Visual Studio Code Precisa de ter um ambiente de desenvolvimento local configurado, de preferência com o Visual Studio Code com NPM e Node instalados Se não tiver o npm configurado no seu computador, aqui está como fazer isso Inicie o seu projeto navegando até à pasta your_work:\nbash\ncd your-work\nnpm start\nO comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abra um navegador e insira esse endereço É uma página em branco por enquanto, mas isso vai mudar Nota: para ver as alterações no ecrã, atualize o navegador",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 2,
    "total_chunks": 5
  },
  {
    "id": "b794bcf385a22377c800beb8f20fb06c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 2: Desenhar Herói e Monstros no Canvas",
    "content": "com o Visual Studio Code com NPM e Node instalados Se não tiver o npm configurado no seu computador, aqui está como fazer isso Inicie o seu projeto navegando até à pasta your_work: bash cd your-work npm start O comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abra um navegador e insira esse endereço É uma página em branco por enquanto, mas isso vai mudar Nota: para ver as alterações no ecrã, atualize o navegadorAdicionar código\nAdicione o código necessário em your-work/app js para resolver o seguinte:\nDesenhar um canvas com fundo preto\ndica: adicione duas linhas no local apropriado indicado pelo TODO em /app js, definindo o elemento ctx para ser preto e as coordenadas superior/esquerda para 0,0, com a altura e largura iguais às do canvas Carregar texturas\ndica: adicione as imagens do jogador e do inimigo usando await loadTexture e passando o caminho da imagem Ainda não verá as imagens no ecrã Desenhar o herói no centro do ecrã na metade inferior\ndica: use a API drawImage para desenhar heroImg no ecrã, definindo canvas width / 2 - 45 e canvas height - canvas height / 4 Desenhar 5*5 monstros\ndica: agora pode descomentar o código para desenhar os inimigos no ecrã Em seguida, vá para a função createEnemies e complete-a Primeiro, configure algumas constantes:\n```javascript\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas width - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\n```\nDepois, crie um loop para desenhar o array de monstros no ecrã:\n```javascript\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 471,
    "chunk_index": 3,
    "total_chunks": 5
  },
  {
    "id": "e559a915947866790722290d0c571573",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 2: Desenhar Herói e Monstros no Canvas",
    "content": "a função createEnemies e complete-a Primeiro, configure algumas constantes: ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvas width - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; ``` Depois, crie um loop para desenhar o array de monstros no ecrã: ```javascript for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { ctxdrawImage(enemyImg, x, y);\n}\n}\n```\nResultado\nO resultado final deve ser assim:\nSolução\nTente resolver sozinho primeiro, mas se ficar preso, veja uma solução 🚀 Desafio\nAprendeu sobre como desenhar com a API Canvas focada em 2D; dê uma olhada na API WebGL e tente desenhar um objeto 3D Questionário Pós-Aula\nQuestionário pós-aula\nRevisão e Autoestudo\nSaiba mais sobre a API Canvas lendo sobre ela Tarefa\nExperimente a API Canvas\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 388,
    "chunk_index": 4,
    "total_chunks": 5
  },
  {
    "id": "651806e34804d12a9563cf0671e2a2da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nÀ medida que uma aplicação web cresce, torna-se um desafio acompanhar todos os fluxos de dados Que código obtém os dados, que página os consome, onde e quando precisam ser atualizados é fácil acabar com um código confuso e difícil de manter Isto é especialmente verdade quando é necessário partilhar dados entre diferentes páginas da aplicação, como os dados do utilizador O conceito de gestão de estado sempre existiu em todos os tipos de programas, mas à medida que as aplicações web continuam a crescer em complexidade, tornou-se um ponto-chave a considerar durante o desenvolvimento Nesta última parte, vamos rever a aplicação que construímos para repensar como o estado é gerido, permitindo suporte para atualizações do navegador em qualquer momento e persistindo os dados entre sessões de utilizador Pré-requisitos\nÉ necessário ter concluído a parte de obtenção de dados da aplicação web para esta lição Também é necessário instalar o Node js e executar a API do servidor localmente para poder gerir os dados da conta Pode testar se o servidor está a funcionar corretamente executando este comando num terminal:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0 0\" as a result\n```\nRepensar a gestão de estado\nNa lição anterior, introduzimos um conceito básico de estado na nossa aplicação com a variável global account, que contém os dados bancários do utilizador atualmente autenticado No entanto, a nossa implementação atual tem algumas falhas Experimente atualizar a página quando estiver no painel de controlo O que acontece Há 3 problemas com o código atual:\nO estado não é persistido, pois uma atualização do navegador leva-o de volta à página de login Existem várias funções que modificam o estado À medida que a aplicação cresce, pode tornar-se difícil acompanhar as alterações e é fácil esquecer de atualizar algo",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 0,
    "total_chunks": 9
  },
  {
    "id": "7a96687e800495bdcd3f6617d7e2c0b5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "do utilizador atualmente autenticado No entanto, a nossa implementação atual tem algumas falhas Experimente atualizar a página quando estiver no painel de controlo O que acontece Há 3 problemas com o código atual: O estado não é persistido, pois uma atualização do navegador leva-o de volta à página de login Existem várias funções que modificam o estado À medida que a aplicação cresce, pode tornar-se difícil acompanhar as alterações e é fácil esquecer de atualizar algoO estado não é limpo, então, quando clica em Logout, os dados da conta ainda estão lá, mesmo estando na página de login Poderíamos atualizar o nosso código para resolver estes problemas um por um, mas isso criaria mais duplicação de código e tornaria a aplicação mais complexa e difícil de manter Ou poderíamos parar por alguns minutos e repensar a nossa estratégia Que problemas estamos realmente a tentar resolver aqui A gestão de estado trata de encontrar uma boa abordagem para resolver estes dois problemas específicos:\nComo manter os fluxos de dados numa aplicação compreensíveis Como manter os dados do estado sempre sincronizados com a interface do utilizador (e vice-versa) Depois de resolver estas questões, quaisquer outros problemas que possa ter podem já estar resolvidos ou tornarem-se mais fáceis de corrigir Existem muitas abordagens possíveis para resolver estes problemas, mas vamos optar por uma solução comum que consiste em centralizar os dados e as formas de os alterar Os fluxos de dados seriam assim:\nNão vamos abordar aqui a parte em que os dados atualizam automaticamente a visualização, pois está ligada a conceitos mais avançados de Programação Reativa É um bom tema para explorar mais a fundo ✅ Existem muitas bibliotecas com diferentes abordagens para a gestão de estado, sendo o Redux uma opção popular Dê uma olhada nos conceitos e padrões utilizados, pois é frequentemente uma boa forma de aprender sobre os potenciais problemas que pode enfrentar em grandes aplicações web e como resolvê-los Tarefa\nVamos começar com um pouco de refatoração",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 1,
    "total_chunks": 9
  },
  {
    "id": "85b030a7823499d1cda00fa76dcf9546",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "visualização, pois está ligada a conceitos mais avançados de Programação Reativa É um bom tema para explorar mais a fundo ✅ Existem muitas bibliotecas com diferentes abordagens para a gestão de estado, sendo o Redux uma opção popular Dê uma olhada nos conceitos e padrões utilizados, pois é frequentemente uma boa forma de aprender sobre os potenciais problemas que pode enfrentar em grandes aplicações web e como resolvê-los Tarefa Vamos começar com um pouco de refatoraçãoSubstitua a declaração de account:\njs\nlet account = null;\nPor:\njs\nlet state = {\naccount: null\n};\nA ideia é centralizar todos os dados da aplicação num único objeto de estado Por enquanto, só temos account no estado, então não muda muito, mas cria um caminho para futuras evoluções Também temos de atualizar as funções que o utilizam Nas funções register() e login(), substitua account = por state account = ;\nNo início da função updateDashboard(), adicione esta linha:\njs\nconst account = state account;\nEsta refatoração, por si só, não trouxe muitas melhorias, mas a ideia era preparar o terreno para as próximas alterações Acompanhar alterações nos dados\nAgora que implementámos o objeto state para armazenar os nossos dados, o próximo passo é centralizar as atualizações O objetivo é tornar mais fácil acompanhar quaisquer alterações e quando elas acontecem Para evitar alterações feitas diretamente ao objeto state, também é uma boa prática considerá-lo imutável, o que significa que não pode ser modificado de forma alguma Isso também implica que é necessário criar um novo objeto de estado se quiser alterar algo nele Ao fazer isso, protege-se contra potenciais efeitos colaterais indesejados e abre-se a possibilidade de implementar novas funcionalidades na aplicação, como desfazer/refazer alterações, além de facilitar a depuração Por exemplo, pode registar todas as alterações feitas ao estado e manter um histórico para entender a origem de um erro Em JavaScript, pode usar Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 2,
    "total_chunks": 9
  },
  {
    "id": "aedcdfc0f299494481b037a97e86dd8e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "pode ser modificado de forma alguma Isso também implica que é necessário criar um novo objeto de estado se quiser alterar algo nele Ao fazer isso, protege-se contra potenciais efeitos colaterais indesejados e abre-se a possibilidade de implementar novas funcionalidades na aplicação, como desfazer/refazer alterações, além de facilitar a depuração Por exemplo, pode registar todas as alterações feitas ao estado e manter um histórico para entender a origem de um erro Em JavaScript, pode usar Objectfreeze() para criar uma versão imutável de um objeto Se tentar fazer alterações num objeto imutável, será gerada uma exceção ✅ Sabe a diferença entre um objeto imutável superficial e profundo Pode ler sobre isso aqui Tarefa\nVamos criar uma nova função updateState():\njs\nfunction updateState(property, newData) {\nstate = Object freeze({ state,\n[property]: newData\n});\n}\nNesta função, estamos a criar um novo objeto de estado e a copiar os dados do estado anterior usando o operador spread ( ) Depois, substituímos uma propriedade específica do objeto de estado com os novos dados usando a notação de colchetes [property] para atribuição Por fim, bloqueamos o objeto para evitar modificações usando Object freeze() Por enquanto, só temos a propriedade account armazenada no estado, mas com esta abordagem pode adicionar quantas propriedades forem necessárias Também vamos atualizar a inicialização do state para garantir que o estado inicial também está congelado:\njs\nlet state = Object freeze({\naccount: null\n});\nDepois disso, atualize a função register substituindo a atribuição state account = result; por:\njs\nupdateState('account', result);\nFaça o mesmo com a função login, substituindo state account = data; por:\njs\nupdateState('account', data);\nAgora vamos aproveitar para corrigir o problema dos dados da conta não serem limpos quando o utilizador clica em Logout",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 3,
    "total_chunks": 9
  },
  {
    "id": "976f17dc860ac89913a67f66b0d6d444",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "atualizar a inicialização do state para garantir que o estado inicial também está congelado: js let state = Object freeze({ account: null }); Depois disso, atualize a função register substituindo a atribuição state account = result; por: js updateState('account', result); Faça o mesmo com a função login, substituindo state account = data; por: js updateState('account', data); Agora vamos aproveitar para corrigir o problema dos dados da conta não serem limpos quando o utilizador clica em LogoutCrie uma nova função logout():\njs\nfunction logout() {\nupdateState('account', null);\nnavigate('/login');\n}\nNa função updateDashboard(), substitua a redireção return navigate('/login'); por return logout();;\nExperimente registar uma nova conta, fazer logout e voltar a entrar para verificar se tudo ainda funciona corretamente Dica: pode verificar todas as alterações no estado adicionando console log(state) no final de updateState() e abrindo a consola nas ferramentas de desenvolvimento do navegador Persistir o estado\nA maioria das aplicações web precisa de persistir dados para funcionar corretamente Todos os dados críticos são geralmente armazenados numa base de dados e acedidos através de uma API de servidor, como os dados da conta do utilizador no nosso caso Mas, por vezes, também é interessante persistir alguns dados na aplicação cliente que está a ser executada no navegador, para uma melhor experiência do utilizador ou para melhorar o desempenho do carregamento Quando quiser persistir dados no navegador, há algumas perguntas importantes que deve fazer:\nOs dados são sensíveis Deve evitar armazenar quaisquer dados sensíveis no cliente, como palavras-passe de utilizadores Por quanto tempo precisa de manter estes dados Pretende aceder a estes dados apenas durante a sessão atual ou quer que sejam armazenados para sempre Existem várias formas de armazenar informações numa aplicação web, dependendo do que pretende alcançar Por exemplo, pode usar os URLs para armazenar uma consulta de pesquisa e torná-la partilhável entre utilizadores Também pode usar cookies HTTP se os dados precisarem de ser partilhados com o servidor, como informações de autenticação",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 4,
    "total_chunks": 9
  },
  {
    "id": "d7095b058d05eeb72f6fc821689fb18b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "utilizadores Por quanto tempo precisa de manter estes dados Pretende aceder a estes dados apenas durante a sessão atual ou quer que sejam armazenados para sempre Existem várias formas de armazenar informações numa aplicação web, dependendo do que pretende alcançar Por exemplo, pode usar os URLs para armazenar uma consulta de pesquisa e torná-la partilhável entre utilizadores Também pode usar cookies HTTP se os dados precisarem de ser partilhados com o servidor, como informações de autenticaçãoOutra opção é usar uma das muitas APIs do navegador para armazenar dados Duas delas são particularmente interessantes:\nlocalStorage: um armazenamento chave/valor que permite persistir dados específicos do site atual entre diferentes sessões Os dados guardados nele nunca expiram sessionStorage: funciona da mesma forma que o localStorage, exceto que os dados armazenados nele são apagados quando a sessão termina (quando o navegador é fechado) Note que ambas as APIs só permitem armazenar strings Se quiser armazenar objetos complexos, terá de os serializar para o formato JSON usando JSON stringify() ✅ Se quiser criar uma aplicação web que não funcione com um servidor, também é possível criar uma base de dados no cliente usando a API IndexedDB Esta é reservada para casos de uso avançados ou se precisar de armazenar uma quantidade significativa de dados, pois é mais complexa de usar Tarefa\nQueremos que os nossos utilizadores permaneçam autenticados até clicarem explicitamente no botão Logout, por isso vamos usar o localStorage para armazenar os dados da conta Primeiro, vamos definir uma chave que usaremos para armazenar os nossos dados js\nconst storageKey = 'savedAccount';\nDepois, adicione esta linha no final da função updateState():\njs\nlocalStorage setItem(storageKey, JSON stringify(state account));\nCom isto, os dados da conta do utilizador serão persistidos e estarão sempre atualizados, já que centralizámos anteriormente todas as atualizações do estado É aqui que começamos a beneficiar de todas as refatorações anteriores 🙂 Como os dados são guardados, também temos de cuidar de os restaurar quando a aplicação é carregada",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 5,
    "total_chunks": 9
  },
  {
    "id": "2d0f065809082cd7161c6f2fbdb73e6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "armazenar os nossos dados js const storageKey = 'savedAccount'; Depois, adicione esta linha no final da função updateState(): js localStorage setItem(storageKey, JSON stringify(state account)); Com isto, os dados da conta do utilizador serão persistidos e estarão sempre atualizados, já que centralizámos anteriormente todas as atualizações do estado É aqui que começamos a beneficiar de todas as refatorações anteriores 🙂 Como os dados são guardados, também temos de cuidar de os restaurar quando a aplicação é carregadaComo começaremos a ter mais código de inicialização, pode ser uma boa ideia criar uma nova função init, que também inclui o nosso código anterior no final de app js:\n```js\nfunction init() {\nconst savedAccount = localStorage getItem(storageKey);\nif (savedAccount) {\nupdateState('account', JSON parse(savedAccount));\n}\n// Our previous initialization code\nwindow onpopstate = () => updateRoute();\nupdateRoute();\n}\ninit();\n```\nAqui recuperamos os dados guardados e, se houver algum, atualizamos o estado em conformidade É importante fazer isso antes de atualizar a rota, pois pode haver código que depende do estado durante a atualização da página Também podemos tornar a página Dashboard a página padrão da nossa aplicação, já que agora estamos a persistir os dados da conta Se não forem encontrados dados, o painel de controlo trata de redirecionar para a página de Login de qualquer forma Na função updateRoute(), substitua o fallback return navigate('/login'); por return navigate('/dashboard'); Agora faça login na aplicação e experimente atualizar a página Deve permanecer no painel de controlo Com esta atualização, resolvemos todos os problemas iniciais Atualizar os dados Mas também podemos ter criado um novo problema Oops",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 397,
    "chunk_index": 6,
    "total_chunks": 9
  },
  {
    "id": "86f60b72f18ad28af32bd221d239bac3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "que agora estamos a persistir os dados da conta Se não forem encontrados dados, o painel de controlo trata de redirecionar para a página de Login de qualquer forma Na função updateRoute(), substitua o fallback return navigate('/login'); por return navigate('/dashboard'); Agora faça login na aplicação e experimente atualizar a página Deve permanecer no painel de controlo Com esta atualização, resolvemos todos os problemas iniciais Atualizar os dados Mas também podemos ter criado um novo problema OopsVá para o painel de controlo usando a conta test, depois execute este comando num terminal para criar uma nova transação:\nsh\ncurl --request POST \\\n--header \"Content-Type: application/json\" \\\n--data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\\nhttp://localhost:5000/api/accounts/test/transactions\nAgora experimente atualizar a página do painel de controlo no navegador O que acontece Vê a nova transação O estado é persistido indefinidamente graças ao localStorage, mas isso também significa que nunca é atualizado até sair da aplicação e voltar a entrar Uma possível estratégia para corrigir isso é recarregar os dados da conta sempre que o painel de controlo for carregado, para evitar dados desatualizados Tarefa\nCrie uma nova função updateAccountData:\n```js\nasync function updateAccountData() {\nconst account = state account;\nif ( account) {\nreturn logout();\n}\nconst data = await getAccount(account user);\nif (data error) {\nreturn logout();\n}\nupdateState('account', data);\n}\n```\nEste método verifica se estamos atualmente autenticados e, em seguida, recarrega os dados da conta a partir do servidor Crie outra função chamada refresh:\njs\nasync function refresh() {\nawait updateAccountData();\nupdateDashboard();\n}\nEsta função atualiza os dados da conta e, em seguida, cuida de atualizar o HTML da página do painel de controlo É o que precisamos de chamar quando a rota do painel de controlo for carregada",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 465,
    "chunk_index": 7,
    "total_chunks": 9
  },
  {
    "id": "7ab7f408eac28138d914bb68d5861d71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "Criar uma App Bancária Parte 4: Conceitos de Gestão de Estado",
    "content": "return logout(); } updateState('account', data); } ``` Este método verifica se estamos atualmente autenticados e, em seguida, recarrega os dados da conta a partir do servidor Crie outra função chamada refresh: js async function refresh() { await updateAccountData(); updateDashboard(); } Esta função atualiza os dados da conta e, em seguida, cuida de atualizar o HTML da página do painel de controlo É o que precisamos de chamar quando a rota do painel de controlo for carregadaAtualize a definição da rota com:\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: refresh }\n};\nExperimente recarregar o painel de controlo agora, ele deve exibir os dados da conta atualizados 🚀 Desafio\nAgora que recarregamos os dados da conta sempre que o painel de controlo é carregado, acha que ainda precisamos de persistir todos os dados da conta Tente trabalhar em conjunto para alterar o que é guardado e carregado do localStorage para incluir apenas o que é absolutamente necessário para a aplicação funcionar Questionário Pós-Aula\nQuestionário pós-aula\nTarefa\nImplementar o diálogo \"Adicionar transação\"\nAqui está um exemplo do resultado após concluir a tarefa:\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 17011,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 428,
    "chunk_index": 8,
    "total_chunks": 9
  },
  {
    "id": "c3db12f7c1e77f7ea3ccbef79b1bfaa1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\assignment.md",
    "source_type": "git_repo",
    "title": "Explorar Colisões",
    "content": "Explorar Colisões\nInstruções\nPara compreender melhor como funcionam as colisões, construa um jogo muito simples com alguns itens que colidem. Faça-os mover através de pressionamento de teclas ou cliques do rato, e faça algo acontecer a um dos itens quando for atingido. Pode ser algo como um meteoro a atingir a Terra ou carros de choque. Seja criativo!\nRubrica\n| Critérios | Exemplar                                                                                                                | Adequado                       | Necessita Melhorias |\n| --------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------- |\n|           | Um exemplo completo de código funcional é produzido, com itens desenhados no canvas, colisões básicas a ocorrer e reações a acontecer | O código está incompleto de alguma forma | O código apresenta falhas |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1842,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 323,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f442e5a1f73de33f920845d16ed5bbe1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\assignment.md",
    "source_type": "git_repo",
    "title": "Criar um Jogo de Pontuação",
    "content": "Criar um Jogo de Pontuação\nInstruções\nCrie um jogo onde mostre a vida e os pontos de forma criativa. Uma sugestão é exibir a vida como corações e os pontos como um número grande na parte inferior central do ecrã. Veja aqui alguns Recursos gratuitos para jogos\nRubrica\n| Critérios | Exemplary              | Adequate                    | Needs Improvement          |\n| --------- | ---------------------- | --------------------------- | -------------------------- |\n|           | jogo completo é apresentado | jogo parcialmente apresentado | jogo parcial contém erros |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1461,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 254,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0ef7c459c4e2dcf4be968265dc444b17",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 5: Pontuação e Vidas",
    "content": "Construir um Jogo Espacial Parte 5: Pontuação e Vidas\nQuestionário Pré-Aula\nQuestionário pré-aula\nNesta lição, vais aprender como adicionar pontuação a um jogo e calcular vidas Desenhar texto no ecrã\nPara conseguir mostrar a pontuação do jogo no ecrã, precisas de saber como colocar texto no ecrã A resposta é usar o método fillText() no objeto canvas Também podes controlar outros aspetos, como o tipo de letra a usar, a cor do texto e até o alinhamento (esquerda, direita, centro) Abaixo está um exemplo de código que desenha texto no ecrã javascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctx fillText(\"show this on the screen\", 0, 0);\n✅ Lê mais sobre como adicionar texto a um canvas e sente-te à vontade para tornar o teu texto mais estiloso Vida, como conceito de jogo\nO conceito de ter vidas num jogo é apenas um número No contexto de um jogo espacial, é comum atribuir um conjunto de vidas que são deduzidas uma a uma quando a tua nave sofre danos É interessante mostrar uma representação gráfica disso, como mini-naves ou corações, em vez de apenas um número O que construir\nVamos adicionar o seguinte ao teu jogo:\nPontuação do jogo: Por cada nave inimiga destruída, o herói deve ganhar alguns pontos Sugerimos 100 pontos por nave A pontuação do jogo deve ser exibida no canto inferior esquerdo Vida: A tua nave tem três vidas Perdes uma vida sempre que uma nave inimiga colide contigo A pontuação de vidas deve ser exibida no canto inferior direito e ser composta pelo seguinte gráfico Passos recomendados\nLocaliza os ficheiros que foram criados para ti na subpasta your-work Deve conter o seguinte:\nbash\n-| assets\n-| enemyShip png\n-| player png\n-| laserRed png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7732,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "32b657782e86ba5ad8f08d1824570472",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 5: Pontuação e Vidas",
    "content": "exibida no canto inferior esquerdo Vida: A tua nave tem três vidas Perdes uma vida sempre que uma nave inimiga colide contigo A pontuação de vidas deve ser exibida no canto inferior direito e ser composta pelo seguinte gráfico Passos recomendados Localiza os ficheiros que foram criados para ti na subpasta your-work Deve conter o seguinte: bash -| assets -| enemyShip png -| player png -| laserRed png -| index html -| app js -| packagejson\nInicia o teu projeto na pasta your_work digitando:\nbash\ncd your-work\nnpm start\nO comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abre um navegador e insere esse endereço Neste momento, deve renderizar o herói e todos os inimigos, e ao pressionares as setas esquerda e direita, o herói move-se e pode disparar contra os inimigos Adicionar código\nCopiar os recursos necessários da pasta solution/assets/ para a pasta your-work; vais adicionar o recurso life png Adiciona o lifeImg à função window onload:\njavascript\nlifeImg = await loadTexture(\"assets/life png\");\nAdiciona o lifeImg à lista de recursos:\njavascript\nlet heroImg, lifeImg, eventEmitter = new EventEmitter();\nAdicionar variáveis Adiciona código que represente a pontuação total (0) e as vidas restantes (3), exibindo estas pontuações no ecrã Estender a função updateGameObjects() Estende a função updateGameObjects() para lidar com colisões de inimigos:\njavascript\nenemies forEach(enemy => {\nconst heroRect = hero rectFromGameObject();\nif (intersectRect(heroRect, enemy rectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy });\n}\n})\nAdicionar vida e pontos Inicializar variáveis Sob this cooldown = 0 na classe Hero, define vida e pontos:\n```javascript\nthis life = 3;\nthis points = 0;\n```\nDesenhar variáveis no ecrã Desenha estes valores no ecrã:\n```javascript\nfunction drawLife() {\n// TODO, 35, 27\nconst START_POS = canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7732,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "5b3a26bb3f20ad3f25e736849ea1d5dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 5: Pontuação e Vidas",
    "content": "com colisões de inimigos: javascript enemies forEach(enemy => { const heroRect = hero rectFromGameObject(); if (intersectRect(heroRect, enemy rectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_HERO, { enemy }); } }) Adicionar vida e pontos Inicializar variáveis Sob this cooldown = 0 na classe Hero, define vida e pontos: ```javascript this life = 3; this points = 0; ``` Desenhar variáveis no ecrã Desenha estes valores no ecrã: ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvaswidth - 180;\nfor(let i=0; i < hero life; i++ ) {\nctx drawImage(\nlifeImg,\nSTART_POS + (45 * (i+1) ),\ncanvas height - 37);\n}\n}\nfunction drawPoints() {\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"left\";\ndrawText(\"Points: \" + hero points, 10, canvas height-20);\n}\nfunction drawText(message, x, y) {\nctx fillText(message, x, y);\n}\n```\nAdicionar métodos ao loop do jogo Certifica-te de que adicionas estas funções à função window onload sob updateGameObjects():\n```javascript\ndrawPoints();\ndrawLife();\n```\nImplementar regras do jogo Implementa as seguintes regras do jogo:\nPor cada colisão entre herói e inimigo, deduz uma vida Estende a classe Hero para fazer esta dedução:\n```javascript\ndecrementLife() {\nthis life--;\nif (this life === 0) {\nthis dead = true;\n}\n}\n```\nPor cada laser que atinge um inimigo, aumenta a pontuação do jogo em 100 pontos Estende a classe Hero para fazer este incremento:\n```javascript\nincrementPoints() {\nthis points += 100;\n}\n```\nAdiciona estas funções aos Emissores de Eventos de Colisão:\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\n})\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7732,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "97dc04c0f8fb0f6adc227a77cb5e49df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 5: Pontuação e Vidas",
    "content": "cada laser que atinge um inimigo, aumenta a pontuação do jogo em 100 pontos Estende a classe Hero para fazer este incremento: ```javascript incrementPoints() { this points += 100; } ``` Adiciona estas funções aos Emissores de Eventos de Colisão: ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); }) eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; herodecrementLife();\n});\n```\n✅ Faz uma pequena pesquisa para descobrir outros jogos criados usando JavaScript/Canvas Quais são as suas características comuns Ao final deste trabalho, deverás ver as pequenas naves de 'vida' no canto inferior direito, os pontos no canto inferior esquerdo, e deverás ver a contagem de vidas a diminuir à medida que colides com inimigos e os pontos a aumentar quando disparas contra inimigos Muito bem O teu jogo está quase completo 🚀 Desafio\nO teu código está quase completo Consegues imaginar os próximos passos Questionário Pós-Aula\nQuestionário pós-aula\nRevisão & Estudo Individual\nPesquisa algumas formas de incrementar e decrementar pontuações e vidas em jogos Existem motores de jogo interessantes como o PlayFab Como é que usar um destes poderia melhorar o teu jogo Tarefa\nConstruir um Jogo de Pontuação\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, tenha em atenção que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes da utilização desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 7732,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "ec4f0ec790bf1ef3fa670e10a1afb267",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "Construir um Jogo Espacial Parte 3: Adicionando Movimento\nQuestionário Pré-Aula\nQuestionário pré-aula\nOs jogos não são muito divertidos até que tenhamos alienígenas a movimentar-se no ecrã Neste jogo, vamos utilizar dois tipos de movimentos:\nMovimento por teclado/rato: quando o utilizador interage com o teclado ou rato para mover um objeto no ecrã Movimento induzido pelo jogo: quando o jogo move um objeto em intervalos de tempo definidos Então, como movemos coisas no ecrã Tudo se resume a coordenadas cartesianas: alteramos a localização (x, y) do objeto e depois redesenhamos o ecrã Normalmente, são necessários os seguintes passos para realizar movimento no ecrã:\nDefinir uma nova localização para um objeto; isto é necessário para que o objeto pareça ter-se movido Limpar o ecrã, o ecrã precisa de ser limpo entre os desenhos Podemos limpá-lo desenhando um retângulo preenchido com uma cor de fundo Redesenhar o objeto na nova localização Ao fazer isto, conseguimos finalmente mover o objeto de uma localização para outra Aqui está como isso pode parecer em código:\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx fillRect(0, 0, canvas width, canvas height)\nctx fillStyle = \"black\";\nctx drawImage(heroImg, hero x, hero y);\n✅ Consegues pensar numa razão pela qual redesenhar o teu herói várias vezes por segundo pode gerar custos de desempenho Lê sobre alternativas a este padrão Lidar com eventos de teclado\nLidamos com eventos ao associar eventos específicos ao código Os eventos de teclado são acionados em toda a janela, enquanto eventos de rato, como um click, podem ser conectados ao clique num elemento específico Vamos usar eventos de teclado ao longo deste projeto",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 0,
    "total_chunks": 9
  },
  {
    "id": "30f199a44445cd67d78a94450a7cc158",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "hero y); ✅ Consegues pensar numa razão pela qual redesenhar o teu herói várias vezes por segundo pode gerar custos de desempenho Lê sobre alternativas a este padrão Lidar com eventos de teclado Lidamos com eventos ao associar eventos específicos ao código Os eventos de teclado são acionados em toda a janela, enquanto eventos de rato, como um click, podem ser conectados ao clique num elemento específico Vamos usar eventos de teclado ao longo deste projetoPara lidar com um evento, precisas de usar o método addEventListener() da janela e fornecer-lhe dois parâmetros de entrada O primeiro parâmetro é o nome do evento, por exemplo, keyup O segundo parâmetro é a função que deve ser invocada como resultado do evento Aqui está um exemplo:\njavascript\nwindow addEventListener('keyup', (evt) => {\n// `evt key` = string representation of the key\nif (evt key === 'ArrowUp') {\n// do something\n}\n})\nPara eventos de teclado, existem duas propriedades no evento que podes usar para ver qual tecla foi pressionada:\nkey, esta é uma representação em texto da tecla pressionada, por exemplo, ArrowUp keyCode, esta é uma representação numérica, por exemplo, 37, que corresponde a ArrowLeft ✅ Manipulação de eventos de teclado é útil fora do desenvolvimento de jogos Que outros usos consegues imaginar para esta técnica Teclas especiais: um alerta\nExistem algumas teclas especiais que afetam a janela Isso significa que, se estiveres a ouvir um evento keyup e usares essas teclas especiais para mover o teu herói, também será realizado o scroll horizontal Por essa razão, talvez queiras desativar este comportamento padrão do navegador enquanto desenvolves o teu jogo Precisarás de código como este:\n```javascript\nlet onKeyDown = function (e) {\nconsole log(e keyCode);\nswitch (e keyCode) {\ncase 37:\ncase 39:\ncase 38:\ncase 40: // Arrow keys\ncase 32:\ne preventDefault();\nbreak; // Space\ndefault:\nbreak; // do not block other keys\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 1,
    "total_chunks": 9
  },
  {
    "id": "6aeaf932059905135cb893469ddf12ae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "especiais para mover o teu herói, também será realizado o scroll horizontal Por essa razão, talvez queiras desativar este comportamento padrão do navegador enquanto desenvolves o teu jogo Precisarás de código como este: ```javascript let onKeyDown = function (e) { console log(e keyCode); switch (e keyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: e preventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown);\n```\nO código acima garantirá que as teclas de seta e a tecla de espaço tenham o seu comportamento padrão desativado O mecanismo de desativação ocorre quando chamamos e preventDefault() Movimento induzido pelo jogo\nPodemos fazer com que as coisas se movam sozinhas usando temporizadores como as funções setTimeout() ou setInterval() que atualizam a localização do objeto em cada intervalo de tempo Aqui está como isso pode parecer:\njavascript\nlet id = setInterval(() => {\n//move the enemy on the y axis\nenemy y += 10;\n})\nO loop do jogo\nO loop do jogo é um conceito que é essencialmente uma função invocada em intervalos regulares É chamado de loop do jogo porque tudo o que deve ser visível para o utilizador é desenhado dentro do loop O loop do jogo utiliza todos os objetos do jogo que fazem parte do jogo, desenhando todos eles, a menos que, por algum motivo, não devam mais fazer parte do jogo Por exemplo, se um objeto for um inimigo que foi atingido por um laser e explodiu, ele já não faz parte do loop atual do jogo (vais aprender mais sobre isso em lições subsequentes) Aqui está como um loop do jogo pode tipicamente parecer, expresso em código:\njavascript\nlet gameLoopId = setInterval(() =>\nfunction gameLoop() {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 465,
    "chunk_index": 2,
    "total_chunks": 9
  },
  {
    "id": "9b591a7e9261fbc7ec49c97b0cc38f46",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "parte do jogo Por exemplo, se um objeto for um inimigo que foi atingido por um laser e explodiu, ele já não faz parte do loop atual do jogo (vais aprender mais sobre isso em lições subsequentes) Aqui está como um loop do jogo pode tipicamente parecer, expresso em código: javascript let gameLoopId = setInterval(() => function gameLoop() { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight);\ndrawHero();\ndrawEnemies();\ndrawStaticObjects();\n}, 200);\nO loop acima é invocado a cada 200 milissegundos para redesenhar o canvas Tens a capacidade de escolher o melhor intervalo que faz sentido para o teu jogo Continuando o Jogo Espacial\nVais pegar no código existente e expandi-lo Podes começar com o código que completaste durante a parte I ou usar o código em Parte II - inicial Mover o herói: vais adicionar código para garantir que podes mover o herói usando as teclas de seta Mover inimigos: também precisarás de adicionar código para garantir que os inimigos se movam de cima para baixo a uma determinada velocidade Passos recomendados\nLocaliza os ficheiros que foram criados para ti na subpasta your-work Deve conter o seguinte:\nbash\n-| assets\n-| enemyShip png\n-| player png\n-| index html\n-| app js\n-| package json\nComeça o teu projeto na pasta your_work digitando:\nbash\ncd your-work\nnpm start\nO comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abre um navegador e insere esse endereço; neste momento, deve renderizar o herói e todos os inimigos; nada está a mover-se - ainda Adicionar código\nAdicionar objetos dedicados para hero, enemy e game object, eles devem ter propriedades x e y (Lembra-te da parte sobre Herança ou composição) DICA: game object deve ser aquele com x e y e a capacidade de se desenhar num canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 3,
    "total_chunks": 9
  },
  {
    "id": "cbd293ae896dab43bf90ccbff2b27372",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "O comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abre um navegador e insere esse endereço; neste momento, deve renderizar o herói e todos os inimigos; nada está a mover-se - ainda Adicionar código Adicionar objetos dedicados para hero, enemy e game object, eles devem ter propriedades x e y (Lembra-te da parte sobre Herança ou composição) DICA: game object deve ser aquele com x e y e a capacidade de se desenhar num canvasdica: começa por adicionar uma nova classe GameObject com o seu construtor delineado como abaixo, e depois desenha-a no canvas:\n```javascript\nclass GameObject {\nconstructor(x, y) {\nthis x = x;\nthis y = y;\nthis dead = false;\nthis type = \"\";\nthis width = 0;\nthis height = 0;\nthis img = undefined;\n}\ndraw(ctx) {\nctx drawImage(this img, this x, this y, this width, this height);\n}\n}\n```\nAgora, estende este GameObject para criar o Hero e o Enemy ```javascript\nclass Hero extends GameObject {\nconstructor(x, y) { it needs an x, y, type, and speed\n}\n}\n```\n```javascript\nclass Enemy extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 98), (this height = 50);\nthis type = \"Enemy\";\nlet id = setInterval(() => {\nif (this y < canvas height - this height) {\nthis y += 5;\n} else {\nconsole log('Stopped at', this y)\nclearInterval(id);\n}\n}, 300)\n}\n}\n```\nAdicionar manipuladores de eventos de teclado para lidar com a navegação por teclas (mover o herói para cima/baixo/esquerda/direita) LEMBRA-TE: é um sistema cartesiano, o canto superior esquerdo é 0,0 Também lembra-te de adicionar código para parar o comportamento padrão dica: cria a tua função onKeyDown e associa-a à janela:\n```javascript\nlet onKeyDown = function (e) {\nconsole log(e keyCode); add the code from the lesson above to stop default behavior\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 4,
    "total_chunks": 9
  },
  {
    "id": "689a9a4cfcca57ee125de500232b88f9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "} } ``` Adicionar manipuladores de eventos de teclado para lidar com a navegação por teclas (mover o herói para cima/baixo/esquerda/direita) LEMBRA-TE: é um sistema cartesiano, o canto superior esquerdo é 0,0 Também lembra-te de adicionar código para parar o comportamento padrão dica: cria a tua função onKeyDown e associa-a à janela: ```javascript let onKeyDown = function (e) { console log(e keyCode); add the code from the lesson above to stop default behavior } }; windowaddEventListener(\"keydown\", onKeyDown);\n```\nVerifica o console do navegador neste ponto e observa as teclas a serem registadas Implementar o Padrão Pub/Sub, isto manterá o teu código limpo enquanto segues as partes restantes Para fazer esta última parte, podes:\nAdicionar um listener de eventos na janela:\njavascript\nwindow addEventListener(\"keyup\", (evt) => {\nif (evt key === \"ArrowUp\") {\neventEmitter emit(Messages KEY_EVENT_UP);\n} else if (evt key === \"ArrowDown\") {\neventEmitter emit(Messages KEY_EVENT_DOWN);\n} else if (evt key === \"ArrowLeft\") {\neventEmitter emit(Messages KEY_EVENT_LEFT);\n} else if (evt key === \"ArrowRight\") {\neventEmitter emit(Messages KEY_EVENT_RIGHT);\n}\n});\nCriar uma classe EventEmitter para publicar e subscrever mensagens:\n```javascript\nclass EventEmitter {\nconstructor() {\nthis listeners = {};\n}\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 380,
    "chunk_index": 5,
    "total_chunks": 9
  },
  {
    "id": "4ea10dd697bb7bd4232dc59cb9c96a22",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "{ eventEmitter emit(Messages KEY_EVENT_DOWN); } else if (evt key === \"ArrowLeft\") { eventEmitter emit(Messages KEY_EVENT_LEFT); } else if (evt key === \"ArrowRight\") { eventEmitter emit(Messages KEY_EVENT_RIGHT); } }); Criar uma classe EventEmitter para publicar e subscrever mensagens: ```javascript class EventEmitter { constructor() { this listeners = {}; } on(message, listener) { if ( this listeners[message]) { this listeners[message] = []; } this listeners[message] push(listener); } emit(message, payload = null) { if (this listeners[message]) { this listeners[message]forEach((l) => l(message, payload));\n}\n}\n}\n```\nAdicionar constantes e configurar o EventEmitter:\n```javascript\nconst Messages = {\nKEY_EVENT_UP: \"KEY_EVENT_UP\",\nKEY_EVENT_DOWN: \"KEY_EVENT_DOWN\",\nKEY_EVENT_LEFT: \"KEY_EVENT_LEFT\",\nKEY_EVENT_RIGHT: \"KEY_EVENT_RIGHT\",\n};\nlet heroImg,\nenemyImg,\nlaserImg,\ncanvas, ctx,\ngameObjects = [],\nhero,\neventEmitter = new EventEmitter();\n```\nInicializar o jogo\n```javascript\nfunction initGame() {\ngameObjects = [];\ncreateEnemies();\ncreateHero();\neventEmitter on(Messages KEY_EVENT_UP, () => {\nhero y -=5 ;\n})\neventEmitter on(Messages KEY_EVENT_DOWN, () => {\nhero y += 5;\n});\neventEmitter on(Messages KEY_EVENT_LEFT, () => {\nhero x -= 5;\n});\neventEmitter on(Messages KEY_EVENT_RIGHT, () => {\nhero x += 5;\n});\n}\n```\nConfigurar o loop do jogo\nRefatora a função window onload para inicializar o jogo e configurar um loop do jogo num intervalo adequado Também vais adicionar um feixe de laser:\n```javascript\nwindow onload = async () => {\ncanvas = document getElementById(\"canvas\");\nctx = canvas getContext(\"2d\");\nheroImg = await loadTexture(\"assets/player png\");\nenemyImg = await loadTexture(\"assets/enemyShip png\");\nlaserImg = await loadTexture(\"assets/laserRed png\");\ninitGame();\nlet gameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 6,
    "total_chunks": 9
  },
  {
    "id": "2483df4bb3ca2c4813fc0a24f06e9873",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "onload para inicializar o jogo e configurar um loop do jogo num intervalo adequado Também vais adicionar um feixe de laser: ```javascript window onload = async () => { canvas = document getElementById(\"canvas\"); ctx = canvas getContext(\"2d\"); heroImg = await loadTexture(\"assets/player png\"); enemyImg = await loadTexture(\"assets/enemyShip png\"); laserImg = await loadTexture(\"assets/laserRed png\"); initGame(); let gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvasheight);\ndrawGameObjects(ctx);\n}, 100)\n};\n```\nAdicionar código para mover inimigos num determinado intervalo\nRefatora a função createEnemies() para criar os inimigos e adicioná-los à nova classe gameObjects:\n```javascript\nfunction createEnemies() {\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas width - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nconst enemy = new Enemy(x, y);\nenemy img = enemyImg;\ngameObjects push(enemy);\n}\n}\n}\n```\ne adiciona uma função createHero() para realizar um processo semelhante para o herói javascript\nfunction createHero() {\nhero = new Hero(\ncanvas width / 2 - 45,\ncanvas height - canvas height / 4\n);\nhero img = heroImg;\ngameObjects push(hero);\n}\ne, finalmente, adiciona uma função drawGameObjects() para começar o desenho:\njavascript\nfunction drawGameObjects(ctx) {\ngameObjects forEach(go => go draw(ctx));\n}\nOs teus inimigos devem começar a avançar na direção da tua nave espacial 🚀 Desafio\nComo podes ver, o teu código pode transformar-se em 'código espaguete' quando começas a adicionar funções, variáveis e classes Como podes organizar melhor o teu código para que seja mais legível",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 7,
    "total_chunks": 9
  },
  {
    "id": "7e906d01f16d437a7624c3ad842c1556",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 3: Adicionando Movimento",
    "content": "/ 4 ); hero img = heroImg; gameObjects push(hero); } e, finalmente, adiciona uma função drawGameObjects() para começar o desenho: javascript function drawGameObjects(ctx) { gameObjects forEach(go => go draw(ctx)); } Os teus inimigos devem começar a avançar na direção da tua nave espacial 🚀 Desafio Como podes ver, o teu código pode transformar-se em 'código espaguete' quando começas a adicionar funções, variáveis e classes Como podes organizar melhor o teu código para que seja mais legívelEsboça um sistema para organizar o teu código, mesmo que ainda esteja num único ficheiro Questionário Pós-Aula\nQuestionário pós-aula\nRevisão & Autoestudo\nEmbora estejamos a escrever o nosso jogo sem usar frameworks, existem muitos frameworks baseados em JavaScript para desenvolvimento de jogos com canvas Dedica algum tempo a ler sobre eles Tarefa\nComenta o teu código\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 15047,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 352,
    "chunk_index": 8,
    "total_chunks": 9
  },
  {
    "id": "786bdc1ab30291a7582aa207423ee3b5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões\nQuestionário Pré-Aula\nQuestionário pré-aula\nNesta lição, vais aprender a disparar lasers com JavaScript Vamos adicionar duas coisas ao nosso jogo:\nUm laser: este laser é disparado da nave do herói e segue verticalmente para cima Deteção de colisões, como parte da implementação da capacidade de disparar, também vamos adicionar algumas regras interessantes ao jogo:\nLaser atinge inimigo: O inimigo morre se for atingido por um laser Laser atinge o topo do ecrã: Um laser é destruído se atingir a parte superior do ecrã Colisão entre inimigo e herói: Um inimigo e o herói são destruídos se colidirem Inimigo atinge o fundo do ecrã: Um inimigo e o herói são destruídos se o inimigo atingir o fundo do ecrã Resumindo, tu -- o herói -- precisas de atingir todos os inimigos com um laser antes que eles consigam chegar ao fundo do ecrã ✅ Faz uma pequena pesquisa sobre o primeiro jogo de computador alguma vez criado Qual era a sua funcionalidade Vamos ser heróicos juntos Deteção de colisões\nComo fazemos a deteção de colisões Precisamos de pensar nos objetos do jogo como retângulos em movimento Porquê, perguntas tu Bem, a imagem usada para desenhar um objeto do jogo é um retângulo: tem um x, y, largura e altura Se dois retângulos, ou seja, um herói e um inimigo intersetarem, tens uma colisão O que deve acontecer a seguir depende das regras do jogo Para implementar a deteção de colisões, precisas do seguinte:\nUma forma de obter uma representação em retângulo de um objeto do jogo, algo como isto:\njavascript\nrectFromGameObject() {\nreturn {\ntop: this y,\nleft: this x,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "f2f8fda8f176dbf257de173240de612f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "objeto do jogo é um retângulo: tem um x, y, largura e altura Se dois retângulos, ou seja, um herói e um inimigo intersetarem, tens uma colisão O que deve acontecer a seguir depende das regras do jogo Para implementar a deteção de colisões, precisas do seguinte: Uma forma de obter uma representação em retângulo de um objeto do jogo, algo como isto: javascript rectFromGameObject() { return { top: this y, left: this x, bottom: thisy + this height,\nright: this x + this width\n}\n}\nUma função de comparação, que pode ser assim:\njavascript\nfunction intersectRect(r1, r2) {\nreturn (r2 left > r1 right ||\nr2 right < r1 left ||\nr2 top > r1 bottom ||\nr2 bottom < r1 top);\n}\nComo destruímos coisas\nPara destruir coisas num jogo, precisas de informar o jogo que não deve mais pintar esse item no ciclo de jogo que é acionado em determinado intervalo Uma forma de fazer isso é marcar um objeto do jogo como morto quando algo acontece, assim:\njavascript\n// collision happened\nenemy dead = true\nDepois podes proceder para eliminar os objetos mortos antes de repintar o ecrã, assim:\njavascript\ngameObjects = gameObject filter(go => go dead);\nComo disparamos um laser\nDisparar um laser traduz-se em responder a um evento de tecla e criar um objeto que se move numa determinada direção Por isso, precisamos de realizar os seguintes passos:\nCriar um objeto laser: a partir do topo da nave do herói, que ao ser criado começa a mover-se para cima em direção ao topo do ecrã Associar código a um evento de tecla: precisamos de escolher uma tecla no teclado que represente o jogador a disparar o laser Criar um objeto do jogo que se pareça com um laser quando a tecla é pressionada Intervalo entre disparos do laser\nO laser precisa de ser disparado sempre que pressionas uma tecla, como espaço, por exemplo",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "ee73b5a6d697513660c844226558c0ca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "nave do herói, que ao ser criado começa a mover-se para cima em direção ao topo do ecrã Associar código a um evento de tecla: precisamos de escolher uma tecla no teclado que represente o jogador a disparar o laser Criar um objeto do jogo que se pareça com um laser quando a tecla é pressionada Intervalo entre disparos do laser O laser precisa de ser disparado sempre que pressionas uma tecla, como espaço, por exemploPara evitar que o jogo produza demasiados lasers num curto espaço de tempo, precisamos de corrigir isso A solução é implementar um chamado intervalo, um temporizador, que garante que um laser só pode ser disparado de tempos em tempos Podes implementar isso da seguinte forma:\n```javascript\nclass Cooldown {\nconstructor(time) {\nthis cool = false;\nsetTimeout(() => {\nthis cool = true;\n}, time)\n}\n}\nclass Weapon {\nconstructor {\n}\nfire() {\nif ( this cooldown || this cooldown cool) {\n// produce a laser\nthis cooldown = new Cooldown(500);\n} else {\n// do nothing - it hasn't cooled down yet }\n}\n}\n```\n✅ Consulta a lição 1 da série de jogos espaciais para te lembrares sobre intervalos O que construir\nVais pegar no código existente (que deves ter limpo e refatorado) da lição anterior e expandi-lo Podes começar com o código da parte II ou usar o código em Parte III - inicial dica: o laser com que vais trabalhar já está na tua pasta de recursos e referenciado pelo teu código Adicionar deteção de colisões, quando um laser colide com algo, as seguintes regras devem ser aplicadas:\nLaser atinge inimigo: o inimigo morre se for atingido por um laser Laser atinge o topo do ecrã: um laser é destruído se atingir a parte superior do ecrã Colisão entre inimigo e herói: um inimigo e o herói são destruídos se colidirem",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "76568659e710322eebeb69ddad4ee8cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "laser com que vais trabalhar já está na tua pasta de recursos e referenciado pelo teu código Adicionar deteção de colisões, quando um laser colide com algo, as seguintes regras devem ser aplicadas: Laser atinge inimigo: o inimigo morre se for atingido por um laser Laser atinge o topo do ecrã: um laser é destruído se atingir a parte superior do ecrã Colisão entre inimigo e herói: um inimigo e o herói são destruídos se colidiremInimigo atinge o fundo do ecrã: um inimigo e o herói são destruídos se o inimigo atingir o fundo do ecrã Passos recomendados\nLocaliza os ficheiros que foram criados para ti na subpasta your-work Deve conter o seguinte:\nbash\n-| assets\n-| enemyShip png\n-| player png\n-| laserRed png\n-| index html\n-| app js\n-| package json\nInicia o teu projeto na pasta your_work digitando:\nbash\ncd your-work\nnpm start\nO comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abre um navegador e insere esse endereço, neste momento deve renderizar o herói e todos os inimigos, nada está a mover-se - ainda :) Adicionar código\nConfigurar uma representação em retângulo do teu objeto do jogo, para lidar com colisões O código abaixo permite-te obter uma representação em retângulo de um GameObject Edita a tua classe GameObject para expandi-la:\njavascript\nrectFromGameObject() {\nreturn {\ntop: this y,\nleft: this x,\nbottom: this y + this height,\nright: this x + this width,\n};\n}\nAdicionar código que verifica colisões Isto será uma nova função que testa se dois retângulos se intersetam:\njavascript\nfunction intersectRect(r1, r2) {\nreturn (\nr2 left > r1 right ||\nr2 right < r1 left ||\nr2 top > r1 bottom ||\nr2 bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "9bba7d8b8031881a9bce11d8477469b8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "tua classe GameObject para expandi-la: javascript rectFromGameObject() { return { top: this y, left: this x, bottom: this y + this height, right: this x + this width, }; } Adicionar código que verifica colisões Isto será uma nova função que testa se dois retângulos se intersetam: javascript function intersectRect(r1, r2) { return ( r2 left > r1 right || r2 right < r1 left || r2 top > r1 bottom || r2 bottom < r1top\n);\n}\nAdicionar capacidade de disparar laser\nAdicionar mensagem de evento de tecla A tecla espaço deve criar um laser logo acima da nave do herói Adiciona três constantes no objeto Messages:\njavascript\nKEY_EVENT_SPACE: \"KEY_EVENT_SPACE\",\nCOLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\",\nCOLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\",\nLidar com a tecla espaço Edita a função window addEventListener keyup para lidar com espaços:\njavascript\n} else if(evt keyCode === 32) {\neventEmitter emit(Messages KEY_EVENT_SPACE);\n}\nAdicionar ouvintes Edita a função initGame() para garantir que o herói pode disparar quando a barra de espaço é pressionada:\njavascript\neventEmitter on(Messages KEY_EVENT_SPACE, () => {\nif (hero canFire()) {\nhero fire();\n}\ne adiciona uma nova função eventEmitter on() para garantir o comportamento quando um inimigo colide com um laser:\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\n})\n```\nMover objeto, Garante que o laser se move gradualmente para o topo do ecrã Vais criar uma nova classe Laser que expande GameObject, como já fizeste antes:\njavascript\nclass Laser extends GameObject {\nconstructor(x, y) {\nsuper(x,y);\n(this width = 9), (this height = 33);\nthis type = 'Laser';\nthis img = laserImg;\nlet id = setInterval(() => {\nif (this y > 0) {\nthis y -= 15;\n} else {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "b244e4012c27657d0189495a5cb77f96",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "true; }) ``` Mover objeto, Garante que o laser se move gradualmente para o topo do ecrã Vais criar uma nova classe Laser que expande GameObject, como já fizeste antes: javascript class Laser extends GameObject { constructor(x, y) { super(x,y); (this width = 9), (this height = 33); this type = 'Laser'; this img = laserImg; let id = setInterval(() => { if (this y > 0) { this y -= 15; } else { thisdead = true;\nclearInterval(id);\n}\n}, 100)\n}\n}\nLidar com colisões, Implementa regras de colisão para o laser Adiciona uma função updateGameObjects() que testa objetos colidindo por impactos:\n```javascript\nfunction updateGameObjects() {\nconst enemies = gameObjects filter(go => go type === 'Enemy');\nconst lasers = gameObjects filter((go) => go type === \"Laser\");\n// laser hit something\nlasers forEach((l) => {\nenemies forEach((m) => {\nif (intersectRect(l rectFromGameObject(), m rectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_LASER, {\nfirst: l,\nsecond: m,\n});\n}\n});\n});\ngameObjects = gameObjects filter(go => go dead);\n}\n```\nCertifica-te de adicionar updateGameObjects() no teu ciclo de jogo em window onload Implementar intervalo no laser, para que só possa ser disparado de tempos em tempos Finalmente, edita a classe Hero para que possa ter intervalo:\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 99), (this height = 75);\nthis type = \"Hero\";\nthis speed = { x: 0, y: 0 };\nthis cooldown = 0;\n}\nfire() {\ngameObjects push(new Laser(this x + 45, this y - 10));\nthis cooldown = 500;\nlet id = setInterval(() => {\nif (this cooldown > 0) {\nthis cooldown -= 100;\n} else {\nclearInterval(id);\n}\n}, 200);\n}\ncanFire() {\nreturn this cooldown === 0;\n}\n}\n```\nNeste ponto, o teu jogo já tem alguma funcionalidade",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "8c6e886524e61440d4a6b29136841db3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 4: Adicionar um Laser e Detetar Colisões",
    "content": "type = \"Hero\"; this speed = { x: 0, y: 0 }; this cooldown = 0; } fire() { gameObjects push(new Laser(this x + 45, this y - 10)); this cooldown = 500; let id = setInterval(() => { if (this cooldown > 0) { this cooldown -= 100; } else { clearInterval(id); } }, 200); } canFire() { return this cooldown === 0; } } ``` Neste ponto, o teu jogo já tem alguma funcionalidadePodes navegar com as teclas de seta, disparar um laser com a barra de espaço, e os inimigos desaparecem quando os atinges Muito bem 🚀 Desafio\nAdiciona uma explosão Dá uma olhada nos recursos do jogo no repositório Space Art e tenta adicionar uma explosão quando o laser atingir um alienígena Questionário Pós-Aula\nQuestionário pós-aula\nRevisão & Estudo Individual\nExperimenta com os intervalos no teu jogo até agora O que acontece quando os alteras Lê mais sobre eventos de temporização em JavaScript Tarefa\nExplorar colisões\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12030,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 387,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "c8aee3692673678c3d42536e4899aad5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\assignment.md",
    "source_type": "git_repo",
    "title": "Criar um Jogo de Exemplo",
    "content": "Criar um Jogo de Exemplo\nInstruções\nTente criar um pequeno jogo onde pratique diferentes condições de término. Varie entre alcançar um número de pontos, o herói perder todas as vidas ou todos os monstros serem derrotados. Construa algo simples, como um jogo de aventura baseado em consola. Use o fluxo de jogo abaixo como inspiração:\nHero> Strikes with broadsword - orc takes 3p damage\nOrc> Hits with club - hero takes 2p damage\nHero> Kicks - orc takes 1p damage\nGame> Orc is defeated - Hero collects 2 coins\nGame> ****No more monsters, you have conquered the evil fortress****\nRubrica\n| Critérios | Exemplar              | Adequado                    | Precisa de Melhorias       |\n| --------- | --------------------- | --------------------------- | -------------------------- |\n|           | jogo completo é apresentado | jogo é parcialmente apresentado | jogo parcial contém erros |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1772,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 345,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "2102e2f23c925868a3c363196aa3d0ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um marcador de posição, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 879,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 143,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "004823d2e33e3c7000c8862ed513f402",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Isto é um espaço reservado, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 903,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 144,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "cf4f947bd17877a5326ae94e7f973570",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um marcador de posição, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se a tradução profissional humana. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 890,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 141,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c52ce957c915e570da51d6b2b9b87e94",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um espaço reservado, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 904,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 143,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "17a32b46467f5b37495ec0d4d6338871",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um marcador de posição, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, tenha em atenção que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes da utilização desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 918,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\5-keeping-score\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 147,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "60c9aa0ded3179c74dfb59553f642c8e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um espaço reservado, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 910,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 143,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "64f5e221bd008d2cc29291aa10962bbe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um espaço reservado, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 908,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\4-collision-detection\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 145,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "413f5695825517732d015cb1ce73c23c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\assignment.md",
    "source_type": "git_repo",
    "title": "Redefina o Estilo da sua Extensão",
    "content": "Redefina o Estilo da sua Extensão\nInstruções\nA base de código desta extensão já inclui estilos, mas não é obrigatório utilizá-los; personalize a sua extensão ao editar o ficheiro css e criar o seu próprio estilo.\nCritérios\n| Critério | Exemplar                                    | Adequado              | Necessita Melhorias |\n| -------- | ------------------------------------------- | --------------------- | ------------------- |\n|          | Código é enviado com novos estilos funcionais | Estilo está incompleto | Estilos apresentam erros |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, tenha em atenção que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes da utilização desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1436,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 258,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "89c6d80410e4613437d04c9c2e66d94c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
    "source_type": "git_repo",
    "title": "Adote uma API",
    "content": "Adote uma API\nInstruções\nAPIs podem ser muito divertidas de explorar. Aqui está uma lista de muitas gratuitas. Escolha uma API e crie uma extensão de navegador que resolva um problema. Pode ser um problema pequeno, como não ter fotos suficientes de animais de estimação (então, experimente a API do dog CEO) ou algo maior - divirta-se!\nCritérios de Avaliação\n| Critério | Exemplar                                                                  | Adequado                                 | Precisa de Melhorias    |\n| -------- | ------------------------------------------------------------------------- | ---------------------------------------- | ----------------------- |\n|          | Uma extensão de navegador completa é submetida usando uma API da lista acima | Uma extensão de navegador parcial é submetida | A submissão contém erros |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1811,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 307,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "08a2d781b683ad0c8ede91fe169d1b1a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 6: Fim e Reinício",
    "content": "Construir um Jogo Espacial Parte 6: Fim e Reinício\nQuestionário Pré-Aula\nQuestionário pré-aula\nExistem várias formas de expressar uma condição de fim num jogo Cabe a ti, como criador do jogo, decidir por que motivo o jogo termina Aqui estão algumas razões, assumindo que estamos a falar do jogo espacial que tens vindo a construir até agora:\nN Naves inimigas foram destruídas: É bastante comum, se dividires o jogo em diferentes níveis, que seja necessário destruir N naves inimigas para completar um nível A tua nave foi destruída: Existem jogos em que perdes se a tua nave for destruída Outra abordagem comum é ter o conceito de vidas Sempre que a tua nave é destruída, perdes uma vida Quando todas as vidas se esgotam, perdes o jogo Colecionaste N pontos: Outra condição de fim comum é colecionar pontos Como obténs pontos depende de ti, mas é habitual atribuir pontos a várias atividades, como destruir uma nave inimiga ou talvez colecionar itens que caem quando são destruídos Completaste um nível: Isto pode envolver várias condições, como X naves inimigas destruídas, Y pontos colecionados ou talvez a recolha de um item específico Reiniciar\nSe as pessoas gostarem do teu jogo, é provável que queiram jogá-lo novamente Assim que o jogo terminar, por qualquer motivo, deves oferecer uma opção para reiniciar ✅ Pensa um pouco sobre as condições em que achas que um jogo termina e como és incentivado a reiniciá-lo O que construir\nVais adicionar estas regras ao teu jogo:\nVencer o jogo Assim que todas as naves inimigas forem destruídas, ganhas o jogo Além disso, exibe uma mensagem de vitória Reiniciar Quando todas as vidas forem perdidas ou o jogo for ganho, deves oferecer uma forma de reiniciar o jogo Lembra-te",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9142,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 0,
    "total_chunks": 5
  },
  {
    "id": "d6c1eb7ccdfdc68f51b751525ab59f6d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 6: Fim e Reinício",
    "content": "uma opção para reiniciar ✅ Pensa um pouco sobre as condições em que achas que um jogo termina e como és incentivado a reiniciá-lo O que construir Vais adicionar estas regras ao teu jogo: Vencer o jogo Assim que todas as naves inimigas forem destruídas, ganhas o jogo Além disso, exibe uma mensagem de vitória Reiniciar Quando todas as vidas forem perdidas ou o jogo for ganho, deves oferecer uma forma de reiniciar o jogo Lembra-tePrecisarás de reinicializar o jogo e limpar o estado anterior Passos recomendados\nLocaliza os ficheiros que foram criados para ti na subpasta your-work Deve conter o seguinte:\nbash\n-| assets\n-| enemyShip png\n-| player png\n-| laserRed png\n-| life png\n-| index html\n-| app js\n-| package json\nInicia o teu projeto na pasta your_work digitando:\nbash\ncd your-work\nnpm start\nO comando acima iniciará um servidor HTTP no endereço http://localhost:5000 Abre um navegador e insere esse endereço O teu jogo deve estar num estado jogável dica: para evitar avisos no Visual Studio Code, edita a função window onload para chamar gameLoopId como está (sem let), e declara o gameLoopId no topo do ficheiro, independentemente: let gameLoopId;\nAdicionar código\nAcompanhar a condição de fim Adiciona código que acompanhe o número de inimigos ou se a nave do herói foi destruída, adicionando estas duas funções:\n```javascript\nfunction isHeroDead() {\nreturn hero life <= 0;\n}\nfunction isEnemiesDead() {\nconst enemies = gameObjects filter((go) => go type === \"Enemy\" && go dead);\nreturn enemies length === 0;\n}\n```\nAdicionar lógica aos manipuladores de mensagens Edita o eventEmitter para lidar com estas condições:\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\nif (isEnemiesDead()) {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9142,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 1,
    "total_chunks": 5
  },
  {
    "id": "f4ce06aff987d7ee34ed93bb179e14ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 6: Fim e Reinício",
    "content": "estas duas funções: ```javascript function isHeroDead() { return hero life <= 0; } function isEnemiesDead() { const enemies = gameObjects filter((go) => go type === \"Enemy\" && go dead); return enemies length === 0; } ``` Adicionar lógica aos manipuladores de mensagens Edita o eventEmitter para lidar com estas condições: ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(MessagesGAME_END_WIN);\n}\n});\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero decrementLife();\nif (isHeroDead())  {\neventEmitter emit(Messages GAME_END_LOSS);\nreturn; // loss before victory\n}\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages GAME_END_WIN, () => {\nendGame(true);\n});\neventEmitter on(Messages GAME_END_LOSS, () => {\nendGame(false);\n});\n```\nAdicionar novos tipos de mensagens Adiciona estas Mensagens ao objeto de constantes:\njavascript\nGAME_END_LOSS: \"GAME_END_LOSS\",\nGAME_END_WIN: \"GAME_END_WIN\",\nAdicionar código de reinício que reinicie o jogo ao pressionar um botão selecionado Ouvir a tecla Enter Edita o eventListener da tua janela para ouvir esta tecla:\njavascript\nelse if(evt key === \"Enter\") {\neventEmitter emit(Messages KEY_EVENT_ENTER);\n}\nAdicionar mensagem de reinício Adiciona esta Mensagem às constantes de Mensagens:\n```javascript\nKEY_EVENT_ENTER: \"KEY_EVENT_ENTER\",\n```\nImplementar regras do jogo Implementa as seguintes regras do jogo:\nCondição de vitória do jogador Quando todas as naves inimigas forem destruídas, exibe uma mensagem de vitória Primeiro, cria uma função displayMessage():\njavascript\nfunction displayMessage(message, color = \"red\") {\nctx font = \"30px Arial\";\nctx fillStyle = color;\nctx textAlign = \"center\";\nctx fillText(message, canvas width / 2, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9142,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 2,
    "total_chunks": 5
  },
  {
    "id": "1edc189927c782df5f162da3d2b24eb4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 6: Fim e Reinício",
    "content": "KEY_EVENT_ENTER); } Adicionar mensagem de reinício Adiciona esta Mensagem às constantes de Mensagens: ```javascript KEY_EVENT_ENTER: \"KEY_EVENT_ENTER\", ``` Implementar regras do jogo Implementa as seguintes regras do jogo: Condição de vitória do jogador Quando todas as naves inimigas forem destruídas, exibe uma mensagem de vitória Primeiro, cria uma função displayMessage(): javascript function displayMessage(message, color = \"red\") { ctx font = \"30px Arial\"; ctx fillStyle = color; ctx textAlign = \"center\"; ctx fillText(message, canvas width / 2, canvasheight / 2);\n}\nCria uma função endGame():\n```javascript\nfunction endGame(win) {\nclearInterval(gameLoopId);\n// set a delay so we are sure any paints have finished\nsetTimeout(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\nif (win) {\ndisplayMessage(\n\"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\",\n\"green\"\n);\n} else {\ndisplayMessage(\n\"You died Press [Enter] to start a new game Captain Pew Pew\"\n);\n}\n}, 200)\n}\n```\nLógica de reinício Quando todas as vidas forem perdidas ou o jogador vencer o jogo, exibe que o jogo pode ser reiniciado Além disso, reinicia o jogo quando a tecla de reinício for pressionada (podes decidir qual tecla será mapeada para reiniciar) Cria a função resetGame():\njavascript\nfunction resetGame() {\nif (gameLoopId) {\nclearInterval(gameLoopId);\neventEmitter clear();\ninitGame();\ngameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\ndrawPoints();\ndrawLife();\nupdateGameObjects();\ndrawGameObjects(ctx);\n}, 100);\n}\n}\nAdiciona uma chamada ao eventEmitter para reiniciar o jogo em initGame():\njavascript\neventEmitter on(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9142,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 3,
    "total_chunks": 5
  },
  {
    "id": "56aca20a0d63f74d3343f176ded394d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "Construir um Jogo Espacial Parte 6: Fim e Reinício",
    "content": "jogo quando a tecla de reinício for pressionada (podes decidir qual tecla será mapeada para reiniciar) Cria a função resetGame(): javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvas height); drawPoints(); drawLife(); updateGameObjects(); drawGameObjects(ctx); }, 100); } } Adiciona uma chamada ao eventEmitter para reiniciar o jogo em initGame(): javascript eventEmitter on(MessagesKEY_EVENT_ENTER, () => {\nresetGame();\n});\nAdiciona uma função clear() ao EventEmitter:\njavascript\nclear() {\nthis listeners = {};\n}\n👽 💥 🚀 Parabéns, Capitão O teu jogo está completo Muito bem 🚀 💥 👽\n🚀 Desafio\nAdiciona um som Consegues adicionar um som para melhorar a experiência do jogo, talvez quando um laser acerta, ou quando o herói morre ou vence Dá uma olhada neste sandbox para aprenderes a tocar som usando JavaScript Questionário Pós-Aula\nQuestionário pós-aula\nRevisão e Autoestudo\nA tua tarefa é criar um novo jogo de exemplo, por isso explora alguns jogos interessantes por aí para veres que tipo de jogo podes construir Tarefa\nConstruir um Jogo de Exemplo\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9142,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 470,
    "chunk_index": 4,
    "total_chunks": 5
  },
  {
    "id": "77633802deee48d09c4fa466de2cfe71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
    "source_type": "git_repo",
    "title": "Analisar um site para desempenho",
    "content": "Analisar um site para desempenho\nForneça um relatório detalhado de um site, mostrando as áreas onde o desempenho apresenta problemas. Analise por que o site é lento e o que pode ser feito para torná-lo mais rápido. Não se limite apenas às ferramentas do navegador, mas pesquise outras ferramentas que possam ajudar no seu relatório.\nCritérios de Avaliação\n| Critérios | Exemplário                                                                                                  | Adequado                    | Necessita Melhorias           |\n| --------- | ---------------------------------------------------------------------------------------------------------- | --------------------------- | ----------------------------- |\n|           | Um relatório é apresentado com detalhes obtidos não apenas de ferramentas do navegador, mas também de ferramentas de terceiros, se disponíveis | Um relatório básico é apresentado | Um relatório mínimo é apresentado |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1848,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 314,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "8f0403601c516337a6da984ddbac06a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores",
    "content": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores\nEsboço por Wassim Chegham\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nExtensões de navegador adicionam funcionalidades extras a um navegador Mas antes de criar uma, é importante aprender um pouco sobre como os navegadores funcionam Sobre o navegador\nNesta série de lições, vais aprender a criar uma extensão de navegador que funcionará nos navegadores Chrome, Firefox e Edge Nesta parte, vais descobrir como os navegadores funcionam e estruturar os elementos da extensão de navegador Mas o que é exatamente um navegador É uma aplicação de software que permite ao utilizador final aceder a conteúdos de um servidor e exibi-los em páginas web ✅ Um pouco de história: o primeiro navegador chamava-se 'WorldWideWeb' e foi criado por Sir Timothy Berners-Lee em 1990 Alguns navegadores antigos, via Karen McGrane\nQuando um utilizador se conecta à internet usando um endereço URL (Uniform Resource Locator), geralmente através do protocolo Hypertext Transfer Protocol com um endereço http ou https, o navegador comunica-se com um servidor web e obtém uma página web Neste ponto, o motor de renderização do navegador exibe a página no dispositivo do utilizador, que pode ser um telemóvel, computador de secretária ou portátil Os navegadores também têm a capacidade de armazenar conteúdo em cache para que não seja necessário recuperá-lo do servidor sempre Podem registar o histórico de navegação de um utilizador, armazenar 'cookies', que são pequenos pedaços de dados que contêm informações usadas para guardar a atividade do utilizador, entre outras funcionalidades Algo muito importante a lembrar sobre os navegadores é que eles não são todos iguais Cada navegador tem os seus pontos fortes e fracos, e um programador web profissional precisa de entender como fazer com que as páginas web funcionem bem em diferentes navegadores Isso inclui lidar com ecrãs pequenos, como os de telemóveis, bem como com utilizadores que estão offline",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 0,
    "total_chunks": 6
  },
  {
    "id": "6715806c6bf1b1707527e418020081a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores",
    "content": "de dados que contêm informações usadas para guardar a atividade do utilizador, entre outras funcionalidades Algo muito importante a lembrar sobre os navegadores é que eles não são todos iguais Cada navegador tem os seus pontos fortes e fracos, e um programador web profissional precisa de entender como fazer com que as páginas web funcionem bem em diferentes navegadores Isso inclui lidar com ecrãs pequenos, como os de telemóveis, bem como com utilizadores que estão offlineUm site muito útil que deves marcar nos teus favoritos, independentemente do navegador que preferes usar, é o caniuse com Quando estás a criar páginas web, é muito útil usar as listas de tecnologias suportadas do caniuse para ofereceres o melhor suporte aos teus utilizadores ✅ Como podes saber quais os navegadores mais populares entre os utilizadores do teu site Verifica as tuas análises - podes instalar vários pacotes de análise como parte do teu processo de desenvolvimento web, e eles dir-te-ão quais os navegadores mais usados pelos utilizadores Extensões de navegador\nPor que motivo quererias criar uma extensão de navegador É algo prático para anexar ao teu navegador quando precisas de acesso rápido a tarefas que costumas repetir Por exemplo, se precisas frequentemente de verificar cores nas várias páginas web que visitas, podes instalar uma extensão de navegador para selecionar cores Se tens dificuldade em lembrar-te de palavras-passe, podes usar uma extensão de navegador para gestão de palavras-passe As extensões de navegador também são divertidas de desenvolver Geralmente, gerem um número limitado de tarefas que executam bem ✅ Quais são as tuas extensões de navegador favoritas Que tarefas realizam Instalar extensões\nAntes de começares a criar, dá uma olhada no processo de construção e implementação de uma extensão de navegador",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 1,
    "total_chunks": 6
  },
  {
    "id": "68425e5a76b071bd215ba4196c4f406d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores",
    "content": "uma extensão de navegador para selecionar cores Se tens dificuldade em lembrar-te de palavras-passe, podes usar uma extensão de navegador para gestão de palavras-passe As extensões de navegador também são divertidas de desenvolver Geralmente, gerem um número limitado de tarefas que executam bem ✅ Quais são as tuas extensões de navegador favoritas Que tarefas realizam Instalar extensões Antes de começares a criar, dá uma olhada no processo de construção e implementação de uma extensão de navegadorEmbora cada navegador varie um pouco na forma como gere esta tarefa, o processo é semelhante no Chrome e Firefox ao exemplo no Edge:\nNota: Certifica-te de que ativaste o modo de programador e permitiste extensões de outras lojas Em essência, o processo será:\ncria a tua extensão usando npm run build\nnavega no navegador até ao painel de extensões usando o botão \"Definições e mais\" (o ícone ) no canto superior direito\nse for uma nova instalação, escolhe load unpacked para carregar uma nova extensão a partir da sua pasta de construção (no nosso caso é /dist)\nou, clica em reload se estiveres a recarregar uma extensão já instalada\n✅ Estas instruções referem-se a extensões que crias tu mesmo; para instalar extensões que foram lançadas na loja de extensões do navegador associado a cada navegador, deves navegar até essas lojas e instalar a extensão da tua escolha Começar\nVais criar uma extensão de navegador que exibe a pegada de carbono da tua região, mostrando o consumo de energia da tua região e a fonte dessa energia A extensão terá um formulário que recolhe uma chave de API para que possas aceder à API do CO2 Signal Vais precisar de:\numa chave de API; insere o teu email na caixa desta página e será enviada uma para ti\no código da tua região correspondente ao Electricity Map (em Boston, por exemplo, uso 'US-NEISO') o código inicial",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 2,
    "total_chunks": 6
  },
  {
    "id": "3118f287c778e20bf31fa14a2f5b1f85",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores",
    "content": "carbono da tua região, mostrando o consumo de energia da tua região e a fonte dessa energia A extensão terá um formulário que recolhe uma chave de API para que possas aceder à API do CO2 Signal Vais precisar de: uma chave de API; insere o teu email na caixa desta página e será enviada uma para ti o código da tua região correspondente ao Electricity Map (em Boston, por exemplo, uso 'US-NEISO') o código inicialFaz o download da pasta start; vais completar o código nesta pasta NPM - NPM é uma ferramenta de gestão de pacotes; instala-a localmente e os pacotes listados no teu ficheiro package json serão instalados para uso nos teus recursos web\n✅ Aprende mais sobre gestão de pacotes neste excelente módulo do Learn\nTira um momento para explorar a base de código:\ndist\n-|manifest json (definições padrão aqui)\n-|index html (marcação HTML do front-end aqui)\n-|background js (JS de fundo aqui)\n-|main js (JS compilado)\nsrc\n-|index js (o teu código JS vai aqui)\n✅ Assim que tiveres a tua chave de API e o código da região prontos, guarda-os numa nota para uso futuro Criar o HTML para a extensão\nEsta extensão tem duas vistas Uma para recolher a chave de API e o código da região:\nE a segunda para exibir o consumo de carbono da região:\nVamos começar por criar o HTML para o formulário e estilizar com CSS Na pasta /dist, vais criar um formulário e uma área de resultados No ficheiro index html, preenche a área do formulário delineada:\n```HTML\nNew Add your Information\nRegion Name\nYour API Key from tmrow\nSubmit\n```\nEste é o formulário onde as tuas informações guardadas serão inseridas e armazenadas no armazenamento local Em seguida, cria a área de resultados; abaixo da última tag do formulário, adiciona algumas divs:\n```HTML\nloading Region:\nCarbon Usage:\nFossil Fuel Percentage:\nChange region\n```\nNeste ponto, podes tentar uma construção",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 3,
    "total_chunks": 6
  },
  {
    "id": "ddf3ede0a4ba323084c6432e7449a70a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores",
    "content": "área de resultados No ficheiro index html, preenche a área do formulário delineada: ```HTML New Add your Information Region Name Your API Key from tmrow Submit ``` Este é o formulário onde as tuas informações guardadas serão inseridas e armazenadas no armazenamento local Em seguida, cria a área de resultados; abaixo da última tag do formulário, adiciona algumas divs: ```HTML loading Region: Carbon Usage: Fossil Fuel Percentage: Change region ``` Neste ponto, podes tentar uma construçãoCertifica-te de instalar as dependências do pacote desta extensão:\nnpm install\nEste comando usará o npm, o Gerenciador de Pacotes do Node, para instalar o webpack para o processo de construção da tua extensão Podes ver o resultado deste processo olhando para /dist/main js - verás que o código foi agrupado Por enquanto, a extensão deve ser construída e, se a implementares no Edge como uma extensão, verás um formulário exibido de forma organizada Parabéns, deste os primeiros passos para criar uma extensão de navegador Nas próximas lições, vais torná-la mais funcional e útil 🚀 Desafio\nDá uma olhada numa loja de extensões de navegador e instala uma no teu navegador Podes examinar os seus ficheiros de formas interessantes O que descobres Questionário Pós-Aula\nQuestionário pós-aula\nRevisão e Autoestudo\nNesta lição aprendeste um pouco sobre a história do navegador web; aproveita esta oportunidade para aprender sobre como os inventores da World Wide Web imaginaram o seu uso, lendo mais sobre a sua história Alguns sites úteis incluem:\nA História dos Navegadores Web\nHistória da Web\nUma entrevista com Tim Berners-Lee\nTarefa\nRedefine o estilo da tua extensão\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 481,
    "chunk_index": 4,
    "total_chunks": 6
  },
  {
    "id": "9d547efd3202ffa2b4defc860121726b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 1: Tudo sobre Navegadores",
    "content": "oportunidade para aprender sobre como os inventores da World Wide Web imaginaram o seu uso, lendo mais sobre a sua história Alguns sites úteis incluem: A História dos Navegadores Web História da Web Uma entrevista com Tim Berners-Lee Tarefa Redefine o estilo da tua extensão Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisõesO documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11243,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 191,
    "chunk_index": 5,
    "total_chunks": 6
  },
  {
    "id": "88b951dcbe62614cac4512623e5b8983",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\README.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Completo",
    "content": "Extensão de Navegador Carbon Trigger: Código Completo\nUsando a API CO2 Signal da tmrow para monitorizar o consumo de eletricidade, crie uma extensão de navegador para que possa ter um lembrete diretamente no seu navegador sobre o quão intenso é o consumo de eletricidade na sua região Utilizar esta extensão de forma pontual ajudará a tomar decisões informadas sobre as suas atividades com base nesta informação Introdução\nSerá necessário ter o npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nCompile a extensão com o webpack:\nnpm run build\nPara instalar no Edge, utilize o menu dos 'três pontos' no canto superior direito do navegador para aceder ao painel de Extensões A partir daí, selecione 'Carregar sem compactação' para carregar uma nova extensão Na janela que aparecer, abra a pasta 'dist' e a extensão será carregada Para utilizá-la, será necessário obter uma chave de API para a API CO2 Signal (obtenha uma aqui por email - insira o seu email na caixa desta página) e o código da sua região correspondente ao Electricity Map (em Boston, por exemplo, utilizo 'US-NEISO') Depois de inserir a chave de API e a região na interface da extensão, o ponto colorido na barra de extensões do navegador deverá mudar para refletir o consumo de energia da sua região e fornecer uma indicação sobre quais atividades intensivas em energia seriam apropriadas para realizar O conceito por trás deste sistema de 'ponto' foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2839,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "b295ec41e73db9b90bb084bfc020bf14",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\README.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Completo",
    "content": "para realizar O conceito por trás deste sistema de 'ponto' foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2839,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 154,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "3f86e0922beb27bb3b292dde535a34dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nNesta lição, vais chamar uma API ao submeter o formulário da tua extensão de navegador e exibir os resultados na extensão Além disso, vais aprender como armazenar dados no armazenamento local do navegador para referência e uso futuro ✅ Segue os segmentos numerados nos ficheiros apropriados para saber onde colocar o teu código Configurar os elementos para manipular na extensão:\nAté agora, já construíste o HTML para o formulário e a <div> de resultados da tua extensão de navegador A partir de agora, vais trabalhar no ficheiro /src/index js e construir a tua extensão passo a passo Consulta a lição anterior para configurar o teu projeto e o processo de build Trabalhando no ficheiro index js, começa por criar algumas variáveis const para armazenar os valores associados aos vários campos:\n```JavaScript\n// form fields\nconst form = document querySelector(' form-data');\nconst region = document querySelector(' region-name');\nconst apiKey = document querySelector(' api-key');\n// results\nconst errors = document querySelector(' errors');\nconst loading = document querySelector(' loading');\nconst results = document querySelector(' result-container');\nconst usage = document querySelector(' carbon-usage');\nconst fossilfuel = document querySelector(' fossil-fuel');\nconst myregion = document querySelector(' my-region');\nconst clearBtn = document querySelector(' clear-btn');\n```\nTodos estes campos são referenciados pelas suas classes CSS, conforme configurado no HTML na lição anterior Adicionar listeners\nA seguir, adiciona event listeners ao formulário e ao botão de limpar que reinicia o formulário, para que, se um utilizador submeter o formulário ou clicar nesse botão de reinício, algo aconteça Adiciona também a chamada para inicializar a aplicação no final do ficheiro:\nJavaScript\nform addEventListener('submit', (e) => handleSubmit(e));\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 0,
    "total_chunks": 8
  },
  {
    "id": "3adb084383470f56b89302cf61f07262",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "const clearBtn = document querySelector(' clear-btn'); ``` Todos estes campos são referenciados pelas suas classes CSS, conforme configurado no HTML na lição anterior Adicionar listeners A seguir, adiciona event listeners ao formulário e ao botão de limpar que reinicia o formulário, para que, se um utilizador submeter o formulário ou clicar nesse botão de reinício, algo aconteça Adiciona também a chamada para inicializar a aplicação no final do ficheiro: JavaScript form addEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e));\ninit();\n✅ Repara na forma abreviada usada para ouvir eventos de submissão ou clique, e como o evento é passado para as funções handleSubmit ou reset Consegues escrever o equivalente desta forma abreviada num formato mais longo Qual preferes Construir as funções init() e reset():\nAgora vais construir a função que inicializa a extensão, chamada init():\n```JavaScript\nfunction init() {\n//if anything is in localStorage, pick it up\nconst storedApiKey = localStorage getItem('apiKey');\nconst storedRegion = localStorage getItem('regionName');\n//set icon to be generic green\n//todo\nif (storedApiKey === null || storedRegion === null) {\n//if we don't have the keys, show the form\nform style display = 'block';\nresults style display = 'none';\nloading style display = 'none';\nclearBtn style display = 'none';\nerrors textContent = '';\n} else {\n//if we have saved keys/regions in localStorage, show results when they load\ndisplayCarbonUsage(storedApiKey, storedRegion);\nresults style display = 'none';\nform style display = 'none';\nclearBtn style display = 'block';\n}\n};\nfunction reset(e) {\ne preventDefault();\n//clear local storage for region only\nlocalStorage removeItem('regionName');\ninit();\n}\n```\nNesta função, há uma lógica interessante Ao lê-la, consegues perceber o que acontece São configuradas duas variáveis const para verificar se o utilizador armazenou uma APIKey e um código de região no armazenamento local Se qualquer uma delas for nula, mostra o formulário alterando o seu estilo para 'block'",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 1,
    "total_chunks": 8
  },
  {
    "id": "d00dd653fe1dcfae17f14a092b68912a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorage removeItem('regionName'); init(); } ``` Nesta função, há uma lógica interessante Ao lê-la, consegues perceber o que acontece São configuradas duas variáveis const para verificar se o utilizador armazenou uma APIKey e um código de região no armazenamento local Se qualquer uma delas for nula, mostra o formulário alterando o seu estilo para 'block'Esconde os resultados, o loading e o clearBtn, e define qualquer texto de erro como uma string vazia Se existir uma chave e uma região, inicia uma rotina para:\nchamar a API para obter dados de uso de carbono,\nesconder a área de resultados,\nesconder o formulário,\nmostrar o botão de reinício Antes de avançar, é útil aprender sobre um conceito muito importante disponível nos navegadores: LocalStorage LocalStorage é uma forma útil de armazenar strings no navegador como um par key-value Este tipo de armazenamento web pode ser manipulado por JavaScript para gerir dados no navegador LocalStorage não expira, enquanto SessionStorage, outro tipo de armazenamento web, é limpo quando o navegador é fechado Os vários tipos de armazenamento têm prós e contras no seu uso Nota - a tua extensão de navegador tem o seu próprio armazenamento local; a janela principal do navegador é uma instância diferente e comporta-se separadamente Definiste a tua APIKey para ter um valor de string, por exemplo, e podes ver que está configurada no Edge ao \"inspecionar\" uma página web (podes clicar com o botão direito no navegador para inspecionar) e ir ao separador Applications para ver o armazenamento ✅ Pensa em situações onde NÃO seria adequado armazenar alguns dados no LocalStorage Em geral, colocar API Keys no LocalStorage é uma má ideia Consegues perceber porquê No nosso caso, como a nossa aplicação é apenas para aprendizagem e não será publicada numa loja de aplicações, vamos usar este método",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 2,
    "total_chunks": 8
  },
  {
    "id": "518490818e00907ac04b2733771d029a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "no Edge ao \"inspecionar\" uma página web (podes clicar com o botão direito no navegador para inspecionar) e ir ao separador Applications para ver o armazenamento ✅ Pensa em situações onde NÃO seria adequado armazenar alguns dados no LocalStorage Em geral, colocar API Keys no LocalStorage é uma má ideia Consegues perceber porquê No nosso caso, como a nossa aplicação é apenas para aprendizagem e não será publicada numa loja de aplicações, vamos usar este métodoRepara que usas a Web API para manipular o LocalStorage, seja com getItem(), setItem(), ou removeItem() É amplamente suportado em vários navegadores Antes de construir a função displayCarbonUsage() que é chamada em init(), vamos construir a funcionalidade para lidar com a submissão inicial do formulário Lidar com a submissão do formulário\nCria uma função chamada handleSubmit que aceita um argumento de evento (e) Impede que o evento se propague (neste caso, queremos impedir que o navegador atualize) e chama uma nova função, setUpUser, passando os argumentos apiKey value e region value Desta forma, usas os dois valores que são trazidos pelo formulário inicial quando os campos apropriados são preenchidos JavaScript\nfunction handleSubmit(e) {\ne preventDefault();\nsetUpUser(apiKey value, region value);\n}\n✅ Refresca a tua memória - o HTML que configuraste na última lição tem dois campos de entrada cujos values são capturados pelas const que configuraste no topo do ficheiro, e ambos são required, então o navegador impede os utilizadores de introduzirem valores nulos Configurar o utilizador\nAvançando para a função setUpUser, aqui é onde defines os valores de armazenamento local para apiKey e regionName Adiciona uma nova função:\nJavaScript\nfunction setUpUser(apiKey, regionName) {\nlocalStorage setItem('apiKey', apiKey);\nlocalStorage setItem('regionName', regionName);\nloading style display = 'block';\nerrors textContent = '';\nclearBtn style display = 'block';\n//make initial call\ndisplayCarbonUsage(apiKey, regionName);\n}\nEsta função define uma mensagem de loading para mostrar enquanto a API é chamada",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 3,
    "total_chunks": 8
  },
  {
    "id": "f579b896799489345b6927e7e2e8f10d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "os utilizadores de introduzirem valores nulos Configurar o utilizador Avançando para a função setUpUser, aqui é onde defines os valores de armazenamento local para apiKey e regionName Adiciona uma nova função: JavaScript function setUpUser(apiKey, regionName) { localStorage setItem('apiKey', apiKey); localStorage setItem('regionName', regionName); loading style display = 'block'; errors textContent = ''; clearBtn style display = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } Esta função define uma mensagem de loading para mostrar enquanto a API é chamadaNeste ponto, chegaste à criação da função mais importante desta extensão de navegador Exibir Uso de Carbono\nFinalmente, é hora de consultar a API Antes de avançar, devemos discutir APIs APIs, ou Interfaces de Programação de Aplicações, são um elemento crítico na caixa de ferramentas de um programador web Elas fornecem formas padrão para programas interagirem e se conectarem uns aos outros Por exemplo, se estás a construir um site que precisa consultar uma base de dados, alguém pode ter criado uma API para usares Embora existam muitos tipos de APIs, uma das mais populares é uma API REST ✅ O termo 'REST' significa 'Transferência de Estado Representacional' e utiliza URLs configuradas de várias formas para obter dados Faz uma pequena pesquisa sobre os vários tipos de APIs disponíveis para programadores Qual formato te parece mais interessante Há coisas importantes a notar sobre esta função Primeiro, repara na palavra-chave async Escrever as tuas funções para que funcionem de forma assíncrona significa que elas esperam que uma ação, como o retorno de dados, seja concluída antes de continuar Aqui está um vídeo rápido sobre async:\n🎥 Clica na imagem acima para um vídeo sobre async/await Cria uma nova função para consultar a API C02Signal:\n```JavaScript\nimport axios from ' /node_modules/axios';\nasync function displayCarbonUsage(apiKey, region) {\ntry {\nawait axios get('https://api co2signal com/v1/latest', {\nparams: {\ncountryCode: region,\n},\nheaders: {\n'auth-token': apiKey,\n},\n})",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 4,
    "total_chunks": 8
  },
  {
    "id": "01750639b71bb85572400a5544ad1cdd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "de forma assíncrona significa que elas esperam que uma ação, como o retorno de dados, seja concluída antes de continuar Aqui está um vídeo rápido sobre async: 🎥 Clica na imagem acima para um vídeo sobre async/await Cria uma nova função para consultar a API C02Signal: ```JavaScript import axios from ' /node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axios get('https://api co2signal com/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => {\nlet CO2 = Math floor(response data data carbonIntensity);\n//calculateColor(CO2);\nloading style display = 'none';\nform style display = 'none';\nmyregion textContent = region;\nusage textContent =\nMath round(response data data carbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)';\nfossilfuel textContent =\nresponse data data fossilFuelPercentage toFixed(2) +\n'% (percentage of fossil fuels used to generate electricity)';\nresults style display = 'block';\n});\n} catch (error) {\nconsole log(error);\nloading style display = 'none';\nresults style display = 'none';\nerrors textContent = 'Sorry, we have no data for the region you have requested ';\n}\n}\n```\nEsta é uma função grande O que está a acontecer aqui Seguindo boas práticas, usas a palavra-chave async para fazer com que esta função se comporte de forma assíncrona A função contém um bloco try/catch, pois retornará uma promessa quando a API devolver dados Como não tens controlo sobre a velocidade com que a API responderá (ela pode nem responder ), precisas de lidar com esta incerteza chamando-a de forma assíncrona Estás a consultar a API co2signal para obter os dados da tua região, usando a tua API Key Para usar essa chave, precisas de usar um tipo de autenticação nos parâmetros do cabeçalho Quando a API responde, atribuis vários elementos dos dados da resposta às partes do ecrã que configuraste para mostrar esses dados Se houver um erro ou se não houver resultado, mostras uma mensagem de erro",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 5,
    "total_chunks": 8
  },
  {
    "id": "4e09776a85c8ed2944c61cc4bbd0ad73",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "lidar com esta incerteza chamando-a de forma assíncrona Estás a consultar a API co2signal para obter os dados da tua região, usando a tua API Key Para usar essa chave, precisas de usar um tipo de autenticação nos parâmetros do cabeçalho Quando a API responde, atribuis vários elementos dos dados da resposta às partes do ecrã que configuraste para mostrar esses dados Se houver um erro ou se não houver resultado, mostras uma mensagem de erro✅ Usar padrões de programação assíncrona é outra ferramenta muito útil na tua caixa de ferramentas Lê sobre as várias formas de configurar este tipo de código Parabéns Se construíres a tua extensão (npm run build) e a atualizares no painel de extensões, tens uma extensão funcional A única coisa que não está a funcionar é o ícone, e vais corrigir isso na próxima lição 🚀 Desafio\nDiscutimos vários tipos de API até agora nestas lições Escolhe uma API web e pesquisa em profundidade o que ela oferece Por exemplo, dá uma olhada nas APIs disponíveis nos navegadores, como a API HTML Drag and Drop O que faz uma API ser excelente na tua opinião Questionário Pós-Aula\nQuestionário pós-aula\nRevisão & Autoestudo\nAprendeste sobre LocalStorage e APIs nesta lição, ambos muito úteis para o programador web profissional Consegues pensar em como estas duas coisas funcionam juntas Pensa em como arquitetarias um site que armazenasse itens para serem usados por uma API Tarefa\nAdota uma API\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 6,
    "total_chunks": 8
  },
  {
    "id": "e8277a28b40fce49151cf2323553e29e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 2: Chamar uma API, usar Local Storage",
    "content": "coisas funcionam juntas Pensa em como arquitetarias um site que armazenasse itens para serem usados por uma API Tarefa Adota uma API Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária Para informações críticas, recomenda-se a tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13251,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 156,
    "chunk_index": 7,
    "total_chunks": 8
  },
  {
    "id": "8622fcc25a9f484d558fd62839dbc459",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\start\\README.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Inicial",
    "content": "Extensão de Navegador Carbon Trigger: Código Inicial\nUsando a API CO2 Signal da tmrow para monitorizar o consumo de eletricidade, construa uma extensão de navegador para que possa ter um lembrete diretamente no seu navegador sobre o quão intenso é o consumo de eletricidade na sua região Utilizar esta extensão de forma ad hoc ajudará a tomar decisões informadas sobre as suas atividades com base nesta informação Primeiros Passos\nSerá necessário ter o npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nCompile a extensão com o webpack:\nnpm run build\nPara instalar no Edge, utilize o menu de 'três pontos' no canto superior direito do navegador para aceder ao painel de Extensões A partir daí, selecione 'Carregar sem compactação' para carregar uma nova extensão Na janela que aparecer, abra a pasta 'dist' e a extensão será carregada Para utilizá-la, será necessário obter uma chave de API para a API CO2 Signal (obtenha uma aqui por email - insira o seu email na caixa desta página) e o código da sua região correspondente ao Electricity Map (em Boston, por exemplo, utilizo 'US-NEISO') Depois de inserir a chave de API e a região na interface da extensão, o ponto colorido na barra de extensões do navegador deverá mudar para refletir o consumo de energia da sua região e fornecer uma indicação sobre quais atividades intensivas em energia seriam apropriadas para realizar O conceito por trás deste sistema de 'ponto' foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\start\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "a16113411e22e12282c7743bbb4762d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\start\\README.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Inicial",
    "content": "para realizar O conceito por trás deste sistema de 'ponto' foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\start\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 154,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "70d14b8e5580881b638b8a8c42a7037d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nNas duas últimas lições deste módulo, aprendeste a construir um formulário e uma área de exibição para dados obtidos de uma API É uma forma bastante comum de criar uma presença na web Também aprendeste a lidar com a obtenção de dados de forma assíncrona A tua extensão de navegador está quase completa Resta gerir algumas tarefas em segundo plano, incluindo a atualização da cor do ícone da extensão, por isso este é um ótimo momento para falar sobre como o navegador gere este tipo de tarefa Vamos pensar nestas tarefas do navegador no contexto do desempenho dos teus recursos web enquanto os desenvolves Noções Básicas de Desempenho Web\n\"O desempenho de um site refere-se a duas coisas: quão rápido a página carrega e quão rápido o código nela é executado \" -- Zack Grossbart\nO tema de como tornar os teus sites incrivelmente rápidos em todos os tipos de dispositivos, para todos os tipos de utilizadores, em todas as situações, é, sem surpresa, vasto Aqui estão alguns pontos a ter em mente ao desenvolveres um projeto web padrão ou uma extensão de navegador A primeira coisa que precisas de fazer para garantir que o teu site está a funcionar de forma eficiente é recolher dados sobre o seu desempenho O primeiro lugar para fazer isso é nas ferramentas de desenvolvimento do teu navegador No Edge, podes selecionar o botão \"Definições e mais\" (o ícone de três pontos no canto superior direito do navegador), depois navegar para Mais Ferramentas > Ferramentas de Desenvolvimento e abrir o separador Desempenho Também podes usar os atalhos de teclado Ctrl + Shift + I no Windows ou Option + Command + I no Mac para abrir as ferramentas de desenvolvimento O separador Desempenho contém uma ferramenta de Perfil",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "adc2e65d40ccf8baf3713cebba885748",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "ferramentas de desenvolvimento do teu navegador No Edge, podes selecionar o botão \"Definições e mais\" (o ícone de três pontos no canto superior direito do navegador), depois navegar para Mais Ferramentas > Ferramentas de Desenvolvimento e abrir o separador Desempenho Também podes usar os atalhos de teclado Ctrl + Shift + I no Windows ou Option + Command + I no Mac para abrir as ferramentas de desenvolvimento O separador Desempenho contém uma ferramenta de PerfilAbre um site (experimenta, por exemplo, https://www microsoft com) e clica no botão 'Gravar', depois atualiza o site Podes parar a gravação a qualquer momento e verás as rotinas geradas para 'script', 'renderizar' e 'pintar' o site:\n✅ Visita a Documentação da Microsoft sobre o painel de Desempenho no Edge Dica: para obter uma leitura precisa do tempo de inicialização do teu site, limpa a cache do navegador Seleciona elementos da linha do tempo do perfil para ampliar eventos que ocorrem enquanto a tua página carrega Obtém uma visão geral do desempenho da tua página selecionando uma parte da linha do tempo do perfil e olhando para o painel de resumo:\nVerifica o painel de Registo de Eventos para ver se algum evento demorou mais de 15 ms:\n✅ Familiariza-te com o teu perfilador Abre as ferramentas de desenvolvimento neste site e verifica se há algum gargalo Qual é o recurso que carrega mais lentamente E o mais rápido Verificações de Perfil\nDe forma geral, existem algumas \"áreas problemáticas\" que todos os desenvolvedores web devem observar ao construir um site para evitar surpresas desagradáveis na hora de implementar em produção Tamanhos de recursos: A web tornou-se mais 'pesada' e, portanto, mais lenta, nos últimos anos Parte desse peso está relacionada ao uso de imagens ✅ Consulta o Arquivo da Internet para uma visão histórica do peso das páginas e mais",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 480,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "22ac22d5cee49adf9ac1b2137eda2e8b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "lentamente E o mais rápido Verificações de Perfil De forma geral, existem algumas \"áreas problemáticas\" que todos os desenvolvedores web devem observar ao construir um site para evitar surpresas desagradáveis na hora de implementar em produção Tamanhos de recursos: A web tornou-se mais 'pesada' e, portanto, mais lenta, nos últimos anos Parte desse peso está relacionada ao uso de imagens ✅ Consulta o Arquivo da Internet para uma visão histórica do peso das páginas e maisUma boa prática é garantir que as tuas imagens estão otimizadas e entregues no tamanho e resolução adequados para os teus utilizadores Percursos no DOM: O navegador precisa construir o Modelo de Objeto de Documento (DOM) com base no código que escreves, por isso é do interesse de um bom desempenho da página manter as tags mínimas, usando e estilizando apenas o que a página necessita Nesse sentido, CSS em excesso associado a uma página pode ser otimizado; estilos que precisam ser usados apenas numa página não precisam ser incluídos na folha de estilo principal, por exemplo JavaScript: Todo desenvolvedor de JavaScript deve estar atento a scripts que bloqueiam a renderização e que precisam ser carregados antes que o restante do DOM possa ser percorrido e pintado no navegador Considera usar defer com os teus scripts inline (como foi feito no módulo Terrarium) ✅ Experimenta alguns sites num site de teste de velocidade para aprender mais sobre as verificações comuns feitas para determinar o desempenho de um site Agora que tens uma ideia de como o navegador renderiza os recursos que envias para ele, vamos ver as últimas coisas que precisas fazer para completar a tua extensão:\nCriar uma função para calcular a cor\nNo ficheiro /src/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 426,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "69e7b6d528e3dbd7e08ca1eb4fea1c4a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "defer com os teus scripts inline (como foi feito no módulo Terrarium) ✅ Experimenta alguns sites num site de teste de velocidade para aprender mais sobre as verificações comuns feitas para determinar o desempenho de um site Agora que tens uma ideia de como o navegador renderiza os recursos que envias para ele, vamos ver as últimas coisas que precisas fazer para completar a tua extensão: Criar uma função para calcular a cor No ficheiro /src/indexjs, adiciona uma função chamada calculateColor() após a série de variáveis const que configuraste para aceder ao DOM:\n```JavaScript\nfunction calculateColor(value) {\nlet co2Scale = [0, 150, 600, 750, 800];\nlet colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02'];\nlet closestNum = co2Scale sort((a, b) => {\nreturn Math abs(a - value) - Math abs(b - value);\n})[0];\nconsole log(value + ' is closest to ' + closestNum);\nlet num = (element) => element > closestNum;\nlet scaleIndex = co2Scale findIndex(num);\nlet closestColor = colors[scaleIndex];\nconsole log(scaleIndex, closestColor);\nchrome runtime sendMessage({ action: 'updateIcon', value: { color: closestColor } });\n}\n```\nO que está a acontecer aqui Passas um valor (a intensidade de carbono) da chamada à API que completaste na última lição e, em seguida, calculas quão próximo o valor está do índice apresentado no array de cores Depois, envias esse valor de cor mais próximo para o runtime do Chrome O chrome runtime tem uma API que lida com todos os tipos de tarefas em segundo plano, e a tua extensão está a aproveitar isso:\n\"Usa a API chrome runtime para recuperar a página de fundo, retornar detalhes sobre o manifesto e ouvir e responder a eventos no ciclo de vida da aplicação ou extensão Também podes usar esta API para converter o caminho relativo de URLs em URLs totalmente qualificados",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 471,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "54d64554efc29ff4bb51bef261f76e11",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "para o runtime do Chrome O chrome runtime tem uma API que lida com todos os tipos de tarefas em segundo plano, e a tua extensão está a aproveitar isso: \"Usa a API chrome runtime para recuperar a página de fundo, retornar detalhes sobre o manifesto e ouvir e responder a eventos no ciclo de vida da aplicação ou extensão Também podes usar esta API para converter o caminho relativo de URLs em URLs totalmente qualificados\"\n✅ Se estás a desenvolver esta extensão de navegador para o Edge, pode surpreender-te que estás a usar uma API do Chrome As versões mais recentes do navegador Edge são baseadas no motor do navegador Chromium, por isso podes aproveitar estas ferramentas Nota: se quiseres fazer o perfil de uma extensão de navegador, abre as ferramentas de desenvolvimento dentro da própria extensão, pois ela é uma instância separada do navegador Definir uma cor padrão para o ícone\nAgora, na função init(), define o ícone para ser genericamente verde no início, chamando novamente a ação updateIcon do Chrome:\nJavaScript\nchrome runtime sendMessage({\naction: 'updateIcon',\nvalue: {\ncolor: 'green',\n},\n});\nChamar a função, executar a chamada\nEm seguida, chama a função que acabaste de criar, adicionando-a à promessa retornada pela API C02Signal:\nJavaScript\n//let CO2 calculateColor(CO2);\nE, finalmente, no ficheiro /dist/background js, adiciona o ouvinte para estas chamadas de ação em segundo plano:\n```JavaScript\nchrome runtime onMessage addListener(function (msg, sender, sendResponse) {\nif (msg action === 'updateIcon') {\nchrome browserAction setIcon({ imageData: drawIcon(msg value) });\n}\n});\n//borrowed from energy lollipop extension, nice feature function drawIcon(value) {\nlet canvas = document createElement('canvas');\nlet context = canvas getContext('2d');\ncontext beginPath();\ncontext fillStyle = value color;\ncontext arc(100, 100, 50, 0, 2 * Math PI);\ncontext fill();\nreturn context",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 468,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "92a26f5646b4686a21c36786041f2633",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "js, adiciona o ouvinte para estas chamadas de ação em segundo plano: ```JavaScript chrome runtime onMessage addListener(function (msg, sender, sendResponse) { if (msg action === 'updateIcon') { chrome browserAction setIcon({ imageData: drawIcon(msg value) }); } }); //borrowed from energy lollipop extension, nice feature function drawIcon(value) { let canvas = document createElement('canvas'); let context = canvas getContext('2d'); context beginPath(); context fillStyle = value color; context arc(100, 100, 50, 0, 2 * Math PI); context fill(); return contextgetImageData(50, 50, 100, 100);\n}\n```\nNeste código, estás a adicionar um ouvinte para quaisquer mensagens que chegam ao gestor de tarefas em segundo plano Se for chamado 'updateIcon', o próximo código é executado para desenhar um ícone da cor apropriada usando a API Canvas ✅ Vais aprender mais sobre a API Canvas nas lições do Jogo Espacial Agora, reconstrói a tua extensão (npm run build), atualiza e lança a tua extensão, e observa a mudança de cor É uma boa altura para fazeres uma pausa ou lavares a loiça Agora já sabes Parabéns, construíste uma extensão de navegador útil e aprendeste mais sobre como o navegador funciona e como fazer o perfil do seu desempenho 🚀 Desafio\nInvestiga alguns sites de código aberto que existem há muito tempo e, com base no histórico do GitHub, vê se consegues determinar como foram otimizados ao longo dos anos para desempenho, se é que foram Qual é o ponto problemático mais comum Questionário Pós-Aula\nQuestionário pós-aula\nRevisão e Autoestudo\nConsidera inscrever-te numa newsletter de desempenho Investiga algumas das formas como os navegadores avaliam o desempenho web, explorando os separadores de desempenho nas suas ferramentas de desenvolvimento Encontras alguma diferença significativa",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "b219ff195d4902cfaf2dc6fbe6921383",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "Projeto de Extensão de Navegador Parte 3: Aprender sobre Tarefas em Segundo Plano e Desempenho",
    "content": "código aberto que existem há muito tempo e, com base no histórico do GitHub, vê se consegues determinar como foram otimizados ao longo dos anos para desempenho, se é que foram Qual é o ponto problemático mais comum Questionário Pós-Aula Questionário pós-aula Revisão e Autoestudo Considera inscrever-te numa newsletter de desempenho Investiga algumas das formas como os navegadores avaliam o desempenho web, explorando os separadores de desempenho nas suas ferramentas de desenvolvimento Encontras alguma diferença significativaTarefa\nAnalisa um site para desempenho\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11020,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 270,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "0f6e6689e3a8d0416ddf25ece832b9c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.es.md",
    "source_type": "git_repo",
    "title": "Extensão de navegador Carbon Trigger: Código completo",
    "content": "Extensão de navegador Carbon Trigger: Código completo\nUsando a API de sinal CO2 da tmrow para monitorizar o uso de eletricidade, crie uma extensão de navegador que lhe permita ter um lembrete direto no seu navegador sobre o consumo de eletricidade na sua região O uso desta extensão ad hoc ajudará a tomar decisões sobre as suas atividades com base nesta informação Começar\nSerá necessário ter npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nConstrua a extensão usando o webpack:\nnpm run build\nPara instalar no Edge, utilize o menu de 'três pontos' no canto superior direito do navegador para encontrar o painel Extensões A partir daí, selecione 'Carregar descompactado' para adicionar uma nova extensão Abra a pasta 'dist' quando solicitado e a extensão será carregada Para utilizá-la, precisará de uma chave API para a API CO2 Signal (obtenha uma aqui por email - insira o seu email na caixa desta página) e o código da sua região correspondente ao Mapa de Eletricidade (em Boston, por exemplo, utilizo 'US-NEISO') Depois de inserir a chave API e a região na interface da extensão, o ponto colorido na barra de extensão do navegador deve mudar para refletir o uso de energia da sua região e fornecer um indicador sobre as atividades de alto consumo de energia que seriam adequadas para si O conceito por trás deste sistema de \"pontos\" foi inspirado pela extensão Energy Lollipop para as emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2809,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.es.md",
      "source_type": "git_repo"
    },
    "token_count": 486,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "ae698191a6e91f04f5dec76d0c01ab56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.es.md",
    "source_type": "git_repo",
    "title": "Extensão de navegador Carbon Trigger: Código completo",
    "content": "si O conceito por trás deste sistema de \"pontos\" foi inspirado pela extensão Energy Lollipop para as emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2809,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.es.md",
      "source_type": "git_repo"
    },
    "token_count": 155,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "bad10bca6690a3797595eb731f5a1b8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.fr.md",
    "source_type": "git_repo",
    "title": "Extensão de navegador Carbon Trigger: Código Completo",
    "content": "Extensão de navegador Carbon Trigger: Código Completo\nUtilizando a API C02 Signal da tmrow para monitorizar o consumo de eletricidade, crie uma extensão de navegador para que possa receber lembretes diretamente no seu navegador sobre o consumo de eletricidade na sua região O uso desta extensão personalizada ajudará a tomar decisões sobre as suas atividades com base nessas informações Introdução\nSerá necessário ter o npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nCompile a extensão utilizando o webpack:\nnpm run build\nPara instalar no Edge, utilize o menu 'três pontos' no canto superior direito do navegador para encontrar o painel Extensões A partir daí, selecione 'Carregar extensão descompactada' para adicionar uma nova extensão Abra a pasta 'dist' quando solicitado, e a extensão será carregada Para utilizá-la, precisará de uma chave API para a API do CO2 Signal (obtenha uma aqui por e-mail - insira o seu e-mail na caixa desta página) e o código da sua região correspondente ao Mapa de Eletricidade (em Boston, por exemplo, utilizo 'US-NEISO') Depois de inserir a chave API e a região na interface da extensão, o ponto colorido na barra de extensões do navegador deve mudar para refletir o consumo de energia da sua região e fornecer um indicador sobre as atividades que consomem mais energia e que seria apropriado realizar O conceito por trás deste sistema de 'pontos' foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2817,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.fr.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "6cda11b6600ac376b7cd281a3552c17e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.fr.md",
    "source_type": "git_repo",
    "title": "Extensão de navegador Carbon Trigger: Código Completo",
    "content": "apropriado realizar O conceito por trás deste sistema de 'pontos' foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2817,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.fr.md",
      "source_type": "git_repo"
    },
    "token_count": 157,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "fc5ab9653624375e45a220fce9e62080",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.hi.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Completo",
    "content": "Extensão de Navegador Carbon Trigger: Código Completo\nUtilizando a API CO2 Signal da tmrow para monitorizar o uso de eletricidade, esta extensão de navegador foi criada para lhe lembrar o quão intensivo é o uso de eletricidade na sua área enquanto navega Usar esta extensão pode ajudá-lo a tomar decisões sobre suas atividades com base nesta informação Começar\nÉ necessário ter npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nCrie a extensão com Webpack:\nnpm run build\nPara instalar no Edge, utilize o menu de 'três pontos' no canto superior direito do navegador para encontrar o painel de extensões A partir daí, selecione 'Carregar não empacotado' para carregar uma nova extensão No prompt, abra a pasta 'dist' e a extensão será carregada Para utilizá-la, precisará de uma chave de API do CO2 Signal (obtenha aqui por email - insira o seu email na caixa desta página) e o código da sua área no Electricity Map (por exemplo, em Boston, utilizo 'US-NEISO') Depois de inserir a chave de API e o código da área na interface da extensão, o ponto colorido na barra de extensões do navegador deve mudar para refletir o uso de energia na sua área e fornecer um indicador sobre quais atividades intensivas em energia são mais adequadas para o momento O conceito por trás deste sistema de 'ponto' foi inspirado na extensão Energy Lollipop para emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.hi.md",
      "source_type": "git_repo"
    },
    "token_count": 476,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "b409960393aabe812a87ee46d0ca148c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.hi.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Completo",
    "content": "o momento O conceito por trás deste sistema de 'ponto' foi inspirado na extensão Energy Lollipop para emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2727,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.hi.md",
      "source_type": "git_repo"
    },
    "token_count": 154,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "a68d990644651caaa55a3136f7d9c1bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.it.md",
    "source_type": "git_repo",
    "title": "Extensão de navegador Carbon Trigger: código para começar",
    "content": "Extensão de navegador Carbon Trigger: código para começar\nSerá utilizada a API Signal CO2 da tmrow para monitorizar o uso de eletricidade e criar uma extensão para o navegador, permitindo ter um lembrete diretamente no navegador sobre o impacto do consumo de eletricidade na sua região O uso desta extensão personalizada ajudará a avaliar as suas atividades com base nessas informações Para Começar\nÉ necessário ter o npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nCrie a extensão com o webpack:\nnpm run build\nPara instalar no Edge, utilize o menu \"três pontos\" no canto superior direito do navegador para encontrar o painel Extensões Caso ainda não esteja ativado, ative o Modo de Programador (no canto inferior esquerdo) Selecione \"Carregar descompactado\" para adicionar uma nova extensão No prompt, abra a pasta \"dist\" e a extensão será carregada Para utilizá-la, será necessário uma chave API para a API CO2 Signal (pode obtê-la aqui por e-mail - insira o seu e-mail na caixa desta página) e o código da sua região correspondente ao mapa elétrico (em Boston, por exemplo, \"US-NEISO\") Depois de inserir a chave API e a região na interface da extensão, o ponto colorido na barra de extensões do navegador deverá mudar para refletir o consumo de energia da região e fornecer uma indicação sobre quais atividades de alto consumo energético seriam apropriadas para realizar O conceito por trás deste sistema de \"pontos\" foi inspirado pela extensão Energy Lollipop para as emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, é importante notar que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritária",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2873,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.it.md",
      "source_type": "git_repo"
    },
    "token_count": 484,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "446175abb7668f2ba285c45698075537",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.it.md",
    "source_type": "git_repo",
    "title": "Extensão de navegador Carbon Trigger: código para começar",
    "content": "sobre quais atividades de alto consumo energético seriam apropriadas para realizar O conceito por trás deste sistema de \"pontos\" foi inspirado pela extensão Energy Lollipop para as emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, é importante notar que traduções automáticas podem conter erros ou imprecisões O documento original na sua língua nativa deve ser considerado a fonte autoritáriaPara informações críticas, recomenda-se a tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2873,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.it.md",
      "source_type": "git_repo"
    },
    "token_count": 173,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "1e2e768ffab1b6ad06244310c9811d81",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\4-typing-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "Este é um marcador de posição, deixado em branco propositadamente\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 892,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\4-typing-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 144,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "27f482fa59d55053b38d626eb7dcb0cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ja.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Finalizado",
    "content": "Extensão de Navegador Carbon Trigger: Código Finalizado\nConstrua uma extensão de navegador que utilize a API CO2 Signal da tmrow para monitorizar o consumo de energia na sua região e exibir lembretes no navegador sobre o impacto do uso de eletricidade Com esta extensão, pode tomar decisões informadas sobre as suas atividades com base nesta informação Introdução\nÉ necessário ter o npm instalado Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários npm install\nConstrua a extensão utilizando o webpack npm run build\nPara instalar no Edge, localize o painel \"Extensões\" no menu dos \"três pontos\" no canto superior direito do navegador A partir daí, selecione \"Carregar sem compactação\" e carregue a nova extensão Quando solicitado, abra a pasta \"dist\" para carregar a extensão Para utilizá-la, precisará de uma chave de API da CO2 Signal (obtenha uma aqui por e-mail - insira o seu e-mail na caixa desta página) e do código da sua região correspondente no Electricity Map (em Boston, por exemplo, utiliza-se 'US-NEISO') Depois de inserir a chave de API e a região na interface da extensão, verá um ponto colorido na barra de extensões do navegador Este ponto muda de cor para refletir o consumo de energia na sua região, ajudando a determinar quais atividades que consomem energia são mais adequadas naquele momento O conceito deste sistema de \"ponto\" foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2764,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ja.md",
      "source_type": "git_repo"
    },
    "token_count": 476,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "e5769254efbc048d7b8d63f9cc49548e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ja.md",
    "source_type": "git_repo",
    "title": "Extensão de Navegador Carbon Trigger: Código Finalizado",
    "content": "mais adequadas naquele momento O conceito deste sistema de \"ponto\" foi inspirado pela extensão Energy Lollipop para emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2764,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ja.md",
      "source_type": "git_repo"
    },
    "token_count": 157,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "4c87e6d63983c35ced5492f7bb8d60da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ms.md",
    "source_type": "git_repo",
    "title": "Extensão do Navegador Carbon Trigger: Código Completo",
    "content": "Extensão do Navegador Carbon Trigger: Código Completo\nUtilizando a API CO2 Signal da tmrow para monitorizar o consumo de eletricidade, crie uma extensão de navegador que permita receber alertas no seu navegador sobre o impacto do consumo de eletricidade na sua região Usar esta extensão pode ajudá-lo a tomar decisões informadas sobre as suas atividades com base nestas informações Começar Aqui\nÉ necessário instalar o npm Faça o download de uma cópia deste código para uma pasta no seu computador Instale todos os pacotes necessários:\nnpm install\nCompile a extensão com o webpack:\nnpm run build\nPara instalar no Edge, utilize o menu dos 'três pontos' no canto superior direito do navegador para aceder ao painel de Extensões A partir daí, selecione 'Carregar sem compactação' para adicionar uma nova extensão Abra a pasta 'dist' quando solicitado, e a extensão será carregada Para utilizá-la, precisará de uma chave API para a API CO2 Signal (obtenha uma aqui por e-mail - insira o seu e-mail na caixa disponível nesta página) e do código da sua região correspondente ao Electricity Map (em Boston, por exemplo, utilizo 'US-NEISO') Depois de inserir a chave API e a região na interface da extensão, o ponto colorido na barra da extensão do navegador mudará para refletir o consumo de energia da sua região, fornecendo-lhe indicações sobre quais atividades intensivas são mais adequadas para realizar O conceito por trás deste sistema de 'pontos' foi inspirado pela extensão de navegador Energy Lollipop para emissões na Califórnia Aviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2826,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ms.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "730e4dd45cf23391f84289ebd5821789",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ms.md",
    "source_type": "git_repo",
    "title": "Extensão do Navegador Carbon Trigger: Código Completo",
    "content": "O conceito por trás deste sistema de 'pontos' foi inspirado pela extensão de navegador Energy Lollipop para emissões na Califórnia Aviso Legal: Este documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanosNão nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2826,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\5-browser-extension\\solution\\translation\\README.ms.md",
      "source_type": "git_repo"
    },
    "token_count": 155,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "de110a6dc3df7433c1e2faf797614796",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\4-typing-game\\typing-game\\assignment.md",
    "source_type": "git_repo",
    "title": "Criar um novo jogo de teclado",
    "content": "Criar um novo jogo de teclado\nInstruções\nCrie um pequeno jogo que utilize eventos de teclado para realizar tarefas. Pode ser um tipo diferente de jogo de digitação ou um jogo artístico que pinta píxeis no ecrã ao pressionar teclas. Seja criativo!\nCritérios de Avaliação\n| Critério  | Exemplary                | Adequate                 | Needs Improvement |\n| --------- | ------------------------ | ------------------------ | ----------------- |\n|           | Um jogo completo é apresentado | O jogo é muito básico   | O jogo tem erros  |\n|           |                          |                          |                   |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritativa. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1494,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\4-typing-game\\typing-game\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 270,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e0c49fa6b82ef12095a54776e784b1d4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\assignment.md",
    "source_type": "git_repo",
    "title": "Pratique o seu HTML: Crie um mockup de blog",
    "content": "Pratique o seu HTML: Crie um mockup de blog\nInstruções\nImagine que está a desenhar, ou redesenhar, o seu site pessoal. Crie um mockup gráfico do seu site e, em seguida, escreva o código HTML que utilizaria para construir os vários elementos do site. Pode fazer isto em papel e digitalizá-lo, ou usar o software da sua escolha, mas certifique-se de que escreve manualmente o código HTML.\nCritérios de Avaliação\n| Critérios | Exemplar                                                                           | Adequado                                                                         | Necessita de Melhorias                                                             |\n| --------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |\n|           | Um layout de blog é representado visualmente com pelo menos 10 elementos de marcação exibidos | Um layout de blog é representado visualmente com cerca de 5 elementos de marcação exibidos | Um layout de blog é representado visualmente com, no máximo, 3 elementos de marcação exibidos |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original no seu idioma nativo deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se uma tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2119,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 348,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "a7ea6369516b6fd9b83253df2424c276",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\assignment.md",
    "source_type": "git_repo",
    "title": "Refatoração de CSS",
    "content": "Refatoração de CSS\nInstruções\nReestilize o terrário utilizando Flexbox ou CSS Grid e tire capturas de ecrã para mostrar que testou em vários navegadores. Pode ser necessário alterar o markup, por isso crie uma nova versão da aplicação com a arte já integrada para a sua refatoração. Não se preocupe em tornar os elementos arrastáveis; por agora, apenas refatore o HTML e o CSS.\nCritérios de Avaliação\n| Critério | Exemplar                                                         | Adequado                      | Necessita de Melhorias              |\n| -------- | ---------------------------------------------------------------- | ----------------------------- | ------------------------------------ |\n|          | Apresenta um terrário completamente reestilizado utilizando Flexbox ou CSS Grid | Reestiliza alguns dos elementos | Não reestiliza o terrário de forma alguma |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos pela precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes do uso desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1739,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 311,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0e2735481892533370548694d5102181",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Projeto Terrário Parte 1: Introdução ao HTML\nSketchnote por Tomomi Imura\nQuestionário Pré-Aula\nQuestionário pré-aula\nVeja o vídeo\nIntrodução\nHTML, ou HyperText Markup Language, é o 'esqueleto' da web Se o CSS 'veste' o seu HTML e o JavaScript dá vida a ele, o HTML é o corpo da sua aplicação web A sintaxe do HTML reflete essa ideia, pois inclui tags como \"head\", \"body\" e \"footer\" Nesta lição, vamos usar HTML para estruturar o 'esqueleto' da interface do nosso terrário virtual Ele terá um título e três colunas: uma coluna à direita e outra à esquerda onde as plantas arrastáveis estarão, e uma área central que será o terrário com aparência de vidro Ao final desta lição, você será capaz de ver as plantas nas colunas, mas a interface parecerá um pouco estranha; não se preocupe, na próxima seção você adicionará estilos CSS para melhorar a aparência da interface Tarefa\nNo seu computador, crie uma pasta chamada 'terrarium' e, dentro dela, um ficheiro chamado 'index html' Você pode fazer isso no Visual Studio Code após criar a pasta do terrário, abrindo uma nova janela do VS Code, clicando em 'abrir pasta' e navegando até a nova pasta Clique no pequeno botão 'ficheiro' no painel do Explorer e crie o novo ficheiro:\nOu\nUse estes comandos no seu git bash:\n* mkdir terrarium\n* cd terrarium\n* touch index html\n* code index html ou nano index html\nFicheiros index html indicam ao navegador que este é o ficheiro padrão numa pasta; URLs como https://anysite com/test podem ser construídos usando uma estrutura de pastas que inclui uma pasta chamada test com index html dentro dela; index html não precisa aparecer na URL O DocType e as tags html\nA primeira linha de um ficheiro HTML é o seu doctype",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12582,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 0,
    "total_chunks": 6
  },
  {
    "id": "cb916f0e9e8e33ff28724dee9257fdd8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "* cd terrarium * touch index html * code index html ou nano index html Ficheiros index html indicam ao navegador que este é o ficheiro padrão numa pasta; URLs como https://anysite com/test podem ser construídos usando uma estrutura de pastas que inclui uma pasta chamada test com index html dentro dela; index html não precisa aparecer na URL O DocType e as tags html A primeira linha de um ficheiro HTML é o seu doctypeÉ um pouco surpreendente que você precise ter esta linha no topo do ficheiro, mas ela informa aos navegadores mais antigos que a página deve ser renderizada em modo padrão, seguindo a especificação atual do HTML Dica: no VS Code, você pode passar o cursor sobre uma tag e obter informações sobre seu uso nos guias de referência do MDN A segunda linha deve ser a tag de abertura <html>, seguida agora pela sua tag de fechamento </html> Estas tags são os elementos raiz da sua interface Tarefa\nAdicione estas linhas no topo do seu ficheiro index html:\n```HTML\n```\n✅ Existem alguns modos diferentes que podem ser determinados ao definir o DocType com uma string de consulta: Modo Quirks e Modo Padrão Estes modos costumavam suportar navegadores muito antigos que não são normalmente usados hoje em dia (Netscape Navigator 4 e Internet Explorer 5) Você pode usar a declaração padrão do doctype O 'head' do documento\nA área 'head' do documento HTML inclui informações cruciais sobre a sua página web, também conhecidas como metadados No nosso caso, informamos ao servidor web, que irá renderizar esta página, estas quatro coisas:\no título da página\nmetadados da página, incluindo:\no 'conjunto de caracteres', que informa sobre a codificação de caracteres usada na página\ninformações do navegador, incluindo x-ua-compatible, que indica que o navegador IE=edge é suportado\ninformações sobre como o viewport deve se comportar ao ser carregado Definir o viewport com uma escala inicial de 1 controla o nível de zoom quando a página é carregada pela primeira vez",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12582,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 1,
    "total_chunks": 6
  },
  {
    "id": "a8c1545e24e24f5109dda83d754c4a2f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "que irá renderizar esta página, estas quatro coisas: o título da página metadados da página, incluindo: o 'conjunto de caracteres', que informa sobre a codificação de caracteres usada na página informações do navegador, incluindo x-ua-compatible, que indica que o navegador IE=edge é suportado informações sobre como o viewport deve se comportar ao ser carregado Definir o viewport com uma escala inicial de 1 controla o nível de zoom quando a página é carregada pela primeira vezTarefa\nAdicione um bloco 'head' ao seu documento entre as tags de abertura e fechamento <html> html\n<head>\n<title>Welcome to my Virtual Terrarium</title>\n<meta charset=\"utf-8\" />\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n</head>\n✅ O que aconteceria se você definisse uma tag meta de viewport assim: <meta name=\"viewport\" content=\"width=600\"> Leia mais sobre o viewport O body do documento\nTags HTML\nNo HTML, você adiciona tags ao seu ficheiro html para criar elementos de uma página web Cada tag geralmente tem uma tag de abertura e uma de fechamento, como esta: <p>olá</p> para indicar um parágrafo Crie o corpo da sua interface adicionando um conjunto de tags <body> dentro do par <html>; o seu código agora ficará assim:\nTarefa\n```html\nWelcome to my Virtual Terrarium\n```\nAgora, você pode começar a construir a sua página Normalmente, você usa tags <div> para criar os elementos separados numa página Vamos criar uma série de elementos <div> que irão conter imagens Imagens\nUma tag HTML que não precisa de uma tag de fechamento é a <img>, porque ela tem um elemento src que contém todas as informações necessárias para a página renderizar o item Crie uma pasta no seu aplicativo chamada images e, dentro dela, adicione todas as imagens na pasta de código fonte; (há 14 imagens de plantas)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12582,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 477,
    "chunk_index": 2,
    "total_chunks": 6
  },
  {
    "id": "680be33f23050c0c18adec3e96177d0e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "para criar os elementos separados numa página Vamos criar uma série de elementos <div> que irão conter imagens Imagens Uma tag HTML que não precisa de uma tag de fechamento é a <img>, porque ela tem um elemento src que contém todas as informações necessárias para a página renderizar o item Crie uma pasta no seu aplicativo chamada images e, dentro dela, adicione todas as imagens na pasta de código fonte; (há 14 imagens de plantas)Tarefa\nAdicione essas imagens de plantas em duas colunas entre as tags <body></body>:\n```html\n```\nNota: Spans vs Divs Divs são considerados elementos 'block', e Spans são 'inline' O que aconteceria se você transformasse esses divs em spans Com este código, as plantas agora aparecem na tela Parece muito ruim, porque ainda não foram estilizadas usando CSS, e faremos isso na próxima lição Cada imagem tem um texto alternativo que aparecerá mesmo que você não consiga ver ou renderizar uma imagem Este é um atributo importante para incluir para acessibilidade Aprenda mais sobre acessibilidade em lições futuras; por enquanto, lembre-se de que o atributo alt fornece informações alternativas para uma imagem caso um utilizador, por algum motivo, não consiga visualizá-la (devido a uma conexão lenta, um erro no atributo src ou se o utilizador usar um leitor de tela) ✅ Reparou que cada imagem tem a mesma tag alt Isso é uma boa prática Por quê Pode melhorar este código Marcação semântica\nEm geral, é preferível usar 'semântica' significativa ao escrever HTML O que isso significa Significa que você usa tags HTML para representar o tipo de dados ou interação para os quais foram projetadas Por exemplo, o texto principal de título numa página deve usar uma tag <h1>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12582,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 430,
    "chunk_index": 3,
    "total_chunks": 6
  },
  {
    "id": "dafb6e23ea189e4133d6b3b7efdc3a2f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "utilizador usar um leitor de tela) ✅ Reparou que cada imagem tem a mesma tag alt Isso é uma boa prática Por quê Pode melhorar este código Marcação semântica Em geral, é preferível usar 'semântica' significativa ao escrever HTML O que isso significa Significa que você usa tags HTML para representar o tipo de dados ou interação para os quais foram projetadas Por exemplo, o texto principal de título numa página deve usar uma tag <h1>Adicione a seguinte linha logo abaixo da sua tag de abertura <body>:\n```html\nMy Terrarium\n```\nUsar marcação semântica, como ter cabeçalhos como <h1> e listas não ordenadas renderizadas como <ul>, ajuda leitores de tela a navegar por uma página Em geral, botões devem ser escritos como <button> e listas como <li> Embora seja possível usar elementos <span> especialmente estilizados com manipuladores de clique para simular botões, é melhor para utilizadores com deficiência usar tecnologias para determinar onde está um botão numa página e interagir com ele, se o elemento aparecer como um botão Por esta razão, tente usar marcação semântica sempre que possível ✅ Veja um leitor de tela e como ele interage com uma página web Consegue perceber por que usar marcação não semântica pode frustrar o utilizador O terrário\nA última parte desta interface envolve criar código que será estilizado para criar um terrário Tarefa:\nAdicione este código acima da última tag </div>:\n```html\n```\n✅ Apesar de ter adicionado este código à tela, você não vê absolutamente nada ser renderizado Por quê 🚀Desafio\nExistem algumas tags 'antigas' no HTML que ainda são divertidas de usar, embora você não deva usar tags obsoletas como estas tags no seu código Ainda assim, consegue usar a antiga tag <marquee> para fazer o título h1 rolar horizontalmente",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12582,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 463,
    "chunk_index": 4,
    "total_chunks": 6
  },
  {
    "id": "01539a676a077a8f8f898ebe8842f47d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "será estilizado para criar um terrário Tarefa: Adicione este código acima da última tag </div>: ```html ``` ✅ Apesar de ter adicionado este código à tela, você não vê absolutamente nada ser renderizado Por quê 🚀Desafio Existem algumas tags 'antigas' no HTML que ainda são divertidas de usar, embora você não deva usar tags obsoletas como estas tags no seu código Ainda assim, consegue usar a antiga tag <marquee> para fazer o título h1 rolar horizontalmente(se o fizer, não se esqueça de removê-la depois)\nQuestionário Pós-Aula\nQuestionário pós-aula\nRevisão & Autoestudo\nHTML é o sistema de blocos de construção 'testado e comprovado' que ajudou a construir a web como a conhecemos hoje Aprenda um pouco sobre sua história estudando algumas tags antigas e novas Consegue descobrir por que algumas tags foram descontinuadas e outras adicionadas Que tags podem ser introduzidas no futuro Saiba mais sobre como criar sites para a web e dispositivos móveis em Microsoft Learn Tarefa\nPratique seu HTML: Crie um mockup de blog\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritária Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12582,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 395,
    "chunk_index": 5,
    "total_chunks": 6
  },
  {
    "id": "0bd4404f69509e55d4028bf0f736b041",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
    "source_type": "git_repo",
    "title": "Trabalhar um pouco mais com o DOM",
    "content": "Trabalhar um pouco mais com o DOM\nInstruções\nPesquise um pouco mais sobre o DOM 'adotando' um elemento do DOM. Visite a lista de interfaces do DOM no MDN e escolha uma. Encontre um exemplo de uso num site na web e escreva uma explicação sobre como ela é utilizada.\nRubrica\n| Critérios | Exemplar                                     | Adequado                                         | Precisa de Melhorias    |\n| --------- | -------------------------------------------- | ------------------------------------------------ | ----------------------- |\n|           | Texto explicativo é apresentado, com exemplo | Texto explicativo é apresentado, sem exemplo     | Nenhum texto explicativo é apresentado |\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator. Embora nos esforcemos para garantir a precisão, tenha em atenção que traduções automáticas podem conter erros ou imprecisões. O documento original na sua língua nativa deve ser considerado a fonte autoritária. Para informações críticas, recomenda-se a tradução profissional realizada por humanos. Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas decorrentes da utilização desta tradução.",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1655,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 275,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "75033b5c792b7bfffc0cc6028815d3bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "Projeto Terrário Parte 2: Introdução ao CSS\nSketchnote por Tomomi Imura\nQuestionário Pré-Aula\nQuestionário pré-aula\nIntrodução\nCSS, ou Cascading Style Sheets, resolve um problema importante no desenvolvimento web: como fazer com que o seu site tenha uma aparência agradável Estilizar as suas aplicações torna-as mais utilizáveis e visualmente atraentes; também pode usar CSS para criar um Design Responsivo (RWD) - permitindo que as suas aplicações fiquem bem em qualquer tamanho de ecrã CSS não é apenas sobre estética; a sua especificação inclui animações e transformações que podem permitir interações sofisticadas nas suas aplicações O Grupo de Trabalho de CSS ajuda a manter as especificações atuais de CSS; pode acompanhar o trabalho deles no site do World Wide Web Consortium Nota: CSS é uma linguagem que evolui, como tudo na web, e nem todos os navegadores suportam as partes mais recentes da especificação Verifique sempre as suas implementações consultando CanIUse com Nesta lição, vamos adicionar estilos ao nosso terrário online e aprender mais sobre vários conceitos de CSS: a cascata, herança, uso de seletores, posicionamento e utilização de CSS para construir layouts Durante o processo, vamos criar o layout do terrário e construir o próprio terrário Pré-requisito\nDeve ter o HTML do seu terrário construído e pronto para ser estilizado Veja o vídeo\nTarefa\nNa pasta do seu terrário, crie um novo ficheiro chamado style css Importe esse ficheiro na secção <head>:\nhtml\n<link rel=\"stylesheet\" href=\" /style css\" />\nA Cascata\nCascading Style Sheets incorporam a ideia de que os estilos 'cascateiam', de forma que a aplicação de um estilo é guiada pela sua prioridade Estilos definidos pelo autor de um site têm prioridade sobre os definidos por um navegador Estilos definidos 'inline' têm prioridade sobre os definidos num ficheiro de estilo externo",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 476,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "4453e129ff5cf5a5df0f667757315969",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "seu terrário, crie um novo ficheiro chamado style css Importe esse ficheiro na secção <head>: html <link rel=\"stylesheet\" href=\" /style css\" /> A Cascata Cascading Style Sheets incorporam a ideia de que os estilos 'cascateiam', de forma que a aplicação de um estilo é guiada pela sua prioridade Estilos definidos pelo autor de um site têm prioridade sobre os definidos por um navegador Estilos definidos 'inline' têm prioridade sobre os definidos num ficheiro de estilo externoTarefa\nAdicione o estilo inline \"color: red\" à sua tag <h1>:\n```HTML\nMy Terrarium\n```\nDepois, adicione o seguinte código ao seu ficheiro style css:\nCSS\nh1 {\ncolor: blue;\n}\n✅ Qual cor é exibida na sua aplicação web Porquê Consegue encontrar uma forma de sobrescrever estilos Quando gostaria de fazer isso, ou por que não Herança\nOs estilos são herdados de um estilo ancestral para um descendente, de forma que elementos aninhados herdam os estilos dos seus pais Tarefa\nDefina a fonte do corpo para uma fonte específica e verifique a fonte de um elemento aninhado:\nCSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nAbra o console do seu navegador na aba 'Elements' e observe a fonte do H1 Ele herda a fonte do corpo, conforme indicado no navegador:\n✅ Consegue fazer com que um estilo aninhado herde uma propriedade diferente Seletores CSS\nTags\nAté agora, o seu ficheiro style css tem apenas algumas tags estilizadas, e a aplicação parece bastante estranha:\n```CSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nh1 {\ncolor: #3a241d;\ntext-align: center;\n}\n```\nEste método de estilizar uma tag dá-lhe controlo sobre elementos únicos, mas precisa de controlar os estilos de muitas plantas no seu terrário Para isso, precisa de usar seletores CSS IDs\nAdicione algum estilo para organizar os contentores esquerdo e direito",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 492,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "7d252b414aab4f9cc579bff2be0ae20c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "Tags Até agora, o seu ficheiro style css tem apenas algumas tags estilizadas, e a aplicação parece bastante estranha: ```CSS body { font-family: helvetica, arial, sans-serif; } h1 { color: #3a241d; text-align: center; } ``` Este método de estilizar uma tag dá-lhe controlo sobre elementos únicos, mas precisa de controlar os estilos de muitas plantas no seu terrário Para isso, precisa de usar seletores CSS IDs Adicione algum estilo para organizar os contentores esquerdo e direitoComo há apenas um contentor esquerdo e um contentor direito, eles recebem IDs no markup Para estilizar, use #:\n```CSS\nleft-container {\nbackground-color: #eee;\nwidth: 15%;\nleft: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\nright-container {\nbackground-color: #eee;\nwidth: 15%;\nright: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\n```\nAqui, posicionou esses contentores com posicionamento absoluto nas extremidades esquerda e direita do ecrã, e usou percentagens para a largura deles, permitindo que se ajustem a ecrãs pequenos de dispositivos móveis ✅ Este código é bastante repetitivo, portanto não segue o princípio \"DRY\" (Don't Repeat Yourself); consegue encontrar uma forma melhor de estilizar esses IDs, talvez com um ID e uma classe Precisaria alterar o markup e refatorar o CSS:\n```html\n```\nClasses\nNo exemplo acima, estilizou dois elementos únicos no ecrã Se quiser que os estilos se apliquem a muitos elementos no ecrã, pode usar classes CSS Faça isso para organizar as plantas nos contentores esquerdo e direito Note que cada planta no markup HTML tem uma combinação de IDs e classes Os IDs aqui são usados pelo JavaScript que será adicionado mais tarde para manipular a colocação das plantas no terrário As classes, no entanto, dão a todas as plantas um estilo específico",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "8d2043ff310bd55a565cd7ef090787f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "únicos no ecrã Se quiser que os estilos se apliquem a muitos elementos no ecrã, pode usar classes CSS Faça isso para organizar as plantas nos contentores esquerdo e direito Note que cada planta no markup HTML tem uma combinação de IDs e classes Os IDs aqui são usados pelo JavaScript que será adicionado mais tarde para manipular a colocação das plantas no terrário As classes, no entanto, dão a todas as plantas um estilo específico```html\n```\nAdicione o seguinte ao seu ficheiro style css:\n```CSS plant-holder {\nposition: relative;\nheight: 13%;\nleft: -10px;\n} plant {\nposition: absolute;\nmax-width: 150%;\nmax-height: 150%;\nz-index: 2;\n}\n```\nNotável neste trecho é a mistura de posicionamento relativo e absoluto, que será abordada na próxima secção Observe como as alturas são tratadas por percentagens:\nDefiniu a altura do suporte da planta para 13%, um bom número para garantir que todas as plantas sejam exibidas em cada contentor vertical sem necessidade de rolagem Moveu o suporte da planta para a esquerda para permitir que as plantas fiquem mais centralizadas dentro do contentor As imagens têm uma grande quantidade de fundo transparente para torná-las mais arrastáveis, então precisam ser empurradas para a esquerda para se ajustarem melhor ao ecrã Depois, a própria planta recebeu uma largura máxima de 150% Isso permite que ela seja redimensionada à medida que o navegador é redimensionado Experimente redimensionar o navegador; as plantas permanecem nos seus contentores, mas ajustam-se para caber Também é notável o uso de z-index, que controla a altitude relativa de um elemento (para que as plantas fiquem acima do contentor e pareçam estar dentro do terrário) ✅ Por que precisa de um seletor CSS para o suporte da planta e outro para a planta",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 459,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "46f4020648c380399cf242fbd1016369",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "de 150% Isso permite que ela seja redimensionada à medida que o navegador é redimensionado Experimente redimensionar o navegador; as plantas permanecem nos seus contentores, mas ajustam-se para caber Também é notável o uso de z-index, que controla a altitude relativa de um elemento (para que as plantas fiquem acima do contentor e pareçam estar dentro do terrário) ✅ Por que precisa de um seletor CSS para o suporte da planta e outro para a plantaPosicionamento CSS\nMisturar propriedades de posicionamento (existem posições estáticas, relativas, fixas, absolutas e adesivas) pode ser um pouco complicado, mas quando feito corretamente dá-lhe um bom controlo sobre os elementos nas suas páginas Elementos posicionados de forma absoluta são posicionados em relação aos seus ancestrais posicionados mais próximos, e se não houver nenhum, são posicionados de acordo com o corpo do documento Elementos posicionados de forma relativa são posicionados com base nas direções do CSS para ajustar a sua colocação em relação à sua posição inicial No nosso exemplo, o plant-holder é um elemento posicionado de forma relativa que está posicionado dentro de um contentor posicionado de forma absoluta O comportamento resultante é que os contentores da barra lateral são fixados à esquerda e à direita, e o plant-holder é aninhado, ajustando-se dentro das barras laterais, dando espaço para as plantas serem colocadas numa fila vertical A própria plant também tem posicionamento absoluto, necessário para torná-la arrastável, como descobrirá na próxima lição ✅ Experimente alternar os tipos de posicionamento dos contentores laterais e do plant-holder O que acontece Layouts CSS\nAgora vai usar o que aprendeu para construir o próprio terrário, tudo usando CSS Primeiro, estilize os filhos da div terrarium como um retângulo arredondado usando CSS:\n```CSS jar-walls {\nheight: 80%;\nwidth: 60%;\nbackground: #d1e1df;\nborder-radius: 1rem;\nposition: absolute;\nbottom: 0 5%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "898186802633d2128f026da570e65289",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "posicionamento absoluto, necessário para torná-la arrastável, como descobrirá na próxima lição ✅ Experimente alternar os tipos de posicionamento dos contentores laterais e do plant-holder O que acontece Layouts CSS Agora vai usar o que aprendeu para construir o próprio terrário, tudo usando CSS Primeiro, estilize os filhos da div terrarium como um retângulo arredondado usando CSS: ```CSS jar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 0 5%; left: 20%; opacity: 05;\nz-index: 1;\n} jar-top {\nwidth: 50%;\nheight: 5%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 80 5%;\nleft: 25%;\nopacity: 0 7;\nz-index: 1;\n} jar-bottom {\nwidth: 50%;\nheight: 1%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 0%;\nleft: 25%;\nopacity: 0 7;\n} dirt {\nwidth: 60%;\nheight: 5%;\nbackground: #3a241d;\nposition: absolute;\nborder-radius: 0 0 1rem 1rem;\nbottom: 1%;\nleft: 20%;\nopacity: 0 7;\nz-index: -1;\n}\n```\nNote o uso de percentagens aqui Se redimensionar o navegador, pode ver como o jarro também se ajusta Também observe as percentagens de largura e altura dos elementos do jarro e como cada elemento é posicionado de forma absoluta no centro, fixado na parte inferior da janela de visualização Também estamos a usar rem para o border-radius, uma unidade de comprimento relativa à fonte Leia mais sobre este tipo de medida relativa na especificação CSS ✅ Experimente alterar as cores e opacidade do jarro em comparação com as da terra O que acontece Porquê 🚀Desafio\nAdicione um brilho de 'bolha' na área inferior esquerda do jarro para que pareça mais com vidro Vai estilizar jar-glossy-long e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "614528df1f88827b15f7ef2b8b121a35",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "Projeto Terrário Parte 2: Introdução ao CSS",
    "content": "centro, fixado na parte inferior da janela de visualização Também estamos a usar rem para o border-radius, uma unidade de comprimento relativa à fonte Leia mais sobre este tipo de medida relativa na especificação CSS ✅ Experimente alterar as cores e opacidade do jarro em comparação com as da terra O que acontece Porquê 🚀Desafio Adicione um brilho de 'bolha' na área inferior esquerda do jarro para que pareça mais com vidro Vai estilizar jar-glossy-long ejar-glossy-short para parecerem um brilho refletido Eis como ficaria:\nPara completar o questionário pós-aula, passe por este módulo Learn: Estilize a sua aplicação HTML com CSS\nQuestionário Pós-Aula\nQuestionário pós-aula\nRevisão & Autoestudo\nCSS parece enganosamente simples, mas há muitos desafios ao tentar estilizar uma aplicação perfeitamente para todos os navegadores e tamanhos de ecrã CSS-Grid e Flexbox são ferramentas desenvolvidas para tornar o trabalho um pouco mais estruturado e confiável Aprenda sobre estas ferramentas jogando Flexbox Froggy e Grid Garden Tarefa\nRefatoração de CSS\nAviso Legal:\nEste documento foi traduzido utilizando o serviço de tradução por IA Co-op Translator Embora nos esforcemos para garantir a precisão, esteja ciente de que traduções automáticas podem conter erros ou imprecisões O documento original no seu idioma nativo deve ser considerado a fonte autoritativa Para informações críticas, recomenda-se uma tradução profissional realizada por humanos Não nos responsabilizamos por quaisquer mal-entendidos ou interpretações incorretas resultantes do uso desta tradução",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\pt\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 417,
    "chunk_index": 6,
    "total_chunks": 7
  }
]