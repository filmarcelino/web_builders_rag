[
  {
    "id": "4606e83b17c5c43dc18546144f3c8557",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templatecontentcloneNode(true); const app = documentgetElementById('app'); appinnerHTML = ''; appappendChild(view); } ``` ここで宣言したルートを対応するテンプレートにマッピングしました。ブラウザでURLを手動で変更して正しく動作するか試してみてください。 ✅ URLに未知のパスを入力するとどうなりますか？これを解決する方法は何でしょうか？ ナビゲーションの追加 次に、URLを手動で変更することなくページ間を移動できる機能をアプリに追加します。これには以下の2つのことが含まれます： 現在のURLを更新する 新しいURLに基づいて表示されるテンプレートを更新する 2番目の部分についてはupdateRoute関数で既に対応済みなので、現在のURLを更新する方法を考える必要があります。 JavaScript、特にhistorypushStateを使用して、HTMLをリロードせずにURLを更新し、ブラウザ履歴に新しいエントリを作成します。 注：HTMLアンカー要素<a href>は単独で異なるURLへのハイパーリンクを作成できますが、デフォルトではブラウザがHTMLをリロードしてしまいます。カスタムJavaScriptでルーティングを処理する際には、クリックイベントでpreventDefault()関数を使用してこの動作を防ぐ必要があります。 タスク アプリ内でナビゲーションに使用できる新しい関数を作成します： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } このメソッドは、与えられたパスに基づいて現在のURLを最初に更新し、その後テンプレートを更新します。windowlocationoriginプロパティはURLのルートを返し、与えられたパスから完全なURLを再構築することができます。 この関数ができたので、パスが定義されたルートに一致しない場合の問題に対処します。updateRoute関数を変更し、マッチが見つからない場合に既存のルートの1つにフォールバックするようにします。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` ルートが見つからない場合、loginページにリダイレクトするようになりました。 次に、リンクがクリックされたときにURLを取得し、ブラウザのデフォルトのリンク動作を防ぐ関数を作成します： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } ナビゲーションシステムを完成させるために、HTML内のログインリンクとログアウトリンクにバインディングを追加します。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上記のeventオブジェクトは、clickイベントをキャプチャし、それをonLinkClick関数に渡します。 onclick属性を使用してclickイベントをJavaScriptコードにバインドします。ここではnavigate()関数の呼び出しです。 これらのリンクをクリックしてみてください。アプリ内の異なる画面間を移動できるようになっているはずです。 ✅ historypushStateメソッドはHTML5標準の一部であり、すべての最新ブラウザで実装されています。古いブラウザ向けにウェブアプリを構築する場合、このAPIの代わりに使用できるトリックがあります：パスの前にハッシュ（#）を使用することで、通常のアンカーナビゲーションで動作し、ページをリロードしないルーティングを実装できます。このハッシュはページ内の内部リンクを作成する目的で使用されていました。 ブラウザの戻るボタンと進むボタンの処理 historypushStateを使用すると、ブラウザのナビゲーション履歴に新しいエントリが作成されます。ブラウザの戻るボタンを長押しすると、以下のようなものが表示されるはずです：\n戻るボタンを数回クリックしてみると、現在のURLが変更され履歴が更新されますが、同じテンプレートが表示され続けます。\nこれは、履歴が変更されるたびにupdateRoute()を呼び出す必要があることをアプリケーションが認識していないためです。history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18182,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1386,
    "chunk_index": 52,
    "total_chunks": 56
  },
  {
    "id": "514fb6d73dba80b1bdff07a110fb372a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "app = documentgetElementById('app'); appinnerHTML = ''; appappendChild(view); } ``` ここで宣言したルートを対応するテンプレートにマッピングしました。ブラウザでURLを手動で変更して正しく動作するか試してみてください。 ✅ URLに未知のパスを入力するとどうなりますか？これを解決する方法は何でしょうか？ ナビゲーションの追加 次に、URLを手動で変更することなくページ間を移動できる機能をアプリに追加します。これには以下の2つのことが含まれます： 現在のURLを更新する 新しいURLに基づいて表示されるテンプレートを更新する 2番目の部分についてはupdateRoute関数で既に対応済みなので、現在のURLを更新する方法を考える必要があります。 JavaScript、特にhistorypushStateを使用して、HTMLをリロードせずにURLを更新し、ブラウザ履歴に新しいエントリを作成します。 注：HTMLアンカー要素<a href>は単独で異なるURLへのハイパーリンクを作成できますが、デフォルトではブラウザがHTMLをリロードしてしまいます。カスタムJavaScriptでルーティングを処理する際には、クリックイベントでpreventDefault()関数を使用してこの動作を防ぐ必要があります。 タスク アプリ内でナビゲーションに使用できる新しい関数を作成します： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } このメソッドは、与えられたパスに基づいて現在のURLを最初に更新し、その後テンプレートを更新します。windowlocationoriginプロパティはURLのルートを返し、与えられたパスから完全なURLを再構築することができます。 この関数ができたので、パスが定義されたルートに一致しない場合の問題に対処します。updateRoute関数を変更し、マッチが見つからない場合に既存のルートの1つにフォールバックするようにします。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` ルートが見つからない場合、loginページにリダイレクトするようになりました。 次に、リンクがクリックされたときにURLを取得し、ブラウザのデフォルトのリンク動作を防ぐ関数を作成します： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } ナビゲーションシステムを完成させるために、HTML内のログインリンクとログアウトリンクにバインディングを追加します。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上記のeventオブジェクトは、clickイベントをキャプチャし、それをonLinkClick関数に渡します。 onclick属性を使用してclickイベントをJavaScriptコードにバインドします。ここではnavigate()関数の呼び出しです。 これらのリンクをクリックしてみてください。アプリ内の異なる画面間を移動できるようになっているはずです。 ✅ historypushStateメソッドはHTML5標準の一部であり、すべての最新ブラウザで実装されています。古いブラウザ向けにウェブアプリを構築する場合、このAPIの代わりに使用できるトリックがあります：パスの前にハッシュ（#）を使用することで、通常のアンカーナビゲーションで動作し、ページをリロードしないルーティングを実装できます。このハッシュはページ内の内部リンクを作成する目的で使用されていました。 ブラウザの戻るボタンと進むボタンの処理 historypushStateを使用すると、ブラウザのナビゲーション履歴に新しいエントリが作成されます。ブラウザの戻るボタンを長押しすると、以下のようなものが表示されるはずです： 戻るボタンを数回クリックしてみると、現在のURLが変更され履歴が更新されますが、同じテンプレートが表示され続けます。 これは、履歴が変更されるたびにupdateRoute()を呼び出す必要があることをアプリケーションが認識していないためです。historypushStateのドキュメントを見ると、状態が変更された場合（つまり異なるURLに移動した場合）、popstateイベントがトリガーされることがわかります。このイベントを使用して問題を修正します。\nタスク\nブラウザ履歴が変更されたときに表示されるテンプレートが更新されるようにするため、updateRoute()を呼び出す新しい関数を追加します。これをapp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18182,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1524,
    "chunk_index": 53,
    "total_chunks": 56
  },
  {
    "id": "9d0043c41c2a11ac5f448475bd2ab5be",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "documentgetElementById('app'); appinnerHTML = ''; appappendChild(view); } ``` ここで宣言したルートを対応するテンプレートにマッピングしました。ブラウザでURLを手動で変更して正しく動作するか試してみてください。 ✅ URLに未知のパスを入力するとどうなりますか？これを解決する方法は何でしょうか？ ナビゲーションの追加 次に、URLを手動で変更することなくページ間を移動できる機能をアプリに追加します。これには以下の2つのことが含まれます： 現在のURLを更新する 新しいURLに基づいて表示されるテンプレートを更新する 2番目の部分についてはupdateRoute関数で既に対応済みなので、現在のURLを更新する方法を考える必要があります。 JavaScript、特にhistorypushStateを使用して、HTMLをリロードせずにURLを更新し、ブラウザ履歴に新しいエントリを作成します。 注：HTMLアンカー要素<a href>は単独で異なるURLへのハイパーリンクを作成できますが、デフォルトではブラウザがHTMLをリロードしてしまいます。カスタムJavaScriptでルーティングを処理する際には、クリックイベントでpreventDefault()関数を使用してこの動作を防ぐ必要があります。 タスク アプリ内でナビゲーションに使用できる新しい関数を作成します： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } このメソッドは、与えられたパスに基づいて現在のURLを最初に更新し、その後テンプレートを更新します。windowlocationoriginプロパティはURLのルートを返し、与えられたパスから完全なURLを再構築することができます。 この関数ができたので、パスが定義されたルートに一致しない場合の問題に対処します。updateRoute関数を変更し、マッチが見つからない場合に既存のルートの1つにフォールバックするようにします。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` ルートが見つからない場合、loginページにリダイレクトするようになりました。 次に、リンクがクリックされたときにURLを取得し、ブラウザのデフォルトのリンク動作を防ぐ関数を作成します： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } ナビゲーションシステムを完成させるために、HTML内のログインリンクとログアウトリンクにバインディングを追加します。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上記のeventオブジェクトは、clickイベントをキャプチャし、それをonLinkClick関数に渡します。 onclick属性を使用してclickイベントをJavaScriptコードにバインドします。ここではnavigate()関数の呼び出しです。 これらのリンクをクリックしてみてください。アプリ内の異なる画面間を移動できるようになっているはずです。 ✅ historypushStateメソッドはHTML5標準の一部であり、すべての最新ブラウザで実装されています。古いブラウザ向けにウェブアプリを構築する場合、このAPIの代わりに使用できるトリックがあります：パスの前にハッシュ（#）を使用することで、通常のアンカーナビゲーションで動作し、ページをリロードしないルーティングを実装できます。このハッシュはページ内の内部リンクを作成する目的で使用されていました。 ブラウザの戻るボタンと進むボタンの処理 historypushStateを使用すると、ブラウザのナビゲーション履歴に新しいエントリが作成されます。ブラウザの戻るボタンを長押しすると、以下のようなものが表示されるはずです： 戻るボタンを数回クリックしてみると、現在のURLが変更され履歴が更新されますが、同じテンプレートが表示され続けます。 これは、履歴が変更されるたびにupdateRoute()を呼び出す必要があることをアプリケーションが認識していないためです。historypushStateのドキュメントを見ると、状態が変更された場合（つまり異なるURLに移動した場合）、popstateイベントがトリガーされることがわかります。このイベントを使用して問題を修正します。 タスク ブラウザ履歴が変更されたときに表示されるテンプレートが更新されるようにするため、updateRoute()を呼び出す新しい関数を追加します。これをappjsファイルの最後に追加します：\njs\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18182,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1540,
    "chunk_index": 54,
    "total_chunks": 56
  },
  {
    "id": "72c053cbc97ad815273c1617b22929f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "= ''; appappendChild(view); } ``` ここで宣言したルートを対応するテンプレートにマッピングしました。ブラウザでURLを手動で変更して正しく動作するか試してみてください。 ✅ URLに未知のパスを入力するとどうなりますか？これを解決する方法は何でしょうか？ ナビゲーションの追加 次に、URLを手動で変更することなくページ間を移動できる機能をアプリに追加します。これには以下の2つのことが含まれます： 現在のURLを更新する 新しいURLに基づいて表示されるテンプレートを更新する 2番目の部分についてはupdateRoute関数で既に対応済みなので、現在のURLを更新する方法を考える必要があります。 JavaScript、特にhistorypushStateを使用して、HTMLをリロードせずにURLを更新し、ブラウザ履歴に新しいエントリを作成します。 注：HTMLアンカー要素<a href>は単独で異なるURLへのハイパーリンクを作成できますが、デフォルトではブラウザがHTMLをリロードしてしまいます。カスタムJavaScriptでルーティングを処理する際には、クリックイベントでpreventDefault()関数を使用してこの動作を防ぐ必要があります。 タスク アプリ内でナビゲーションに使用できる新しい関数を作成します： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } このメソッドは、与えられたパスに基づいて現在のURLを最初に更新し、その後テンプレートを更新します。windowlocationoriginプロパティはURLのルートを返し、与えられたパスから完全なURLを再構築することができます。 この関数ができたので、パスが定義されたルートに一致しない場合の問題に対処します。updateRoute関数を変更し、マッチが見つからない場合に既存のルートの1つにフォールバックするようにします。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` ルートが見つからない場合、loginページにリダイレクトするようになりました。 次に、リンクがクリックされたときにURLを取得し、ブラウザのデフォルトのリンク動作を防ぐ関数を作成します： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } ナビゲーションシステムを完成させるために、HTML内のログインリンクとログアウトリンクにバインディングを追加します。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上記のeventオブジェクトは、clickイベントをキャプチャし、それをonLinkClick関数に渡します。 onclick属性を使用してclickイベントをJavaScriptコードにバインドします。ここではnavigate()関数の呼び出しです。 これらのリンクをクリックしてみてください。アプリ内の異なる画面間を移動できるようになっているはずです。 ✅ historypushStateメソッドはHTML5標準の一部であり、すべての最新ブラウザで実装されています。古いブラウザ向けにウェブアプリを構築する場合、このAPIの代わりに使用できるトリックがあります：パスの前にハッシュ（#）を使用することで、通常のアンカーナビゲーションで動作し、ページをリロードしないルーティングを実装できます。このハッシュはページ内の内部リンクを作成する目的で使用されていました。 ブラウザの戻るボタンと進むボタンの処理 historypushStateを使用すると、ブラウザのナビゲーション履歴に新しいエントリが作成されます。ブラウザの戻るボタンを長押しすると、以下のようなものが表示されるはずです： 戻るボタンを数回クリックしてみると、現在のURLが変更され履歴が更新されますが、同じテンプレートが表示され続けます。 これは、履歴が変更されるたびにupdateRoute()を呼び出す必要があることをアプリケーションが認識していないためです。historypushStateのドキュメントを見ると、状態が変更された場合（つまり異なるURLに移動した場合）、popstateイベントがトリガーされることがわかります。このイベントを使用して問題を修正します。 タスク ブラウザ履歴が変更されたときに表示されるテンプレートが更新されるようにするため、updateRoute()を呼び出す新しい関数を追加します。これをappjsファイルの最後に追加します： js windowonpopstate = () => updateRoute();\nupdateRoute();\n注：ここでは簡潔さのためにアロー関数を使用してpopstateイベントハンドラーを宣言しましたが、通常の関数でも同じように動作します。\nアロー関数についての復習動画はこちら：\n🎥 上の画像をクリックするとアロー関数についての動画が再生されます。\nブラウザの戻るボタンと進むボタンを使用してみてください。今回は表示されるルートが正しく更新されることを確認してください。\n🚀 チャレンジ\nこのアプリのクレジットを表示する3番目のページ用の新しいテンプレートとルートを追加してください。\n講義後クイズ\n講義後クイズ\n復習と自己学習\nウェブ開発の中でもルーティングは意外と難しい部分の1つです。特にウェブがページリフレッシュの動作からシングルページアプリケーションのリフレッシュに移行するにつれてです。Azure Static Web Appサービスがルーティングをどのように処理しているかについて少し読んでみてください。このドキュメントで説明されているいくつかの決定がなぜ必要なのか説明できますか？\n課題\nルーティングを改善する\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書を正式な情報源としてお考えください。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18182,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2151,
    "chunk_index": 55,
    "total_chunks": 56
  },
  {
    "id": "3f2c726e9d21b3cefbfa5c332289e0d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\assignment.md",
    "source_type": "git_repo",
    "title": "「取引を追加」ダイアログの実装",
    "content": "「取引を追加」ダイアログの実装\n手順\n私たちの銀行アプリにはまだ重要な機能が欠けています。それは、新しい取引を入力する機能です。\nこれまでの4つのレッスンで学んだことを活用して、「取引を追加」ダイアログを実装してください。\nダッシュボードページに「取引を追加」ボタンを追加する\n新しいHTMLテンプレートを使用して新しいページを作成するか、JavaScriptを使用してダッシュボードページを離れることなくダイアログHTMLを表示/非表示にする（hidden属性やCSSクラスを使用できます）\nダイアログのキーボードとスクリーンリーダーのアクセシビリティを確実に対応する\n入力データを受け取るためのHTMLフォームを実装する\nフォームデータからJSONデータを作成し、APIに送信する\n新しいデータでダッシュボードページを更新する\nサーバーAPI仕様を確認して、どのAPIを呼び出す必要があるか、期待されるJSON形式が何かを確認してください。\n以下は課題を完了した後の例です：\n評価基準\n| 基準     | 優秀                                                                                              | 適切                                                                                                                   | 改善が必要                                   |\n| -------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- | --------------------------------------------|\n|          | 取引の追加がレッスンで見たすべてのベストプラクティスに従って完全に実装されている。                 | 取引の追加が実装されているが、レッスンで見たベストプラクティスに従っていない、または部分的にしか機能していない。         | 取引の追加が全く機能していない。             |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3418,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 754,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "43ba8228c2eb30176668feb587e56ecb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 430,
    "chunk_index": 0,
    "total_chunks": 30
  },
  {
    "id": "0ad091a430e70ad1d199737dc3ea7091",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 538,
    "chunk_index": 1,
    "total_chunks": 30
  },
  {
    "id": "e577315364a2be5c2e8407c2ae7ef7e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 538,
    "chunk_index": 2,
    "total_chunks": 30
  },
  {
    "id": "c7b1fc85111c93f1b4490f384cd59c83",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n状態管理を再考する\n前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？\n現在のコードには3つの問題があります：\n状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。\n状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。\n状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。\nこれらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。\nここで本当に解決しようとしている問題は何でしょうか？\n状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです：\nアプリ内のデータフローを理解しやすくするにはどうすればよいか？\n状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？\nこれらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります：\nデータが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。\n✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。\nタスク\nまずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます：\njs\nlet account = null;\n以下に置き換えます：\njs\nlet state = {\naccount: null\n};\nこのアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。\nまた、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1647,
    "chunk_index": 3,
    "total_chunks": 30
  },
  {
    "id": "bc1a24ff187f10aac9275011a56672b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n状態管理を再考する\n前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？\n現在のコードには3つの問題があります：\n状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。\n状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。\n状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。\nこれらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。\nここで本当に解決しようとしている問題は何でしょうか？\n状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです：\nアプリ内のデータフローを理解しやすくするにはどうすればよいか？\n状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？\nこれらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります：\nデータが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。\n✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。\nタスク\nまずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます：\njs\nlet account = null;\n以下に置き換えます：\njs\nlet state = {\naccount: null\n};\nこのアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。\nまた、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstate",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1649,
    "chunk_index": 4,
    "total_chunks": 30
  },
  {
    "id": "bcaf698fed8ebbfd80cf497e3aac4d03",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n状態管理を再考する\n前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？\n現在のコードには3つの問題があります：\n状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。\n状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。\n状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。\nこれらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。\nここで本当に解決しようとしている問題は何でしょうか？\n状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです：\nアプリ内のデータフローを理解しやすくするにはどうすればよいか？\n状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？\nこれらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります：\nデータが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。\n✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。\nタスク\nまずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます：\njs\nlet account = null;\n以下に置き換えます：\njs\nlet state = {\naccount: null\n};\nこのアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。\nまた、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1651,
    "chunk_index": 5,
    "total_chunks": 30
  },
  {
    "id": "c136634b78a5bd706ff6b0426e8adae6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n状態管理を再考する\n前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？\n現在のコードには3つの問題があります：\n状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。\n状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。\n状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。\nこれらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。\nここで本当に解決しようとしている問題は何でしょうか？\n状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです：\nアプリ内のデータフローを理解しやすくするにはどうすればよいか？\n状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？\nこれらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります：\nデータが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。\n✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。\nタスク\nまずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます：\njs\nlet account = null;\n以下に置き換えます：\njs\nlet state = {\naccount: null\n};\nこのアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。\nまた、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。\nupdateDashboard()関数の冒頭に以下の行を追加します：\njs\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1685,
    "chunk_index": 6,
    "total_chunks": 30
  },
  {
    "id": "2d187e467b9b9e10d5929e2926630520",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n状態管理を再考する\n前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？\n現在のコードには3つの問題があります：\n状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。\n状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。\n状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。\nこれらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。\nここで本当に解決しようとしている問題は何でしょうか？\n状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです：\nアプリ内のデータフローを理解しやすくするにはどうすればよいか？\n状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？\nこれらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります：\nデータが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。\n✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。\nタスク\nまずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます：\njs\nlet account = null;\n以下に置き換えます：\njs\nlet state = {\naccount: null\n};\nこのアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。\nまた、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。\nupdateDashboard()関数の冒頭に以下の行を追加します：\njs\nconst account = stateaccount;\nこのリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。\nデータ変更の追跡\nstateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。\nstateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。\nJavaScriptでは、Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2096,
    "chunk_index": 7,
    "total_chunks": 30
  },
  {
    "id": "ee6eec0de1e4963124e69765476956da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "銀行アプリを作る Part 4: 状態管理の概念\n講義前クイズ\n講義前クイズ\nはじめに\nウェブアプリケーションが成長するにつれて、すべてのデータフローを追跡するのが難しくなります。どのコードがデータを取得し、どのページがそれを使用し、どこでいつ更新が必要なのか コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。\nこの最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。\n前提条件\nこのレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。\nサーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n状態管理を再考する\n前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？\n現在のコードには3つの問題があります：\n状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。\n状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。\n状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。\nこれらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。\nここで本当に解決しようとしている問題は何でしょうか？\n状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです：\nアプリ内のデータフローを理解しやすくするにはどうすればよいか？\n状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？\nこれらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります：\nデータが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。\n✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。\nタスク\nまずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます：\njs\nlet account = null;\n以下に置き換えます：\njs\nlet state = {\naccount: null\n};\nこのアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。\nまた、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。\nupdateDashboard()関数の冒頭に以下の行を追加します：\njs\nconst account = stateaccount;\nこのリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。\nデータ変更の追跡\nstateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。\nstateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。\nJavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。\n✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。\nタスク\n新しいupdateState()関数を作成します：\njs\nfunction updateState(property, newData) {\nstate = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2233,
    "chunk_index": 8,
    "total_chunks": 30
  },
  {
    "id": "3c5ab2549602927833336cc9219dca64",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。 この最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。 前提条件 このレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。 サーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 状態管理を再考する 前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？ 現在のコードには3つの問題があります： 状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。 状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。 状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。 これらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。 ここで本当に解決しようとしている問題は何でしょうか？ 状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです： アプリ内のデータフローを理解しやすくするにはどうすればよいか？ 状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？ これらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります： データが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。 ✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。 タスク まずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます： js let account = null; 以下に置き換えます： js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2106,
    "chunk_index": 9,
    "total_chunks": 30
  },
  {
    "id": "ab7b33727ebed745733542e292b05460",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "コードが散らかり、保守が難しくなるのは簡単です。特に、アプリの異なるページ間でデータを共有する必要がある場合（例えば、ユーザーデータ）にこの問題は顕著です。状態管理の概念は、あらゆる種類のプログラムにおいて常に存在していましたが、ウェブアプリがますます複雑化する中で、開発中に考慮すべき重要なポイントとなっています。 この最終パートでは、これまでに作成したアプリを見直し、状態管理を再考します。これにより、ブラウザのリフレッシュをサポートし、ユーザーセッション間でデータを永続化できるようにします。 前提条件 このレッスンのために、ウェブアプリのデータ取得パートを完了している必要があります。また、Nodejsをインストールし、サーバーAPIをローカルで実行してアカウントデータを管理できるようにする必要があります。 サーバーが正しく動作しているかどうかは、ターミナルで以下のコマンドを実行して確認できます。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 状態管理を再考する 前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？ 現在のコードには3つの問題があります： 状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。 状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。 状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。 これらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。 ここで本当に解決しようとしている問題は何でしょうか？ 状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです： アプリ内のデータフローを理解しやすくするにはどうすればよいか？ 状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？ これらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります： データが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。 ✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。 タスク まずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます： js let account = null; 以下に置き換えます： js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state,\n[property]: newData\n});\n}\nこの関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2218,
    "chunk_index": 10,
    "total_chunks": 30
  },
  {
    "id": "4937125c76529e92c579c7d344365513",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 状態管理を再考する 前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？ 現在のコードには3つの問題があります： 状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。 状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。 状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。 これらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。 ここで本当に解決しようとしている問題は何でしょうか？ 状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです： アプリ内のデータフローを理解しやすくするにはどうすればよいか？ 状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？ これらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります： データが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。 ✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。 タスク まずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます： js let account = null; 以下に置き換えます： js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。\nまた、初期状態が凍結されていることを確認するために、stateの初期化を更新します：\njs\nlet state = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1971,
    "chunk_index": 11,
    "total_chunks": 30
  },
  {
    "id": "11d26b112a21f2e1a8f82c1dd62a2662",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "\"Bank API v100\" as a result ``` 状態管理を再考する 前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？ 現在のコードには3つの問題があります： 状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。 状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。 状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。 これらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。 ここで本当に解決しようとしている問題は何でしょうか？ 状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです： アプリ内のデータフローを理解しやすくするにはどうすればよいか？ 状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？ これらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります： データが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。 ✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。 タスク まずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます： js let account = null; 以下に置き換えます： js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({\naccount: null\n});\nその後、register関数を更新し、state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1976,
    "chunk_index": 12,
    "total_chunks": 30
  },
  {
    "id": "ef5e5ae644752feee70e0c7e0473ee8c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "a result ``` 状態管理を再考する 前回のレッスンでは、現在ログインしているユーザーの銀行データを含むグローバル変数accountを使用して、アプリ内での基本的な状態の概念を紹介しました。しかし、現在の実装にはいくつかの欠点があります。ダッシュボードページでページをリフレッシュしてみてください。何が起こりますか？ 現在のコードには3つの問題があります： 状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。 状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。 状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。 これらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。 ここで本当に解決しようとしている問題は何でしょうか？ 状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです： アプリ内のデータフローを理解しやすくするにはどうすればよいか？ 状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？ これらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります： データが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。 ✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。 タスク まずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます： js let account = null; 以下に置き換えます： js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します：\njs\nupdateState('account', result);\n同様に、login関数ではstate",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2003,
    "chunk_index": 13,
    "total_chunks": 30
  },
  {
    "id": "1856f4e88a4421d2e0b75f6f38415377",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "状態が永続化されていないため、ブラウザをリフレッシュするとログインページに戻ってしまいます。 状態を変更する関数が複数あり、アプリが成長するにつれて変更を追跡するのが難しくなり、更新を忘れることが容易になります。 状態がクリアされないため、ログアウトをクリックしても、ログインページにいる間もアカウントデータが残っています。 これらの問題に1つずつ対処するようにコードを更新することもできますが、それではコードの重複が増え、アプリがより複雑で保守が難しくなります。あるいは、数分間立ち止まって戦略を再考することもできます。 ここで本当に解決しようとしている問題は何でしょうか？ 状態管理とは、以下の2つの特定の問題を解決するための良いアプローチを見つけることです： アプリ内のデータフローを理解しやすくするにはどうすればよいか？ 状態データを常にユーザーインターフェースと同期させるにはどうすればよいか（その逆も）？ これらの問題に対処すれば、他の問題もすでに解決されているか、解決が容易になっている可能性があります。これらの問題を解決するためのアプローチは多数ありますが、ここではデータとその変更方法を中央集約化するという一般的な解決策を採用します。データフローは以下のようになります： データが自動的にビューを更新する部分については、リアクティブプログラミングのより高度な概念に関連しているため、ここでは取り上げません。深く掘り下げたい場合には良いフォローアップのテーマです。 ✅ 状態管理にはさまざまなアプローチを持つ多くのライブラリがありますが、Reduxはその中でも人気のある選択肢です。使用されている概念やパターンを調べてみてください。大規模なウェブアプリで直面する可能性のある問題や、それをどのように解決できるかを学ぶ良い方法です。 タスク まずは少しリファクタリングを行います。accountの宣言を以下のように置き換えます： js let account = null; 以下に置き換えます： js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます：\njs\nupdateState('account', data);\n次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。\n新しい関数logout()を作成します：\njs\nfunction logout() {\nupdateState('account', null);\nnavigate('/login');\n}\nupdateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。\n新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。\nヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2045,
    "chunk_index": 14,
    "total_chunks": 30
  },
  {
    "id": "e17019264a56af8fc490599ca9296a7b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "js let state = { account: null }; このアイデアは、アプリのすべてのデータを単一の状態オブジェクトに中央集約化することです。現在のところ状態にはaccountしかありませんが、これにより将来の拡張が可能になります。 また、これを使用する関数も更新する必要があります。register()およびlogin()関数では、account =をstateaccount =に置き換えます。 updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。\n状態を永続化する\nほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。\nブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです：\nデータは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。\nこのデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？\nウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。\nもう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです：\nlocalStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。\nsessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。\nこれらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1985,
    "chunk_index": 15,
    "total_chunks": 30
  },
  {
    "id": "319c5c7ef456835b0efe89f09bfef973",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "updateDashboard()関数の冒頭に以下の行を追加します： js const account = stateaccount; このリファクタリング自体は大きな改善をもたらしませんが、次の変更の基盤を築くことが目的です。 データ変更の追跡 stateオブジェクトをデータの保存に使用するようにしたので、次のステップは更新を中央集約化することです。これにより、変更内容とそのタイミングを追跡しやすくなります。 stateオブジェクトに変更を加えないようにするために、それを不変と見なすのも良いプラクティスです。つまり、全く変更できないということです。これにより、状態オブジェクトに何かを変更したい場合は新しい状態オブジェクトを作成する必要があります。この方法を採用することで、意図しない副作用を防ぐ保護が構築され、アプリに新しい機能（例えば、元に戻す/やり直しの実装）を追加する可能性が開かれます。また、デバッグが容易になります。例えば、状態に加えられたすべての変更をログに記録し、変更履歴を保持することで、バグの原因を理解することができます。 JavaScriptでは、Objectfreeze()を使用してオブジェクトの不変バージョンを作成できます。不変オブジェクトに変更を加えようとすると、例外が発生します。 ✅ 浅い不変オブジェクトと深い不変オブジェクトの違いを知っていますか？こちらで読むことができます。 タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。\n✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。\nタスク\nユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。\njs\nconst storageKey = 'savedAccount';\n次に、updateState()関数の末尾に以下の行を追加します：\njs\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2098,
    "chunk_index": 16,
    "total_chunks": 30
  },
  {
    "id": "cffb1d37b9d9f56a2f65bbf1f18f033a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "タスク 新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1562,
    "chunk_index": 17,
    "total_chunks": 30
  },
  {
    "id": "e1529462e992a323dc655470d5fe9b57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1562,
    "chunk_index": 18,
    "total_chunks": 30
  },
  {
    "id": "7cc180dc8286d3307cfdec23e1a0b822",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "新しいupdateState()関数を作成します： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount));\nこれにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。\nデータが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1717,
    "chunk_index": 19,
    "total_chunks": 30
  },
  {
    "id": "320d8d262c939a3581d4954747a1af20",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません：\n```js\nfunction init() {\nconst savedAccount = localStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1763,
    "chunk_index": 20,
    "total_chunks": 30
  },
  {
    "id": "7037d9da5f7fc7f14620a0a470c8a381",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "newData }); } この関数では、新しい状態オブジェクトを作成し、スプレッド演算子を使用して前の状態からデータをコピーします。その後、ブラケット記法を使用して状態オブジェクトの特定のプロパティを新しいデータで上書きします。最後に、Objectfreeze()を使用してオブジェクトをロックし、変更を防ぎます。現在のところ状態にはaccountプロパティしか保存されていませんが、このアプローチを使用すれば、状態に必要なプロパティをいくつでも追加できます。 また、初期状態が凍結されていることを確認するために、stateの初期化を更新します： js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey);\nif (savedAccount) {\nupdateState('account', JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1761,
    "chunk_index": 21,
    "total_chunks": 30
  },
  {
    "id": "a7abb4c7900d32352152bb7790ee81a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "js let state = Objectfreeze({ account: null }); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount));\n}\n// Our previous initialization code\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1530,
    "chunk_index": 22,
    "total_chunks": 30
  },
  {
    "id": "20f75a4809db44b1049f2e112523dab5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "}); その後、register関数を更新し、stateaccount = result;の代わりに以下を使用します： js updateState('account', result); 同様に、login関数ではstateaccount = data;を以下に置き換えます： js updateState('account', data); 次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute();\nupdateRoute();\n}\ninit();\n```\nここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。\nまた、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。\nアプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しました",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1807,
    "chunk_index": 23,
    "total_chunks": 30
  },
  {
    "id": "99d2b226da3b0fe5e4949eebc9e797e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` ここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。 また、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。 アプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しましたデータをリフレッシュする",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1748,
    "chunk_index": 24,
    "total_chunks": 30
  },
  {
    "id": "83ad6e5ecf5a11b50e27ea213ae2f21a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "次に、ユーザーがログアウトをクリックしたときにアカウントデータがクリアされない問題を修正します。 新しい関数logout()を作成します： js function logout() { updateState('account', null); navigate('/login'); } updateDashboard()では、リダイレクトreturn navigate('/login');をreturn logout();に置き換えます。 新しいアカウントを登録し、ログアウトして再度ログインして、すべてが正しく動作することを確認してください。 ヒント：ブラウザの開発ツールでコンソールを開き、updateState()の末尾にconsolelog(state)を追加することで、すべての状態変更を確認できます。 状態を永続化する ほとんどのウェブアプリは、正しく動作するためにデータを永続化する必要があります。すべての重要なデータは通常、データベースに保存され、サーバーAPIを介してアクセスされます。例えば、今回のケースではユーザーアカウントデータが該当します。しかし、ブラウザで実行されているクライアントアプリにデータを永続化することも、ユーザーエクスペリエンスを向上させたり、読み込みパフォーマンスを改善したりするために興味深い場合があります。 ブラウザ内でデータを永続化したい場合、以下のような重要な質問を自分に問いかけるべきです： データは機密性が高いか？ クライアントにユーザーパスワードなどの機密データを保存するのは避けるべきです。 このデータをどのくらいの期間保持する必要があるか？ このデータを現在のセッションでのみアクセスする予定なのか、それとも永続的に保存したいのか？ ウェブアプリ内で情報を保存する方法は、達成したいことに応じてさまざまです。例えば、検索クエリをURLに保存して、他のユーザーと共有可能にすることができます。また、HTTPクッキーを使用して、認証情報のようにサーバーと共有する必要があるデータを保存することもできます。 もう1つのオプションは、データを保存するためのブラウザAPIの1つを使用することです。その中でも特に興味深いのは以下の2つです： localStorage：現在のウェブサイトに特化したデータを異なるセッション間で永続化するためのキー/値ストア。保存されたデータは期限切れになりません。 sessionStorage：localStorageと同じように動作しますが、保存されたデータはセッションが終了すると（ブラウザが閉じられると）クリアされます。 これらのAPIはどちらも文字列のみを保存できることに注意してください。複雑なオブジェクトを保存したい場合は、JSONstringify()を使用してJSON形式にシリアライズする必要があります。 ✅ サーバーを使用しないウェブアプリを作成したい場合、IndexedDB APIを使用してクライアント側にデータベースを作成することも可能です。これは高度なユースケースや大量のデータを保存する必要がある場合に予約されていますが、使用するのはより複雑です。 タスク ユーザーがログアウトボタンを明示的にクリックするまでログイン状態を維持したいので、localStorageを使用してアカウントデータを保存します。まず、データを保存するために使用するキーを定義します。 js const storageKey = 'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` ここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。 また、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。 アプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しましたデータをリフレッシュするしかし、新しい問題を作り出してしまったかもしれません。おっと！\ntestアカウントを使用してダッシュボードに移動し、次に以下のコマンドをターミナルで実行して新しいトランザクションを作成します：\nsh\ncurl --request POST \\\n--header \"Content-Type: application/json\" \\\n--data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\\nhttp://localhost:5000/api/accounts/test/transactions\nその後、ブラウザでダッシュボードページをリフレッシュしてみてください。何が起こりますか？新しいトランザクションが表示されますか？\n状態はlocalStorageのおかげで無期限に永続化されますが、それはログアウトして再度ログインするまで更新されないことも意味します！\nこれを修正する1つの戦略は、ダッシュボードが読み込まれるたびにアカウントデータを再読み込みすることです。これにより、古いデータを回避できます。\nタスク\n新しい関数updateAccountDataを作成します：\n```js\nasync function updateAccountData() {\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2102,
    "chunk_index": 25,
    "total_chunks": 30
  },
  {
    "id": "f3e5b71646513086d4fe94800f8d99b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "'savedAccount'; 次に、updateState()関数の末尾に以下の行を追加します： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` ここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。 また、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。 アプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しましたデータをリフレッシュするしかし、新しい問題を作り出してしまったかもしれません。おっと！ testアカウントを使用してダッシュボードに移動し、次に以下のコマンドをターミナルで実行して新しいトランザクションを作成します： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions その後、ブラウザでダッシュボードページをリフレッシュしてみてください。何が起こりますか？新しいトランザクションが表示されますか？ 状態はlocalStorageのおかげで無期限に永続化されますが、それはログアウトして再度ログインするまで更新されないことも意味します！ これを修正する1つの戦略は、ダッシュボードが読み込まれるたびにアカウントデータを再読み込みすることです。これにより、古いデータを回避できます。 タスク 新しい関数updateAccountDataを作成します： ```js async function updateAccountData() { const account = stateaccount;\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 939,
    "chunk_index": 26,
    "total_chunks": 30
  },
  {
    "id": "e15e913b809fc3d995f49fdff58ba6b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "js localStoragesetItem(storageKey, JSONstringify(stateaccount)); これにより、ユーザーアカウントデータが永続化され、以前に中央集約化したすべての状態更新のおかげで常に最新の状態になります。この時点で、これまでのリファクタリングの恩恵を受け始めています🙂。 データが保存されるので、アプリが読み込まれたときにそれを復元することも必要です。初期化コードが増え始めるので、appjsの末尾にあった以前のコードを含む新しいinit関数を作成するのが良いアイデアかもしれません： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` ここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。 また、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。 アプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しましたデータをリフレッシュするしかし、新しい問題を作り出してしまったかもしれません。おっと！ testアカウントを使用してダッシュボードに移動し、次に以下のコマンドをターミナルで実行して新しいトランザクションを作成します： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions その後、ブラウザでダッシュボードページをリフレッシュしてみてください。何が起こりますか？新しいトランザクションが表示されますか？ 状態はlocalStorageのおかげで無期限に永続化されますが、それはログアウトして再度ログインするまで更新されないことも意味します！ これを修正する1つの戦略は、ダッシュボードが読み込まれるたびにアカウントデータを再読み込みすることです。これにより、古いデータを回避できます。 タスク 新しい関数updateAccountDataを作成します： ```js async function updateAccountData() { const account = stateaccount; if (account) {\nreturn logout();\n}\nconst data = await getAccount(account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 924,
    "chunk_index": 27,
    "total_chunks": 30
  },
  {
    "id": "7e1669e0ac52d4226e67f4a6afe65d08",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` ここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。 また、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。 アプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しましたデータをリフレッシュするしかし、新しい問題を作り出してしまったかもしれません。おっと！ testアカウントを使用してダッシュボードに移動し、次に以下のコマンドをターミナルで実行して新しいトランザクションを作成します： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions その後、ブラウザでダッシュボードページをリフレッシュしてみてください。何が起こりますか？新しいトランザクションが表示されますか？ 状態はlocalStorageのおかげで無期限に永続化されますが、それはログアウトして再度ログインするまで更新されないことも意味します！ これを修正する1つの戦略は、ダッシュボードが読み込まれるたびにアカウントデータを再読み込みすることです。これにより、古いデータを回避できます。 タスク 新しい関数updateAccountDataを作成します： ```js async function updateAccountData() { const account = stateaccount; if (account) { return logout(); } const data = await getAccount(accountuser);\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 706,
    "chunk_index": 28,
    "total_chunks": 30
  },
  {
    "id": "7bb3aa3a7a4aee5e7e79f192ef27279c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作る Part 4: 状態管理の概念",
    "content": "= localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` ここでは保存されたデータを取得し、もしあれば状態をそれに応じて更新します。ページ更新中に状態に依存するコードがある可能性があるため、ルートを更新する前にこれを行うことが重要です。 また、アカウントデータを永続化するようになったので、ダッシュボードページをアプリケーションのデフォルトページにすることもできます。データが見つからない場合、ダッシュボードはログインページにリダイレクトする処理を行います。updateRoute()では、フォールバックのreturn navigate('/login');をreturn navigate('/dashboard');に置き換えます。 アプリにログインしてページをリフレッシュしてみてください。ダッシュボードに留まるはずです。この更新により、すべての初期問題に対処しましたデータをリフレッシュするしかし、新しい問題を作り出してしまったかもしれません。おっと！ testアカウントを使用してダッシュボードに移動し、次に以下のコマンドをターミナルで実行して新しいトランザクションを作成します： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions その後、ブラウザでダッシュボードページをリフレッシュしてみてください。何が起こりますか？新しいトランザクションが表示されますか？ 状態はlocalStorageのおかげで無期限に永続化されますが、それはログアウトして再度ログインするまで更新されないことも意味します！ これを修正する1つの戦略は、ダッシュボードが読み込まれるたびにアカウントデータを再読み込みすることです。これにより、古いデータを回避できます。 タスク 新しい関数updateAccountDataを作成します： ```js async function updateAccountData() { const account = stateaccount; if (account) { return logout(); } const data = await getAccount(accountuser); if (dataerror) {\nreturn logout();\n}\nupdateState('account', data);\n}\n```\nこのメソッドは、現在ログインしていることを確認し、サーバーからアカウントデータを再読み込みします。\n次に、refreshという名前の別の関数を作成します：\njs\nasync function refresh() {\nawait updateAccountData();\nupdateDashboard();\n}\nこの関数はアカウントデータを更新し、その後ダッシュボードページのHTMLを更新します。これは、ダッシュボードルートが読み込まれたときに呼び出す必要があります。ルート定義を以下のように更新します：\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: refresh }\n};\nこれでダッシュボードをリロードしてみてください。更新されたアカウントデータが表示されるはずです。\n🚀 チャレンジ\nダッシュボードが読み込まれるたびにアカウントデータを再読み込みするようになった今、すべてのアカウントデータを永続化する必要がまだあると思いますか？\nアプリが動作するために絶対に必要なものだけをlocalStorageに保存および読み込むように変更してみてください。\n講義後のクイズ\n課題\n「取引を追加」ダイアログを実装する\n課題を完了した後の例はこちらです:\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 19700,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1318,
    "chunk_index": 29,
    "total_chunks": 30
  },
  {
    "id": "cf2f3516e41b9f71b187e41f0b2b5024",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "銀行アプリを作成する Part 2: ログインと登録フォームを作成\n講義前のクイズ\n講義前のクイズ\nはじめに\nほとんどの現代的なウェブアプリでは、アカウントを作成して自分専用のスペースを持つことができます。複数のユーザーが同時にウェブアプリにアクセスできるため、各ユーザーの個人データを別々に保存し、どの情報を表示するかを選択する仕組みが必要です。ユーザーの身元を安全に管理する方法については、非常に広範なトピックであるためここでは扱いませんが、各ユーザーが1つ（または複数）の銀行口座をアプリ内で作成できるようにします。\nこのパートでは、HTMLフォームを使用してウェブアプリにログインと登録機能を追加します。データをサーバーAPIにプログラム的に送信する方法や、ユーザー入力に対する基本的な検証ルールを定義する方法を学びます。\n前提条件\nこのレッスンを進めるには、ウェブアプリのHTMLテンプレートとルーティングを完了している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行して、アカウントを作成するためのデータを送信できるようにする必要があります。\n注意\n以下の2つのターミナルを同時に実行する必要があります。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 0,
    "total_chunks": 86
  },
  {
    "id": "40be6e5ac7a8750e191c676bfbe5e41f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "銀行アプリを作成する Part 2: ログインと登録フォームを作成\n講義前のクイズ\n講義前のクイズ\nはじめに\nほとんどの現代的なウェブアプリでは、アカウントを作成して自分専用のスペースを持つことができます。複数のユーザーが同時にウェブアプリにアクセスできるため、各ユーザーの個人データを別々に保存し、どの情報を表示するかを選択する仕組みが必要です。ユーザーの身元を安全に管理する方法については、非常に広範なトピックであるためここでは扱いませんが、各ユーザーが1つ（または複数）の銀行口座をアプリ内で作成できるようにします。\nこのパートでは、HTMLフォームを使用してウェブアプリにログインと登録機能を追加します。データをサーバーAPIにプログラム的に送信する方法や、ユーザー入力に対する基本的な検証ルールを定義する方法を学びます。\n前提条件\nこのレッスンを進めるには、ウェブアプリのHTMLテンプレートとルーティングを完了している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行して、アカウントを作成するためのデータを送信できるようにする必要があります。\n注意\n以下の2つのターミナルを同時に実行する必要があります。\n1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 527,
    "chunk_index": 1,
    "total_chunks": 86
  },
  {
    "id": "1643c69c6c8472739c923930975353ca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "銀行アプリを作成する Part 2: ログインと登録フォームを作成\n講義前のクイズ\n講義前のクイズ\nはじめに\nほとんどの現代的なウェブアプリでは、アカウントを作成して自分専用のスペースを持つことができます。複数のユーザーが同時にウェブアプリにアクセスできるため、各ユーザーの個人データを別々に保存し、どの情報を表示するかを選択する仕組みが必要です。ユーザーの身元を安全に管理する方法については、非常に広範なトピックであるためここでは扱いませんが、各ユーザーが1つ（または複数）の銀行口座をアプリ内で作成できるようにします。\nこのパートでは、HTMLフォームを使用してウェブアプリにログインと登録機能を追加します。データをサーバーAPIにプログラム的に送信する方法や、ユーザー入力に対する基本的な検証ルールを定義する方法を学びます。\n前提条件\nこのレッスンを進めるには、ウェブアプリのHTMLテンプレートとルーティングを完了している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行して、アカウントを作成するためのデータを送信できるようにする必要があります。\n注意\n以下の2つのターミナルを同時に実行する必要があります。\n1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用\n2上記でセットアップした銀行アプリのサーバーAPI用\nこれら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。\nサーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 705,
    "chunk_index": 2,
    "total_chunks": 86
  },
  {
    "id": "fa5d80444804c27e53212482ede408b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "銀行アプリを作成する Part 2: ログインと登録フォームを作成\n講義前のクイズ\n講義前のクイズ\nはじめに\nほとんどの現代的なウェブアプリでは、アカウントを作成して自分専用のスペースを持つことができます。複数のユーザーが同時にウェブアプリにアクセスできるため、各ユーザーの個人データを別々に保存し、どの情報を表示するかを選択する仕組みが必要です。ユーザーの身元を安全に管理する方法については、非常に広範なトピックであるためここでは扱いませんが、各ユーザーが1つ（または複数）の銀行口座をアプリ内で作成できるようにします。\nこのパートでは、HTMLフォームを使用してウェブアプリにログインと登録機能を追加します。データをサーバーAPIにプログラム的に送信する方法や、ユーザー入力に対する基本的な検証ルールを定義する方法を学びます。\n前提条件\nこのレッスンを進めるには、ウェブアプリのHTMLテンプレートとルーティングを完了している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行して、アカウントを作成するためのデータを送信できるようにする必要があります。\n注意\n以下の2つのターミナルを同時に実行する必要があります。\n1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用\n2上記でセットアップした銀行アプリのサーバーAPI用\nこれら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。\nサーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 705,
    "chunk_index": 3,
    "total_chunks": 86
  },
  {
    "id": "3571967ce02c94f6e93c86b0024bbc6f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "銀行アプリを作成する Part 2: ログインと登録フォームを作成\n講義前のクイズ\n講義前のクイズ\nはじめに\nほとんどの現代的なウェブアプリでは、アカウントを作成して自分専用のスペースを持つことができます。複数のユーザーが同時にウェブアプリにアクセスできるため、各ユーザーの個人データを別々に保存し、どの情報を表示するかを選択する仕組みが必要です。ユーザーの身元を安全に管理する方法については、非常に広範なトピックであるためここでは扱いませんが、各ユーザーが1つ（または複数）の銀行口座をアプリ内で作成できるようにします。\nこのパートでは、HTMLフォームを使用してウェブアプリにログインと登録機能を追加します。データをサーバーAPIにプログラム的に送信する方法や、ユーザー入力に対する基本的な検証ルールを定義する方法を学びます。\n前提条件\nこのレッスンを進めるには、ウェブアプリのHTMLテンプレートとルーティングを完了している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行して、アカウントを作成するためのデータを送信できるようにする必要があります。\n注意\n以下の2つのターミナルを同時に実行する必要があります。\n1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用\n2上記でセットアップした銀行アプリのサーバーAPI用\nこれら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。\nサーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\nフォームとコントロール\n<form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。\n<input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。\nhtml\n<input id=\"username\" name=\"username\" type=\"text\">\nname属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。\n<input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。\n✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。\nフォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です：\nsubmit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。\nreset: ボタンがすべてのフォームコントロールを初期値にリセットします。\nbutton: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。\nタスク\nまず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。\n```html\nLogin\nUsername\nLogin\n```\nよく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります：\nラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。\nラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。\nウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。\n次に、登録用の2つ目のフォームを前のフォームの下に追加します：\n```html\nRegister\nUsername\nCurrency\nDescription\nCurrent balance\nRegister\n```\nvalue属性を使用して、特定の入力にデフォルト値を定義できます。\nまた、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。\n✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？\nサーバーへのデータ送信\n機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？\nブラウザのURLセクションに変化があったことに気づきましたか？\n<form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります：\n送信されるデータのサイズが非常に制限されている（約2000文字）\nデータがURLに直接表示される（パスワードには適していない）\nファイルアップロードには対応していない\nそのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。\nPOSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。\nタスク\n登録フォームにactionとmethodプロパティを追加してください：\n```html\n```\n次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2383,
    "chunk_index": 4,
    "total_chunks": 86
  },
  {
    "id": "43bbf902ccaafa54d3ed63eef17f5248",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "以下の2つのターミナルを同時に実行する必要があります。 1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1968,
    "chunk_index": 5,
    "total_chunks": 86
  },
  {
    "id": "4ee453aad4a2edbbb73388e4f6ed5e72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "以下の2つのターミナルを同時に実行する必要があります。 1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1969,
    "chunk_index": 6,
    "total_chunks": 86
  },
  {
    "id": "5096a64452b7073ffe40fbf439ab3e3f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "以下の2つのターミナルを同時に実行する必要があります。 1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1969,
    "chunk_index": 7,
    "total_chunks": 86
  },
  {
    "id": "aff41ab993254d994188a236e371f887",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "以下の2つのターミナルを同時に実行する必要があります。 1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1969,
    "chunk_index": 8,
    "total_chunks": 86
  },
  {
    "id": "75e4cda8895198d553c7c8affa17841d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "以下の2つのターミナルを同時に実行する必要があります。 1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-post",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1980,
    "chunk_index": 9,
    "total_chunks": 86
  },
  {
    "id": "6bdf43fe99ad2fa9d07da413bfb28d35",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "以下の2つのターミナルを同時に実行する必要があります。 1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng)\nすべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2033,
    "chunk_index": 10,
    "total_chunks": 86
  },
  {
    "id": "c74c373722ac5ca163564fbc405748f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjson",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2010,
    "chunk_index": 11,
    "total_chunks": 86
  },
  {
    "id": "135da1c041b1f3d05b7333cf7dba9204",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2013,
    "chunk_index": 12,
    "total_chunks": 86
  },
  {
    "id": "5a88106972416caaa1d069f775070feb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "1HTMLテンプレートとルーティングレッスンで作成したメインの銀行アプリ用 2上記でセットアップした銀行アプリのサーバーAPI用 これら2つのサーバーを稼働させることで、レッスンの残りの部分を進めることができます。それぞれ異なるポート（ポート3000とポート5000）でリスニングしているため、問題なく動作するはずです。 サーバーが正しく動作しているかどうかを確認するには、ターミナルで以下のコマンドを実行してください。 ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。\n✅ 同じ名前で再度登録を試みてください。何が起こりますか？\n## ページをリロードせずにデータを送信する\n先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2172,
    "chunk_index": 13,
    "total_chunks": 86
  },
  {
    "id": "46c53d9ebaefbfd0dabc441e2a7b3089",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1979,
    "chunk_index": 14,
    "total_chunks": 86
  },
  {
    "id": "8b221f719e456b213cb9d8b67f5740b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` フォームとコントロール <form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。\nページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります：\n- フォームデータの取得\n- フォームデータを適切な形式に変換およびエンコード\n- HTTPリクエストを作成してサーバーに送信\n### タスク\n登録フォームの`action`を以下に置き換えてください：\n```html\n```\n`app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2259,
    "chunk_index": 15,
    "total_chunks": 86
  },
  {
    "id": "3f55e3c60f52a0758fd0456e615abaf5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "<form>要素は、ユーザーがインタラクティブなコントロールを使用してデータを入力および送信できるHTMLドキュメントのセクションをカプセル化します。フォーム内で使用できるユーザーインターフェース（UI）コントロールはさまざまで、最も一般的なものは<input>と<button>要素です。 <input>には多くの異なるタイプがあります。たとえば、ユーザー名を入力するフィールドを作成するには以下のようにします。 html <input id=\"username\" name=\"username\" type=\"text\"> name属性は、フォームデータが送信される際にプロパティ名として使用されます。id属性は、<label>をフォームコントロールに関連付けるために使用されます。 <input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください：\n```js\nfunction register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2259,
    "chunk_index": 16,
    "total_chunks": 86
  },
  {
    "id": "63eba8d03b1f16c47c85c1539f7abcee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "<input>タイプやその他のフォームコントロールの全リストを確認して、UIを構築する際に使用できるネイティブUI要素を理解してください。 ✅ <input>は空要素であり、対応する閉じタグを追加してはいけません。ただし、自己閉じタグ<input/>の記法を使用することはできますが、必須ではありません。 フォーム内の<button>要素は少し特別です。type属性を指定しない場合、押されたときにフォームデータをサーバーに自動的に送信します。以下は可能なtype値です： submit: <form>内のデフォルトで、ボタンがフォーム送信アクションをトリガーします。 reset: ボタンがすべてのフォームコントロールを初期値にリセットします。 button: ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst data = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2034,
    "chunk_index": 17,
    "total_chunks": 86
  },
  {
    "id": "1a72f58dfab8270d823fa4357b7b3715",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "ボタンが押されたときにデフォルトの動作を割り当てません。JavaScriptを使用してカスタムアクションを割り当てることができます。 タスク まず、loginテンプレートにフォームを追加しましょう。usernameフィールドとLoginボタンが必要です。 ```html Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData);\nconst jsonData = JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1775,
    "chunk_index": 18,
    "total_chunks": 86
  },
  {
    "id": "91dd76bd5565b4cd89a7466dfcddb384",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "Login Username Login ``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data);\n}\n```\nここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1704,
    "chunk_index": 19,
    "total_chunks": 86
  },
  {
    "id": "75a42cfdd714b0dcd2994e976aa81026",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1703,
    "chunk_index": 20,
    "total_chunks": 86
  },
  {
    "id": "32b6894777dc24c943da0fe006479226",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1749,
    "chunk_index": 21,
    "total_chunks": 86
  },
  {
    "id": "d9f415714c66c51659e479896e5946c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1756,
    "chunk_index": 22,
    "total_chunks": 86
  },
  {
    "id": "baa9bca6aadde326645f39272ced44e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1758,
    "chunk_index": 23,
    "total_chunks": 86
  },
  {
    "id": "645db4aa5801a61cdc697cbcc461b41e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1807,
    "chunk_index": 24,
    "total_chunks": 86
  },
  {
    "id": "f6f65f57259b38ec05d97d12261071c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjson",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1808,
    "chunk_index": 25,
    "total_chunks": 86
  },
  {
    "id": "0fac4b376613aeab2afef11798c9c632",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1811,
    "chunk_index": 26,
    "total_chunks": 86
  },
  {
    "id": "e5d76f43699ea0c430b093321c70cd6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` よく見ると、ここに<label>要素も追加されていることがわかります。<label>要素は、ユーザー名フィールドのようなUIコントロールに名前を付けるために使用されます。ラベルはフォームの読みやすさを向上させるだけでなく、以下のような追加の利点もあります： ラベルをフォームコントロールに関連付けることで、支援技術（スクリーンリーダーなど）を使用するユーザーがどのデータを提供する必要があるかを理解しやすくなります。 ラベルをクリックすると、関連付けられた入力に直接フォーカスを当てることができ、タッチスクリーンデバイスでの操作が簡単になります。 ウェブアクセシビリティは、しばしば見過ごされがちな非常に重要なトピックです。セマンティックHTML要素を適切に使用すれば、アクセシブルなコンテンツを作成するのは難しくありません。アクセシビリティについてさらに読むことで、一般的なミスを避け、責任ある開発者になることができます。 次に、登録用の2つ目のフォームを前のフォームの下に追加します： ```html Register Username Currency Description Current balance Register ``` value属性を使用して、特定の入力にデフォルト値を定義できます。 また、balanceの入力がnumberタイプであることに注意してください。他の入力と見た目が異なりますか？試して操作してみてください。 ✅ キーボードだけでフォームを操作できますか？どうやってそれを行いますか？ サーバーへのデータ送信 機能的なUIができたので、次のステップはデータをサーバーに送信することです。現在のコードを使用して簡単なテストを行いましょう：LoginまたはRegisterボタンをクリックするとどうなりますか？ ブラウザのURLセクションに変化があったことに気づきましたか？ <form>のデフォルトの動作は、現在のサーバーURLにフォームをGETメソッドを使用して送信し、フォームデータをURLに直接追加することです。しかし、この方法にはいくつかの欠点があります： 送信されるデータのサイズが非常に制限されている（約2000文字） データがURLに直接表示される（パスワードには適していない） ファイルアップロードには対応していない そのため、POSTメソッドを使用して、フォームデータをHTTPリクエストのボディに送信し、これらの制限を回避することができます。 POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。\nデータはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください：\n```js\nasync function createAccount(account) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts', {\nmethod: 'POST',\nheaders: { 'Content-Type': 'application/json' },\nbody: account\n});\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1941,
    "chunk_index": 27,
    "total_chunks": 86
  },
  {
    "id": "52ff17852bd8365826d5300a624f45db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "POSTはデータ送信に最も一般的に使用されるメソッドですが、特定のシナリオではGETメソッドを使用する方が適している場合があります。たとえば、検索フィールドを実装する場合などです。 タスク 登録フォームにactionとmethodプロパティを追加してください： ```html ``` 次に、自分の名前で新しいアカウントを登録してみてください。*Register*ボタンをクリックすると、以下のような画面が表示されるはずです：[localhost:5000/api/accountsのアドレスでブラウザウィンドウが表示され、ユーザーデータを含むJSON文字列が表示されている](////7-bank-project/2-forms/images/form-postpng) すべてが正常に動作すれば、サーバーはリクエストに応答し、作成されたアカウントデータを含む[JSON](https://wwwjsonorg/json-enhtml)レスポンスを返します。 ✅ 同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson();\n} catch (error) {\nreturn { error: error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1072,
    "chunk_index": 28,
    "total_chunks": 86
  },
  {
    "id": "90adbd2cc9f875f70039fb83ca5c0e81",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "同じ名前で再度登録を試みてください。何が起こりますか？ ## ページをリロードせずにデータを送信する 先ほど使用した方法には少し問題があることに気づいたかもしれません：フォームを送信すると、アプリから離れてブラウザがサーバーURLにリダイレクトしてしまいます。私たちは[シングルページアプリケーション（SPA）](https://enwikipediaorg/wiki/Single-page_application)を作成しているため、すべてのページリロードを避けたいと考えています。 ページをリロードせずにフォームデータをサーバーに送信するには、JavaScriptコードを使用する必要があります。``要素の`action`プロパティにURLを指定する代わりに、`javascript:`文字列を先頭に付けた任意のJavaScriptコードを使用してカスタムアクションを実行できます。この方法を使用すると、ブラウザが自動的に行っていた以下のタスクを自分で実装する必要があります： - フォームデータの取得 - フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' };\n}\n}\n```\nこの関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 837,
    "chunk_index": 29,
    "total_chunks": 86
  },
  {
    "id": "4f89f356cb5a15b9b5210c8de3b01999",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 30,
    "total_chunks": 86
  },
  {
    "id": "2e9f9b66baf474d26293971c48cdccbd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "フォームデータを適切な形式に変換およびエンコード - HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。\n`async/await`の使用方法についての簡単な動画はこちらです：\n[",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 623,
    "chunk_index": 31,
    "total_chunks": 86
  },
  {
    "id": "3fd025c9844e02963bf96b14d095a732",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://img",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 610,
    "chunk_index": 32,
    "total_chunks": 86
  },
  {
    "id": "d08edc9851118fec9bbf3c9cc836b384",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutube",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 611,
    "chunk_index": 33,
    "total_chunks": 86
  },
  {
    "id": "29d294036d1b73f75ed696323f02b5a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 34,
    "total_chunks": 86
  },
  {
    "id": "1c01648f218f442a8d3a9a0ec10da48d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtube",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 632,
    "chunk_index": 35,
    "total_chunks": 86
  },
  {
    "id": "f3788f5b631a981af31198e6df18dff2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watch",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 36,
    "total_chunks": 86
  },
  {
    "id": "67208c141937c015465a5bf8676a329f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "HTTPリクエストを作成してサーバーに送信 ### タスク 登録フォームの`action`を以下に置き換えてください： ```html ``` `appjs`を開き、`register`という名前の新しい関数を追加してください： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\")\n> 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。\n`fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります：\n- サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。\n- リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。\nサーバーがリクエストにJSONで応答するため、`await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 881,
    "chunk_index": 37,
    "total_chunks": 86
  },
  {
    "id": "07f4763bf3b6541517fa8ce8a071aa9c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` ここでは、`getElementById()`を使用してフォーム要素を取得し、[`FormData`](https://developermozillaorg/docs/Web/API/FormData)ヘルパーを使用してフォームコントロールからキー/値ペアとして値を抽出します。その後、[`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)を使用してデータを通常のオブジェクトに変換し、最終的に[JSON](https://wwwjsonorg/json-enhtml)にシリアル化します。JSONはウェブ上でデータを交換する際によく使用される形式です。 データはサーバーに送信する準備が整いました。`createAccount`という名前の新しい関数を作成してください： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。\n次に、`register`関数に`createAccount()`を呼び出すコードを追加してください：\n```js\nconst result = await createAccount(jsonData);\n```\nここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります：\n```js\nasync function register() {\n```\n最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります：\n```js\nasync function register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1029,
    "chunk_index": 38,
    "total_chunks": 86
  },
  {
    "id": "9963383178bfc739e0c6fd4c5796052b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "{ try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst jsonData = JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 781,
    "chunk_index": 39,
    "total_chunks": 86
  },
  {
    "id": "19f16803284c4a6e864810ff659eb16b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 767,
    "chunk_index": 40,
    "total_chunks": 86
  },
  {
    "id": "0dc7cfc755e4fe800b93d821b9092e86",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData));\nconst result = await createAccount(jsonData);\nif (result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 783,
    "chunk_index": 41,
    "total_chunks": 86
  },
  {
    "id": "41c881092cacae7792d7170ed8e38df8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "body: account }); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) {\nreturn console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 772,
    "chunk_index": 42,
    "total_chunks": 86
  },
  {
    "id": "4079c671b3e961063c4f397d1adce15c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 775,
    "chunk_index": 43,
    "total_chunks": 86
  },
  {
    "id": "e9fe094ce5fe7b6f009b08a4fbc9cf16",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "} catch (error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror);\n}\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 775,
    "chunk_index": 44,
    "total_chunks": 86
  },
  {
    "id": "49808c780ab3d1b548687ee109448280",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "(error) { return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 45,
    "total_chunks": 86
  },
  {
    "id": "2206193ae727a752e948509dfea90137",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "{ return { error: errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result);\n}\n```\n少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 814,
    "chunk_index": 46,
    "total_chunks": 86
  },
  {
    "id": "4203eff7ca4556cf2feea772e243aae8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 811,
    "chunk_index": 47,
    "total_chunks": 86
  },
  {
    "id": "516aa1bf408028c678d846c0838dacb7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 902,
    "chunk_index": 48,
    "total_chunks": 86
  },
  {
    "id": "a4ae5937d2df29e581c8d307b84452c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 934,
    "chunk_index": 49,
    "total_chunks": 86
  },
  {
    "id": "70f1ef37a8f8df1011d06c640d1fea95",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 935,
    "chunk_index": 50,
    "total_chunks": 86
  },
  {
    "id": "1cb57b879251090b0f332fe52ed10edd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 935,
    "chunk_index": 51,
    "total_chunks": 86
  },
  {
    "id": "588f45d24804df5c61f6218e9fc736ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 935,
    "chunk_index": 52,
    "total_chunks": 86
  },
  {
    "id": "051b4f02690bc6a1dc026e60390c9272",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 946,
    "chunk_index": 53,
    "total_chunks": 86
  },
  {
    "id": "11b049fc07b0faabeca072486a8ba397",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "errormessage || 'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng)\n✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1006,
    "chunk_index": 54,
    "total_chunks": 86
  },
  {
    "id": "e28183f1e19a6365adbf76d75c763c7b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1004,
    "chunk_index": 55,
    "total_chunks": 86
  },
  {
    "id": "acf1e5f582c0389770ae514fe525361a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "'Unknown error' }; } } ``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。\n## データの検証\nユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1093,
    "chunk_index": 56,
    "total_chunks": 86
  },
  {
    "id": "e90cd2ed0a6c7a53275f9247c9a7c0e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1087,
    "chunk_index": 57,
    "total_chunks": 86
  },
  {
    "id": "1ac76278ac561f91d53032dc56b72e25",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1132,
    "chunk_index": 58,
    "total_chunks": 86
  },
  {
    "id": "2c1cb8801d53436b45c4619f622e3ddc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "``` この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。\nデータをサーバーに送信する前に可能であれば[フォームデータを検証](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1192,
    "chunk_index": 59,
    "total_chunks": 86
  },
  {
    "id": "51d4026ff618c2dce7f3f9ee1767efb8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1193,
    "chunk_index": 60,
    "total_chunks": 86
  },
  {
    "id": "c0fb28717e4d40ae1c3fd6234a003a58",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "この関数は何をしているのでしょうか？まず、ここで`async`キーワードに注目してください。これは、関数内に[**非同期**](https://developermozillaorg/docs/Web/JavaScript/Reference/Statements/async_function)で実行されるコードが含まれていることを意味します。`await`キーワードと組み合わせて使用すると、ここでサーバーの応答を待つなど、非同期コードの実行を待機してから処理を続行できます。 `async/await`の使用方法についての簡単な動画はこちらです： [[AsyncとAwaitでプロミスを管理する](https://imgyoutubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"AsyncとAwaitでプロミスを管理する\") > 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 `fetch()`APIを使用してJSONデータをサーバーに送信します。このメソッドは2つのパラメータを取ります： - サーバーのURL。ここでは`//localhost:5000/api/accounts`を指定します。 - リクエストの設定。ここでメソッドを`POST`に設定し、リクエストの`body`を提供します。JSONデータをサーバーに送信しているため、`Content-Type`ヘッダーを`application/json`に設定して、サーバーがコンテンツを解釈できるようにします。 サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します：\n- `required`: フィールドが入力されていない場合、フォームを送信できません。\n- `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。\n- `min`と`max`: 数値フィールドの最小および最大値を定義します。\n- `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1418,
    "chunk_index": 61,
    "total_chunks": 86
  },
  {
    "id": "dff04a3f759c76f7a0248c578bf5dcfb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 971,
    "chunk_index": 62,
    "total_chunks": 86
  },
  {
    "id": "939d750a7c5b8c049b4994cc36bc7a94",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "サーバーがリクエストにJSONで応答するため、`await responsejson()`を使用してJSONコンテンツを解析し、結果のオブジェクトを返します。このメソッドは非同期であるため、解析中のエラーもキャッチできるように`await`キーワードを使用します。 次に、`register`関数に`createAccount()`を呼び出すコードを追加してください： ```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。\n- `pattern`: [正規表現](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1033,
    "chunk_index": 63,
    "total_chunks": 86
  },
  {
    "id": "2c53db0b555741cac00974c29e9ad6ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 904,
    "chunk_index": 64,
    "total_chunks": 86
  },
  {
    "id": "93f287f70a791fba713ef528c2dbd33d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "```js const result = await createAccount(jsonData); ``` ここで`await`キーワードを使用しているため、`register`関数の前に`async`キーワードを追加する必要があります： ```js async function register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。\nヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。\n### タスク\n新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします：\n```html\nUsername (required)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1118,
    "chunk_index": 65,
    "total_chunks": 86
  },
  {
    "id": "0c3e1ba7fa42a0d60261a171f5e064ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "register() { ``` 最後に、結果を確認するためのログを追加します。最終的な関数は以下のようになります： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required)\n```\nこのサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。\nテキストフィールドに`maxlength`属性を追加してください：\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1158,
    "chunk_index": 66,
    "total_chunks": 86
  },
  {
    "id": "93dadacfe8e5d7de49c7c0d26052d2e8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html```\n次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1182,
    "chunk_index": 67,
    "total_chunks": 86
  },
  {
    "id": "55f92b2edfc7a63df8df658544c8e7da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1213,
    "chunk_index": 68,
    "total_chunks": 86
  },
  {
    "id": "96c6c36b04dfa578cebc36c8a0e4ca7d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1214,
    "chunk_index": 69,
    "total_chunks": 86
  },
  {
    "id": "cfdf91d2bd469591cfaff2921e303a3c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1214,
    "chunk_index": 70,
    "total_chunks": 86
  },
  {
    "id": "97d3387a209315fb4f4277ea3ddbcb63",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1214,
    "chunk_index": 71,
    "total_chunks": 86
  },
  {
    "id": "a5eb96232c2e8d23a2b47ee3c36ba694",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1225,
    "chunk_index": 72,
    "total_chunks": 86
  },
  {
    "id": "d10b77125498ab1c8bfa4a58b25a2f9f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng)\nこのように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。\n通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。\n---\n## 🚀 チャレンジ\nユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。\n以下は、少しスタイリングを加えた後の最終的なログインページの例です：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1612,
    "chunk_index": 73,
    "total_chunks": 86
  },
  {
    "id": "dde3db629f6fb04bf95f48684cdc4139",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1625,
    "chunk_index": 74,
    "total_chunks": 86
  },
  {
    "id": "cd2e86e22b399d9d6d9215a65f833bba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1626,
    "chunk_index": 75,
    "total_chunks": 86
  },
  {
    "id": "e3f7bc4d4c7de8910b209903614f3730",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1626,
    "chunk_index": 76,
    "total_chunks": 86
  },
  {
    "id": "06d81a7cd00a3d9d8db265aa6138ba37",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1626,
    "chunk_index": 77,
    "total_chunks": 86
  },
  {
    "id": "f50075c66c5ed44a72b67150149d9f49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1636,
    "chunk_index": 78,
    "total_chunks": 86
  },
  {
    "id": "b198b690e389b758ffc3f64313a3a488",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "formData = new FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng)\n## 講義後のクイズ\n[講義後のクイズ](https://ashy-river-0debb7803",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1674,
    "chunk_index": 79,
    "total_chunks": 86
  },
  {
    "id": "af30f482a380299ff1774c306f6bac15",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1670,
    "chunk_index": 80,
    "total_chunks": 86
  },
  {
    "id": "3474cd6d74e626f76fb4e0950417b51b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1673,
    "chunk_index": 81,
    "total_chunks": 86
  },
  {
    "id": "0e3d96cf58f0efee9b45fa2ac94ee7f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "FormData(registerForm); const jsonData = JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/44)\n## 復習と自己学習\n開発者たちは、特にバリデーション戦略に関して、フォーム作成に非常に創造的になっています。[CodePen](https://codepen",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1745,
    "chunk_index": 82,
    "total_chunks": 86
  },
  {
    "id": "a568a3b025adb2395726b49ae28204ee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "= JSONstringify(ObjectfromEntries(formData)); const result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 復習と自己学習 開発者たちは、特にバリデーション戦略に関して、フォーム作成に非常に創造的になっています。[CodePen](https://codepencom)を見て、さまざまなフォームフローについて学んでみてください。興味深く、インスピレーションを与えるフォームを見つけられますか？\n## 課題\n[銀行アプリをスタイリングする](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1826,
    "chunk_index": 83,
    "total_chunks": 86
  },
  {
    "id": "abe0054c241047a313868358c5cc6b71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "result = await createAccount(jsonData); if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 復習と自己学習 開発者たちは、特にバリデーション戦略に関して、フォーム作成に非常に創造的になっています。[CodePen](https://codepencom)を見て、さまざまなフォームフローについて学んでみてください。興味深く、インスピレーションを与えるフォームを見つけられますか？ ## 課題 [銀行アプリをスタイリングする](assignmentmd)\n**免責事項**:\nこの文書は、AI翻訳サービス [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1851,
    "chunk_index": 84,
    "total_chunks": 86
  },
  {
    "id": "c5d5559680c194264c62cde2bb90a7b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成する Part 2: ログインと登録フォームを作成",
    "content": "if (resulterror) { return consolelog('An error occurred:', resulterror); } consolelog('Account created', result); } ``` 少し長くなりましたが、これで完了です！[ブラウザの開発者ツール](https://developermozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)を開き、新しいアカウントを登録してみてください。ウェブページには変化が見られませんが、コンソールにメッセージが表示され、すべてが正常に動作していることを確認できます。[ブラウザコンソールにログメッセージが表示されているスクリーンショット](////7-bank-project/2-forms/images/browser-consolepng) ✅ データは安全にサーバーに送信されていると思いますか？リクエストが傍受された場合はどうなるでしょうか？[HTTPS](https://enwikipediaorg/wiki/HTTPS)について読んで、安全なデータ通信について学んでください。 ## データの検証 ユーザー名を設定せずに新しいアカウントを登録しようとすると、サーバーが[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing))ステータスコードでエラーを返すことがわかります。 データをサーバーに送信する前に可能であれば[フォームデータを検証](https://developermozillaorg/docs/Learn/Forms/Form_validation)することは、正しいリクエストを送信するための良い習慣です。HTML5フォームコントロールは、さまざまな属性を使用して組み込みの検証を提供します： - `required`: フィールドが入力されていない場合、フォームを送信できません。 - `minlength`と`maxlength`: テキストフィールドの最小および最大文字数を定義します。 - `min`と`max`: 数値フィールドの最小および最大値を定義します。 - `type`: `number`、`email`、`file`などのデータの種類を定義します。[その他の組み込みタイプ](https://developermozillaorg/docs/Web/HTML/Element/input)もあります。この属性はフォームコントロールの視覚的なレンダリングを変更する場合もあります。 - `pattern`: [正規表現](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)パターンを定義して、入力されたデータが有効かどうかをテストします。 ヒント: `:valid` および `:invalid` CSS疑似クラスを使用して、フォームコントロールが有効か無効かに応じて外観をカスタマイズすることができます。 ### タスク 新しいアカウントを作成するには、ユーザー名と通貨の2つの必須フィールドが必要です。他のフィールドは任意です。フォームのHTMLを更新し、`required`属性とフィールドラベル内のテキストを使用して次のようにします： ```html Username (required)Currency (required) ``` このサーバー実装では、フィールドの最大長に特定の制限を課していませんが、ユーザーが入力するテキストには常に適切な制限を設けるのが良い習慣です。 テキストフィールドに`maxlength`属性を追加してください： ```html``` 次に、*登録*ボタンを押して、定義したバリデーションルールに従わないフィールドがある場合、次のようなエラーメッセージが表示されるはずです：[フォーム送信時のバリデーションエラーを示すスクリーンショット](////7-bank-project/2-forms/images/validation-errorpng) このように、データをサーバーに送信する*前に*行われるバリデーションは、**クライアントサイド**バリデーションと呼ばれます。ただし、すべてのチェックをデータを送信せずに行うことは常に可能ではありません。例えば、同じユーザー名のアカウントが既に存在するかどうかは、サーバーにリクエストを送信しないと確認できません。サーバーで行われる追加のバリデーションは、**サーバーサイド**バリデーションと呼ばれます。 通常、両方を実装する必要があります。クライアントサイドバリデーションは、ユーザーに即時のフィードバックを提供することでユーザー体験を向上させますが、サーバーサイドバリデーションは、操作するユーザーデータが正確で安全であることを保証するために重要です。 --- ## 🚀 チャレンジ ユーザーが既に存在する場合、HTMLにエラーメッセージを表示してください。 以下は、少しスタイリングを加えた後の最終的なログインページの例です：[CSSスタイルを追加した後のログインページのスクリーンショット](////7-bank-project/2-forms/images/resultpng) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 復習と自己学習 開発者たちは、特にバリデーション戦略に関して、フォーム作成に非常に創造的になっています。[CodePen](https://codepencom)を見て、さまざまなフォームフローについて学んでみてください。興味深く、インスピレーションを与えるフォームを見つけられますか？ ## 課題 [銀行アプリをスタイリングする](assignmentmd) **免責事項**: この文書は、AI翻訳サービス [Co-op Translator](https://githubcom/Azure/co-op-translator) を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22584,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2020,
    "chunk_index": 85,
    "total_chunks": 86
  },
  {
    "id": "baea09d52216dce1f98988de4eed19bc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\solution\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリ",
    "content": "銀行アプリ\n銀行アプリプロジェクトの例として作成されたソリューション。純粋なHTML5、CSS、JavaScriptで構築されています（フレームワークやライブラリは使用していません）。\nアプリの実行\nまず、APIサーバーが稼働していることを確認してください。\nどのウェブサーバーでもアプリを実行できますが、APIを実行するためにNode.jsをインストールしているはずなので、以下の手順を実行してください：\nこのリポジトリをGit cloneします。\nターミナルを開き、このディレクトリに移動してから、npx lite-server .を実行します。これにより、ポート3000で開発用ウェブサーバーが起動します。\nブラウザでhttp://localhost:3000を開き、アプリを実行します。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1789,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 472,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "218af6dd52d41875ce0a54d8e2f14b7b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\assignment.md",
    "source_type": "git_repo",
    "title": "ゲームのモックアップ",
    "content": "ゲームのモックアップ\n手順\nレッスン内のコードサンプルを使って、あなたが楽しんでいるゲームを表現してください。シンプルなゲームで構いませんが、クラスまたはコンポジションパターンと、pub/subパターンを使用してゲームがどのように起動するかを示すことが目標です。創造力を発揮しましょう！\n採点基準\n| 基準     | 優秀                                                   | 適切                                                   | 改善が必要                                         |\n| -------- | ------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------- |\n|          | 画面上に3つの要素が配置され、操作されている             | 画面上に2つの要素が配置され、操作されている           | 画面上に1つの要素が配置され、操作されている         |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があります。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1891,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 455,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "af9818222e2c920098e69e5648af9140",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行API",
    "content": "銀行API\nNode js + Express で構築された銀行API。\nこのAPIはすでに構築済みで、演習の一部ではありません。\nただし、このようなAPIの構築方法を学びたい場合は、以下のビデオシリーズを参照してください: https://aka ms/NodeBeginner （ビデオの17～21がこのAPIをカバーしています）。\nまた、こちらのインタラクティブなチュートリアルも参考にしてください: https://aka ms/learn/express-api\nサーバーの起動\nNode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3356,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 169,
    "chunk_index": 0,
    "total_chunks": 3
  },
  {
    "id": "73e63c2949e334385254db75a4acd060",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行API",
    "content": "銀行API\nNode js + Express で構築された銀行API。\nこのAPIはすでに構築済みで、演習の一部ではありません。\nただし、このようなAPIの構築方法を学びたい場合は、以下のビデオシリーズを参照してください: https://aka ms/NodeBeginner （ビデオの17～21がこのAPIをカバーしています）。\nまた、こちらのインタラクティブなチュートリアルも参考にしてください: https://aka ms/learn/express-api\nサーバーの起動\nNodejs がインストールされていることを確認してください。\nこのリポジトリ The Web-Dev-For-Beginners をGitクローンします。\nターミナルを開き、Web-Dev-For-Beginners/7-bank-project/api フォルダに移動します。\nnpm install を実行し、パッケージのインストールが完了するのを待ちます（インターネット接続の品質によっては時間がかかる場合があります）。\nインストールが完了したら、npm start を実行すれば準備完了です。\nサーバーはポート 5000 でリッスンを開始します。\nこのサーバーはメインの銀行アプリサーバー（ポート 3000 でリッスン中）と一緒に動作しますので、閉じないでください。\n注意: すべてのエントリはメモリ内に保存され、永続化されません。そのため、サーバーを停止するとすべてのデータが失われます。\nAPIの詳細\nルート                                        | 説明\n---------------------------------------------|------------------------------------\nGET    /api/                                 | サーバー情報を取得\nPOST   /api/accounts/                        | アカウントを作成、例: { user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 }\nGET    /api/accounts/:user                   | 指定されたアカウントのすべてのデータを取得\nDELETE /api/accounts/:user                   | 指定されたアカウントを削除\nPOST   /api/accounts/:user/transactions      | トランザクションを追加、例: { date: '2020-07-23T18:25:43",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3356,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 639,
    "chunk_index": 1,
    "total_chunks": 3
  },
  {
    "id": "9afe7ee12b82aad5a748a175b11a2e5a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行API",
    "content": "銀行API\nNode js + Express で構築された銀行API。\nこのAPIはすでに構築済みで、演習の一部ではありません。\nただし、このようなAPIの構築方法を学びたい場合は、以下のビデオシリーズを参照してください: https://aka ms/NodeBeginner （ビデオの17～21がこのAPIをカバーしています）。\nまた、こちらのインタラクティブなチュートリアルも参考にしてください: https://aka ms/learn/express-api\nサーバーの起動\nNodejs がインストールされていることを確認してください。\nこのリポジトリ The Web-Dev-For-Beginners をGitクローンします。\nターミナルを開き、Web-Dev-For-Beginners/7-bank-project/api フォルダに移動します。\nnpm install を実行し、パッケージのインストールが完了するのを待ちます（インターネット接続の品質によっては時間がかかる場合があります）。\nインストールが完了したら、npm start を実行すれば準備完了です。\nサーバーはポート 5000 でリッスンを開始します。\nこのサーバーはメインの銀行アプリサーバー（ポート 3000 でリッスン中）と一緒に動作しますので、閉じないでください。\n注意: すべてのエントリはメモリ内に保存され、永続化されません。そのため、サーバーを停止するとすべてのデータが失われます。\nAPIの詳細\nルート                                        | 説明\n---------------------------------------------|------------------------------------\nGET    /api/                                 | サーバー情報を取得\nPOST   /api/accounts/                        | アカウントを作成、例: { user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 }\nGET    /api/accounts/:user                   | 指定されたアカウントのすべてのデータを取得\nDELETE /api/accounts/:user                   | 指定されたアカウントを削除\nPOST   /api/accounts/:user/transactions      | トランザクションを追加、例: { date: '2020-07-23T18:25:43511Z', object: 'Bought a book', amount: -20 }\nDELETE  /api/accounts/:user/transactions/:id | 指定されたトランザクションを削除\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3356,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 882,
    "chunk_index": 2,
    "total_chunks": 3
  },
  {
    "id": "b951e78b19a48dbd2ec85de0e2070a62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\assignment.md",
    "source_type": "git_repo",
    "title": "Canvas APIで遊ぼう",
    "content": "Canvas APIで遊ぼう\n手順\nCanvas APIの要素を1つ選び、それを使って何か面白いものを作ってみましょう。小さな銀河のように星を繰り返し描くことはできますか？色とりどりの線で面白いテクスチャを作ることはできますか？インスピレーションを得るためにCodePenを見ても構いません（ただしコピーはしないでください）。\n評価基準\n| 基準     | 優秀な例                                                 | 十分な例                          | 改善が必要な例         |\n| -------- | --------------------------------------------------------- | ----------------------------------- | --------------------- |\n|          | 興味深いテクスチャや形状を示すコードが提出されている       | コードは提出されているが動作しない | コードが提出されていない |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があることをご承知おきください。原文（元の言語で記載された文書）が信頼できる情報源として優先されるべきです。重要な情報については、専門の人間による翻訳をお勧めします。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いかねます。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1827,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "dbc8387e501c79bd1f85232c6c2d825e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "宇宙ゲームを作ろう パート1: はじめに\n講義前クイズ\n講義前クイズ\nゲーム開発における継承とコンポジション\n以前のレッスンでは、作成したアプリの設計アーキテクチャについてあまり気にする必要はありませんでした。プロジェクトの規模が非常に小さかったからです。しかし、アプリケーションの規模や範囲が大きくなるにつれて、アーキテクチャの決定が重要な課題となります。JavaScriptで大規模なアプリケーションを作成する際には、主に2つのアプローチがあります：コンポジションまたは継承です。それぞれに利点と欠点がありますが、ゲームの文脈で説明してみましょう。\n✅ 最も有名なプログラミング書籍の1つはデザインパターンに関するものです。\nゲームでは、ゲームオブジェクトという画面上に存在するオブジェクトがあります。これらはデカルト座標系上の位置を持ち、x座標とy座標で特徴付けられます。ゲームを開発していくと、すべてのゲームオブジェクトが標準的なプロパティを持っていることに気づくでしょう。これは、作成するすべてのゲームに共通する要素であり、以下のようなものです：\n位置ベース ほとんどのゲーム要素は位置ベースです。つまり、xとyの位置を持っています。\n移動可能 新しい位置に移動できるオブジェクトです。通常、ヒーロー、モンスター、NPC（非プレイヤーキャラクター）などが該当しますが、例えば木のような静的なオブジェクトは該当しません。\n自己破壊型 これらのオブジェクトは一定期間だけ存在し、その後削除される準備をします。通常、deadやdestroyedというブール値で表され、ゲームエンジンにこのオブジェクトを描画しないように指示します。\nクールダウン 'クールダウン'は短命のオブジェクトに共通するプロパティです。典型的な例としては、数ミリ秒だけ表示されるテキストや爆発のようなグラフィカルエフェクトがあります。\n✅ パックマンのようなゲームを考えてみましょう。このゲームで上記の4つのオブジェクトタイプを特定できますか？\n振る舞いの表現\n上記で説明したのは、ゲームオブジェクトが持つ可能性のある振る舞いです。それをどのようにコード化するのでしょうか？これらの振る舞いは、クラスやオブジェクトに関連付けられたメソッドとして表現できます。\nクラス\nクラスを使用して、継承と組み合わせることで、特定の振る舞いをクラスに追加することができます。\n✅ 継承は重要な概念です。MDNの継承に関する記事でさらに学びましょう。\nコードで表現すると、ゲームオブジェクトは通常以下のようになります：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1100,
    "chunk_index": 0,
    "total_chunks": 19
  },
  {
    "id": "042b25ced66a2b94674ceefb86c6a027",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "宇宙ゲームを作ろう パート1: はじめに\n講義前クイズ\n講義前クイズ\nゲーム開発における継承とコンポジション\n以前のレッスンでは、作成したアプリの設計アーキテクチャについてあまり気にする必要はありませんでした。プロジェクトの規模が非常に小さかったからです。しかし、アプリケーションの規模や範囲が大きくなるにつれて、アーキテクチャの決定が重要な課題となります。JavaScriptで大規模なアプリケーションを作成する際には、主に2つのアプローチがあります：コンポジションまたは継承です。それぞれに利点と欠点がありますが、ゲームの文脈で説明してみましょう。\n✅ 最も有名なプログラミング書籍の1つはデザインパターンに関するものです。\nゲームでは、ゲームオブジェクトという画面上に存在するオブジェクトがあります。これらはデカルト座標系上の位置を持ち、x座標とy座標で特徴付けられます。ゲームを開発していくと、すべてのゲームオブジェクトが標準的なプロパティを持っていることに気づくでしょう。これは、作成するすべてのゲームに共通する要素であり、以下のようなものです：\n位置ベース ほとんどのゲーム要素は位置ベースです。つまり、xとyの位置を持っています。\n移動可能 新しい位置に移動できるオブジェクトです。通常、ヒーロー、モンスター、NPC（非プレイヤーキャラクター）などが該当しますが、例えば木のような静的なオブジェクトは該当しません。\n自己破壊型 これらのオブジェクトは一定期間だけ存在し、その後削除される準備をします。通常、deadやdestroyedというブール値で表され、ゲームエンジンにこのオブジェクトを描画しないように指示します。\nクールダウン 'クールダウン'は短命のオブジェクトに共通するプロパティです。典型的な例としては、数ミリ秒だけ表示されるテキストや爆発のようなグラフィカルエフェクトがあります。\n✅ パックマンのようなゲームを考えてみましょう。このゲームで上記の4つのオブジェクトタイプを特定できますか？\n振る舞いの表現\n上記で説明したのは、ゲームオブジェクトが持つ可能性のある振る舞いです。それをどのようにコード化するのでしょうか？これらの振る舞いは、クラスやオブジェクトに関連付けられたメソッドとして表現できます。\nクラス\nクラスを使用して、継承と組み合わせることで、特定の振る舞いをクラスに追加することができます。\n✅ 継承は重要な概念です。MDNの継承に関する記事でさらに学びましょう。\nコードで表現すると、ゲームオブジェクトは通常以下のようになります：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1105,
    "chunk_index": 1,
    "total_chunks": 19
  },
  {
    "id": "6e44285f0399a3de101e0cbb9705a30c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "宇宙ゲームを作ろう パート1: はじめに\n講義前クイズ\n講義前クイズ\nゲーム開発における継承とコンポジション\n以前のレッスンでは、作成したアプリの設計アーキテクチャについてあまり気にする必要はありませんでした。プロジェクトの規模が非常に小さかったからです。しかし、アプリケーションの規模や範囲が大きくなるにつれて、アーキテクチャの決定が重要な課題となります。JavaScriptで大規模なアプリケーションを作成する際には、主に2つのアプローチがあります：コンポジションまたは継承です。それぞれに利点と欠点がありますが、ゲームの文脈で説明してみましょう。\n✅ 最も有名なプログラミング書籍の1つはデザインパターンに関するものです。\nゲームでは、ゲームオブジェクトという画面上に存在するオブジェクトがあります。これらはデカルト座標系上の位置を持ち、x座標とy座標で特徴付けられます。ゲームを開発していくと、すべてのゲームオブジェクトが標準的なプロパティを持っていることに気づくでしょう。これは、作成するすべてのゲームに共通する要素であり、以下のようなものです：\n位置ベース ほとんどのゲーム要素は位置ベースです。つまり、xとyの位置を持っています。\n移動可能 新しい位置に移動できるオブジェクトです。通常、ヒーロー、モンスター、NPC（非プレイヤーキャラクター）などが該当しますが、例えば木のような静的なオブジェクトは該当しません。\n自己破壊型 これらのオブジェクトは一定期間だけ存在し、その後削除される準備をします。通常、deadやdestroyedというブール値で表され、ゲームエンジンにこのオブジェクトを描画しないように指示します。\nクールダウン 'クールダウン'は短命のオブジェクトに共通するプロパティです。典型的な例としては、数ミリ秒だけ表示されるテキストや爆発のようなグラフィカルエフェクトがあります。\n✅ パックマンのようなゲームを考えてみましょう。このゲームで上記の4つのオブジェクトタイプを特定できますか？\n振る舞いの表現\n上記で説明したのは、ゲームオブジェクトが持つ可能性のある振る舞いです。それをどのようにコード化するのでしょうか？これらの振る舞いは、クラスやオブジェクトに関連付けられたメソッドとして表現できます。\nクラス\nクラスを使用して、継承と組み合わせることで、特定の振る舞いをクラスに追加することができます。\n✅ 継承は重要な概念です。MDNの継承に関する記事でさらに学びましょう。\nコードで表現すると、ゲームオブジェクトは通常以下のようになります：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthisy = y;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1110,
    "chunk_index": 2,
    "total_chunks": 19
  },
  {
    "id": "19b83dea9871a9a6c43e3be8c4545fc4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "宇宙ゲームを作ろう パート1: はじめに\n講義前クイズ\n講義前クイズ\nゲーム開発における継承とコンポジション\n以前のレッスンでは、作成したアプリの設計アーキテクチャについてあまり気にする必要はありませんでした。プロジェクトの規模が非常に小さかったからです。しかし、アプリケーションの規模や範囲が大きくなるにつれて、アーキテクチャの決定が重要な課題となります。JavaScriptで大規模なアプリケーションを作成する際には、主に2つのアプローチがあります：コンポジションまたは継承です。それぞれに利点と欠点がありますが、ゲームの文脈で説明してみましょう。\n✅ 最も有名なプログラミング書籍の1つはデザインパターンに関するものです。\nゲームでは、ゲームオブジェクトという画面上に存在するオブジェクトがあります。これらはデカルト座標系上の位置を持ち、x座標とy座標で特徴付けられます。ゲームを開発していくと、すべてのゲームオブジェクトが標準的なプロパティを持っていることに気づくでしょう。これは、作成するすべてのゲームに共通する要素であり、以下のようなものです：\n位置ベース ほとんどのゲーム要素は位置ベースです。つまり、xとyの位置を持っています。\n移動可能 新しい位置に移動できるオブジェクトです。通常、ヒーロー、モンスター、NPC（非プレイヤーキャラクター）などが該当しますが、例えば木のような静的なオブジェクトは該当しません。\n自己破壊型 これらのオブジェクトは一定期間だけ存在し、その後削除される準備をします。通常、deadやdestroyedというブール値で表され、ゲームエンジンにこのオブジェクトを描画しないように指示します。\nクールダウン 'クールダウン'は短命のオブジェクトに共通するプロパティです。典型的な例としては、数ミリ秒だけ表示されるテキストや爆発のようなグラフィカルエフェクトがあります。\n✅ パックマンのようなゲームを考えてみましょう。このゲームで上記の4つのオブジェクトタイプを特定できますか？\n振る舞いの表現\n上記で説明したのは、ゲームオブジェクトが持つ可能性のある振る舞いです。それをどのようにコード化するのでしょうか？これらの振る舞いは、クラスやオブジェクトに関連付けられたメソッドとして表現できます。\nクラス\nクラスを使用して、継承と組み合わせることで、特定の振る舞いをクラスに追加することができます。\n✅ 継承は重要な概念です。MDNの継承に関する記事でさらに学びましょう。\nコードで表現すると、ゲームオブジェクトは通常以下のようになります：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthisy = y;\nthistype = type;\n}\n}\n//this class will extend the GameObject's inherent class properties\nclass Movable extends GameObject {\nconstructor(x,y, type) {\nsuper(x,y, type)\n}\n//this movable object can be moved on the screen\nmoveTo(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1168,
    "chunk_index": 3,
    "total_chunks": 19
  },
  {
    "id": "148d2ad68a0ab757ff0cb3549ffd78d9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "最も有名なプログラミング書籍の1つはデザインパターンに関するものです。 ゲームでは、ゲームオブジェクトという画面上に存在するオブジェクトがあります。これらはデカルト座標系上の位置を持ち、x座標とy座標で特徴付けられます。ゲームを開発していくと、すべてのゲームオブジェクトが標準的なプロパティを持っていることに気づくでしょう。これは、作成するすべてのゲームに共通する要素であり、以下のようなものです： 位置ベース ほとんどのゲーム要素は位置ベースです。つまり、xとyの位置を持っています。 移動可能 新しい位置に移動できるオブジェクトです。通常、ヒーロー、モンスター、NPC（非プレイヤーキャラクター）などが該当しますが、例えば木のような静的なオブジェクトは該当しません。 自己破壊型 これらのオブジェクトは一定期間だけ存在し、その後削除される準備をします。通常、deadやdestroyedというブール値で表され、ゲームエンジンにこのオブジェクトを描画しないように指示します。 クールダウン 'クールダウン'は短命のオブジェクトに共通するプロパティです。典型的な例としては、数ミリ秒だけ表示されるテキストや爆発のようなグラフィカルエフェクトがあります。 ✅ パックマンのようなゲームを考えてみましょう。このゲームで上記の4つのオブジェクトタイプを特定できますか？ 振る舞いの表現 上記で説明したのは、ゲームオブジェクトが持つ可能性のある振る舞いです。それをどのようにコード化するのでしょうか？これらの振る舞いは、クラスやオブジェクトに関連付けられたメソッドとして表現できます。 クラス クラスを使用して、継承と組み合わせることで、特定の振る舞いをクラスに追加することができます。 ✅ 継承は重要な概念です。MDNの継承に関する記事でさらに学びましょう。 コードで表現すると、ゲームオブジェクトは通常以下のようになります： ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x; thisy = y; thistype = type; } } //this class will extend the GameObject's inherent class properties class Movable extends GameObject { constructor(x,y, type) { super(x,y, type) } //this movable object can be moved on the screen moveTo(x, y) { thisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 887,
    "chunk_index": 4,
    "total_chunks": 19
  },
  {
    "id": "def9fa2eecfc61509d60a2902a1232f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "ほとんどのゲーム要素は位置ベースです。つまり、xとyの位置を持っています。 移動可能 新しい位置に移動できるオブジェクトです。通常、ヒーロー、モンスター、NPC（非プレイヤーキャラクター）などが該当しますが、例えば木のような静的なオブジェクトは該当しません。 自己破壊型 これらのオブジェクトは一定期間だけ存在し、その後削除される準備をします。通常、deadやdestroyedというブール値で表され、ゲームエンジンにこのオブジェクトを描画しないように指示します。 クールダウン 'クールダウン'は短命のオブジェクトに共通するプロパティです。典型的な例としては、数ミリ秒だけ表示されるテキストや爆発のようなグラフィカルエフェクトがあります。 ✅ パックマンのようなゲームを考えてみましょう。このゲームで上記の4つのオブジェクトタイプを特定できますか？ 振る舞いの表現 上記で説明したのは、ゲームオブジェクトが持つ可能性のある振る舞いです。それをどのようにコード化するのでしょうか？これらの振る舞いは、クラスやオブジェクトに関連付けられたメソッドとして表現できます。 クラス クラスを使用して、継承と組み合わせることで、特定の振る舞いをクラスに追加することができます。 ✅ 継承は重要な概念です。MDNの継承に関する記事でさらに学びましょう。 コードで表現すると、ゲームオブジェクトは通常以下のようになります： ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x; thisy = y; thistype = type; } } //this class will extend the GameObject's inherent class properties class Movable extends GameObject { constructor(x,y, type) { super(x,y, type) } //this movable object can be moved on the screen moveTo(x, y) { thisx = x; thisy = y;\n}\n}\n//this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits\nclass Hero extends Movable {\nconstructor(x,y) {\nsuper(x,y, 'Hero')\n}\n}\n//this class, on the other hand, only inherits the GameObject properties\nclass Tree extends GameObject {\nconstructor(x,y) {\nsuper(x,y, 'Tree')\n}\n}\n//a hero can move",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 769,
    "chunk_index": 5,
    "total_chunks": 19
  },
  {
    "id": "65baf70d3b5c271c8b0bd5bb5b0b4e16",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "can be moved on the screen moveTo(x, y) { thisx = x; thisy = y; } } //this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits class Hero extends Movable { constructor(x,y) { super(x,y, 'Hero') } } //this class, on the other hand, only inherits the GameObject properties class Tree extends GameObject { constructor(x,y) { super(x,y, 'Tree') } } //a hero can moveconst hero = new Hero();\nhero moveTo(5,5);\n//but a tree cannot\nconst tree = new Tree();\n```\n✅ 数分間、パックマンのヒーロー（例えば、インキー、ピンキー、ブリンキー）を再構想し、それをJavaScriptでどのように記述するか考えてみましょう。\nコンポジション\nオブジェクトの継承を処理する別の方法として、コンポジションを使用することがあります。この場合、オブジェクトは以下のように振る舞いを表現します：\n```javascript\n//create a constant gameObject\nconst gameObject = {\nx: 0,\ny: 0,\ntype: ''\n};\n// and a constant movable\nconst movable = {\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//then the constant movableObject is composed of the gameObject and movable constants\nconst movableObject = { gameObject, movable};\n//then create a function to create a new Hero who inherits the movableObject properties\nfunction createHero(x, y) {\nreturn { movableObject,\nx,\ny,\ntype: 'Hero'\n}\n}\n// and a static object that inherits only the gameObject properties\nfunction createStatic(x, y, type) {\nreturn { gameObject\nx,\ny,\ntype\n}\n}\n//create the hero and move it\nconst hero = createHero(10,10);\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 6,
    "total_chunks": 19
  },
  {
    "id": "779d5a26af3895c2d76cd1c6fea3c8c7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "is composed of the gameObject and movable constants const movableObject = { gameObject, movable}; //then create a function to create a new Hero who inherits the movableObject properties function createHero(x, y) { return { movableObject, x, y, type: 'Hero' } } // and a static object that inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); heromoveTo(5,5);\n//and create a static tree which only stands around\nconst tree = createStatic(0,0, 'Tree');\n```\nどのパターンを使うべきか？\nどちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。\n--\nゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。\nPub/subパターン\n✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。\nこのパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します：\nメッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。\nパブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。\nサブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。\nこの実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます：\n```javascript\n//set up an EventEmitter class that contains listeners\nclass EventEmitter {\nconstructor() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 734,
    "chunk_index": 7,
    "total_chunks": 19
  },
  {
    "id": "63596ccfa0eac4adecd928458e1660aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "object that inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` どのパターンを使うべきか？ どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {};\n}\n//when a message is received, let the listener to handle its payload\non(message, listener) {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 702,
    "chunk_index": 8,
    "total_chunks": 19
  },
  {
    "id": "050a995a16bee6e9bcc8b7d139955104",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "//create the hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` どのパターンを使うべきか？ どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 675,
    "chunk_index": 9,
    "total_chunks": 19
  },
  {
    "id": "75e4853e589a10c6b6f6d2cf8b714799",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "//create the hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` どのパターンを使うべきか？ どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 681,
    "chunk_index": 10,
    "total_chunks": 19
  },
  {
    "id": "72ed4acefc93ec1118bb8ddc504e0796",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` どのパターンを使うべきか？ どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = [];\n}\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 11,
    "total_chunks": 19
  },
  {
    "id": "07242207f636c0822e834f27c1bc35b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` どのパターンを使うべきか？ どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 12,
    "total_chunks": 19
  },
  {
    "id": "aba5332e9c39ed003afa831cab0dfc32",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` どのパターンを使うべきか？ どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener);\n}\n//when a message is sent, send it to a listener with some payload\nemit(message, payload = null) {\nif (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 717,
    "chunk_index": 13,
    "total_chunks": 19
  },
  {
    "id": "43d92b40246145d3c5b47b4e1bf08cab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "どちらのパターンを選ぶかはあなた次第です。JavaScriptはこれら両方のパラダイムをサポートしています。 -- ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 663,
    "chunk_index": 14,
    "total_chunks": 19
  },
  {
    "id": "e2d0daabca751835b5a955b4590450ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { thislisteners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 624,
    "chunk_index": 15,
    "total_chunks": 19
  },
  {
    "id": "14ca27700cc61ab0b2df25f9576662ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "ゲーム開発で一般的なもう1つのパターンは、ゲームのユーザーエクスペリエンスとパフォーマンスを処理する問題に対処するものです。 Pub/subパターン ✅ Pub/Subは「パブリッシュ-サブスクライブ」の略です。 このパターンは、アプリケーションの異なる部分が互いを知らないようにするというアイデアに対処します。なぜそれが重要なのでしょうか？アプリケーションの各部分が分離されていると、全体の状況を把握しやすくなります。また、必要に応じて振る舞いを突然変更するのも簡単になります。これをどうやって実現するのでしょうか？以下の概念を確立することで実現します： メッセージ: メッセージは通常、テキスト文字列とオプションのペイロード（メッセージの内容を明確にするデータ）で構成されます。ゲームでの典型的なメッセージはKEY_PRESSED_ENTERです。 パブリッシャー: この要素はメッセージを発行し、すべてのサブスクライバーに送信します。 サブスクライバー: この要素は特定のメッセージを受信し、そのメッセージを受け取った結果として何らかのタスクを実行します。例えば、レーザーを発射するなどです。 この実装は非常に小規模ですが、非常に強力なパターンです。以下のように実装できます： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { thislisteners[message]forEach(l => l(message, payload))\n}\n}\n}\n```\n上記のコードを使用して、非常に小さな実装を作成できます：\n```javascript\n//set up a message structure\nconst Messages = {\nHERO_MOVE_LEFT: 'HERO_MOVE_LEFT'\n};\n//invoke the eventEmitter you set up above\nconst eventEmitter = new EventEmitter();\n//set up a hero\nconst hero = createHero(0,0);\n//let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 745,
    "chunk_index": 16,
    "total_chunks": 19
  },
  {
    "id": "2f797a7614a0a7da3fef48b36a665c2b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { thislisteners[message]forEach(l => l(message, payload)) } } } ``` 上記のコードを使用して、非常に小さな実装を作成できます： ```javascript //set up a message structure const Messages = { HERO_MOVE_LEFT: 'HERO_MOVE_LEFT' }; //invoke the eventEmitter you set up above const eventEmitter = new EventEmitter(); //set up a hero const hero = createHero(0,0); //let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it eventEmitteron(Messages HERO_MOVE_LEFT, () => {\nhero move(5,0);\n});\n//set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left\nwindow addEventListener('keyup', (evt) => {\nif (evt key === 'ArrowLeft') {\neventEmitter emit(Messages HERO_MOVE_LEFT)\n}\n});\n```\n上記では、キーボードイベントArrowLeftを接続し、HERO_MOVE_LEFTメッセージを送信しています。そのメッセージを受信して、結果としてheroを移動させます。このパターンの強みは、イベントリスナーとヒーローが互いを知らないことです。ArrowLeftをAキーに再マッピングすることもできます。また、イベントEmitterのon関数を少し編集することで、ArrowLeftで完全に異なる動作を行うことも可能です：\njavascript\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 395,
    "chunk_index": 17,
    "total_chunks": 19
  },
  {
    "id": "bf777bd284c414754d470cd356a9e5d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート1: はじめに",
    "content": "the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it eventEmitteron(Messages HERO_MOVE_LEFT, () => { hero move(5,0); }); //set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left window addEventListener('keyup', (evt) => { if (evt key === 'ArrowLeft') { eventEmitter emit(Messages HERO_MOVE_LEFT) } }); ``` 上記では、キーボードイベントArrowLeftを接続し、HERO_MOVE_LEFTメッセージを送信しています。そのメッセージを受信して、結果としてheroを移動させます。このパターンの強みは、イベントリスナーとヒーローが互いを知らないことです。ArrowLeftをAキーに再マッピングすることもできます。また、イベントEmitterのon関数を少し編集することで、ArrowLeftで完全に異なる動作を行うことも可能です： javascript eventEmitter on(Messages HERO_MOVE_LEFT, () => { heromove(5,0);\n});\nゲームが成長して複雑になるにつれて、このパターンの複雑さは変わらず、コードはきれいなままです。このパターンを採用することを強くお勧めします。\n🚀 チャレンジ\nPub/Subパターンがゲームをどのように強化できるか考えてみましょう。どの部分がイベントを発行すべきで、ゲームはそれにどう反応すべきでしょうか？新しいゲームを考え、その部分がどのように振る舞うかを創造的に考えるチャンスです。\n講義後クイズ\n講義後クイズ\n復習と自己学習\nPub/Subについてさらに学ぶには、こちらの記事を読むことをお勧めします。\n課題\nゲームをモックアップする\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11426,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 763,
    "chunk_index": 18,
    "total_chunks": 19
  },
  {
    "id": "025b1a6e1fda318b4baf7ccfb2fa03aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "コードにコメントを追加しよう",
    "content": "コードにコメントを追加しよう\n手順\nゲームフォルダ内の現在の /app.js ファイルを確認し、コメントを追加したり整理したりする方法を見つけてください。コードはすぐに散らかりがちなので、今がコメントを追加して読みやすいコードにする良い機会です。後で再利用できるようにしておきましょう。\n評価基準\n| 基準     | 優秀                                                              | 適切                                | 改善が必要                                                      |\n| -------- | ------------------------------------------------------------------ | ----------------------------------- | -------------------------------------------------------------- |\n|          | app.js のコードが完全にコメントされ、論理的なブロックに整理されている | app.js のコードが適切にコメントされている | app.js のコードがやや整理されておらず、良いコメントが不足している |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1966,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 459,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "5daa5fd3fdd084d46056aab9ab52bd3b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 0,
    "total_chunks": 24
  },
  {
    "id": "480b733ff1a7e7a19c3a0655ab704ce6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = documentgetElementById(\"myCanvas\");\n//2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 1,
    "total_chunks": 24
  },
  {
    "id": "1dbf06d60fb0fc53052e172db307c5ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = documentgetElementById(\"myCanvas\");\n//2set the context to 2D to draw basic shapes\nctx = canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 522,
    "chunk_index": 2,
    "total_chunks": 24
  },
  {
    "id": "cbe1b35eb684ef8667e194bea61dfb42",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = documentgetElementById(\"myCanvas\");\n//2set the context to 2D to draw basic shapes\nctx = canvasgetContext(\"2d\");\n//3",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 3,
    "total_chunks": 24
  },
  {
    "id": "19964c42468258391dbacf08acb02162",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = documentgetElementById(\"myCanvas\");\n//2set the context to 2D to draw basic shapes\nctx = canvasgetContext(\"2d\");\n//3fill it with the color red\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 537,
    "chunk_index": 4,
    "total_chunks": 24
  },
  {
    "id": "95845580ffd067e6e6d1e98c6208a5bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = documentgetElementById(\"myCanvas\");\n//2set the context to 2D to draw basic shapes\nctx = canvasgetContext(\"2d\");\n//3fill it with the color red\nctxfillStyle = 'red';\n//4",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 5,
    "total_chunks": 24
  },
  {
    "id": "e641bb202632af8d9dbc97546a08a6f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する\n講義前のクイズ\n講義前のクイズ\nキャンバス\nキャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。\n✅ Canvas APIについてもっと読む (MDN)\n通常、キャンバスはページのbody部分で以下のように宣言されます:\n```html\n```\n上記では、id、width、heightを設定しています。\nid: キャンバスにアクセスして操作するための参照を取得するために設定します。\nwidth: 要素の幅を指定します。\nheight: 要素の高さを指定します。\n簡単な図形を描画する\nキャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。\n画像提供: MDN\nキャンバス要素に描画するには、以下の手順を踏む必要があります:\nキャンバス要素の参照を取得する。\nキャンバス上のコンテキスト要素の参照を取得する。\nコンテキスト要素を使って描画操作を実行する。\n上記の手順を実現するコードは通常以下のようになります:\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = documentgetElementById(\"myCanvas\");\n//2set the context to 2D to draw basic shapes\nctx = canvasgetContext(\"2d\");\n//3fill it with the color red\nctxfillStyle = 'red';\n//4and draw a rectangle with these parameters, setting location and size\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 559,
    "chunk_index": 6,
    "total_chunks": 24
  },
  {
    "id": "b31274fd322f7894ff457cb717d98179",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "パート2: ヒーローとモンスターをキャンバスに描画する 講義前のクイズ 講義前のクイズ キャンバス キャンバスはHTMLの要素で、デフォルトでは何も内容がありません。真っ白な状態です。描画することで内容を追加します。 ✅ Canvas APIについてもっと読む (MDN) 通常、キャンバスはページのbody部分で以下のように宣言されます: ```html ``` 上記では、id、width、heightを設定しています。 id: キャンバスにアクセスして操作するための参照を取得するために設定します。 width: 要素の幅を指定します。 height: 要素の高さを指定します。 簡単な図形を描画する キャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。 画像提供: MDN キャンバス要素に描画するには、以下の手順を踏む必要があります: キャンバス要素の参照を取得する。 キャンバス上のコンテキスト要素の参照を取得する。 コンテキスト要素を使って描画操作を実行する。 上記の手順を実現するコードは通常以下のようになります: ```javascript // draws a red rectangle //1 get the canvas reference canvas = documentgetElementById(\"myCanvas\"); //2set the context to 2D to draw basic shapes ctx = canvasgetContext(\"2d\"); //3fill it with the color red ctxfillStyle = 'red'; //4and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height\n```\n✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。\nCanvas APIを使えば、以下のようなものを描画できます:\n幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。\nテキスト: 任意のフォントや色でテキストを描画できます。\n画像: 例えば",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 717,
    "chunk_index": 7,
    "total_chunks": 24
  },
  {
    "id": "d82e17c5986cc7dfd7f617082398384f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "height: 要素の高さを指定します。 簡単な図形を描画する キャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。 画像提供: MDN キャンバス要素に描画するには、以下の手順を踏む必要があります: キャンバス要素の参照を取得する。 キャンバス上のコンテキスト要素の参照を取得する。 コンテキスト要素を使って描画操作を実行する。 上記の手順を実現するコードは通常以下のようになります: ```javascript // draws a red rectangle //1 get the canvas reference canvas = documentgetElementById(\"myCanvas\"); //2set the context to 2D to draw basic shapes ctx = canvasgetContext(\"2d\"); //3fill it with the color red ctxfillStyle = 'red'; //4and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。 Canvas APIを使えば、以下のようなものを描画できます: 幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。 テキスト: 任意のフォントや色でテキストを描画できます。 画像: 例えばjpgや",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 8,
    "total_chunks": 24
  },
  {
    "id": "86ddd643360508827923bb71f8861691",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "height: 要素の高さを指定します。 簡単な図形を描画する キャンバスはデカルト座標系を使用して描画を行います。そのため、x軸とy軸を使って位置を表現します。座標0,0は左上の位置を示し、右下はキャンバスの幅と高さで指定した位置になります。 画像提供: MDN キャンバス要素に描画するには、以下の手順を踏む必要があります: キャンバス要素の参照を取得する。 キャンバス上のコンテキスト要素の参照を取得する。 コンテキスト要素を使って描画操作を実行する。 上記の手順を実現するコードは通常以下のようになります: ```javascript // draws a red rectangle //1 get the canvas reference canvas = documentgetElementById(\"myCanvas\"); //2set the context to 2D to draw basic shapes ctx = canvasgetContext(\"2d\"); //3fill it with the color red ctxfillStyle = 'red'; //4and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。 Canvas APIを使えば、以下のようなものを描画できます: 幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。 テキスト: 任意のフォントや色でテキストを描画できます。 画像: 例えばjpgやpngなどの画像アセットを基に画像を描画できます。\n✅ 試してみましょう！長方形の描き方を学びましたが、円をページに描画できますか？CodePenで興味深いCanvasの描画例を見てみましょう。特に印象的な例はこちら。\n画像アセットを読み込んで描画する\n画像アセットを読み込むには、Imageオブジェクトを作成し、そのsrcプロパティを設定します。その後、loadイベントを監視して使用可能になったことを確認します。コードは以下のようになります:\nアセットの読み込み\njavascript\nconst img = new Image();\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 719,
    "chunk_index": 9,
    "total_chunks": 24
  },
  {
    "id": "52e5aeeb5edd7a8ee31f45aa9b9cd213",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "// draws a red rectangle //1 get the canvas reference canvas = documentgetElementById(\"myCanvas\"); //2set the context to 2D to draw basic shapes ctx = canvasgetContext(\"2d\"); //3fill it with the color red ctxfillStyle = 'red'; //4and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。 Canvas APIを使えば、以下のようなものを描画できます: 幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。 テキスト: 任意のフォントや色でテキストを描画できます。 画像: 例えばjpgやpngなどの画像アセットを基に画像を描画できます。 ✅ 試してみましょう！長方形の描き方を学びましたが、円をページに描画できますか？CodePenで興味深いCanvasの描画例を見てみましょう。特に印象的な例はこちら。 画像アセットを読み込んで描画する 画像アセットを読み込むには、Imageオブジェクトを作成し、そのsrcプロパティを設定します。その後、loadイベントを監視して使用可能になったことを確認します。コードは以下のようになります: アセットの読み込み javascript const img = new Image(); imgsrc = 'path/to/my/image png';\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 10,
    "total_chunks": 24
  },
  {
    "id": "48d999130e1fc5832872d8c62c26b962",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "rectangle //1 get the canvas reference canvas = documentgetElementById(\"myCanvas\"); //2set the context to 2D to draw basic shapes ctx = canvasgetContext(\"2d\"); //3fill it with the color red ctxfillStyle = 'red'; //4and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。 Canvas APIを使えば、以下のようなものを描画できます: 幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。 テキスト: 任意のフォントや色でテキストを描画できます。 画像: 例えばjpgやpngなどの画像アセットを基に画像を描画できます。 ✅ 試してみましょう！長方形の描き方を学びましたが、円をページに描画できますか？CodePenで興味深いCanvasの描画例を見てみましょう。特に印象的な例はこちら。 画像アセットを読み込んで描画する 画像アセットを読み込むには、Imageオブジェクトを作成し、そのsrcプロパティを設定します。その後、loadイベントを監視して使用可能になったことを確認します。コードは以下のようになります: アセットの読み込み javascript const img = new Image(); imgsrc = 'path/to/my/image png'; imgonload = () => {\n// image loaded and ready to be used\n}\nアセット読み込みのパターン\n上記を以下のような構造にラップすることを推奨します。これにより使いやすくなり、完全に読み込まれた後でのみ操作を試みることができます:\n```javascript\nfunction loadAsset(path) {\nreturn new Promise((resolve) => {\nconst img = new Image();\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 11,
    "total_chunks": 24
  },
  {
    "id": "78fdb778cabf3ade98e68798f7e08b87",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "//4and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。 Canvas APIを使えば、以下のようなものを描画できます: 幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。 テキスト: 任意のフォントや色でテキストを描画できます。 画像: 例えばjpgやpngなどの画像アセットを基に画像を描画できます。 ✅ 試してみましょう！長方形の描き方を学びましたが、円をページに描画できますか？CodePenで興味深いCanvasの描画例を見てみましょう。特に印象的な例はこちら。 画像アセットを読み込んで描画する 画像アセットを読み込むには、Imageオブジェクトを作成し、そのsrcプロパティを設定します。その後、loadイベントを監視して使用可能になったことを確認します。コードは以下のようになります: アセットの読み込み javascript const img = new Image(); imgsrc = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } アセット読み込みのパターン 上記を以下のような構造にラップすることを推奨します。これにより使いやすくなり、完全に読み込まれた後でのみ操作を試みることができます: ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path;\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 12,
    "total_chunks": 24
  },
  {
    "id": "8f485103284a416f94ccb073e19d50e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas APIは主に2D図形に焦点を当てていますが、Webサイトに3D要素を描画することも可能です。その場合はWebGL APIを使用します。 Canvas APIを使えば、以下のようなものを描画できます: 幾何学的な図形: すでに長方形の描画方法を紹介しましたが、他にも多くの図形を描画できます。 テキスト: 任意のフォントや色でテキストを描画できます。 画像: 例えばjpgやpngなどの画像アセットを基に画像を描画できます。 ✅ 試してみましょう！長方形の描き方を学びましたが、円をページに描画できますか？CodePenで興味深いCanvasの描画例を見てみましょう。特に印象的な例はこちら。 画像アセットを読み込んで描画する 画像アセットを読み込むには、Imageオブジェクトを作成し、そのsrcプロパティを設定します。その後、loadイベントを監視して使用可能になったことを確認します。コードは以下のようになります: アセットの読み込み javascript const img = new Image(); imgsrc = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } アセット読み込みのパターン 上記を以下のような構造にラップすることを推奨します。これにより使いやすくなり、完全に読み込まれた後でのみ操作を試みることができます: ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path; imgonload = () => {\n// image loaded and ready to be used\nresolve(img);\n}\n})\n}\n// use like so\nasync function run() {\nconst heroImg = await loadAsset('hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 578,
    "chunk_index": 13,
    "total_chunks": 24
  },
  {
    "id": "b1edc09f8881adeb6728f966fb0868ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "画像アセットを読み込んで描画する 画像アセットを読み込むには、Imageオブジェクトを作成し、そのsrcプロパティを設定します。その後、loadイベントを監視して使用可能になったことを確認します。コードは以下のようになります: アセットの読み込み javascript const img = new Image(); imgsrc = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } アセット読み込みのパターン 上記を以下のような構造にラップすることを推奨します。これにより使いやすくなり、完全に読み込まれた後でのみ操作を試みることができます: ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path; imgonload = () => { // image loaded and ready to be used resolve(img); } }) } // use like so async function run() { const heroImg = await loadAsset('heropng')\nconst monsterImg = await loadAsset('monster png')\n}\n```\nゲームアセットを画面に描画するコードは以下のようになります:\n```javascript\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster png')\ncanvas = document getElementById(\"myCanvas\");\nctx = canvas getContext(\"2d\");\nctx drawImage(heroImg, canvas width/2,canvas height/2);\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 391,
    "chunk_index": 14,
    "total_chunks": 24
  },
  {
    "id": "763e878c663235cab45768bd29eb130c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "= new Image(); imgsrc = path; imgonload = () => { // image loaded and ready to be used resolve(img); } }) } // use like so async function run() { const heroImg = await loadAsset('heropng') const monsterImg = await loadAsset('monster png') } ``` ゲームアセットを画面に描画するコードは以下のようになります: ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0);\n}\n```\nいよいよゲーム作りを始めましょう\n作るもの\nキャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています:\nヒーローの船\n5*5のモンスター\n開発を始めるための推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです:\nbash\n-| assets\n-| enemyShip png\n-| player png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 346,
    "chunk_index": 15,
    "total_chunks": 24
  },
  {
    "id": "e7369e87871c903721faaafebe651478",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "async function run() { const heroImg = await loadAsset('heropng') const monsterImg = await loadAsset('monster png') } ``` ゲームアセットを画面に描画するコードは以下のようになります: ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0); } ``` いよいよゲーム作りを始めましょう 作るもの キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson\nこのフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。\nプロジェクトを開始するには、your_workフォルダに移動します:\nbash\ncd your-work\nnpm start\n上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。\n注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。\nコードを追加する\n以下を解決するためにyour-work/app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 16,
    "total_chunks": 24
  },
  {
    "id": "b6c54f7c0b2cef7127f783c0ab459669",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "``` ゲームアセットを画面に描画するコードは以下のようになります: ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0); } ``` いよいよゲーム作りを始めましょう 作るもの キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson このフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。 プロジェクトを開始するには、your_workフォルダに移動します: bash cd your-work npm start 上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。 注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。 コードを追加する 以下を解決するためにyour-work/appjsに必要なコードを追加してください:\nキャンバスを黒い背景で描画する\nヒント: /app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 582,
    "chunk_index": 17,
    "total_chunks": 24
  },
  {
    "id": "1eb598862a841815c655fd5e11095cc6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0); } ``` いよいよゲーム作りを始めましょう 作るもの キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson このフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。 プロジェクトを開始するには、your_workフォルダに移動します: bash cd your-work npm start 上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。 注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。 コードを追加する 以下を解決するためにyour-work/appjsに必要なコードを追加してください: キャンバスを黒い背景で描画する ヒント: /appjsの適切なTODOの下に2行追加し、ctx要素を黒に設定し、左上の座標を0,0に、キャンバスの幅と高さをキャンバスのサイズに等しく設定します。\nテクスチャを読み込む\nヒント: await loadTextureを使用して画像パスを渡し、プレイヤーと敵の画像を追加します。まだ画面には表示されません！\n画面の下半分の中央にヒーローを描画する\nヒント: drawImage APIを使用してheroImgを画面に描画し、canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 734,
    "chunk_index": 18,
    "total_chunks": 24
  },
  {
    "id": "31516f5b10dfc48bb70257e9514fe42e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0); } ``` いよいよゲーム作りを始めましょう 作るもの キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson このフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。 プロジェクトを開始するには、your_workフォルダに移動します: bash cd your-work npm start 上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。 注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。 コードを追加する 以下を解決するためにyour-work/appjsに必要なコードを追加してください: キャンバスを黒い背景で描画する ヒント: /appjsの適切なTODOの下に2行追加し、ctx要素を黒に設定し、左上の座標を0,0に、キャンバスの幅と高さをキャンバスのサイズに等しく設定します。 テクスチャを読み込む ヒント: await loadTextureを使用して画像パスを渡し、プレイヤーと敵の画像を追加します。まだ画面には表示されません！ 画面の下半分の中央にヒーローを描画する ヒント: drawImage APIを使用してheroImgを画面に描画し、canvaswidth / 2 - 45とcanvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 732,
    "chunk_index": 19,
    "total_chunks": 24
  },
  {
    "id": "b86b20fe7584b280fc7c0cac636099b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "= await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0); } ``` いよいよゲーム作りを始めましょう 作るもの キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson このフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。 プロジェクトを開始するには、your_workフォルダに移動します: bash cd your-work npm start 上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。 注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。 コードを追加する 以下を解決するためにyour-work/appjsに必要なコードを追加してください: キャンバスを黒い背景で描画する ヒント: /appjsの適切なTODOの下に2行追加し、ctx要素を黒に設定し、左上の座標を0,0に、キャンバスの幅と高さをキャンバスのサイズに等しく設定します。 テクスチャを読み込む ヒント: await loadTextureを使用して画像パスを渡し、プレイヤーと敵の画像を追加します。まだ画面には表示されません！ 画面の下半分の中央にヒーローを描画する ヒント: drawImage APIを使用してheroImgを画面に描画し、canvaswidth / 2 - 45とcanvasheight - canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 726,
    "chunk_index": 20,
    "total_chunks": 24
  },
  {
    "id": "bb4d02ef8d0e312d0fda721ee710d241",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctxdrawImage(monsterImg, 0,0); } ``` いよいよゲーム作りを始めましょう 作るもの キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson このフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。 プロジェクトを開始するには、your_workフォルダに移動します: bash cd your-work npm start 上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。 注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。 コードを追加する 以下を解決するためにyour-work/appjsに必要なコードを追加してください: キャンバスを黒い背景で描画する ヒント: /appjsの適切なTODOの下に2行追加し、ctx要素を黒に設定し、左上の座標を0,0に、キャンバスの幅と高さをキャンバスのサイズに等しく設定します。 テクスチャを読み込む ヒント: await loadTextureを使用して画像パスを渡し、プレイヤーと敵の画像を追加します。まだ画面には表示されません！ 画面の下半分の中央にヒーローを描画する ヒント: drawImage APIを使用してheroImgを画面に描画し、canvaswidth / 2 - 45とcanvasheight - canvasheight / 4を設定します。\n5*5のモンスターを描画する\nヒント: 敵を画面に描画するコードをコメント解除します。その後、createEnemies関数に移動して構築します。\nまず、いくつかの定数を設定します:\n```javascript\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 836,
    "chunk_index": 21,
    "total_chunks": 24
  },
  {
    "id": "148b10e291eb57a117a00001d06a07e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "キャンバス要素を含むWebページを作成します。1024*768の黒い画面を描画します。以下の2つの画像を提供しています: ヒーローの船 5*5のモンスター 開発を始めるための推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです: bash -| assets -| enemyShip png -| player png -| index html -| app js -| packagejson このフォルダのコピーをVisual Studio Codeで開きます。ローカル開発環境をセットアップする必要があります。理想的には、Visual Studio CodeとNPM、Nodeがインストールされている状態です。コンピュータにnpmがセットアップされていない場合は、こちらで設定方法を確認してください。 プロジェクトを開始するには、your_workフォルダに移動します: bash cd your-work npm start 上記の操作で、http://localhost:5000アドレスでHTTPサーバーが開始されます。ブラウザを開き、そのアドレスを入力してください。現在は空白のページですが、これから変わります。 注意: 画面上の変更を確認するには、ブラウザをリフレッシュしてください。 コードを追加する 以下を解決するためにyour-work/appjsに必要なコードを追加してください: キャンバスを黒い背景で描画する ヒント: /appjsの適切なTODOの下に2行追加し、ctx要素を黒に設定し、左上の座標を0,0に、キャンバスの幅と高さをキャンバスのサイズに等しく設定します。 テクスチャを読み込む ヒント: await loadTextureを使用して画像パスを渡し、プレイヤーと敵の画像を追加します。まだ画面には表示されません！ 画面の下半分の中央にヒーローを描画する ヒント: drawImage APIを使用してheroImgを画面に描画し、canvaswidth / 2 - 45とcanvasheight - canvasheight / 4を設定します。 5*5のモンスターを描画する ヒント: 敵を画面に描画するコードをコメント解除します。その後、createEnemies関数に移動して構築します。 まず、いくつかの定数を設定します: ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\n```\n次に、モンスターの配列を画面に描画するループを作成します:\n```javascript\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 854,
    "chunk_index": 22,
    "total_chunks": 24
  },
  {
    "id": "be08171a8c018a3d395d132cb97167a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート2: ヒーローとモンスターをキャンバスに描画する",
    "content": "/appjsの適切なTODOの下に2行追加し、ctx要素を黒に設定し、左上の座標を0,0に、キャンバスの幅と高さをキャンバスのサイズに等しく設定します。 テクスチャを読み込む ヒント: await loadTextureを使用して画像パスを渡し、プレイヤーと敵の画像を追加します。まだ画面には表示されません！ 画面の下半分の中央にヒーローを描画する ヒント: drawImage APIを使用してheroImgを画面に描画し、canvaswidth / 2 - 45とcanvasheight - canvasheight / 4を設定します。 5*5のモンスターを描画する ヒント: 敵を画面に描画するコードをコメント解除します。その後、createEnemies関数に移動して構築します。 まず、いくつかの定数を設定します: ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; ``` 次に、モンスターの配列を画面に描画するループを作成します: ```javascript for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { ctxdrawImage(enemyImg, x, y);\n}\n}\n```\n結果\n完成した結果は以下のようになります:\n解答\nまずは自分で解決を試みてください。もし行き詰まった場合は、解答を確認してください。\n🚀 チャレンジ\n2Dに焦点を当てたCanvas APIについて学びました。WebGL APIを見て、3Dオブジェクトを描画してみてください。\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\nCanvas APIについてもっと学ぶには、こちらを読んでください。\n課題\nCanvas APIで遊んでみよう\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9855,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 811,
    "chunk_index": 23,
    "total_chunks": 24
  },
  {
    "id": "dbe4986aa3efdb74106ce180d08d8428",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\assignment.md",
    "source_type": "git_repo",
    "title": "衝突を探る",
    "content": "衝突を探る\n手順\n衝突の仕組みをよりよく理解するために、いくつかのアイテムが衝突する小さなゲームを作成してください。キー操作やマウスクリックでアイテムを動かし、衝突した際に何かが起こるようにしましょう。例えば、隕石が地球に衝突する場面や、バンパーカーのようなものを作ることができます。創造力を発揮してください！\n評価基準\n| 基準     | 優秀                                                                                                                     | 適切                          | 改善が必要         |\n| -------- | ------------------------------------------------------------------------------------------------------------------------ | ----------------------------- | ----------------- |\n|          | 完全に動作するコードサンプルが作成され、アイテムがキャンバスに描画され、基本的な衝突が発生し、反応が起こる               | コードが何らかの形で不完全    | コードが正常に動作しない |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2005,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ce8b3b5fc6dea89841298b9347c4ca1c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 401,
    "chunk_index": 0,
    "total_chunks": 107
  },
  {
    "id": "77ebf54c457e9164c0e8ecbabd3f8596",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 984,
    "chunk_index": 1,
    "total_chunks": 107
  },
  {
    "id": "080f6e517301710aa95df29dfb50bd79",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1082,
    "chunk_index": 2,
    "total_chunks": 107
  },
  {
    "id": "a86e9ebea41574812b84ac8920c93586",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1116,
    "chunk_index": 3,
    "total_chunks": 107
  },
  {
    "id": "c80cf89361c5949b45d88a202d646738",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = documentgetElementById('loginForm')\nconst user = loginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1127,
    "chunk_index": 4,
    "total_chunks": 107
  },
  {
    "id": "d847bf438a942e51b043cb805315bfec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = documentgetElementById('loginForm')\nconst user = loginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1128,
    "chunk_index": 5,
    "total_chunks": 107
  },
  {
    "id": "e2552f85c2332f814542fe1efb8f6aab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = documentgetElementById('loginForm')\nconst user = loginFormuservalue;\n}\nここでは、getElementById()を使用してフォーム要素を取得し、次にloginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1157,
    "chunk_index": 6,
    "total_chunks": 107
  },
  {
    "id": "8e50ea57ec63f2af721ae2257cdeeb47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = documentgetElementById('loginForm')\nconst user = loginFormuservalue;\n}\nここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1158,
    "chunk_index": 7,
    "total_chunks": 107
  },
  {
    "id": "f3adf5059fe81199b426708d62ab397e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = documentgetElementById('loginForm')\nconst user = loginFormuservalue;\n}\nここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。\n登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します:\njs\nasync function getAccount(user) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1309,
    "chunk_index": 8,
    "total_chunks": 107
  },
  {
    "id": "5d5a9ce572b3c3abc94f984a8a2f3b36",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "銀行アプリを作成するパート3: データの取得と使用方法\n講義前クイズ\n講義前クイズ\nはじめに\nすべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。\nこのレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。\n前提条件\nこのレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。\nサーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください:\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAXとデータ取得\n従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。\nウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。\nAJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。\n現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。\n課題\n前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください:\njs\nasync function login() {\nconst loginForm = documentgetElementById('loginForm')\nconst user = loginFormuservalue;\n}\nここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。\n登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します:\njs\nasync function getAccount(user) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user));\nreturn await responsejson();\n} catch (error) {\nreturn { error: error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1322,
    "chunk_index": 9,
    "total_chunks": 107
  },
  {
    "id": "aea86e904713dda871a240915ce07351",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "講義前クイズ はじめに すべてのウェブアプリケーションの中心にはデータがあります。データはさまざまな形を取りますが、その主な目的は常にユーザーに情報を表示することです。ウェブアプリがますますインタラクティブで複雑になる中で、ユーザーが情報にアクセスし、操作する方法はウェブ開発の重要な部分となっています。 このレッスンでは、サーバーから非同期でデータを取得し、そのデータを使用してHTMLをリロードせずにウェブページに情報を表示する方法を学びます。 前提条件 このレッスンのために、ウェブアプリのログインと登録フォーム部分を構築している必要があります。また、Node jsをインストールし、サーバーAPIをローカルで実行してアカウントデータを取得できるようにする必要があります。 サーバーが正しく動作しているかを確認するには、ターミナルで次のコマンドを実行してください: ```sh curl http://localhost:5000/api -> should return \"Bank API v1 00\" as a result ``` AJAXとデータ取得 従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。 ウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。 AJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。 現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。 課題 前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください: js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' };\n}\n}\nfetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。\n✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？\n次に、login関数を更新してgetAccountを使用します:\n```js\nasync function login() {\nconst loginForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1482,
    "chunk_index": 10,
    "total_chunks": 107
  },
  {
    "id": "ae2232dcb834c2df5e05c645ae6b276d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "``` AJAXとデータ取得 従来のウェブサイトでは、リンクを選択したりフォームを使用してデータを送信したりすると、HTMLページ全体をリロードして表示内容を更新します。新しいデータを読み込むたびに、ウェブサーバーは新しいHTMLページを返し、ブラウザがそれを処理する必要があります。このプロセスは現在のユーザー操作を中断し、リロード中の操作を制限します。このワークフローはマルチページアプリケーション（MPA）とも呼ばれます。 ウェブアプリケーションがより複雑でインタラクティブになるにつれて、AJAX（Asynchronous JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。 AJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。 現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。 課題 前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください: js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm')\nconst user = loginForm",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1123,
    "chunk_index": 11,
    "total_chunks": 107
  },
  {
    "id": "a4cdceb2dae7638a546a2a3f126445e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。 AJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。 現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。 課題 前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください: js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuser",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 897,
    "chunk_index": 12,
    "total_chunks": 107
  },
  {
    "id": "5cd3ec45fa6a86de2ce4b1dcd6abfa26",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "JavaScript and XML）と呼ばれる新しい技術が登場しました。この技術により、JavaScriptを使用してサーバーから非同期でデータを送受信し、HTMLページをリロードせずに更新することが可能になり、より高速な更新とスムーズなユーザー操作が実現しました。サーバーから新しいデータを受信すると、DOM APIを使用して現在のHTMLページをJavaScriptで更新できます。このアプローチは進化を遂げ、現在ではシングルページアプリケーション（SPA）と呼ばれています。 AJAXが最初に導入されたとき、非同期でデータを取得するために利用可能な唯一のAPIはXMLHttpRequestでした。しかし、現在のブラウザは、より便利で強力なFetch APIも実装しており、これはPromiseを使用し、JSONデータの操作に適しています。 現代のすべてのブラウザがFetch APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。 課題 前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください: js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue;\nconst data = await getAccount(user);\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 911,
    "chunk_index": 13,
    "total_chunks": 107
  },
  {
    "id": "26fa6df1eb7f13b24c67f90cdd3fd9e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "APIをサポートしていますが、ウェブアプリケーションを古いブラウザやレガシーブラウザで動作させたい場合は、caniusecomの互換性表を確認することをお勧めします。 課題 前回のレッスンでは、アカウントを作成するための登録フォームを実装しました。今回は、既存のアカウントを使用してログインし、そのデータを取得するコードを追加します。appjsファイルを開き、新しいlogin関数を追加してください: js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) {\nreturn console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 622,
    "chunk_index": 14,
    "total_chunks": 107
  },
  {
    "id": "11e2298f0aa5eeb08020ed51fd1069fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 451,
    "chunk_index": 15,
    "total_chunks": 107
  },
  {
    "id": "38fe2f16e5afa27d8442edb909521b78",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; } ここでは、getElementById()を使用してフォーム要素を取得し、次にloginFormuservalueで入力からユーザー名を取得します。すべてのフォームコントロールは、HTMLでname属性を使用して設定された名前をプロパティとしてフォームからアクセスできます。 登録時と同様に、サーバーリクエストを実行するための別の関数を作成しますが、今回はアカウントデータを取得します: js async function getAccount(user) { try { const response = await fetch('//localhost:5000/api/accounts/' + encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror);\n}\naccount = data;\nnavigate('/dashboard');\n}\n```\nまず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。\n次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します:\njs\nlet account = null;\nユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。\n最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します:\n```html\n```\n新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。\n次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます:\n```js\naccount = result;\nnavigate('/dashboard');\n```\n✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1010,
    "chunk_index": 16,
    "total_chunks": 107
  },
  {
    "id": "938807ac946f6faf4d180e3b2c39736e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 814,
    "chunk_index": 17,
    "total_chunks": 107
  },
  {
    "id": "f56ba736e6d14e910eb2531512b0fe36",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "encodeURIComponent(user)); return await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。\n> APIについてさらに学ぶには、この[レッスン](https://docs",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 932,
    "chunk_index": 18,
    "total_chunks": 107
  },
  {
    "id": "3b22d2f4dc33fcdbbb40b429561c8c49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 930,
    "chunk_index": 19,
    "total_chunks": 107
  },
  {
    "id": "c4b8b99900641b03bbcca2005fa5e366",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 943,
    "chunk_index": 20,
    "total_chunks": 107
  },
  {
    "id": "55912f7c4c32fdea388d67da6cb772fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WT",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 944,
    "chunk_index": 21,
    "total_chunks": 107
  },
  {
    "id": "772e43f168c784fc6498e65b9cb34a09",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "await responsejson(); } catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。\n## HTMLを更新してデータを表示する\nユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1013,
    "chunk_index": 22,
    "total_chunks": 107
  },
  {
    "id": "08ff1d8962fb179867b3df6cdf93efac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "catch (error) { return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます:\n- [`textContent`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1075,
    "chunk_index": 23,
    "total_chunks": 107
  },
  {
    "id": "60a0bbf5ccdc33c3ab349f53de944286",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1073,
    "chunk_index": 24,
    "total_chunks": 107
  },
  {
    "id": "41748c7fffd2d98e871dd73cabe185f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return { error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。\n- [`document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1210,
    "chunk_index": 25,
    "total_chunks": 107
  },
  {
    "id": "52691fbeca7811ae40cd04760eb7f46b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1214,
    "chunk_index": 26,
    "total_chunks": 107
  },
  {
    "id": "04e5aa5c62e2048a94f4ddf306890e17",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1216,
    "chunk_index": 27,
    "total_chunks": 107
  },
  {
    "id": "b0809311678b8724d0f9fba477061cf2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1233,
    "chunk_index": 28,
    "total_chunks": 107
  },
  {
    "id": "a688443354899d049c0e7452f3606e86",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1235,
    "chunk_index": 29,
    "total_chunks": 107
  },
  {
    "id": "195552855136e61cf30748ec0509cd75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ error: errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。\n✅ 要素の[`innerHTML`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1289,
    "chunk_index": 30,
    "total_chunks": 107
  },
  {
    "id": "5f8eb15526bdcd4c05b691d674fe76bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1288,
    "chunk_index": 31,
    "total_chunks": 107
  },
  {
    "id": "8176e1bfc4f76390a0a87a5e21dbf10d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1342,
    "chunk_index": 32,
    "total_chunks": 107
  },
  {
    "id": "c9f5df5f95b88cb122674670fcdc4093",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1344,
    "chunk_index": 33,
    "total_chunks": 107
  },
  {
    "id": "b7d1513289e46ef0a535539f79c3e3d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "errormessage || 'Unknown error' }; } } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。\n### 課題\n*ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。\nログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です:\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1562,
    "chunk_index": 34,
    "total_chunks": 107
  },
  {
    "id": "b163dfb46db8554c7090b7129e81bb1e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "} } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1555,
    "chunk_index": 35,
    "total_chunks": 107
  },
  {
    "id": "82adb6aedf6f6775902d874990153be2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "} } fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin```\nこの``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。\n`app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1618,
    "chunk_index": 36,
    "total_chunks": 107
  },
  {
    "id": "a94e2d61c3aac18067f95ff059f4f766",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "fetch APIを使用してサーバーから非同期でデータをリクエストしますが、今回はURL以外の追加パラメータは必要ありません。ここではデータをクエリするだけなので、デフォルトでfetchはGET HTTPリクエストを作成します。 ✅ encodeURIComponent()はURLの特殊文字をエスケープする関数です。この関数を呼び出さずにuser値をURLに直接使用した場合、どのような問題が発生する可能性があるでしょうか？ 次に、login関数を更新してgetAccountを使用します: ```js async function login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します:\n```js\nfunction updateElement(id, text) {\nconst element = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1661,
    "chunk_index": 37,
    "total_chunks": 107
  },
  {
    "id": "8c48fdd6b7203f5026c9f0c0ef45064d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "login() { const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id);\nelement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1486,
    "chunk_index": 38,
    "total_chunks": 107
  },
  {
    "id": "9d05c51be3a806f9369b8783a61ed3e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ const loginForm = documentgetElementById('loginForm') const user = loginFormuservalue; const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text;\n}\n```\nこの関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します:\n```js\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1583,
    "chunk_index": 39,
    "total_chunks": 107
  },
  {
    "id": "460ba4932a1125f4c327ae0adf9429f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "const data = await getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) {\nreturn updateElement('loginError', data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1572,
    "chunk_index": 40,
    "total_chunks": 107
  },
  {
    "id": "d13e467f4f32fa6ac7c9336ecc2751f1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "getAccount(user); if (dataerror) { return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror);\n}\n```\nこれで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1609,
    "chunk_index": 41,
    "total_chunks": 107
  },
  {
    "id": "d9f0a5587e2c2474eba94648aac81b02",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1624,
    "chunk_index": 42,
    "total_chunks": 107
  },
  {
    "id": "06120f09bfc4d34a6549826f7fbcbe8b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1625,
    "chunk_index": 43,
    "total_chunks": 107
  },
  {
    "id": "c1d5d79d53d7691acee8ad5b6b923083",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1625,
    "chunk_index": 44,
    "total_chunks": 107
  },
  {
    "id": "7cba6cb35b26f6937c47aaaeba6708e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1625,
    "chunk_index": 45,
    "total_chunks": 107
  },
  {
    "id": "647c6baa9dfcd1aa301fd96cbd61f65c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1635,
    "chunk_index": 46,
    "total_chunks": 107
  },
  {
    "id": "1552dd7576d03e66228b08d7a0ab3660",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-errorpng)\nこれでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1750,
    "chunk_index": 47,
    "total_chunks": 107
  },
  {
    "id": "5ac6d0d93bd7f298717e6c244c7e86b8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-errorpng) これでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1752,
    "chunk_index": 48,
    "total_chunks": 107
  },
  {
    "id": "1af808ad9573766453ea4f30adb46054",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "return consolelog('loginError', dataerror); } account = data; navigate('/dashboard'); } ``` まず、getAccountが非同期関数であるため、サーバーの結果を待つためにawaitキーワードを使用する必要があります。また、サーバーリクエストではエラーケースを処理する必要があります。ここではエラーメッセージをログに表示するだけにしておき、後で戻ってきます。 次に、データをどこかに保存して、後でダッシュボード情報を表示するために使用できるようにする必要があります。account変数がまだ存在しないため、ファイルの先頭にグローバル変数を作成します: js let account = null; ユーザーデータが変数に保存された後、既存のnavigate()関数を使用してログインページからダッシュボードに移動できます。 最後に、ログインフォームが送信されたときにlogin関数を呼び出すようにHTMLを変更します: ```html ``` 新しいアカウントを登録し、同じアカウントを使用してログインを試みることで、すべてが正しく動作していることを確認してください。 次の部分に進む前に、`register`関数を次のコードを追加して完成させることができます: ```js account = result; navigate('/dashboard'); ``` ✅ デフォルトでは、*同じドメインとポート*からのみサーバーAPIを呼び出すことができます。これはブラウザによって強制されるセキュリティメカニズムです。しかし、私たちのウェブアプリは`localhost:3000`で動作しているのに対し、サーバーAPIは`localhost:5000`で動作しています。それでもなぜ動作するのでしょうか？[クロスオリジンリソース共有（CORS）](https://developermozillaorg/docs/Web/HTTP/CORS)と呼ばれる技術を使用することで、サーバーが特定のドメインに対して例外を許可する特別なヘッダーをレスポンスに追加することで、クロスオリジンHTTPリクエストを実行することが可能です。 > APIについてさらに学ぶには、この[レッスン](https://docsmicrosoftcom/learn/modules/use-apis-discover-museum-art/WTmc_id=academic-77807-sagibbon)を参照してください。 ## HTMLを更新してデータを表示する ユーザーデータを取得したので、既存のHTMLを更新してそれを表示する必要があります。例えば、`documentgetElementById()`を使用してDOMから要素を取得する方法はすでに知っています。ベース要素を取得した後、以下のAPIを使用してその内容を変更したり子要素を追加したりできます: - [`textContent`](https://developermozillaorg/docs/Web/API/Node/textContent)プロパティを使用して要素のテキストを変更できます。この値を変更すると、要素のすべての子要素（存在する場合）が削除され、指定されたテキストに置き換えられます。そのため、特定の要素のすべての子要素を削除する効率的な方法として、空の文字列`''`を割り当てることもできます。 - [`documentcreateElement()`](https://developermozillaorg/docs/Web/API/Document/createElement)と[`append()`](https://developermozillaorg/docs/Web/API/ParentNode/append)メソッドを組み合わせて、新しい子要素を作成して添付できます。 ✅ 要素の[`innerHTML`](https://developermozillaorg/docs/Web/API/Element/innerHTML)プロパティを使用してHTML内容を変更することも可能ですが、これは[クロスサイトスクリプティング（XSS）](https://developermozillaorg/docs/Glossary/Cross-site_scripting)攻撃に対して脆弱であるため避けるべきです。 ### 課題 *ログイン*ページでダッシュボード画面に進む前に、もう1つやるべきことがあります。現在、存在しないユーザー名でログインしようとすると、コンソールにメッセージが表示されますが、通常のユーザーには何も変わらず、何が起こっているのか分かりません。 ログインフォームにエラーメッセージを表示するためのプレースホルダー要素を追加しましょう。適切な場所はログイン``の直前です: ```htmlLogin``` この``要素は空であり、何か内容を追加するまで画面には何も表示されません。また、`id`を指定してJavaScriptで簡単に取得できるようにしています。 `appjs`ファイルに戻り、新しいヘルパー関数`updateElement`を作成します: ```js function updateElement(id, text) { const element = documentgetElementById(id); elementtextContent = text; } ``` この関数は非常にシンプルです: 要素の*id*と*text*を指定すると、対応する`id`を持つDOM要素のテキスト内容を更新します。このメソッドを`login`関数内の以前のエラーメッセージの代わりに使用します: ```js if (dataerror) { return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-errorpng) これでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)と呼ばれるものを使用する必要があります。ここでは、アラートと呼ばれる特定のタイプのライブリージョンを使用します:\n```html\n```\n同じ動作を`register`関数のエラーにも実装してください（HTMLの更新を忘れないでください）。\n## ダッシュボードに情報を表示する\nこれまでに学んだ技術を使用して、ダッシュボードページにアカウント情報を表示する作業も行います。\nサーバーから受信したアカウントオブジェクトは次のようになります:\n```json\n{\n\"user\": \"test\",\n\"currency\": \"$\",\n\"description\": \"Test account\",\n\"balance\": 75,\n\"transactions\": [\n{ \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 },\n{ \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 },\n{ \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 }\n],\n}\n```\n> 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。\n### 課題\nまず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます:\n```html\nBalance:\n```\nまた、アカウントの説明を表示するために、その下に新しいセクションを追加します:\n```html\n```\n✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2258,
    "chunk_index": 49,
    "total_chunks": 107
  },
  {
    "id": "e2e5be580e0379692bb629c18cc97086",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-errorpng) これでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)と呼ばれるものを使用する必要があります。ここでは、アラートと呼ばれる特定のタイプのライブリージョンを使用します: ```html ``` 同じ動作を`register`関数のエラーにも実装してください（HTMLの更新を忘れないでください）。 ## ダッシュボードに情報を表示する これまでに学んだ技術を使用して、ダッシュボードページにアカウント情報を表示する作業も行います。 サーバーから受信したアカウントオブジェクトは次のようになります: ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensa",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 50,
    "total_chunks": 107
  },
  {
    "id": "f12c31c61881074c6957018058fcf4c7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "{ return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-errorpng) これでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)と呼ばれるものを使用する必要があります。ここでは、アラートと呼ばれる特定のタイプのライブリージョンを使用します: ```html ``` 同じ動作を`register`関数のエラーにも実装してください（HTMLの更新を忘れないでください）。 ## ダッシュボードに情報を表示する これまでに学んだ技術を使用して、ダッシュボードページにアカウント情報を表示する作業も行います。 サーバーから受信したアカウントオブジェクトは次のようになります: ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。\n次に、`app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 784,
    "chunk_index": 51,
    "total_chunks": 107
  },
  {
    "id": "3b32806ea4993c100f479d99bb940874",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "return updateElement('loginError', dataerror); } ``` これで無効なアカウントでログインしようとすると、次のようなものが表示されるはずです:[ログイン中に表示されるエラーメッセージのスクリーンショット](////7-bank-project/3-data/images/login-errorpng) これでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)と呼ばれるものを使用する必要があります。ここでは、アラートと呼ばれる特定のタイプのライブリージョンを使用します: ```html ``` 同じ動作を`register`関数のエラーにも実装してください（HTMLの更新を忘れないでください）。 ## ダッシュボードに情報を表示する これまでに学んだ技術を使用して、ダッシュボードページにアカウント情報を表示する作業も行います。 サーバーから受信したアカウントオブジェクトは次のようになります: ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます:\n```js\nfunction updateDashboard() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 821,
    "chunk_index": 52,
    "total_chunks": 107
  },
  {
    "id": "49e9389c22d461c6afd1d8e16b70e811",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "これでエラーテキストが視覚的に表示されるようになりましたが、スクリーンリーダーで試してみると何もアナウンスされないことに気付くでしょう。ページに動的に追加されたテキストがスクリーンリーダーでアナウンスされるためには、[ライブリージョン](https://developermozillaorg/docs/Web/Accessibility/ARIA/ARIA_Live_Regions)と呼ばれるものを使用する必要があります。ここでは、アラートと呼ばれる特定のタイプのライブリージョンを使用します: ```html ``` 同じ動作を`register`関数のエラーにも実装してください（HTMLの更新を忘れないでください）。 ## ダッシュボードに情報を表示する これまでに学んだ技術を使用して、ダッシュボードページにアカウント情報を表示する作業も行います。 サーバーから受信したアカウントオブジェクトは次のようになります: ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) {\nreturn navigate('/login');\n}\nupdateElement('description', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 53,
    "total_chunks": 107
  },
  {
    "id": "7bd65ab924aedd8d5775c4143a66c6bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "これまでに学んだ技術を使用して、ダッシュボードページにアカウント情報を表示する作業も行います。 サーバーから受信したアカウントオブジェクトは次のようになります: ```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription);\nupdateElement('balance', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 523,
    "chunk_index": 54,
    "total_chunks": 107
  },
  {
    "id": "0b375e92a175af780a87b5bebb21200b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "```json { \"user\": \"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2));\nupdateElement('currency', account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 465,
    "chunk_index": 55,
    "total_chunks": 107
  },
  {
    "id": "96d58cb01fecc59c048b668d119f2aa5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "\"test\", \"currency\": \"$\", \"description\": \"Test account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency);\n}\n```\nまず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。\n> 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 549,
    "chunk_index": 56,
    "total_chunks": 107
  },
  {
    "id": "aea0c12d56591fc270df449dae9700bb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 538,
    "chunk_index": 57,
    "total_chunks": 107
  },
  {
    "id": "05dcd5a722713469c1d3bf1f9774083c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "account\", \"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。\n次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 631,
    "chunk_index": 58,
    "total_chunks": 107
  },
  {
    "id": "10d32eed6f1ae7e83c45e148b8bbe0c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "\"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 637,
    "chunk_index": 59,
    "total_chunks": 107
  },
  {
    "id": "93debb1fda7b8ada2bc35664ccda5f6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "\"balance\": 75, \"transactions\": [ { \"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。\n`updateRoute()`関数の最後に次のコードを追加します:\n```js\nif (typeof route",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 709,
    "chunk_index": 60,
    "total_chunks": 107
  },
  {
    "id": "46bd5dba62258807cf5f89f75b412b48",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "\"id\": \"1\", \"date\": \"2020-10-01\", \"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') {\nroute",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 703,
    "chunk_index": 61,
    "total_chunks": 107
  },
  {
    "id": "0a455a2456f6f33e5165ff08e669a1dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "\"object\": \"Pocket money\", \"amount\": 50 }, { \"id\": \"2\", \"date\": \"2020-10-03\", \"object\": \"Book\", \"amount\": -10 }, { \"id\": \"3\", \"date\": \"2020-10-04\", \"object\": \"Sandwich\", \"amount\": -5 } ], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit();\n}\n```\nそして、ルート定義を次のように更新します:\n```js\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: updateDashboard }\n};\n```\nこの変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。\n## HTMLテンプレートを使用してテーブル行を動的に作成する\n[最初のレッスン](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 845,
    "chunk_index": 62,
    "total_chunks": 107
  },
  {
    "id": "d063f884d38321b46f79dd71c7e2bb4d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/README",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 775,
    "chunk_index": 63,
    "total_chunks": 107
  },
  {
    "id": "a14187e243750e25ddddaa2cbd56e7fb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 795,
    "chunk_index": 64,
    "total_chunks": 107
  },
  {
    "id": "15d1d7dbc09926bd63ec79771acffd4b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 797,
    "chunk_index": 65,
    "total_chunks": 107
  },
  {
    "id": "1bd634849ca0c6fc01aea64b6085aed2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "], } ``` > 注: 既にデータが入力されている`test`アカウントを使用すると、作業が簡単になります。 ### 課題 まず、HTMLの\"Balance\"セクションをプレースホルダー要素に置き換えます: ```html Balance: ``` また、アカウントの説明を表示するために、その下に新しいセクションを追加します: ```html ``` ✅ アカウントの説明はその下の内容のタイトルとして機能するため、セマンティックに見出しとしてマークアップされています。[見出し構造](https://wwwnomensacom/blog/2017/how-structure-headings-web-accessibility)がアクセシビリティにとって重要である理由を学び、ページを批判的に見て他に見出しにできる部分がないか検討してください。 次に、`appjs`に新しい関数を作成してプレースホルダーを埋めます: ```js function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。\n同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。\n### 課題\nHTMLの``に新しいテンプレートを追加します:\n```html\n```\nこのテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。\n次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します:\n```html\n```\nHTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します:\n```js\nfunction createTransactionRow(transaction) {\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1121,
    "chunk_index": 66,
    "total_chunks": 107
  },
  {
    "id": "df53c95f82a76450fd30f0872799a477",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "function updateDashboard() { if (account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction');\nconst transactionRow = template",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 829,
    "chunk_index": 67,
    "total_chunks": 107
  },
  {
    "id": "a6861acb02ec7dcbbb474626cba0934b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "(account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontent",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 823,
    "chunk_index": 68,
    "total_chunks": 107
  },
  {
    "id": "cfbb367e93e2297952457831d68a6c3d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "(account) { return navigate('/login'); } updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true);\nconst tr = transactionRow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 832,
    "chunk_index": 69,
    "total_chunks": 107
  },
  {
    "id": "7343414279c6158787d0436a58add221",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "} updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr');\ntr",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 829,
    "chunk_index": 70,
    "total_chunks": 107
  },
  {
    "id": "cde145ba5f0377feafe984166b680e2a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 832,
    "chunk_index": 71,
    "total_chunks": 107
  },
  {
    "id": "1966a9886be5dcc3fa100343743db16b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "updateElement('description', accountdescription); updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transaction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 835,
    "chunk_index": 72,
    "total_chunks": 107
  },
  {
    "id": "9e8ff50cba132650d0f6c820b9e6122f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "updateElement('balance', accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate;\ntr",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 830,
    "chunk_index": 73,
    "total_chunks": 107
  },
  {
    "id": "6ec0607852cbddc6abbf1bcd0b38c3d3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 829,
    "chunk_index": 74,
    "total_chunks": 107
  },
  {
    "id": "db902ed1cef23e34fb2c50befcff7642",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "accountbalance toFixed(2)); updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transaction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 832,
    "chunk_index": 75,
    "total_chunks": 107
  },
  {
    "id": "86895c73e1cb573150efd5b012221e04",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "updateElement('currency', accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject;\ntr",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 828,
    "chunk_index": 76,
    "total_chunks": 107
  },
  {
    "id": "82efa3a0f0e0fb2c87e38a071d550328",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 827,
    "chunk_index": 77,
    "total_chunks": 107
  },
  {
    "id": "a39a9441e8e5345fd8bc5b0da174d060",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "accountcurrency); } ``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transaction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 830,
    "chunk_index": 78,
    "total_chunks": 107
  },
  {
    "id": "bb6459ee7eda6d5fc4e85ad8fad76160",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamount",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 827,
    "chunk_index": 79,
    "total_chunks": 107
  },
  {
    "id": "2775e05fe99ba19e81b15d40898e498c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "``` まず、必要なアカウントデータがあることを確認してから進みます。その後、先ほど作成した`updateElement()`関数を使用してHTMLを更新します。 > 残高表示をより見栄え良くするために、[`toFixed(2)`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)メソッドを使用して小数点以下2桁を強制的に表示します。 次に、ダッシュボードが読み込まれるたびに`updateDashboard()`関数を呼び出す必要があります。[レッスン1の課題](/1-template-route/assignmentmd)を既に完了している場合は簡単なはずです。そうでない場合は、次の実装を使用できます。 `updateRoute()`関数の最後に次のコードを追加します: ```js if (typeof routeinit === 'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2);\nreturn transactionRow;\n}\n```\nこの関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます:\n```js\nconst transactionsRows = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 938,
    "chunk_index": 80,
    "total_chunks": 107
  },
  {
    "id": "517ebae222e7ee1d0ce94d385ce4de0c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "'function') { routeinit(); } ``` そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment();\nfor (const transaction of account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 684,
    "chunk_index": 81,
    "total_chunks": 107
  },
  {
    "id": "f53ab58a1a2a6ffd66ed6fd12f135af3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "そして、ルート定義を次のように更新します: ```js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) {\nconst transactionRow = createTransactionRow(transaction);\ntransactionsRows",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 82,
    "total_chunks": 107
  },
  {
    "id": "88ecf610c8a330f44f8c090431212cbc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "'/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow);\n}\nupdateElement('transactions', transactionsRows);\n```\nここでは、[`document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 687,
    "chunk_index": 83,
    "total_chunks": 107
  },
  {
    "id": "e287e0136b493330c65b4b93d88e8182",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "'/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 684,
    "chunk_index": 84,
    "total_chunks": 107
  },
  {
    "id": "c3702457b5ef3d27475971bbd5c0dab0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "'/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 85,
    "total_chunks": 107
  },
  {
    "id": "dd66c4423470877cfd3718144ccd54a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "'/dashboard': { templateId: 'dashboard', init: updateDashboard } }; ``` この変更により、ダッシュボードページが表示されるたびに`updateDashboard()`関数が呼び出されます。ログイン後、アカウントの残高、通貨、説明が表示されるはずです。 ## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。\nこのコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります:\n```js\nfunction updateElement(id, textOrNode) {\nconst element = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 815,
    "chunk_index": 86,
    "total_chunks": 107
  },
  {
    "id": "f6fd42d0af094847f5be73fedf90a1d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "## HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id);\nelement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 87,
    "total_chunks": 107
  },
  {
    "id": "b87a80fefebf6637523b45759318a0e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "HTMLテンプレートを使用してテーブル行を動的に作成する [最初のレッスン](/1-template-route/READMEmd)では、HTMLテンプレートと[`appendChild()`](https://developermozillaorg/docs/Web/API/Node/appendChild)メソッドを使用してアプリのナビゲーションを実装しました。テンプレートはより小さく、ページの繰り返し部分を動的に埋めるためにも使用できます。 同様のアプローチを使用して、HTMLテーブル内のトランザクションリストを表示します。 ### 課題 HTMLの``に新しいテンプレートを追加します: ```html ``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children\nelement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 741,
    "chunk_index": 88,
    "total_chunks": 107
  },
  {
    "id": "187c5a0c53661e0c2253cfc34096ecbc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "``` このテンプレートは1つのテーブル行を表し、トランザクションの*日付*、*オブジェクト*、*金額*の3つの列を埋めるためのものです。 次に、JavaScriptで簡単に見つけられるように、ダッシュボードテンプレート内のテーブルの``要素にこの`id`プロパティを追加します: ```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode);\n}\n```\n[`append()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 558,
    "chunk_index": 89,
    "total_chunks": 107
  },
  {
    "id": "d2a9dac3d3ec11a109cf931248d63dd9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "```html ``` HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 467,
    "chunk_index": 90,
    "total_chunks": 107
  },
  {
    "id": "1b5956b743ce614b7e96188f16705ef0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "HTMLの準備が整ったので、JavaScriptコードに切り替えて新しい関数`createTransactionRow`を作成します: ```js function createTransactionRow(transaction) { const template = documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。\n`test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。\n---\n## 🚀 チャレンジ\n協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 636,
    "chunk_index": 91,
    "total_chunks": 107
  },
  {
    "id": "8b84b71985e83cec8ee0b873574e1558",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 586,
    "chunk_index": 92,
    "total_chunks": 107
  },
  {
    "id": "13a1948f0b39f98aa2121700adb733eb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 642,
    "chunk_index": 93,
    "total_chunks": 107
  },
  {
    "id": "20728c7fad0268155e8c8c9df72b0f7d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 644,
    "chunk_index": 94,
    "total_chunks": 107
  },
  {
    "id": "2cbf4cd877673031250657ffa0d12c49",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。\n以下はスタイリングされたダッシュボードページの例です：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 690,
    "chunk_index": 95,
    "total_chunks": 107
  },
  {
    "id": "373b1fedd43f3c7509cb5b2fb299a976",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 717,
    "chunk_index": 96,
    "total_chunks": 107
  },
  {
    "id": "32cc39a1e83620a044ed5be19586f4ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 718,
    "chunk_index": 97,
    "total_chunks": 107
  },
  {
    "id": "d2ebecd9382399aa30e37def28e50720",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 718,
    "chunk_index": 98,
    "total_chunks": 107
  },
  {
    "id": "c913d2ee568834aa3ebba320fcead267",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 718,
    "chunk_index": 99,
    "total_chunks": 107
  },
  {
    "id": "5abf0e9fe060979c4756b22e4720864f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 100,
    "total_chunks": 107
  },
  {
    "id": "760fd021389df0091ab3c86e4e85f192",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "documentgetElementById('transaction'); const transactionRow = templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2png)\n## 講義後のクイズ\n[講義後のクイズ](https://ashy-river-0debb7803",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 763,
    "chunk_index": 101,
    "total_chunks": 107
  },
  {
    "id": "9bb7a8aa9a3ec656d27dc2249a1ecd9c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2png) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 753,
    "chunk_index": 102,
    "total_chunks": 107
  },
  {
    "id": "f82ae4514a46e4c2027fba701d359dc1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2png) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 756,
    "chunk_index": 103,
    "total_chunks": 107
  },
  {
    "id": "fbdc0d7d7242e7fb3a76777f9395f480",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= templatecontentcloneNode(true); const tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2png) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/46)\n## 課題\n[コードをリファクタリングしてコメントを追加する](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 789,
    "chunk_index": 104,
    "total_chunks": 107
  },
  {
    "id": "50d2f9d37857334f0a27320ab9ed8163",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "tr = transactionRowquerySelector('tr'); trchildren[0]textContent = transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2png) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/46) ## 課題 [コードをリファクタリングしてコメントを追加する](assignmentmd)\n**免責事項**:\nこの文書は、AI翻訳サービス [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 816,
    "chunk_index": 105,
    "total_chunks": 107
  },
  {
    "id": "84b2707855996007bcb1628dcdda18d2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "銀行アプリを作成するパート3: データの取得と使用方法",
    "content": "= transactiondate; trchildren[1]textContent = transactionobject; trchildren[2]textContent = transactionamounttoFixed(2); return transactionRow; } ``` この関数はその名前が示す通りのことを行います: 先ほど作成したテンプレートを使用して新しいテーブル行を作成し、トランザクションデータを使用してその内容を埋めます。これを`updateDashboard()`関数内で使用してテーブルを埋めます: ```js const transactionsRows = documentcreateDocumentFragment(); for (const transaction of accounttransactions) { const transactionRow = createTransactionRow(transaction); transactionsRowsappendChild(transactionRow); } updateElement('transactions', transactionsRows); ``` ここでは、[`documentcreateDocumentFragment()`](https://developermozillaorg/docs/Web/API/Document/createDocumentFragment)メソッドを使用して新しいDOMフラグメントを作成し、それを操作してから最終的にHTMLテーブルに添付します。 このコードが動作するようにするには、`updateElement()`関数が現在テキストコンテンツのみをサポートしているため、少しコードを変更する必要があります: ```js function updateElement(id, textOrNode) { const element = documentgetElementById(id); elementtextContent = ''; // Removes all children elementappend(textOrNode); } ``` [`append()`](https://developermozilla org/docs/Web/API/ParentNode/append)メソッドを使用すると、テキストまたは[DOMノード](https://developer mozillaorg/docs/Web/API/Node)のいずれかを親要素に添付できるため、すべてのユースケースに適しています。 `test`アカウントを使用してログインを試みると、ダッシュボードに取引リストが表示されるはずです 🎉。 --- ## 🚀 チャレンジ 協力してダッシュボードページを本物の銀行アプリのように見えるようにしましょう。すでにアプリをスタイリングしている場合は、[メディアクエリ](https://developermozillaorg/docs/Web/CSS/Media_Queries)を使用して、デスクトップとモバイルデバイスの両方でうまく動作する[レスポンシブデザイン](https://developermozillaorg/docs/Web/Progressive_web_apps/Responsive/responsive_design_building_blocks)を作成してみてください。 以下はスタイリングされたダッシュボードページの例です：[スタイリング後のダッシュボードの例のスクリーンショット](////7-bank-project/images/screen2png) ## 講義後のクイズ [講義後のクイズ](https://ashy-river-0debb78031azurestaticappsnet/quiz/46) ## 課題 [コードをリファクタリングしてコメントを追加する](assignmentmd) **免責事項**: この文書は、AI翻訳サービス [Co-op Translator](https://githubcom/Azure/co-op-translator) を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された原文が正式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21369,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 977,
    "chunk_index": 106,
    "total_chunks": 107
  },
  {
    "id": "2405548c43c22a0d5833942718b42b7b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\assignment.md",
    "source_type": "git_repo",
    "title": "スコアリングゲームを作ろう",
    "content": "スコアリングゲームを作ろう\n手順\nライフとポイントを創造的に表示するゲームを作成してください。ライフをハートで表示し、ポイントを画面の下中央に大きな数字で表示するのがおすすめです。こちらを参考にしてください：無料ゲームリソース\n採点基準\n| 基準     | 優秀                   | 適切                       | 改善が必要                 |\n| -------- | ---------------------- | --------------------------- | -------------------------- |\n|          | 完全なゲームが提示されている | 部分的なゲームが提示されている | 部分的なゲームにバグが含まれている |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1610,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 407,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "505368668a4b5e2108d31a425bfe4e14",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 0,
    "total_chunks": 44
  },
  {
    "id": "2e97f079676504372048ee817a693974",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 503,
    "chunk_index": 1,
    "total_chunks": 44
  },
  {
    "id": "7f27d39816373612e3cd663b49d32001",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 2,
    "total_chunks": 44
  },
  {
    "id": "7465833235a9d97439b54dddc85e9f64",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 509,
    "chunk_index": 3,
    "total_chunks": 44
  },
  {
    "id": "08f24e4136ae67536cb6bd7e490d124a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 516,
    "chunk_index": 4,
    "total_chunks": 44
  },
  {
    "id": "47161e731d7b22d7ded840f3285ec874",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 522,
    "chunk_index": 5,
    "total_chunks": 44
  },
  {
    "id": "8e546e3bda6881da41f81d13c9b21b40",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 525,
    "chunk_index": 6,
    "total_chunks": 44
  },
  {
    "id": "1faec429f5675df514f9f7bc1d4cb4c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, heroy);\n✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。\nキーボードイベントを処理する\nイベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。\nイベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。\n以下は例です：\njavascript\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 840,
    "chunk_index": 7,
    "total_chunks": 44
  },
  {
    "id": "07a1c02f5c32efa589ad8dd8ac201230",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームを作ろう パート3: 動きを追加する\n講義前クイズ\n講義前クイズ\nゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します：\nキーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。\nゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。\nでは、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。\n通常、画面上で「動き」を実現するには以下のステップが必要です：\n新しい位置を設定する: オブジェクトが移動したように見えるために必要です。\n画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。\n新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。\n以下はコードの例です：\njavascript\n//set the hero's location\nhero x += 5;\n// clear the rectangle that hosts the hero\nctx clearRect(0, 0, canvas width, canvas height);\n// redraw the game background and hero\nctxfillRect(0, 0, canvaswidth, canvasheight)\nctxfillStyle = \"black\";\nctxdrawImage(heroImg, herox, heroy);\n✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。\nキーボードイベントを処理する\nイベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。\nイベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。\n以下は例です：\njavascript\nwindowaddEventListener('keyup', (evt) => {\n// `evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 852,
    "chunk_index": 8,
    "total_chunks": 44
  },
  {
    "id": "6f692b6cf6d6707fbc9a09b49416db80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "講義前クイズ ゲームは、画面上でエイリアンが動き回るようになって初めて面白くなります！このゲームでは、以下の2種類の動きを使用します： キーボード/マウスの動き: ユーザーがキーボードやマウスを操作して画面上のオブジェクトを動かす場合。 ゲームによる動き: ゲームが一定の時間間隔でオブジェクトを動かす場合。 では、画面上で物を動かすにはどうすればいいのでしょうか？それはすべてデカルト座標に関することです。オブジェクトの位置 (x, y) を変更し、画面を再描画します。 通常、画面上で「動き」を実現するには以下のステップが必要です： 新しい位置を設定する: オブジェクトが移動したように見えるために必要です。 画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。 新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。 以下はコードの例です： javascript //set the hero's location hero x += 5; // clear the rectangle that hosts the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。 キーボードイベントを処理する イベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。 イベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。 以下は例です： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key\nif (evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 829,
    "chunk_index": 9,
    "total_chunks": 44
  },
  {
    "id": "4f8d21e31e9a603bfe59d3c49a609dd4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "y) を変更し、画面を再描画します。 通常、画面上で「動き」を実現するには以下のステップが必要です： 新しい位置を設定する: オブジェクトが移動したように見えるために必要です。 画面をクリアする: 描画の間に画面をクリアする必要があります。背景色で塗りつぶした矩形を描画することでクリアできます。 新しい位置でオブジェクトを再描画する: これにより、オブジェクトをある位置から別の位置に移動させることができます。 以下はコードの例です： javascript //set the hero's location hero x += 5; // clear the rectangle that hosts the hero ctx clearRect(0, 0, canvas width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。 キーボードイベントを処理する イベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。 イベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。 以下は例です： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') {\n// do something\n}\n})\nキーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります：\nkey: 押されたキーの文字列表現（例: ArrowUp）\nkeyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。\n✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。\n特殊キー: 注意点\nウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です：\n```javascript\nlet onKeyDown = function (e) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 919,
    "chunk_index": 10,
    "total_chunks": 44
  },
  {
    "id": "037746275ea9df934c598916c73803cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。 キーボードイベントを処理する イベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。 イベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。 以下は例です： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) キーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります： key: 押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 11,
    "total_chunks": 44
  },
  {
    "id": "dbcbac61ec53e07a440e7bd36d3ff873",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "width, canvas height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。 キーボードイベントを処理する イベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。 イベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。 以下は例です： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) キーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります： key: 押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode);\nswitch (e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 693,
    "chunk_index": 12,
    "total_chunks": 44
  },
  {
    "id": "51febba258621a15f110c457a6a0ea2e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "height); // redraw the game background and hero ctxfillRect(0, 0, canvaswidth, canvasheight) ctxfillStyle = \"black\"; ctxdrawImage(heroImg, herox, heroy); ✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。 キーボードイベントを処理する イベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。 イベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。 以下は例です： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) キーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります： key: 押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) {\ncase 37:\ncase 39:\ncase 38:\ncase 40: // Arrow keys\ncase 32:\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 718,
    "chunk_index": 13,
    "total_chunks": 44
  },
  {
    "id": "9070c9ff5b3765c158649d24d840a6fb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "ctxdrawImage(heroImg, herox, heroy); ✅ ヒーローを1秒間に何フレームも再描画することで、パフォーマンスコストが発生する理由を考えられますか？このパターンの代替案について読んでみましょう。 キーボードイベントを処理する イベントは特定のコードに紐付けて処理します。キーボードイベントはウィンドウ全体でトリガーされますが、マウスイベント（例えば click）は特定の要素をクリックすることに紐付けることができます。このプロジェクトではキーボードイベントを使用します。 イベントを処理するには、ウィンドウの addEventListener() メソッドを使用し、2つの入力パラメータを提供する必要があります。1つ目のパラメータはイベント名（例: keyup）、2つ目のパラメータはイベントが発生した結果として呼び出されるべき関数です。 以下は例です： javascript windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) キーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります： key: 押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault();\nbreak; // Space\ndefault:\nbreak; // do not block other keys\n}\n};\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 14,
    "total_chunks": 44
  },
  {
    "id": "851699e2aa011c432f0d6ef00d9a7136",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "windowaddEventListener('keyup', (evt) => { // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) キーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります： key: 押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown);\n```\n上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 436,
    "chunk_index": 15,
    "total_chunks": 44
  },
  {
    "id": "09ecf476ccb7196b7419467012ef5c43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "{ // `evtkey` = string representation of the key if (evtkey === 'ArrowUp') { // do something } }) キーイベントでは、押されたキーを確認するために使用できる2つのプロパティがあります： key: 押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。\nゲームによる動き\nsetTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です：\njavascript\nlet id = setInterval(() => {\n//move the enemy on the y axis\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 16,
    "total_chunks": 44
  },
  {
    "id": "946d4184c841673e51c73242b60c4b58",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "押されたキーの文字列表現（例: ArrowUp） keyCode: 数値表現（例: 37）、これは ArrowLeft に対応します。 ✅ キーイベントの操作はゲーム開発以外でも役立ちます。この技術の他の用途を考えてみてください。 特殊キー: 注意点 ウィンドウに影響を与える特殊なキーがあります。つまり、keyup イベントを監視していて、これらの特殊キーを使ってヒーローを移動させると、水平スクロールも実行されます。そのため、ゲームを構築する際にはこのブラウザの組み込み動作を無効化する必要があります。以下のようなコードが必要です： ```javascript let onKeyDown = function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10;\n})\nゲームループ\nゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。\n以下は典型的なゲームループをコードで表現したものです：\njavascript\nlet gameLoopId = setInterval(() =>\nfunction gameLoop() {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 748,
    "chunk_index": 17,
    "total_chunks": 44
  },
  {
    "id": "458fdfcdc92ad76228e735009f4aa058",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "= function (e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 514,
    "chunk_index": 18,
    "total_chunks": 44
  },
  {
    "id": "f12a555680ebdbefd4dffb91eab36f5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "(e) { consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 514,
    "chunk_index": 19,
    "total_chunks": 44
  },
  {
    "id": "3b4c1e1fe33fe16f7dfec0fae09ce302",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "{ consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight);\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 515,
    "chunk_index": 20,
    "total_chunks": 44
  },
  {
    "id": "58c5c240ae5093d01ea874e1dde7598e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "consolelog(ekeyCode); switch (ekeyCode) { case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 21,
    "total_chunks": 44
  },
  {
    "id": "63d6b778acd12a6166a7bc2e88442d48",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "{ case 37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 520,
    "chunk_index": 22,
    "total_chunks": 44
  },
  {
    "id": "c4a095bc24fa6fe1a02b0f4652b800f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "37: case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 520,
    "chunk_index": 23,
    "total_chunks": 44
  },
  {
    "id": "9d142814785020a05a8dd2639b024162",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "case 39: case 38: case 40: // Arrow keys case 32: epreventDefault(); break; // Space default: break; // do not block other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight);\ndrawHero();\ndrawEnemies();\ndrawStaticObjects();\n}, 200);\n上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。\n宇宙ゲームの続き\n既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。\nヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。\n敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。\n推奨ステップ\nyour-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 776,
    "chunk_index": 24,
    "total_chunks": 44
  },
  {
    "id": "01b50d0300eed1b99d81df21b1e0929c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "other keys } }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 745,
    "chunk_index": 25,
    "total_chunks": 44
  },
  {
    "id": "ea1a9d8a3b2649ba35a9410a99c5f7fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "} }; windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 747,
    "chunk_index": 26,
    "total_chunks": 44
  },
  {
    "id": "5d82160c3faf3c3c09124f26cd3bfa3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "windowaddEventListener('keydown', onKeyDown); ``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 749,
    "chunk_index": 27,
    "total_chunks": 44
  },
  {
    "id": "e099d351b7a588bae47e649bd3caadff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "``` 上記のコードは、矢印キーとスペースキーのデフォルト動作を無効化します。この無効化メカニズムは、epreventDefault() を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 746,
    "chunk_index": 28,
    "total_chunks": 44
  },
  {
    "id": "959642240ceacb034eefcb2076fec2bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "を呼び出すことで実現されます。 ゲームによる動き setTimeout() や setInterval() 関数を使用して、一定の時間間隔でオブジェクトの位置を更新することで、物を自動的に動かすことができます。以下はその例です： javascript let id = setInterval(() => { //move the enemy on the y axis enemyy += 10; }) ゲームループ ゲームループは、定期的に呼び出される関数の概念です。ゲームループと呼ばれるのは、ユーザーに表示されるべきすべてのものがループ内で描画されるためです。ゲームループは、ゲームの一部であるすべてのゲームオブジェクトを使用し、それらを描画します。ただし、何らかの理由でゲームの一部ではなくなった場合は除外されます。例えば、敵がレーザーで撃たれて爆発した場合、その敵は現在のゲームループの一部ではなくなります（これについては後のレッスンで詳しく学びます）。 以下は典型的なゲームループをコードで表現したものです： javascript let gameLoopId = setInterval(() => function gameLoop() { ctxclearRect(0, 0, canvaswidth, canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson\nyour_work フォルダでプロジェクトを開始するには以下を入力してください：\nbash\ncd your-work\nnpm start\n上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！\nコードを追加する\n専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。\nヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。\nヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください：\n```javascript\nclass GameObject {\nconstructor(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1007,
    "chunk_index": 29,
    "total_chunks": 44
  },
  {
    "id": "feef4a66dd70f2f4111545dbec9eb1b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "canvasheight); ctxfillStyle = \"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 608,
    "chunk_index": 30,
    "total_chunks": 44
  },
  {
    "id": "e83682bcb37bc3852c4c86b5a67f3c6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "\"black\"; ctxfillRect(0, 0, canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 31,
    "total_chunks": 44
  },
  {
    "id": "670cfd765e9b24c42d008e930357761f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "canvaswidth, canvasheight); drawHero(); drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 599,
    "chunk_index": 32,
    "total_chunks": 44
  },
  {
    "id": "56a6dfe119b55cdc3bf27888022f2c0a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "drawEnemies(); drawStaticObjects(); }, 200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\";\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 595,
    "chunk_index": 33,
    "total_chunks": 44
  },
  {
    "id": "673c59981f6545473efeac78998a0ac5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "200); 上記のループは、200 ミリ秒ごとにキャンバスを再描画します。ゲームに最適な間隔を選択することができます。 宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 592,
    "chunk_index": 34,
    "total_chunks": 44
  },
  {
    "id": "fa54bf0182db6e66e0aea53e478adaeb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "宇宙ゲームの続き 既存のコードを拡張します。パートIで完成させたコードを使用するか、パートIIのスターターコードを使用してください。 ヒーローを動かす: 矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 35,
    "total_chunks": 44
  },
  {
    "id": "ed97e7a0c3963c78c4c9fbb87166cc1b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "矢印キーを使用してヒーローを動かせるようにコードを追加します。 敵を動かす: 敵が一定の速度で上から下へ移動するようにコードを追加します。 推奨ステップ your-work サブフォルダに作成されたファイルを見つけてください。以下が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined;\n}\ndraw(ctx) {\nctx drawImage(this img, this x, this y, this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 36,
    "total_chunks": 44
  },
  {
    "id": "9439e7bb473aed020243a386e0ee2a62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "-| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには以下を入力してください： bash cd your-work npm start 上記のコマンドは、http://localhost:5000 アドレスでHTTPサーバーを開始します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示されるはずですが、まだ何も動いていません！ コードを追加する 専用のオブジェクトを追加する: hero、enemy、game object を追加し、それぞれに x と y プロパティを持たせます。（継承またはコンポジション の部分を思い出してください）。 ヒント game object は x と y を持ち、キャンバスに自分自身を描画する能力を持つべきです。 ヒント: 以下のようにコンストラクタを定義した新しい GameObject クラスを追加し、キャンバスに描画してください： ```javascript class GameObject { constructor(x, y) { thisx = x; thisy = y; thisdead = false; thistype = \"\"; thiswidth = 0; thisheight = 0; thisimg = undefined; } draw(ctx) { ctx drawImage(this img, this x, this y, thiswidth, this height);\n}\n}\n```\n次に、この GameObject を拡張して Hero と Enemy を作成します。\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) { it needs an x, y, type, and speed\n}\n}\n```\n```javascript\nclass Enemy extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 98), (this height = 50);\nthis type = \"Enemy\";\nlet id = setInterval(() => {\nif (this y < canvas height - this height) {\nthis y += 5;\n} else {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 498,
    "chunk_index": 37,
    "total_chunks": 44
  },
  {
    "id": "50d663fb7447f9cd15edcb2ec39fde02",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "} ``` 次に、この GameObject を拡張して Hero と Enemy を作成します。 ```javascript class Hero extends GameObject { constructor(x, y) { it needs an x, y, type, and speed } } ``` ```javascript class Enemy extends GameObject { constructor(x, y) { super(x, y); (this width = 98), (this height = 50); this type = \"Enemy\"; let id = setInterval(() => { if (this y < canvas height - this height) { this y += 5; } else { consolelog('Stopped at', this y)\nclearInterval(id);\n}\n}, 300)\n}\n}\n```\nキーイベントハンドラを追加する: キー操作（ヒーローを上下左右に移動）を処理するコードを追加します。\n注意 デカルト座標系では、左上が 0,0 です。また、デフォルト動作を停止するコードを追加することを忘れないでください。\nヒント: onKeyDown 関数を作成し、それをウィンドウに紐付けます：\n```javascript\nlet onKeyDown = function (e) {\nconsole log(e keyCode); add the code from the lesson above to stop default behavior\n}\n};\nwindow addEventListener(\"keydown\", onKeyDown);\n```\nこの時点でブラウザのコンソールを確認し、キー入力がログに記録されるのを確認してください。\nPub sub パターン を実装する: 残りの部分を進める際にコードを整理するためにこれを使用します。\nこの最後の部分を行うには：\nウィンドウにイベントリスナーを追加する:\njavascript\nwindow addEventListener(\"keyup\", (evt) => {\nif (evt key === \"ArrowUp\") {\neventEmitter emit(Messages KEY_EVENT_UP);\n} else if (evt key === \"ArrowDown\") {\neventEmitter emit(Messages KEY_EVENT_DOWN);\n} else if (evt key === \"ArrowLeft\") {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 38,
    "total_chunks": 44
  },
  {
    "id": "ec685e31ace7250d49d2a7cf68f88574",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "0,0 です。また、デフォルト動作を停止するコードを追加することを忘れないでください。 ヒント: onKeyDown 関数を作成し、それをウィンドウに紐付けます： ```javascript let onKeyDown = function (e) { console log(e keyCode); add the code from the lesson above to stop default behavior } }; window addEventListener(\"keydown\", onKeyDown); ``` この時点でブラウザのコンソールを確認し、キー入力がログに記録されるのを確認してください。 Pub sub パターン を実装する: 残りの部分を進める際にコードを整理するためにこれを使用します。 この最後の部分を行うには： ウィンドウにイベントリスナーを追加する: javascript window addEventListener(\"keyup\", (evt) => { if (evt key === \"ArrowUp\") { eventEmitter emit(Messages KEY_EVENT_UP); } else if (evt key === \"ArrowDown\") { eventEmitter emit(Messages KEY_EVENT_DOWN); } else if (evt key === \"ArrowLeft\") { eventEmitter emit(MessagesKEY_EVENT_LEFT);\n} else if (evt key === \"ArrowRight\") {\neventEmitter emit(Messages KEY_EVENT_RIGHT);\n}\n});\nEventEmitter クラスを作成する: メッセージを発行および購読するために使用します：\n```javascript\nclass EventEmitter {\nconstructor() {\nthis listeners = {};\n}\non(message, listener) {\nif ( this listeners[message]) {\nthis listeners[message] = [];\n}\nthis listeners[message] push(listener);\n}\nemit(message, payload = null) {\nif (this listeners[message]) {\nthis listeners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 414,
    "chunk_index": 39,
    "total_chunks": 44
  },
  {
    "id": "54bcf92bde0fde0af24151d495c79669",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "} else if (evt key === \"ArrowDown\") { eventEmitter emit(Messages KEY_EVENT_DOWN); } else if (evt key === \"ArrowLeft\") { eventEmitter emit(MessagesKEY_EVENT_LEFT); } else if (evt key === \"ArrowRight\") { eventEmitter emit(Messages KEY_EVENT_RIGHT); } }); EventEmitter クラスを作成する: メッセージを発行および購読するために使用します： ```javascript class EventEmitter { constructor() { this listeners = {}; } on(message, listener) { if ( this listeners[message]) { this listeners[message] = []; } this listeners[message] push(listener); } emit(message, payload = null) { if (this listeners[message]) { this listeners[message]forEach((l) => l(message, payload));\n}\n}\n}\n```\n定数を追加し、EventEmitter を設定します：\n```javascript\nconst Messages = {\nKEY_EVENT_UP: \"KEY_EVENT_UP\",\nKEY_EVENT_DOWN: \"KEY_EVENT_DOWN\",\nKEY_EVENT_LEFT: \"KEY_EVENT_LEFT\",\nKEY_EVENT_RIGHT: \"KEY_EVENT_RIGHT\",\n};\nlet heroImg,\nenemyImg,\nlaserImg,\ncanvas, ctx,\ngameObjects = [],\nhero,\neventEmitter = new EventEmitter();\n```\nゲームを初期化する\n```javascript\nfunction initGame() {\ngameObjects = [];\ncreateEnemies();\ncreateHero();\neventEmitter on(Messages KEY_EVENT_UP, () => {\nhero y -=5 ;\n})\neventEmitter on(Messages KEY_EVENT_DOWN, () => {\nhero y += 5;\n});\neventEmitter on(Messages KEY_EVENT_LEFT, () => {\nhero x -= 5;\n});\neventEmitter on(Messages KEY_EVENT_RIGHT, () => {\nhero x += 5;\n});\n}\n```\nゲームループを設定する\nwindow onload 関数をリファクタリングしてゲームを初期化し、適切な間隔でゲームループを設定します。また、レーザービームを追加します：\n```javascript\nwindow onload = async () => {\ncanvas = document getElementById(\"canvas\");\nctx = canvas getContext(\"2d\");\nheroImg = await loadTexture(\"assets/player png\");\nenemyImg = await loadTexture(\"assets/enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 489,
    "chunk_index": 40,
    "total_chunks": 44
  },
  {
    "id": "1da400ce7511d8bfc6ec48be51f3b0a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "createHero(); eventEmitter on(Messages KEY_EVENT_UP, () => { hero y -=5 ; }) eventEmitter on(Messages KEY_EVENT_DOWN, () => { hero y += 5; }); eventEmitter on(Messages KEY_EVENT_LEFT, () => { hero x -= 5; }); eventEmitter on(Messages KEY_EVENT_RIGHT, () => { hero x += 5; }); } ``` ゲームループを設定する window onload 関数をリファクタリングしてゲームを初期化し、適切な間隔でゲームループを設定します。また、レーザービームを追加します： ```javascript window onload = async () => { canvas = document getElementById(\"canvas\"); ctx = canvas getContext(\"2d\"); heroImg = await loadTexture(\"assets/player png\"); enemyImg = await loadTexture(\"assets/enemyShippng\");\nlaserImg = await loadTexture(\"assets/laserRed png\");\ninitGame();\nlet gameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\ndrawGameObjects(ctx);\n}, 100)\n};\n```\n敵を一定間隔で動かすコードを追加する\ncreateEnemies() 関数をリファクタリングして敵を作成し、新しい gameObjects クラスに追加します：\n```javascript\nfunction createEnemies() {\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas width - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nconst enemy = new Enemy(x, y);\nenemy img = enemyImg;\ngameObjects",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 41,
    "total_chunks": 44
  },
  {
    "id": "6729426fd0d897beba0eace0905b1486",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "drawGameObjects(ctx); }, 100) }; ``` 敵を一定間隔で動かすコードを追加する createEnemies() 関数をリファクタリングして敵を作成し、新しい gameObjects クラスに追加します： ```javascript function createEnemies() { const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvas width - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { const enemy = new Enemy(x, y); enemy img = enemyImg; gameObjectspush(enemy);\n}\n}\n}\n```\nまた、ヒーロー用に同様のプロセスを行う createHero() 関数を追加します。\njavascript\nfunction createHero() {\nhero = new Hero(\ncanvas width / 2 - 45,\ncanvas height - canvas height / 4\n);\nhero img = heroImg;\ngameObjects push(hero);\n}\n最後に、描画を開始する drawGameObjects() 関数を追加します：\njavascript\nfunction drawGameObjects(ctx) {\ngameObjects forEach(go => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 305,
    "chunk_index": 42,
    "total_chunks": 44
  },
  {
    "id": "83f8b848060c8433317d278443d0df69",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート3: 動きを追加する",
    "content": "x += 98) { for (let y = 0; y < 50 * 5; y += 50) { const enemy = new Enemy(x, y); enemy img = enemyImg; gameObjectspush(enemy); } } } ``` また、ヒーロー用に同様のプロセスを行う createHero() 関数を追加します。 javascript function createHero() { hero = new Hero( canvas width / 2 - 45, canvas height - canvas height / 4 ); hero img = heroImg; gameObjects push(hero); } 最後に、描画を開始する drawGameObjects() 関数を追加します： javascript function drawGameObjects(ctx) { gameObjects forEach(go => godraw(ctx));\n}\n敵がヒーローの宇宙船に向かって進み始めるはずです！\n🚀 チャレンジ\nご覧の通り、関数や変数、クラスを追加していくとコードが「スパゲッティコード」になりがちです。コードをより読みやすくするために、どのように整理すればよいかを考え、スケッチしてみてください。たとえコードが1つのファイルに収まっていても構いません。\n講義後クイズ\n講義後クイズ\n復習と自己学習\nフレームワークを使用せずにゲームを作成していますが、ゲーム開発のためのJavaScriptベースのキャンバスフレームワークは多数存在します。これらについて調べてみましょう。\n課題\nコードにコメントを追加する\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16380,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\3-moving-elements-around\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 657,
    "chunk_index": 43,
    "total_chunks": 44
  },
  {
    "id": "f06fb46998df77a8c27b25d0a56ebf2b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\assignment.md",
    "source_type": "git_repo",
    "title": "サンプルゲームを作成する",
    "content": "サンプルゲームを作成する\n手順\n異なる終了条件を練習するために、小さなゲームを作ってみましょう。ポイントを一定数獲得する、ヒーローがすべてのライフを失う、またはすべてのモンスターが倒されるなど、終了条件を変えてみてください。コンソールベースの冒険ゲームのようなシンプルなものを作成してください。以下のゲームフローを参考にしてください:\nHero> Strikes with broadsword - orc takes 3p damage\nOrc> Hits with club - hero takes 2p damage\nHero> Kicks - orc takes 1p damage\nGame> Orc is defeated - Hero collects 2 coins\nGame> ****No more monsters, you have conquered the evil fortress****\n評価基準\n| 基準     | 優秀                   | 適切                        | 改善が必要                 |\n| -------- | ---------------------- | --------------------------- | -------------------------- |\n|          | 完全なゲームが提示されている | 部分的なゲームが提示されている | 部分的なゲームにバグが含まれている |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された原文が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2010,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 541,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ed124a9e05c19dfd02d26826b0871672",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 695,
    "chunk_index": 0,
    "total_chunks": 58
  },
  {
    "id": "9c720b461721eb2ec0bc540877b5b2a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 700,
    "chunk_index": 1,
    "total_chunks": 58
  },
  {
    "id": "621d09843b14e88a28e573710291e1d3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 705,
    "chunk_index": 2,
    "total_chunks": 58
  },
  {
    "id": "26ff971f7764f0755c5f89e95c72d698",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 3,
    "total_chunks": 58
  },
  {
    "id": "8a17ec110ec94274695edc7d11794c65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 713,
    "chunk_index": 4,
    "total_chunks": 58
  },
  {
    "id": "d122fb906165165f36eae6aacbaadd5e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 716,
    "chunk_index": 5,
    "total_chunks": 58
  },
  {
    "id": "8ab59e0e86d33d4cfdacf775c93099dd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 760,
    "chunk_index": 6,
    "total_chunks": 58
  },
  {
    "id": "369425cbd6b5bcedeb0a4c2001b37af9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 762,
    "chunk_index": 7,
    "total_chunks": 58
  },
  {
    "id": "221c32fc51bf13f1696d66e295784a8b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 766,
    "chunk_index": 8,
    "total_chunks": 58
  },
  {
    "id": "82d70b7d063433df9324dbf79b6b92d9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 770,
    "chunk_index": 9,
    "total_chunks": 58
  },
  {
    "id": "db2cf01b544a8b586714600af711b1da",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 774,
    "chunk_index": 10,
    "total_chunks": 58
  },
  {
    "id": "0aa88d627f1c58ac8bdb4d8b37923b4e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 778,
    "chunk_index": 11,
    "total_chunks": 58
  },
  {
    "id": "e32a25a5d18c17bf3e660bd65cfa44d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 782,
    "chunk_index": 12,
    "total_chunks": 58
  },
  {
    "id": "bbcf8c7d3226d60b5fa5a83008eb048c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 786,
    "chunk_index": 13,
    "total_chunks": 58
  },
  {
    "id": "1374fdaf30eb38c37a717f107e76e8dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 790,
    "chunk_index": 14,
    "total_chunks": 58
  },
  {
    "id": "d8d8f2accce3ab7e6141c1a657fc9394",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定\n講義前クイズ\n講義前クイズ\nこのレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します：\nレーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー\n衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\nつまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。\n✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？\n一緒にヒーローになりましょう！\n衝突判定\n衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。\nもし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です：\nゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの：\njavascript\nrectFromGameObject() {\nreturn {\ntop: thisy,\nleft: thisx,\nbottom: thisy + thisheight,\nright: thisx + thiswidth\n}\n}\n比較関数、この関数は以下のように見えるかもしれません：\njavascript\nfunction intersectRect(r1, r2) {\nreturn(r2left > r1right ||\nr2right < r1left ||\nr2top > r1bottom ||\nr2bottom < r1top);\n}\n物を破壊する方法\nゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです：\njavascript\n// collision happened\nenemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 901,
    "chunk_index": 15,
    "total_chunks": 58
  },
  {
    "id": "92dc8f00390b0713d0c6f9c6aec8ed39",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "レーザーの追加と衝突判定 講義前クイズ 講義前クイズ このレッスンでは、JavaScriptを使ってレーザーを発射する方法を学びます！ゲームに以下の2つを追加します： レーザー: ヒーローの宇宙船から垂直に上方向へ発射されるレーザー 衝突判定: 撃つ機能を実装する一環として、以下のようなゲームルールを追加します： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 つまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。 ✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？ 一緒にヒーローになりましょう！ 衝突判定 衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。 もし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です： ゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true\nその後、死んだオブジェクトを画面再描画の前に除外することができます：\njavascript\ngameObjects = gameObject",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 920,
    "chunk_index": 16,
    "total_chunks": 58
  },
  {
    "id": "37e88fe68e586f4435ed720f4894088d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "撃つ機能を実装する一環として、以下のようなゲームルールを追加します： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 つまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。 ✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？ 一緒にヒーローになりましょう！ 衝突判定 衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。 もし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です： ゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 796,
    "chunk_index": 17,
    "total_chunks": 58
  },
  {
    "id": "321f4ac092ee86d33e74b9f1e8b7b2a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 つまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。 ✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？ 一緒にヒーローになりましょう！ 衝突判定 衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。 もし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です： ゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 761,
    "chunk_index": 18,
    "total_chunks": 58
  },
  {
    "id": "733898e815a0e7f6e75583432446f664",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 つまり、あなた -- ヒーロー -- は、敵が画面下部に到達する前にレーザーで全ての敵を倒す必要があります。 ✅ 最初に作られたコンピュータゲームについて少し調べてみましょう。その機能はどのようなものでしたか？ 一緒にヒーローになりましょう！ 衝突判定 衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。 もし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です： ゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead);\nレーザーを発射する方法\nレーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します：\nレーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。\nキーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。\nレーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。\nレーザーのクールダウン\nレーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます：\n```javascript\nclass Cooldown {\nconstructor(time) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1128,
    "chunk_index": 19,
    "total_chunks": 58
  },
  {
    "id": "f71166d560bac1438f39e2dae8fa0589",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "衝突判定はどのように行うのでしょうか？ゲームオブジェクトを動く長方形として考える必要があります。なぜかというと、ゲームオブジェクトを描画するために使用される画像は長方形だからです：x、y、width、heightを持っています。 もし2つの長方形、例えばヒーローと敵が交差した場合、それは衝突が発生したことを意味します。その後に何が起こるべきかはゲームのルール次第です。衝突判定を実装するには以下が必要です： ゲームオブジェクトの長方形表現を取得する方法、例えば以下のようなもの： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false;\nsetTimeout(() => {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 872,
    "chunk_index": 20,
    "total_chunks": 58
  },
  {
    "id": "2bf9119057d2660adc2122bf7fd3eef2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth } } 比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true;\n}, time)\n}\n}\nclass Weapon {\nconstructor {\n}\nfire() {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 655,
    "chunk_index": 21,
    "total_chunks": 58
  },
  {
    "id": "74d7b004ada0ef8c9b9772b4c772406d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 625,
    "chunk_index": 22,
    "total_chunks": 58
  },
  {
    "id": "13668aeb41b5aa79751e762ab1502d26",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "比較関数、この関数は以下のように見えるかもしれません： javascript function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 628,
    "chunk_index": 23,
    "total_chunks": 58
  },
  {
    "id": "8b19bba6dd45799b8bb6b0fcbee21679",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldown",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 24,
    "total_chunks": 58
  },
  {
    "id": "678c6ec4214af0c0f29d2e933aa0e95b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "function intersectRect(r1, r2) { return(r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) {\n// produce a laser\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 610,
    "chunk_index": 25,
    "total_chunks": 58
  },
  {
    "id": "845ba7b26d8aef47954b3fe8260dee34",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top); } 物を破壊する方法 ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500);\n} else {\n// do nothing - it hasn't cooled down yet",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 615,
    "chunk_index": 26,
    "total_chunks": 58
  },
  {
    "id": "ca16f090fb1a32ab5cf7eb156f1289e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "ゲーム内で物を破壊するには、ゲームループでそのアイテムを描画しないようにする必要があります。これを行う方法の一つは、何かが起こったときにゲームオブジェクトを死んだとマークすることです： javascript // collision happened enemydead = true その後、死んだオブジェクトを画面再描画の前に除外することができます： javascript gameObjects = gameObjectfilter(go =>godead); レーザーを発射する方法 レーザーを発射するには、キーイベントに応答して特定の方向に移動するオブジェクトを作成する必要があります。そのため、以下の手順を実行します： レーザーオブジェクトを作成: ヒーローの宇宙船の上部から、作成と同時に画面上部に向かって移動を開始します。 キーイベントにコードを紐付ける: レーザー発射を表すキーボードのキーを選択します。 レーザーのように見えるゲームオブジェクトを作成: キーが押されたときに表示されるようにします。 レーザーのクールダウン レーザーはキー（例えばスペースキー）を押すたびに発射される必要があります。しかし、短時間で大量のレーザーが生成されるのを防ぐために、クールダウンと呼ばれるタイマーを実装します。これにより、レーザーは一定間隔でしか発射されなくなります。以下のように実装できます： ```javascript class Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet}\n}\n}\n```\n✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。\n作成するもの\n前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。\nヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。\n衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます：\nレーザーが敵に当たる: レーザーが敵に当たると敵が消滅\nレーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅\n敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅\n敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 970,
    "chunk_index": 27,
    "total_chunks": 58
  },
  {
    "id": "2dc7fc9e0597500e5f9c7f6da1ab5db2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "Cooldown { constructor(time) { thiscool = false; setTimeout(() => { thiscool = true; }, time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng\n-| player png\n-| laserRed png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 28,
    "total_chunks": 58
  },
  {
    "id": "8327a8c9e068d414208697d76d31e393",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "time) } } class Weapon { constructor { } fire() { if (thiscooldown || thiscooldowncool) { // produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson\nyour_workフォルダで以下を入力してプロジェクトを開始します：\nbash\ncd your-work\nnpm start\n上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。\nコードを追加\nゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください：\njavascript\nrectFromGameObject() {\nreturn {\ntop: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 675,
    "chunk_index": 29,
    "total_chunks": 58
  },
  {
    "id": "d5d14620768c0917538e47d92f8182a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "produce a laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy,\nleft: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 650,
    "chunk_index": 30,
    "total_chunks": 58
  },
  {
    "id": "2b9524d9243fc6f623907f1f9fb19108",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "laser thiscooldown = new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx,\nbottom: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 654,
    "chunk_index": 31,
    "total_chunks": 58
  },
  {
    "id": "17439165a16befccefc92b4574a21bd0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "= new Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 653,
    "chunk_index": 32,
    "total_chunks": 58
  },
  {
    "id": "abecec3674c9d8cfcb5247aa49dd97f7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "Cooldown(500); } else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight,\nright: this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 655,
    "chunk_index": 33,
    "total_chunks": 58
  },
  {
    "id": "eb2cf6d3b161aa94cc8652dfee044200",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "else { // do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 653,
    "chunk_index": 34,
    "total_chunks": 58
  },
  {
    "id": "53c5e55894f8535da8cbde6af9f2b0ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "// do nothing - it hasn't cooled down yet} } } ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth,\n};\n}\n衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります：\njavascript\nfunction intersectRect(r1, r2) {\nreturn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 715,
    "chunk_index": 35,
    "total_chunks": 58
  },
  {
    "id": "863f08aee38b58bfde371bf2284636d7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "} ``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return(\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 705,
    "chunk_index": 36,
    "total_chunks": 58
  },
  {
    "id": "b7cdbf134bb4963b4cdb2041c57e879f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "``` ✅ 宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 37,
    "total_chunks": 58
  },
  {
    "id": "c9ee563862165b72e67b77fcc0c5da7e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "宇宙ゲームシリーズのレッスン1を参照して、クールダウンについて復習しましょう。 作成するもの 前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 709,
    "chunk_index": 38,
    "total_chunks": 58
  },
  {
    "id": "55fca22d6ea75adc0baeee7ba93a6583",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "前回のレッスンで作成したコード（整理してリファクタリング済みのもの）を拡張します。パートIIのコードから始めるか、パートIIIのスターターコードを使用してください。 ヒント: 使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 660,
    "chunk_index": 39,
    "total_chunks": 58
  },
  {
    "id": "1cc44b8f7e858bf55d64ebd3a013391e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "使用するレーザーはすでにアセットフォルダにあり、コードで参照されています。 衝突判定を追加: レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 594,
    "chunk_index": 40,
    "total_chunks": 58
  },
  {
    "id": "b008448bea8880ac298968e7d4f51c9b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "レーザーが何かに衝突したとき、以下のルールが適用されます： レーザーが敵に当たる: レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 555,
    "chunk_index": 41,
    "total_chunks": 58
  },
  {
    "id": "269a88b2f626fc4293f5638876f761a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "レーザーが敵に当たると敵が消滅 レーザーが画面上部に当たる: レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom ||\nr2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 518,
    "chunk_index": 42,
    "total_chunks": 58
  },
  {
    "id": "982aea753050511262a6ea64e1d25a0e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "レーザーが画面上部に到達すると消滅 敵とヒーローが衝突: 敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 43,
    "total_chunks": 58
  },
  {
    "id": "114e7f9c162a5b91e79c0f34b9de4515",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "敵とヒーローが衝突すると両方消滅 敵が画面下部に到達: 敵が画面下部に到達すると敵とヒーローが消滅 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| player png -| laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top\n);\n}\nレーザー発射機能を追加\nキーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください：\njavascript\nKEY_EVENT_SPACE: \"KEY_EVENT_SPACE\",\nCOLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\",\nCOLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\",\nスペースキーを処理 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 44,
    "total_chunks": 58
  },
  {
    "id": "67b1a8f6df6ef551e5f9bd3dac1f0818",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "laserRed png -| index html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します：\njavascript\n} else if(evt",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 511,
    "chunk_index": 45,
    "total_chunks": 58
  },
  {
    "id": "3f5861678cbeb5c9b0969ca984d2a2f7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "html -| app js -| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) {\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 511,
    "chunk_index": 46,
    "total_chunks": 58
  },
  {
    "id": "50cfcc7f608e660ee32e3b4305176371",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "-| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 508,
    "chunk_index": 47,
    "total_chunks": 58
  },
  {
    "id": "5a20d69857987851adad4abbcc33e7c1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "-| packagejson your_workフォルダで以下を入力してプロジェクトを開始します： bash cd your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE);\n}\nリスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします：\njavascript\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 567,
    "chunk_index": 48,
    "total_chunks": 58
  },
  {
    "id": "a52eefe90dbd59c1611e8bc021e4e89f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE); } リスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします： javascript eventEmitteron(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 540,
    "chunk_index": 49,
    "total_chunks": 58
  },
  {
    "id": "5ee48c6fc36d4dc90758762a0d90bb2b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "your-work npm start 上記のコマンドは、アドレスhttp://localhost:5000でHTTPサーバーを起動します。ブラウザを開いてそのアドレスを入力してください。現在のところ、ヒーローと全ての敵が表示されますが、まだ何も動いていません。 コードを追加 ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE); } リスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします： javascript eventEmitteron(MessagesKEY_EVENT_SPACE, () => {\nif (hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 550,
    "chunk_index": 50,
    "total_chunks": 58
  },
  {
    "id": "b1fb8ff2900a16a6c67e80cb909db456",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "ゲームオブジェクトの長方形表現を設定して衝突を処理 以下のコードは、GameObjectの長方形表現を取得する方法を提供します。GameObjectクラスを編集して拡張してください： javascript rectFromGameObject() { return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE); } リスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします： javascript eventEmitteron(MessagesKEY_EVENT_SPACE, () => { if (herocanFire()) {\nhero fire();\n}\nまた、敵がレーザーに衝突したときの動作を確保するために新しいeventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 51,
    "total_chunks": 58
  },
  {
    "id": "4951eadfae03b3ec11540142a49b67b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "return { top: thisy, left: thisx, bottom: thisy + thisheight, right: thisx + thiswidth, }; } 衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE); } リスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします： javascript eventEmitteron(MessagesKEY_EVENT_SPACE, () => { if (herocanFire()) { hero fire(); } また、敵がレーザーに衝突したときの動作を確保するために新しいeventEmitteron()関数を追加します：\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 456,
    "chunk_index": 52,
    "total_chunks": 58
  },
  {
    "id": "488ddd72acc6d18a5393bdfa0838d8fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "衝突をチェックするコードを追加 これは2つの長方形が交差しているかをテストする新しい関数になります： javascript function intersectRect(r1, r2) { return( r2left > r1right || r2right < r1left || r2top > r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE); } リスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします： javascript eventEmitteron(MessagesKEY_EVENT_SPACE, () => { if (herocanFire()) { hero fire(); } また、敵がレーザーに衝突したときの動作を確保するために新しいeventEmitteron()関数を追加します： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; seconddead = true;\n})\n```\nオブジェクトを移動 レーザーが徐々に画面上部に移動するようにします。これには、GameObjectを拡張した新しいLaserクラスを作成します：\njavascript\nclass Laser extends GameObject {\nconstructor(x, y) {\nsuper(x,y);\n(this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 53,
    "total_chunks": 58
  },
  {
    "id": "9ccac2241698142c1afab02cef61e4b6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "> r1bottom || r2bottom < r1top ); } レーザー発射機能を追加 キーイベントメッセージを追加 スペースキーがヒーローの宇宙船のすぐ上にレーザーを作成するようにします。Messagesオブジェクトに以下の3つの定数を追加してください： javascript KEY_EVENT_SPACE: \"KEY_EVENT_SPACE\", COLLISION_ENEMY_LASER: \"COLLISION_ENEMY_LASER\", COLLISION_ENEMY_HERO: \"COLLISION_ENEMY_HERO\", スペースキーを処理 windowaddEventListenerのkeyup関数を編集してスペースキーを処理します： javascript } else if(evtkeyCode === 32) { eventEmitteremit(MessagesKEY_EVENT_SPACE); } リスナーを追加 initGame()関数を編集して、スペースキーが押されたときにヒーローが発射できるようにします： javascript eventEmitteron(MessagesKEY_EVENT_SPACE, () => { if (herocanFire()) { hero fire(); } また、敵がレーザーに衝突したときの動作を確保するために新しいeventEmitteron()関数を追加します： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; seconddead = true; }) ``` オブジェクトを移動 レーザーが徐々に画面上部に移動するようにします。これには、GameObjectを拡張した新しいLaserクラスを作成します： javascript class Laser extends GameObject { constructor(x, y) { super(x,y); (thiswidth = 9), (this height = 33);\nthis type = 'Laser';\nthis img = laserImg;\nlet id = setInterval(() => {\nif (this y > 0) {\nthis y -= 15;\n} else {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 479,
    "chunk_index": 54,
    "total_chunks": 58
  },
  {
    "id": "38f8a4dd1cb22b81ce7c8646fe0dfe47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "=> { if (herocanFire()) { hero fire(); } また、敵がレーザーに衝突したときの動作を確保するために新しいeventEmitteron()関数を追加します： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; seconddead = true; }) ``` オブジェクトを移動 レーザーが徐々に画面上部に移動するようにします。これには、GameObjectを拡張した新しいLaserクラスを作成します： javascript class Laser extends GameObject { constructor(x, y) { super(x,y); (thiswidth = 9), (this height = 33); this type = 'Laser'; this img = laserImg; let id = setInterval(() => { if (this y > 0) { this y -= 15; } else { thisdead = true;\nclearInterval(id);\n}\n}, 100)\n}\n}\n衝突を処理 レーザーの衝突ルールを実装します。衝突するオブジェクトをテストするupdateGameObjects()関数を追加します：\n```javascript\nfunction updateGameObjects() {\nconst enemies = gameObjects filter(go => go type === 'Enemy');\nconst lasers = gameObjects filter((go) => go type === \"Laser\");\n// laser hit something\nlasers forEach((l) => {\nenemies forEach((m) => {\nif (intersectRect(l rectFromGameObject(), m rectFromGameObject())) {\neventEmitter emit(Messages COLLISION_ENEMY_LASER, {\nfirst: l,\nsecond: m,\n});\n}\n});\n});\ngameObjects = gameObjects filter(go => go dead);\n}\n```\nupdateGameObjects()をwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 408,
    "chunk_index": 55,
    "total_chunks": 58
  },
  {
    "id": "864ace3ca41e8f93fcb63d712ff8dacc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "{ thisdead = true; clearInterval(id); } }, 100) } } 衝突を処理 レーザーの衝突ルールを実装します。衝突するオブジェクトをテストするupdateGameObjects()関数を追加します： ```javascript function updateGameObjects() { const enemies = gameObjects filter(go => go type === 'Enemy'); const lasers = gameObjects filter((go) => go type === \"Laser\"); // laser hit something lasers forEach((l) => { enemies forEach((m) => { if (intersectRect(l rectFromGameObject(), m rectFromGameObject())) { eventEmitter emit(Messages COLLISION_ENEMY_LASER, { first: l, second: m, }); } }); }); gameObjects = gameObjects filter(go => go dead); } ``` updateGameObjects()をwindowonloadのゲームループに追加することを忘れないでください。\nレーザーのクールダウンを実装 レーザーが一定間隔でしか発射されないようにします。\n最後に、ヒーロークラスを編集してクールダウンを可能にします：\n```javascript\nclass Hero extends GameObject {\nconstructor(x, y) {\nsuper(x, y);\n(this width = 99), (this height = 75);\nthis type = \"Hero\";\nthis speed = { x: 0, y: 0 };\nthis cooldown = 0;\n}\nfire() {\ngameObjects push(new Laser(this x + 45, this y - 10));\nthis cooldown = 500;\nlet id = setInterval(() => {\nif (this cooldown > 0) {\nthis cooldown -= 100;\n} else {\nclearInterval(id);\n}\n}, 200);\n}\ncanFire() {\nreturn this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 403,
    "chunk_index": 56,
    "total_chunks": 58
  },
  {
    "id": "f9df110fbf25813c259d674d978c7555",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート4: レーザーの追加と衝突判定",
    "content": "{ constructor(x, y) { super(x, y); (this width = 99), (this height = 75); this type = \"Hero\"; this speed = { x: 0, y: 0 }; this cooldown = 0; } fire() { gameObjects push(new Laser(this x + 45, this y - 10)); this cooldown = 500; let id = setInterval(() => { if (this cooldown > 0) { this cooldown -= 100; } else { clearInterval(id); } }, 200); } canFire() { return thiscooldown === 0;\n}\n}\n```\nこれで、ゲームにいくつかの機能が追加されました！矢印キーで移動し、スペースキーでレーザーを発射し、敵に当たると消滅します。お疲れ様でした！\n🚀 チャレンジ\n爆発を追加してみましょう！Space Artリポジトリのゲームアセットを確認し、レーザーがエイリアンに当たったときに爆発を追加してみてください。\n講義後クイズ\n講義後クイズ\n復習と自己学習\nこれまでのゲームの間隔を調整してみましょう。間隔を変更するとどうなるか試してみてください。JavaScriptのタイミングイベントについてさらに学びましょう。\n課題\n衝突を探る\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書が正式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13098,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 598,
    "chunk_index": 57,
    "total_chunks": 58
  },
  {
    "id": "56e3749c49ee36e5228fa262242aff8e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書を正式な情報源としてお考えください。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 909,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 218,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "707fb5ff042fd668b8ea2da288cd6fcc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があります。原文（元の言語で記載された文書）が信頼できる情報源とみなされるべきです。重要な情報については、専門の人間による翻訳をお勧めします。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 949,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 233,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f260a64291edecdec118441e0fed3b2a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 953,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 230,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "271a8f58864f71b74eee3a2b1f2a17c0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確さが含まれる可能性があります。元の言語で記載された原文が公式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 922,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 221,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "cec3f85d5fc3cb2ec572cfd9197b53aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 941,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 225,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0cd5e71647646d92f01aeb35f8db1136",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があることをご承知おきください。原文（元の言語で記載された文書）が信頼できる情報源として優先されるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 979,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 241,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "56b0661f09c58ea37699312ed1f847c2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\your-work\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 959,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\4-collision-detection\\your-work\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 230,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0803abdb50b0570838fb36a800ebd2b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 256,
    "chunk_index": 0,
    "total_chunks": 27
  },
  {
    "id": "45ce124047289eb0fc28dea47a7b75c7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 699,
    "chunk_index": 1,
    "total_chunks": 27
  },
  {
    "id": "157114d2ebd4c63df5fba98b7c92132e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 705,
    "chunk_index": 2,
    "total_chunks": 27
  },
  {
    "id": "11def5aad2c82053931f8fe2acea5dc8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 711,
    "chunk_index": 3,
    "total_chunks": 27
  },
  {
    "id": "6ad290222edb4137c1311fdb461a62ff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 716,
    "chunk_index": 4,
    "total_chunks": 27
  },
  {
    "id": "d1e8b0d4a885be97feb4b93ebde36bd9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 721,
    "chunk_index": 5,
    "total_chunks": 27
  },
  {
    "id": "c25d69408bc3ec6a75e716656139b7df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 726,
    "chunk_index": 6,
    "total_chunks": 27
  },
  {
    "id": "63e02f0f642577d701464a7150587695",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_workフォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。\nコードを追加する\n必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlife",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 906,
    "chunk_index": 7,
    "total_chunks": 27
  },
  {
    "id": "db5e7fd354fe58c53ec984d6ad339a5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_workフォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。\nコードを追加する\n必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 919,
    "chunk_index": 8,
    "total_chunks": 27
  },
  {
    "id": "7af1a34ec09985b78f8ffd3aa78bdd54",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_workフォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。\nコードを追加する\n必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください：\njavascript\nlifeImg = await loadTexture(\"assets/life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 945,
    "chunk_index": 9,
    "total_chunks": 27
  },
  {
    "id": "4ad4106330c534be712fcd45a5e1e9cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_workフォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。\nコードを追加する\n必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください：\njavascript\nlifeImg = await loadTexture(\"assets/lifepng\");\nlifeImgをアセットのリストに追加します：\njavascript\nlet heroImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 969,
    "chunk_index": 10,
    "total_chunks": 27
  },
  {
    "id": "228bcfd36499e1f79895af803dbf5b55",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_workフォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。\nコードを追加する\n必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください：\njavascript\nlifeImg = await loadTexture(\"assets/lifepng\");\nlifeImgをアセットのリストに追加します：\njavascript\nlet heroImg,lifeImg,",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 972,
    "chunk_index": 11,
    "total_chunks": 27
  },
  {
    "id": "bad6c81b1e1436fab2419e684c652ee6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "宇宙ゲームを作ろう パート5: スコアとライフ\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ゲームにスコアを追加し、ライフを計算する方法を学びます。\n画面にテキストを描画する\nゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。\njavascript\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"right\";\nctxfillText(\"show this on the screen\", 0, 0);\n✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！\nゲームの概念としてのライフ\nゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。\n作成するもの\nゲームに以下を追加しましょう：\nゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。\nライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。\n推奨手順\nyour-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_workフォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。\nコードを追加する\n必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください：\njavascript\nlifeImg = await loadTexture(\"assets/lifepng\");\nlifeImgをアセットのリストに追加します：\njavascript\nlet heroImg,lifeImg,eventEmitter = new EventEmitter();\n変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。\nupdateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します：\njavascript\nenemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1075,
    "chunk_index": 12,
    "total_chunks": 27
  },
  {
    "id": "4df2f21dfd433013b1d8cc5661ff852d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "画面にテキストを描画する ゲームのスコアを画面に表示するには、テキストを画面に配置する方法を知る必要があります。その答えは、canvasオブジェクトのfillText()メソッドを使用することです。また、使用するフォント、テキストの色、さらにはテキストの配置（左揃え、右揃え、中央揃え）など、他の要素も制御できます。以下は、画面にテキストを描画するコード例です。 javascript ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => {\nconst heroRect = hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 985,
    "chunk_index": 13,
    "total_chunks": 27
  },
  {
    "id": "3976be791c7f05fe0434b1ee04ccb9ee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "\"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject();\nif (intersectRect(heroRect, enemy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 14,
    "total_chunks": 27
  },
  {
    "id": "44449e058f98f2d7feb8a6e20bf8e654",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "fillStyle = \"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) {\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 844,
    "chunk_index": 15,
    "total_chunks": 27
  },
  {
    "id": "e2573cc61111d4bf3cec94fc7e8fb833",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "\"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 843,
    "chunk_index": 16,
    "total_chunks": 27
  },
  {
    "id": "f780dc8abd97d1a8328349b1b49fffe9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "\"red\"; ctx textAlign = \"right\"; ctxfillText(\"show this on the screen\", 0, 0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy });\n}\n})\nライフとポイントを追加します。\n変数を初期化します。Heroクラスのthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 884,
    "chunk_index": 17,
    "total_chunks": 27
  },
  {
    "id": "96b9bacdccf4e427805f87ffc91cd7f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "on the screen\", 0, 0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します：\n```javascript\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 894,
    "chunk_index": 18,
    "total_chunks": 27
  },
  {
    "id": "a645441bbf19eb2d2b8666ebf3de6b2e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "0); ✅ キャンバスにテキストを追加する方法についてさらに学び、自分のテキストをもっと魅力的にしてみましょう！ ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します： ```javascript thislife = 3;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 891,
    "chunk_index": 19,
    "total_chunks": 27
  },
  {
    "id": "fe01bdf52f55fbf752261dda5c0627e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "ゲームの概念としてのライフ ゲームにおけるライフの概念は単なる数字です。宇宙ゲームの文脈では、ダメージを受けるたびに1つずつ減るライフを設定するのが一般的です。数字ではなく、ミニシップやハートのようなグラフィックで表現すると、より視覚的にわかりやすくなります。 作成するもの ゲームに以下を追加しましょう： ゲームスコア: 敵の船を1隻撃破するごとに、ヒーローにポイントが与えられます。1隻につき100ポイントを提案します。ゲームスコアは画面の左下に表示されます。 ライフ: 自分の船には3つのライフがあります。敵の船が衝突するたびにライフが1つ減ります。ライフスコアは画面の右下に表示され、以下のグラフィックで構成されます 。 推奨手順 your-workサブフォルダに作成されたファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します： ```javascript thislife = 3; thispoints = 0;\n```\n変数を画面に描画します。これらの値を画面に描画します：\n```javascript\nfunction drawLife() {\n// TODO, 35, 27\nconst START_POS = canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 891,
    "chunk_index": 20,
    "total_chunks": 27
  },
  {
    "id": "4ac6449c083a0c184ccebd1a2abb5397",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "-| playerpng -| laserRedpng -| indexhtml -| appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します： ```javascript thislife = 3; thispoints = 0; ``` 変数を画面に描画します。これらの値を画面に描画します： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvaswidth - 180;\nfor(let i=0; i < hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 21,
    "total_chunks": 27
  },
  {
    "id": "050216a707927a209bde317f5abd17a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "appjs -| packagejson your_workフォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します： ```javascript thislife = 3; thispoints = 0; ``` 変数を画面に描画します。これらの値を画面に描画します： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvaswidth - 180; for(let i=0; i < herolife; i++ ) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 522,
    "chunk_index": 22,
    "total_chunks": 27
  },
  {
    "id": "6ca6353c6f188275cf3daae69cd3159e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "bash cd your-work npm start 上記のコマンドでHTTPサーバーがhttp://localhost:5000で起動します。ブラウザを開き、そのアドレスを入力してください。現在のところ、ヒーローとすべての敵が表示され、左右の矢印キーを押すとヒーローが移動し、敵を撃つことができます。 コードを追加する 必要なアセットをコピーします。solution/assets/フォルダからyour-workフォルダにlifepngアセットを追加します。windowonload関数にlifeImgを追加してください： javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します： ```javascript thislife = 3; thispoints = 0; ``` 変数を画面に描画します。これらの値を画面に描画します： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvaswidth - 180; for(let i=0; i < herolife; i++ ) { ctxdrawImage(\nlifeImg,\nSTART_POS + (45 * (i+1) ),\ncanvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 509,
    "chunk_index": 23,
    "total_chunks": 27
  },
  {
    "id": "a276e3ec8ae4783c7728729fbb93051e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "javascript lifeImg = await loadTexture(\"assets/lifepng\"); lifeImgをアセットのリストに追加します： javascript let heroImg,lifeImg,eventEmitter = new EventEmitter(); 変数を追加します。合計スコア（0）と残りのライフ（3）を表すコードを追加し、これらのスコアを画面に表示します。 updateGameObjects()関数を拡張します。敵との衝突を処理するようにupdateGameObjects()関数を拡張します： javascript enemiesforEach(enemy => { const heroRect = herorectFromGameObject(); if (intersectRect(heroRect, enemyrectFromGameObject())) { eventEmitteremit(MessagesCOLLISION_ENEMY_HERO, { enemy }); } }) ライフとポイントを追加します。 変数を初期化します。Heroクラスのthiscooldown = 0の下にライフとポイントを設定します： ```javascript thislife = 3; thispoints = 0; ``` 変数を画面に描画します。これらの値を画面に描画します： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvaswidth - 180; for(let i=0; i < herolife; i++ ) { ctxdrawImage( lifeImg, START_POS + (45 * (i+1) ), canvasheight - 37);\n}\n}\nfunction drawPoints() {\nctx font = \"30px Arial\";\nctx fillStyle = \"red\";\nctx textAlign = \"left\";\ndrawText(\"Points: \" + hero points, 10, canvas height-20);\n}\nfunction drawText(message, x, y) {\nctx fillText(message, x, y);\n}\n```\nゲームループにメソッドを追加します。これらの関数をwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 433,
    "chunk_index": 24,
    "total_chunks": 27
  },
  {
    "id": "e844da158c178631533c75da0e5993a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "= 0; ``` 変数を画面に描画します。これらの値を画面に描画します： ```javascript function drawLife() { // TODO, 35, 27 const START_POS = canvaswidth - 180; for(let i=0; i < herolife; i++ ) { ctxdrawImage( lifeImg, START_POS + (45 * (i+1) ), canvasheight - 37); } } function drawPoints() { ctx font = \"30px Arial\"; ctx fillStyle = \"red\"; ctx textAlign = \"left\"; drawText(\"Points: \" + hero points, 10, canvas height-20); } function drawText(message, x, y) { ctx fillText(message, x, y); } ``` ゲームループにメソッドを追加します。これらの関数をwindowonload関数のupdateGameObjects()の下に追加してください：\n```javascript\ndrawPoints();\ndrawLife();\n```\nゲームルールを実装します。以下のゲームルールを実装します：\nヒーローと敵の衝突ごとに、ライフを1つ減らします。\nHeroクラスを拡張してこの減算を行います：\n```javascript\ndecrementLife() {\nthis life--;\nif (this life === 0) {\nthis dead = true;\n}\n}\n```\nレーザーが敵に当たるごとに、ゲームスコアを100ポイント増やします。\nHeroクラスを拡張してこの加算を行います：\n```javascript\nincrementPoints() {\nthis points += 100;\n}\n```\n衝突イベントエミッターにこれらの関数を追加します：\n```javascript\neventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\n})\neventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 473,
    "chunk_index": 25,
    "total_chunks": 27
  },
  {
    "id": "b414f519c79a8cb9ea1470a91ea47e5e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート5: スコアとライフ",
    "content": "} ``` ゲームループにメソッドを追加します。これらの関数をwindowonload関数のupdateGameObjects()の下に追加してください： ```javascript drawPoints(); drawLife(); ``` ゲームルールを実装します。以下のゲームルールを実装します： ヒーローと敵の衝突ごとに、ライフを1つ減らします。 Heroクラスを拡張してこの減算を行います： ```javascript decrementLife() { this life--; if (this life === 0) { this dead = true; } } ``` レーザーが敵に当たるごとに、ゲームスコアを100ポイント増やします。 Heroクラスを拡張してこの加算を行います： ```javascript incrementPoints() { this points += 100; } ``` 衝突イベントエミッターにこれらの関数を追加します： ```javascript eventEmitter on(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); }) eventEmitter on(Messages COLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; herodecrementLife();\n});\n```\n✅ JavaScript/Canvasで作られた他のゲームを調べてみましょう。それらの共通点は何でしょうか？\nこの作業が終わると、画面の右下に小さな「ライフ」シップが表示され、左下にポイントが表示されます。また、敵と衝突するとライフが減り、敵を撃つとポイントが増えるのが確認できるはずです。よくできました！ゲームはほぼ完成です。\n🚀 チャレンジ\nコードはほぼ完成しています。次のステップを想像できますか？\n講義後クイズ\n講義後クイズ\n復習と自己学習\nゲームスコアとライフを増減させる方法をいくつか調べてみましょう。PlayFabのような興味深いゲームエンジンがあります。これらを使用することでゲームがどのように向上するか考えてみましょう。\n課題\nスコアリングゲームを作る\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書を正式な情報源としてお考えください。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8512,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\5-keeping-score\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 828,
    "chunk_index": 26,
    "total_chunks": 27
  },
  {
    "id": "b55f749402f22a983ce7930fa655084f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 877,
    "chunk_index": 0,
    "total_chunks": 22
  },
  {
    "id": "7320bf0153b872bc4060b5c5271f33a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| player",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 883,
    "chunk_index": 1,
    "total_chunks": 22
  },
  {
    "id": "ab2c52d5252f7813c488c00d475364ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRed",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 889,
    "chunk_index": 2,
    "total_chunks": 22
  },
  {
    "id": "21bbd47e3947549270d16e16982bc8f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| life",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 894,
    "chunk_index": 3,
    "total_chunks": 22
  },
  {
    "id": "e00664ba869ee6b708fec23b2460cccb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 900,
    "chunk_index": 4,
    "total_chunks": 22
  },
  {
    "id": "3e4ea66ff0bc4e328e01825177a8f24d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 905,
    "chunk_index": 5,
    "total_chunks": 22
  },
  {
    "id": "bb633d3e67ba3266b521c0e2b6022ec2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 910,
    "chunk_index": 6,
    "total_chunks": 22
  },
  {
    "id": "07dad1851f8a5fd10fd284f2b98bdbfa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_work フォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。\nヒント: Visual Studio Codeで警告を避けるには、window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1045,
    "chunk_index": 7,
    "total_chunks": 22
  },
  {
    "id": "17d3e91a7f60ba7700c57632723b67f7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "宇宙ゲームを作ろう パート6: 終了と再スタート\n講義前クイズ\n講義前クイズ\nゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます：\nN 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。\n自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。\nN ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。\nレベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。\n再スタート\nゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。\n✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。\n作成する内容\n以下のルールをゲームに追加します：\nゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。\n再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。\n推奨手順\nyour-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです：\nbash\n-| assets\n-| enemyShippng\n-| playerpng\n-| laserRedpng\n-| lifepng\n-| indexhtml\n-| appjs\n-| packagejson\nyour_work フォルダでプロジェクトを開始するには、以下を入力します：\nbash\ncd your-work\nnpm start\n上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。\nヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。\nコードを追加する\n終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください：\n```javascript\nfunction isHeroDead() {\nreturn hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1186,
    "chunk_index": 8,
    "total_chunks": 22
  },
  {
    "id": "05dc44ddea80fc80286b910d74b6b9ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "講義前クイズ ゲームにおける「終了条件」を表現する方法はいくつかあります。ゲームの制作者であるあなたが、ゲームが終了する理由を決めることができます。これまで作成してきた宇宙ゲームを例にすると、以下のような理由が考えられます： N 隻の敵船を破壊した場合: ゲームを異なるレベルに分ける場合、N 隻の敵船を破壊することでレベルをクリアするというのはよくあるパターンです。 自分の船が破壊された場合: 自分の船が破壊されるとゲームオーバーになるゲームもあります。別の一般的な方法として「ライフ」の概念があります。自分の船が破壊されるたびにライフが減り、すべてのライフを失うとゲームオーバーになります。 N ポイントを獲得した場合: ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。 レベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。 再スタート ゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。 ✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。 作成する内容 以下のルールをゲームに追加します： ゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。 再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。 推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0;\n}\nfunction isEnemiesDead() {\nconst enemies = gameObjects",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1156,
    "chunk_index": 9,
    "total_chunks": 22
  },
  {
    "id": "746fc148055c147ed5ffce0a0056608c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "ポイントを集めることが終了条件になることもあります。ポイントの獲得方法は自由ですが、敵船を破壊したり、破壊されたアイテムが落とすものを集めたりすることでポイントを得るのが一般的です。 レベルをクリアした場合: これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。 再スタート ゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。 ✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。 作成する内容 以下のルールをゲームに追加します： ゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。 再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。 推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 831,
    "chunk_index": 10,
    "total_chunks": 22
  },
  {
    "id": "da662989a0ddc759eb719ddd75551f57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "これには、X 隻の敵船を破壊する、Y ポイントを集める、特定のアイテムを集めるなど、複数の条件が含まれる場合があります。 再スタート ゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。 ✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。 作成する内容 以下のルールをゲームに追加します： ゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。 再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。 推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 11,
    "total_chunks": 22
  },
  {
    "id": "0d8326a5c39bf01b83548b05e1601315",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "再スタート ゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。 ✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。 作成する内容 以下のルールをゲームに追加します： ゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。 再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。 推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&go",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 669,
    "chunk_index": 12,
    "total_chunks": 22
  },
  {
    "id": "eb8d5513128ddfa549b23b759fae327a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "再スタート ゲームを楽しんでくれる人は、再びプレイしたいと思うでしょう。どのような理由でゲームが終了したとしても、再スタートの選択肢を提供するべきです。 ✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。 作成する内容 以下のルールをゲームに追加します： ゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。 再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。 推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead);\nreturn enemies",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 674,
    "chunk_index": 13,
    "total_chunks": 22
  },
  {
    "id": "fd63bab858b0efb8139d9ff29e00f87c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "✅ ゲームがどのような条件で終了し、どのように再スタートを促されるかを少し考えてみましょう。 作成する内容 以下のルールをゲームに追加します： ゲームの勝利条件: すべての敵船を破壊するとゲームに勝利します。また、勝利メッセージを表示します。 再スタート: すべてのライフを失った場合やゲームに勝利した場合、ゲームを再スタートする方法を提供します。注意！ ゲームを再初期化し、前回のゲーム状態をクリアする必要があります。 推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0;\n}\n```\nメッセージハンドラーにロジックを追加する: eventEmitter を編集して、以下の条件を処理します：\n```javascript\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 646,
    "chunk_index": 14,
    "total_chunks": 22
  },
  {
    "id": "8169317b40cbab7c7d4a4c8660cf5792",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "推奨手順 your-work サブフォルダに作成済みのファイルを見つけてください。以下の内容が含まれているはずです： bash -| assets -| enemyShippng -| playerpng -| laserRedpng -| lifepng -| indexhtml -| appjs -| packagejson your_work フォルダでプロジェクトを開始するには、以下を入力します： bash cd your-work npm start 上記のコマンドで、アドレス http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0; } ``` メッセージハンドラーにロジックを追加する: eventEmitter を編集して、以下の条件を処理します： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => {\nfirst dead = true;\nsecond dead = true;\nhero incrementPoints();\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 492,
    "chunk_index": 15,
    "total_chunks": 22
  },
  {
    "id": "45e6cc1213db052ea328e9bce45566ca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "http://localhost:5000 でHTTPサーバーが起動します。ブラウザを開き、そのアドレスを入力してください。ゲームがプレイ可能な状態になっているはずです。 ヒント: Visual Studio Codeで警告を避けるには、windowonload 関数を編集して gameLoopId をそのまま呼び出し（let を付けずに）、ファイルの先頭で let gameLoopId; を独立して宣言してください。 コードを追加する 終了条件を追跡する: 敵の数やヒーロー船が破壊されたかどうかを追跡するコードを追加します。以下の2つの関数を追加してください： ```javascript function isHeroDead() { return herolife <= 0; } function isEnemiesDead() { const enemies = gameObjectsfilter((go) => gotype === \"Enemy\" &&godead); return enemieslength === 0; } ``` メッセージハンドラーにロジックを追加する: eventEmitter を編集して、以下の条件を処理します： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(MessagesCOLLISION_ENEMY_HERO, (_, { enemy }) => {\nenemy dead = true;\nhero decrementLife();\nif (isHeroDead())  {\neventEmitter emit(Messages GAME_END_LOSS);\nreturn; // loss before victory\n}\nif (isEnemiesDead()) {\neventEmitter emit(Messages GAME_END_WIN);\n}\n});\neventEmitter on(Messages GAME_END_WIN, () => {\nendGame(true);\n});\neventEmitter on(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 16,
    "total_chunks": 22
  },
  {
    "id": "bfaae3f3aa6fc213bec3ca33160caabf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "``` メッセージハンドラーにロジックを追加する: eventEmitter を編集して、以下の条件を処理します： ```javascript eventEmitteron(Messages COLLISION_ENEMY_LASER, (_, { first, second }) => { first dead = true; second dead = true; hero incrementPoints(); if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(MessagesCOLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(Messages GAME_END_LOSS); return; // loss before victory } if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages GAME_END_WIN, () => { endGame(true); }); eventEmitter on(MessagesGAME_END_LOSS, () => {\nendGame(false);\n});\n```\n新しいメッセージタイプを追加する: 以下のメッセージを constants オブジェクトに追加します：\njavascript\nGAME_END_LOSS: \"GAME_END_LOSS\",\nGAME_END_WIN: \"GAME_END_WIN\",\n再スタートコードを追加する: 選択したボタンを押すことでゲームを再スタートするコードを追加します。\nEnter キーの押下をリッスンする: ウィンドウの eventListener を編集して、このキー押下をリッスンします：\njavascript\nelse if(evt key === \"Enter\") {\neventEmitter emit(Messages",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 359,
    "chunk_index": 17,
    "total_chunks": 22
  },
  {
    "id": "07015bd55782ed87df41e49a50ce873a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "}); eventEmitter on(MessagesCOLLISION_ENEMY_HERO, (_, { enemy }) => { enemy dead = true; hero decrementLife(); if (isHeroDead()) { eventEmitter emit(Messages GAME_END_LOSS); return; // loss before victory } if (isEnemiesDead()) { eventEmitter emit(Messages GAME_END_WIN); } }); eventEmitter on(Messages GAME_END_WIN, () => { endGame(true); }); eventEmitter on(MessagesGAME_END_LOSS, () => { endGame(false); }); ``` 新しいメッセージタイプを追加する: 以下のメッセージを constants オブジェクトに追加します： javascript GAME_END_LOSS: \"GAME_END_LOSS\", GAME_END_WIN: \"GAME_END_WIN\", 再スタートコードを追加する: 選択したボタンを押すことでゲームを再スタートするコードを追加します。 Enter キーの押下をリッスンする: ウィンドウの eventListener を編集して、このキー押下をリッスンします： javascript else if(evt key === \"Enter\") { eventEmitter emit(MessagesKEY_EVENT_ENTER);\n}\n再スタートメッセージを追加する: 以下のメッセージを Messages 定数に追加します：\n```javascript\nKEY_EVENT_ENTER: \"KEY_EVENT_ENTER\",\n```\nゲームルールを実装する: 以下のゲームルールを実装します：\nプレイヤーの勝利条件: すべての敵船が破壊されたとき、勝利メッセージを表示します。\nまず、displayMessage() 関数を作成します：\njavascript\nfunction displayMessage(message, color = \"red\") {\nctx font = \"30px Arial\";\nctx fillStyle = color;\nctx textAlign = \"center\";\nctx fillText(message, canvas width / 2, canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 449,
    "chunk_index": 18,
    "total_chunks": 22
  },
  {
    "id": "3298e8ebf1fef7772f9ab0dfaf6c4176",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "}); eventEmitter on(MessagesGAME_END_LOSS, () => { endGame(false); }); ``` 新しいメッセージタイプを追加する: 以下のメッセージを constants オブジェクトに追加します： javascript GAME_END_LOSS: \"GAME_END_LOSS\", GAME_END_WIN: \"GAME_END_WIN\", 再スタートコードを追加する: 選択したボタンを押すことでゲームを再スタートするコードを追加します。 Enter キーの押下をリッスンする: ウィンドウの eventListener を編集して、このキー押下をリッスンします： javascript else if(evt key === \"Enter\") { eventEmitter emit(MessagesKEY_EVENT_ENTER); } 再スタートメッセージを追加する: 以下のメッセージを Messages 定数に追加します： ```javascript KEY_EVENT_ENTER: \"KEY_EVENT_ENTER\", ``` ゲームルールを実装する: 以下のゲームルールを実装します： プレイヤーの勝利条件: すべての敵船が破壊されたとき、勝利メッセージを表示します。 まず、displayMessage() 関数を作成します： javascript function displayMessage(message, color = \"red\") { ctx font = \"30px Arial\"; ctx fillStyle = color; ctx textAlign = \"center\"; ctx fillText(message, canvas width / 2, canvasheight / 2);\n}\n次に、endGame() 関数を作成します：\n```javascript\nfunction endGame(win) {\nclearInterval(gameLoopId);\n// set a delay so we are sure any paints have finished\nsetTimeout(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\nif (win) {\ndisplayMessage(\n\"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\",\n\"green\"\n);\n} else {\ndisplayMessage(\n\"You died",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 19,
    "total_chunks": 22
  },
  {
    "id": "e5fdbdbdf907adee3230c9762ceb4c57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "ctx fillText(message, canvas width / 2, canvasheight / 2); } 次に、endGame() 関数を作成します： ```javascript function endGame(win) { clearInterval(gameLoopId); // set a delay so we are sure any paints have finished setTimeout(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvas height); if (win) { displayMessage( \"Victory Pew Pew - Press [Enter] to start a new game Captain Pew Pew\", \"green\" ); } else { displayMessage( \"You diedPress [Enter] to start a new game Captain Pew Pew\"\n);\n}\n}, 200)\n}\n```\n再スタートロジック: すべてのライフを失った場合やプレイヤーがゲームに勝利した場合、再スタート可能であることを表示します。また、再スタートキーが押されたときにゲームを再スタートします（どのキーを再スタートに割り当てるかは自由です）。\nresetGame() 関数を作成します：\njavascript\nfunction resetGame() {\nif (gameLoopId) {\nclearInterval(gameLoopId);\neventEmitter clear();\ninitGame();\ngameLoopId = setInterval(() => {\nctx clearRect(0, 0, canvas width, canvas height);\nctx fillStyle = \"black\";\nctx fillRect(0, 0, canvas width, canvas height);\ndrawPoints();\ndrawLife();\nupdateGameObjects();\ndrawGameObjects(ctx);\n}, 100);\n}\n}\ninitGame() 内で eventEmitter を呼び出してゲームをリセットするコードを追加します：\njavascript\neventEmitter on(Messages KEY_EVENT_ENTER, () => {\nresetGame();\n});\nEventEmitter に clear() 関数を追加します：\njavascript\nclear() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 20,
    "total_chunks": 22
  },
  {
    "id": "fc6d5e7904f2027102d5dd8fe540e5ee",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
    "source_type": "git_repo",
    "title": "宇宙ゲームを作ろう パート6: 終了と再スタート",
    "content": "Captain Pew Pew\" ); } }, 200) } ``` 再スタートロジック: すべてのライフを失った場合やプレイヤーがゲームに勝利した場合、再スタート可能であることを表示します。また、再スタートキーが押されたときにゲームを再スタートします（どのキーを再スタートに割り当てるかは自由です）。 resetGame() 関数を作成します： javascript function resetGame() { if (gameLoopId) { clearInterval(gameLoopId); eventEmitter clear(); initGame(); gameLoopId = setInterval(() => { ctx clearRect(0, 0, canvas width, canvas height); ctx fillStyle = \"black\"; ctx fillRect(0, 0, canvas width, canvas height); drawPoints(); drawLife(); updateGameObjects(); drawGameObjects(ctx); }, 100); } } initGame() 内で eventEmitter を呼び出してゲームをリセットするコードを追加します： javascript eventEmitter on(Messages KEY_EVENT_ENTER, () => { resetGame(); }); EventEmitter に clear() 関数を追加します： javascript clear() { thislisteners = {};\n}\n👽 💥 🚀 おめでとうございます、キャプテン！ゲームが完成しました！よくやりました！ 🚀 💥 👽\n🚀 チャレンジ\n音を追加してみましょう！レーザーが命中したときや、ヒーローが死んだとき、または勝利したときに音を追加してゲームプレイを強化できますか？JavaScriptで音を再生する方法を学ぶには、この サンドボックス を見てみましょう。\n講義後クイズ\n講義後クイズ\n復習と自己学習\n新しいサンプルゲームを作成することが課題です。どのようなゲームを作るかを考えるために、興味深いゲームをいくつか探してみましょう。\n課題\nサンプルゲームを作成する\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された原文が公式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10434,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\6-space-game\\6-end-condition\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 769,
    "chunk_index": 21,
    "total_chunks": 22
  },
  {
    "id": "14aa196eda470417f53dba2209a1ce03",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\assignment.md",
    "source_type": "git_repo",
    "title": "拡張機能のスタイルを変更する",
    "content": "拡張機能のスタイルを変更する\n手順\nこの拡張機能のコードベースにはスタイルが含まれていますが、それを使う必要はありません。CSSファイルを編集して、自分だけのスタイルにカスタマイズしましょう。\n評価基準\n| 基準     | 優秀な状態                                    | 十分な状態            | 改善が必要な状態   |\n| -------- | -------------------------------------------- | --------------------- | ----------------- |\n|          | 機能的な新しいスタイルが提出されている        | スタイリングが不完全 | スタイルに不具合がある |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1551,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 408,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c96287f5b5cc73f1bb7c9f66098a0330",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
    "source_type": "git_repo",
    "title": "APIを採用しよう",
    "content": "APIを採用しよう\n手順\nAPIはとても楽しく使うことができます。こちらに無料で使えるAPIのリストがあります。この中から1つ選び、問題を解決するブラウザ拡張機能を作成してください。例えば、ペットの写真が足りないという小さな問題を解決するためにdog CEO APIを試してみるのも良いですし、もっと大きな問題に挑戦しても構いません。楽しんでください！\n評価基準\n| 基準     | 優秀な例                                                                 | 十分な例                              | 改善が必要な例          |\n| -------- | ------------------------------------------------------------------------ | ------------------------------------- | ----------------------- |\n|          | 上記リストのAPIを使用した完全なブラウザ拡張機能が提出されている            | 部分的なブラウザ拡張機能が提出されている | 提出物にバグがある      |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1998,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 487,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "223423a65c71cb5689d667c49f32385d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
    "source_type": "git_repo",
    "title": "サイトのパフォーマンスを分析する",
    "content": "サイトのパフォーマンスを分析する\nウェブサイトの詳細なレポートを作成し、パフォーマンスに問題がある箇所を特定します。サイトが遅い理由を分析し、速度を向上させるためにできることを提案します。ブラウザツールだけに頼らず、他のツールを調査してレポートに役立ててください。\n評価基準\n| 基準     | 優秀                                                                                                      | 適切                         | 改善が必要                     |\n| -------- | ---------------------------------------------------------------------------------------------------------- | --------------------------- | ----------------------------- |\n|          | ブラウザツールだけでなく、可能であれば第三者ツールから得た詳細を含むレポートが提示されている                 | 基本的なレポートが提示されている | 最小限のレポートが提示されている |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1955,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "4124ddaa6ecb92b8a0941b5a7c34eb75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 856,
    "chunk_index": 0,
    "total_chunks": 13
  },
  {
    "id": "4f105f87e1438f4a9b7c41e542b9ffc7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上の",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1518,
    "chunk_index": 1,
    "total_chunks": 13
  },
  {
    "id": "11974e0fa4b53d0a6bbe694b41628c65",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する\n新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする\nまたは、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする\n✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。\n始めましょう\nあなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。\n必要なもの:\nAPIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます\n地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します）\nスターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます\nNPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1995,
    "chunk_index": 2,
    "total_chunks": 13
  },
  {
    "id": "26964e2dcbf84bea30677de9581919c7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する\n新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする\nまたは、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする\n✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。\n始めましょう\nあなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。\n必要なもの:\nAPIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます\n地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します）\nスターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます\nNPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります\n✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。\nコードベースを確認してみましょう：\ndist\n-|manifest",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2103,
    "chunk_index": 3,
    "total_chunks": 13
  },
  {
    "id": "a53912ab08dca40eafd826e5ff4a1951",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する\n新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする\nまたは、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする\n✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。\n始めましょう\nあなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。\n必要なもの:\nAPIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます\n地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します）\nスターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます\nNPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります\n✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。\nコードベースを確認してみましょう：\ndist\n-|manifestjson (デフォルト設定はこちら)\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2121,
    "chunk_index": 4,
    "total_chunks": 13
  },
  {
    "id": "89dcfba3098d8ba72788d2734b009040",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する\n新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする\nまたは、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする\n✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。\n始めましょう\nあなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。\n必要なもの:\nAPIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます\n地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します）\nスターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます\nNPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります\n✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。\nコードベースを確認してみましょう：\ndist\n-|manifestjson (デフォルト設定はこちら)\n-|indexhtml (フロントエンドのHTMLマークアップはこちら)\n-|background",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2145,
    "chunk_index": 5,
    "total_chunks": 13
  },
  {
    "id": "c889a2dafeb277bc9a49d94abebce959",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する\n新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする\nまたは、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする\n✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。\n始めましょう\nあなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。\n必要なもの:\nAPIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます\n地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します）\nスターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます\nNPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります\n✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。\nコードベースを確認してみましょう：\ndist\n-|manifestjson (デフォルト設定はこちら)\n-|indexhtml (フロントエンドのHTMLマークアップはこちら)\n-|backgroundjs (バックグラウンドJSはこちら)\n-|main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2163,
    "chunk_index": 6,
    "total_chunks": 13
  },
  {
    "id": "1e713e26268446320247fe90a3fd8512",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザ拡張プロジェクト パート1: ブラウザについて\nスケッチノート: Wassim Chegham\n講義前のクイズ\n講義前のクイズ\nはじめに\nブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。\nブラウザについて\nこのレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。\nでは、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。\n✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。\n初期のブラウザの一部: Karen McGrane\nユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。\nこの時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。\nブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。\nブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。\nウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。\n✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。\nブラウザ拡張機能\nなぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。\nブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。\n✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？\n拡張機能のインストール\n作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります：\n注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。\n基本的なプロセスは以下のようになります：\nnpm run buildを使用して拡張機能をビルドする\nブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する\n新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする\nまたは、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする\n✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。\n始めましょう\nあなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。\n必要なもの:\nAPIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます\n地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します）\nスターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます\nNPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります\n✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。\nコードベースを確認してみましょう：\ndist\n-|manifestjson (デフォルト設定はこちら)\n-|indexhtml (フロントエンドのHTMLマークアップはこちら)\n-|backgroundjs (バックグラウンドJSはこちら)\n-|mainjs (ビルド済みJS)\nsrc\n-|index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2178,
    "chunk_index": 7,
    "total_chunks": 13
  },
  {
    "id": "b5409228e726425c8cbfa8b9710d258e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "スケッチノート: Wassim Chegham 講義前のクイズ 講義前のクイズ はじめに ブラウザ拡張機能は、ブラウザに追加の機能を提供します。しかし、拡張機能を作成する前に、ブラウザがどのように動作するかを少し学ぶ必要があります。 ブラウザについて このレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。 では、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。 ✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。 初期のブラウザの一部: Karen McGrane ユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。 この時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。 ブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。 ブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。 ウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。 ✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。 ブラウザ拡張機能 なぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。 ブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。 ✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？ 拡張機能のインストール 作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります： 注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。 基本的なプロセスは以下のようになります： npm run buildを使用して拡張機能をビルドする ブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する 新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする または、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする ✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。 始めましょう あなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。 必要なもの: APIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます 地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します） スターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます NPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります ✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。 コードベースを確認してみましょう： dist -|manifestjson (デフォルト設定はこちら) -|indexhtml (フロントエンドのHTMLマークアップはこちら) -|backgroundjs (バックグラウンドJSはこちら) -|mainjs (ビルド済みJS) src -|indexjs (あなたのJSコードはこちら)\n✅ APIキーと地域コードを準備したら、それらをメモに保存しておきましょう。\n拡張機能のHTMLを作成する\nこの拡張機能には2つのビューがあります。1つはAPIキーと地域コードを収集するためのもの：\nもう1つは地域の炭素使用量を表示するためのもの：\nまず、フォームを作成し、CSSでスタイリングします。\n/distフォルダ内で、フォームと結果表示エリアを作成します。index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2332,
    "chunk_index": 8,
    "total_chunks": 13
  },
  {
    "id": "68e9cc513b8e0b61b743dbd03e659f4f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "このレッスンシリーズでは、Chrome、Firefox、Edgeブラウザで動作するブラウザ拡張機能の作成方法を学びます。このパートでは、ブラウザの仕組みを理解し、ブラウザ拡張機能の要素を構築していきます。 では、ブラウザとは何でしょうか？ブラウザは、エンドユーザーがサーバーからコンテンツを取得し、それをウェブページ上に表示するためのソフトウェアアプリケーションです。 ✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。 初期のブラウザの一部: Karen McGrane ユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。 この時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。 ブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。 ブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。 ウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。 ✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。 ブラウザ拡張機能 なぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。 ブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。 ✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？ 拡張機能のインストール 作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります： 注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。 基本的なプロセスは以下のようになります： npm run buildを使用して拡張機能をビルドする ブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する 新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする または、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする ✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。 始めましょう あなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。 必要なもの: APIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます 地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します） スターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます NPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります ✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。 コードベースを確認してみましょう： dist -|manifestjson (デフォルト設定はこちら) -|indexhtml (フロントエンドのHTMLマークアップはこちら) -|backgroundjs (バックグラウンドJSはこちら) -|mainjs (ビルド済みJS) src -|indexjs (あなたのJSコードはこちら) ✅ APIキーと地域コードを準備したら、それらをメモに保存しておきましょう。 拡張機能のHTMLを作成する この拡張機能には2つのビューがあります。1つはAPIキーと地域コードを収集するためのもの： もう1つは地域の炭素使用量を表示するためのもの： まず、フォームを作成し、CSSでスタイリングします。 /distフォルダ内で、フォームと結果表示エリアを作成します。indexhtmlファイル内で、指定されたフォームエリアを埋めます：\n```HTML\nNew",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2239,
    "chunk_index": 9,
    "total_chunks": 13
  },
  {
    "id": "477777bbf944721ab52652a43c987bf8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "✅ 少し歴史を振り返ると、最初のブラウザは「WorldWideWeb」と呼ばれ、1990年にティモシー・バーナーズ＝リー卿によって作られました。 初期のブラウザの一部: Karen McGrane ユーザーがURL（Uniform Resource Locator）アドレスを使用してインターネットに接続するとき、通常はhttpまたはhttpsアドレスを介してHypertext Transfer Protocolを使用します。ブラウザはウェブサーバーと通信し、ウェブページを取得します。 この時点で、ブラウザのレンダリングエンジンがウェブページをユーザーのデバイス（スマートフォン、デスクトップ、またはノートパソコンなど）に表示します。 ブラウザは、コンテンツをキャッシュして毎回サーバーから取得する必要がないようにしたり、ユーザーの閲覧履歴を記録したり、「クッキー」と呼ばれる小さなデータを保存してユーザーの活動情報を保持したりすることができます。 ブラウザについて重要な点は、すべてのブラウザが同じではないということです！各ブラウザにはそれぞれの強みと弱みがあり、プロのウェブ開発者はウェブページをクロスブラウザでうまく動作させる方法を理解する必要があります。これには、スマートフォンのような小さなビューポートや、オフラインのユーザーへの対応が含まれます。 ウェブページを作成する際に非常に役立つウェブサイトとして、caniusecomがあります。このサイトでは、サポートされている技術のリストを確認でき、ユーザーを最適にサポートするために役立ちます。 ✅ あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。 ブラウザ拡張機能 なぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。 ブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。 ✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？ 拡張機能のインストール 作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります： 注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。 基本的なプロセスは以下のようになります： npm run buildを使用して拡張機能をビルドする ブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する 新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする または、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする ✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。 始めましょう あなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。 必要なもの: APIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます 地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します） スターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます NPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります ✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。 コードベースを確認してみましょう： dist -|manifestjson (デフォルト設定はこちら) -|indexhtml (フロントエンドのHTMLマークアップはこちら) -|backgroundjs (バックグラウンドJSはこちら) -|mainjs (ビルド済みJS) src -|indexjs (あなたのJSコードはこちら) ✅ APIキーと地域コードを準備したら、それらをメモに保存しておきましょう。 拡張機能のHTMLを作成する この拡張機能には2つのビューがあります。1つはAPIキーと地域コードを収集するためのもの： もう1つは地域の炭素使用量を表示するためのもの： まず、フォームを作成し、CSSでスタイリングします。 /distフォルダ内で、フォームと結果表示エリアを作成します。indexhtmlファイル内で、指定されたフォームエリアを埋めます： ```HTML NewAdd your Information\nRegion Name\nYour API Key from tmrow\nSubmit\n```\nこれは保存された情報が入力され、ローカルストレージに保存されるフォームです。\n次に、結果表示エリアを作成します。最後のフォームタグの下にいくつかのdivを追加します：\n```HTML\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2152,
    "chunk_index": 10,
    "total_chunks": 13
  },
  {
    "id": "33ff5002d76b13bf50cc79e43caec575",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "あなたのウェブサイトのユーザー層で最も人気のあるブラウザをどうやって知ることができますか？分析ツールをインストールすることで、ウェブ開発プロセスの一環として、どのブラウザが最も使用されているかを確認できます。 ブラウザ拡張機能 なぜブラウザ拡張機能を作成したいのでしょうか？繰り返し行うタスクにすばやくアクセスするためにブラウザに追加する便利なツールだからです。例えば、さまざまなウェブページで色を確認する必要がある場合、カラーピッカーのブラウザ拡張機能をインストールするかもしれません。パスワードを覚えるのが苦手な場合は、パスワード管理のブラウザ拡張機能を使用するかもしれません。 ブラウザ拡張機能の開発は楽しいものです。通常、限られた数のタスクを効率的に管理することに特化しています。 ✅ あなたのお気に入りのブラウザ拡張機能は何ですか？それらはどのようなタスクを実行しますか？ 拡張機能のインストール 作成を始める前に、ブラウザ拡張機能の構築と展開のプロセスを確認してください。各ブラウザによってこのタスクの管理方法は少し異なりますが、ChromeやFirefoxと同様に、Edgeでの例は以下のようになります： 注: 開発者モードをオンにし、他のストアからの拡張機能を許可してください。 基本的なプロセスは以下のようになります： npm run buildを使用して拡張機能をビルドする ブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する 新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする または、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする ✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。 始めましょう あなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。 必要なもの: APIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます 地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します） スターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます NPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります ✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。 コードベースを確認してみましょう： dist -|manifestjson (デフォルト設定はこちら) -|indexhtml (フロントエンドのHTMLマークアップはこちら) -|backgroundjs (バックグラウンドJSはこちら) -|mainjs (ビルド済みJS) src -|indexjs (あなたのJSコードはこちら) ✅ APIキーと地域コードを準備したら、それらをメモに保存しておきましょう。 拡張機能のHTMLを作成する この拡張機能には2つのビューがあります。1つはAPIキーと地域コードを収集するためのもの： もう1つは地域の炭素使用量を表示するためのもの： まず、フォームを作成し、CSSでスタイリングします。 /distフォルダ内で、フォームと結果表示エリアを作成します。indexhtmlファイル内で、指定されたフォームエリアを埋めます： ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` これは保存された情報が入力され、ローカルストレージに保存されるフォームです。 次に、結果表示エリアを作成します。最後のフォームタグの下にいくつかのdivを追加します： ```HTML loadingRegion:\nCarbon Usage:\nFossil Fuel Percentage:\nChange region\n```\nこの時点でビルドを試すことができます。拡張機能のパッケージ依存関係をインストールしてください：\nnpm install\nこのコマンドはnpm（Node Package Manager）を使用して、拡張機能のビルドプロセスに必要なwebpackをインストールします。ビルドプロセスの出力は/dist/main",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1682,
    "chunk_index": 11,
    "total_chunks": 13
  },
  {
    "id": "004337c2d7242e537734becbd671d2d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート1: ブラウザについて",
    "content": "ブラウザで「設定とその他」ボタン（右上のアイコン）を使用して拡張機能のペインに移動する 新しいインストールの場合、load unpackedを選択してビルドフォルダ（この場合は/dist）から新しい拡張機能をアップロードする または、すでにインストールされている拡張機能を再ロードする場合はreloadをクリックする ✅ これらの手順は自分で作成した拡張機能に関するものです。各ブラウザに関連するブラウザ拡張機能ストアでリリースされた拡張機能をインストールするには、それらのストアに移動して、好きな拡張機能をインストールしてください。 始めましょう あなたは、地域の炭素排出量を表示するブラウザ拡張機能を作成します。この拡張機能は、地域のエネルギー使用量とエネルギーの供給源を表示します。拡張機能には、APIキーを収集するフォームがあり、CO2 SignalのAPIにアクセスできます。 必要なもの: APIキー - このページのボックスにメールアドレスを入力すると、APIキーが送信されます 地域コード - Electricity Mapに対応するコード（例えば、ボストンでは「US-NEISO」を使用します） スターターコード - startフォルダをダウンロードし、このフォルダ内のコードを完成させます NPM - NPMはパッケージ管理ツールです。ローカルにインストールすると、packagejsonファイルに記載されているパッケージがウェブアセットで使用できるようになります ✅ パッケージ管理についてもっと学びたい場合は、この優れた学習モジュールを参照してください。 コードベースを確認してみましょう： dist -|manifestjson (デフォルト設定はこちら) -|indexhtml (フロントエンドのHTMLマークアップはこちら) -|backgroundjs (バックグラウンドJSはこちら) -|mainjs (ビルド済みJS) src -|indexjs (あなたのJSコードはこちら) ✅ APIキーと地域コードを準備したら、それらをメモに保存しておきましょう。 拡張機能のHTMLを作成する この拡張機能には2つのビューがあります。1つはAPIキーと地域コードを収集するためのもの： もう1つは地域の炭素使用量を表示するためのもの： まず、フォームを作成し、CSSでスタイリングします。 /distフォルダ内で、フォームと結果表示エリアを作成します。indexhtmlファイル内で、指定されたフォームエリアを埋めます： ```HTML NewAdd your Information Region Name Your API Key from tmrow Submit ``` これは保存された情報が入力され、ローカルストレージに保存されるフォームです。 次に、結果表示エリアを作成します。最後のフォームタグの下にいくつかのdivを追加します： ```HTML loadingRegion: Carbon Usage: Fossil Fuel Percentage: Change region ``` この時点でビルドを試すことができます。拡張機能のパッケージ依存関係をインストールしてください： npm install このコマンドはnpm（Node Package Manager）を使用して、拡張機能のビルドプロセスに必要なwebpackをインストールします。ビルドプロセスの出力は/dist/mainjsで確認できます。コードがバンドルされていることがわかります。\n現時点では、拡張機能をビルドし、Edgeに拡張機能として展開すると、フォームがきれいに表示されるはずです。\nおめでとうございます！ブラウザ拡張機能の作成に向けた最初のステップを踏み出しました。次のレッスンでは、さらに機能的で便利なものにしていきます。\n🚀 チャレンジ\nブラウザ拡張機能ストアを見て、1つをブラウザにインストールしてみましょう。そのファイルを興味深い方法で調べることができます。何を発見しましたか？\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\nこのレッスンでは、ウェブブラウザの歴史について少し学びました。この機会に、ワールドワイドウェブの発明者がその使用方法をどのように考えていたかについて、さらに学んでみましょう。役立つサイトには以下があります：\nウェブブラウザの歴史\nウェブの歴史\nティム・バーナーズ＝リーとのインタビュー\n課題\n拡張機能をリスタイルする\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12841,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\1-about-browsers\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1725,
    "chunk_index": 12,
    "total_chunks": 13
  },
  {
    "id": "13a353195591c30e727df75e518da403",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\README.md",
    "source_type": "git_repo",
    "title": "カーボントリガー ブラウザー拡張機能: 完成コード",
    "content": "カーボントリガー ブラウザー拡張機能: 完成コード\ntmrowのC02 Signal APIを使用して電力使用量を追跡し、地域の電力使用状況がどれだけ負荷がかかっているかをブラウザーで通知する拡張機能を作成します。この拡張機能を使うことで、得られた情報に基づいて活動を判断する助けになります。\nはじめに\nnpm をインストールする必要があります。このコードをコンピューターのフォルダーにダウンロードしてください。\n必要なパッケージをすべてインストールします:\nnpm install\nwebpackを使って拡張機能をビルドします:\nnpm run build\nEdgeにインストールするには、ブラウザー右上の「三点メニュー」から拡張機能パネルを開きます。そこから「パッケージされていない拡張機能を読み込む」を選択し、新しい拡張機能を読み込みます。プロンプトで「dist」フォルダーを開くと、拡張機能が読み込まれます。使用するには、CO2 SignalのAPIキーが必要です（こちらからメールで取得 - ページのボックスにメールアドレスを入力してください）と、Electricity Map に対応する地域コード（例: ボストンの場合は「US-NEISO」を使用）を取得してください (地域コードはこちら)。\n拡張機能のインターフェースにAPIキーと地域コードを入力すると、ブラウザー拡張機能バーのカラードットが地域のエネルギー使用状況を反映するように変わります。また、エネルギー消費の多い活動を行うべきかどうかの指針を示してくれます。この「ドット」システムのコンセプトは、カリフォルニアの排出量を対象とした Energy Lollipop拡張機能 から着想を得ています。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3175,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 836,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "1f41a3af241a7b83929b039516954bb8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\start\\README.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger ブラウザー拡張機能: スターターコード",
    "content": "Carbon Trigger ブラウザー拡張機能: スターターコード\ntmrowのC02 Signal APIを使用して電力使用量を追跡し、地域の電力使用状況がどれほど重いかをブラウザーで直接確認できるリマインダーを作成するブラウザー拡張機能を構築します。この拡張機能を臨時で使用することで、この情報に基づいて活動に関する判断を下す助けになります。\nはじめに\nnpm をインストールする必要があります。このコードをコンピューターのフォルダーにダウンロードしてください。\n必要なパッケージをすべてインストールします:\nnpm install\nwebpackを使用して拡張機能をビルドします:\nnpm run build\nEdgeにインストールするには、ブラウザーの右上にある「三点メニュー」から拡張機能パネルを見つけます。そこで「Load Unpacked」を選択して新しい拡張機能を読み込みます。プロンプトで「dist」フォルダーを開くと拡張機能が読み込まれます。使用するには、CO2 SignalのAPIキーが必要です (こちらからメールで取得 - このページのボックスにメールアドレスを入力してください) と、Electricity Map に対応する地域コード (地域コードはこちら) が必要です。例えば、ボストンでは「US-NEISO」を使用します。\nAPIキーと地域コードを拡張機能のインターフェースに入力すると、ブラウザー拡張機能バーの色付きドットが地域のエネルギー使用状況を反映して変化し、エネルギー消費の多い活動を行うべきかどうかの指針を示します。この「ドット」システムのコンセプトは、カリフォルニア州の排出量に関する Energy Lollipop 拡張機能 から着想を得ました。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があることをご承知おきください。原文（元の言語で記載された文書）が公式な情報源として優先されるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3173,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\start\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 835,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "bdf265079c39d7624d7fd41c33f31b6e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.es.md",
    "source_type": "git_repo",
    "title": "Carbon Triggerブラウザ拡張機能: 完全なコード",
    "content": "Carbon Triggerブラウザ拡張機能: 完全なコード\ntmrowのCO2 Signal APIを使用して電力使用量を追跡し、地域の電力消費に関するリマインダーをブラウザで直接表示する拡張機能を作成します。このアドホックな拡張機能を使用することで、この情報に基づいて活動を決定するのに役立ちます。\n始める\nnpmがインストールされている必要があります。このコードのコピーをコンピュータのフォルダにダウンロードしてください。\n必要なすべてのパッケージをインストールします:\nnpm install\nwebpackを使用して拡張機能をビルドします:\nnpm run build\nEdgeにインストールするには、ブラウザの右上にある「三点メニュー」から「拡張機能」パネルを見つけます。そこから「パッケージ化されていない拡張機能を読み込む」を選択して新しい拡張機能を読み込みます。プロンプトが表示されたら「dist」フォルダを開き、拡張機能が読み込まれます。使用するには、CO2 Signal APIのAPIキーが必要です（こちらでメールで取得 - このページのボックスにメールアドレスを入力してください）と、Electricity Mapに対応する地域コードが必要です（例えば、ボストンでは「US-NEISO」を使用します）。\nAPIキーと地域コードを拡張機能のインターフェースに入力すると、ブラウザの拡張機能バーにある色付きの点が地域のエネルギー使用量を反映して変化し、高エネルギー消費活動に関する適切な指標を提供します。この「点」システムのコンセプトは、カリフォルニアの排出量に関するEnergy Lollipop拡張機能から着想を得ました。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があります。元の言語で記載された文書が正式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳をお勧めします。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3081,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.es.md",
      "source_type": "git_repo"
    },
    "token_count": 802,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ab8df7d2ab5a23d4009440d798408b29",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.fr.md",
    "source_type": "git_repo",
    "title": "Carbon Triggerブラウザ拡張機能: 完成したコード",
    "content": "Carbon Triggerブラウザ拡張機能: 完成したコード\ntmrowのC02 Signal APIを使用して電力消費を追跡し、地域の電力消費に関するリマインダーをブラウザ内で直接表示するブラウザ拡張機能を作成します。このアドホックな拡張機能を使用することで、これらの情報に基づいて活動を判断する助けになります。\n始める\nnpmがインストールされている必要があります。このコードをコンピュータのフォルダにダウンロードしてください。\n必要なパッケージをすべてインストールします：\nnpm install\nWebpackで拡張機能をビルドします：\nnpm run build\nEdgeにインストールするには、ブラウザの右上にある「三点メニュー」を使用して拡張機能パネルを見つけます。そこから「解凍された拡張機能を読み込む」を選択して新しい拡張機能を読み込みます。プロンプトで「dist」フォルダを開くと、拡張機能が読み込まれます。使用するには、CO2 Signal APIのAPIキーが必要です（こちらのページでメールで取得 - ページのボックスにメールアドレスを入力してください）と、電力マップに対応する地域コードが必要です（例えば、ボストンでは「US-NEISO」を使用します）。\nAPIキーと地域コードを拡張機能のインターフェースに入力すると、ブラウザの拡張機能バーにある色付きの点が地域の電力消費を反映して変化し、エネルギー消費の多い活動を行うべきかどうかの指標を提供します。この「点」システムのコンセプトは、カリフォルニア州の排出量に関するEnergy Lollipop拡張機能から着想を得ています。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書を正式な情報源としてお考えください。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3094,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.fr.md",
      "source_type": "git_repo"
    },
    "token_count": 796,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "644ea3bf8861b927bd52fba4dec178b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.hi.md",
    "source_type": "git_repo",
    "title": "カーボントリガーブラウザー拡張機能: 完成したコード",
    "content": "カーボントリガーブラウザー拡張機能: 完成したコード\n電力使用量を追跡するためにtmrowのCO2 Signal APIを利用し、ブラウザー拡張機能を作成しました。この拡張機能は、あなたの地域での電力使用状況がどれほど負荷がかかっているかをブラウザー内で通知します。この情報を基に、活動内容を決定する手助けをします。\n始め方\nまず、npmをインストールしてください。そして、このコードをコンピューターの任意のフォルダーにダウンロードします。\n必要なパッケージをすべてインストールします:\nnpm install\nWebpackを使って拡張機能をビルドします:\nnpm run build\nEdgeにインストールするには、ブラウザーの右上にある「三点メニュー」をクリックして拡張機能パネルを探します。そこから「未梱包の拡張機能を読み込む」を選択してください。プロンプトが表示されたら「dist」フォルダーを開き、拡張機能をロードします。この拡張機能を使用するには、CO2 Signal APIのAPIキー（こちらでメールを通じて取得できます。このページのボックスにメールアドレスを入力してください）と、地域コードが必要です。Electricity Mapで確認できます。（例: ボストンの場合、「US-NEISO」を使用します。）\nAPIキーと地域コードを拡張機能のインターフェースに入力すると、ブラウザー拡張機能バーに表示されるカラードットが地域のエネルギー使用状況を反映するようになります。このドットは、エネルギー負荷の高い活動がどの程度適切かを示す指標となります。この「ドット」システムのアイデアは、カリフォルニアの排出量を可視化するEnergy Lollipop拡張機能から得ました。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3229,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.hi.md",
      "source_type": "git_repo"
    },
    "token_count": 830,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3de74293392c636185bea546a7bb5a4f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.it.md",
    "source_type": "git_repo",
    "title": "カーボントリガー ブラウザ拡張機能: スタートガイド",
    "content": "カーボントリガー ブラウザ拡張機能: スタートガイド\ntmrowのSignal CO2 APIを使用して電力使用量を監視し、自分の地域での電力使用の負荷をブラウザ上で直接確認できるリマインダーを作成するためのブラウザ拡張機能を作成します。この特別な拡張機能を使用することで、これらの情報に基づいて自分の活動を評価するのに役立ちます。\n始める前に\nnpmがインストールされている必要があります。このコードのコピーを自分のコンピュータのフォルダにダウンロードしてください。\n必要なパッケージをすべてインストールします:\nnpm install\nwebpackで拡張機能を作成します:\nnpm run build\nEdgeにインストールするには、ブラウザの右上隅にある「三点メニュー」から拡張機能パネルを開きます。まだ有効化されていない場合は、開発者モード（左下）を有効にしてください。「解凍済みを読み込む」を選択して新しい拡張機能を読み込みます。プロンプトで「dist」フォルダを開くと、拡張機能が読み込まれます。使用するには、CO2 Signal APIのAPIキー（こちらからメールで取得可能 - このページのボックスに自分のメールアドレスを入力してください）と、電力マップに対応する地域コードが必要です（例: ボストンの場合は「US-NEISO」）。\nAPIキーと地域を拡張機能のインターフェースに入力すると、ブラウザの拡張機能バーにある色付きの点が地域のエネルギー使用量を反映して変化します。また、高エネルギー消費の活動を実行するのに適したタイミングを示す指標を提供します。この「ポイント」システムのコンセプトは、カリフォルニア州の排出量を対象としたEnergy Lollipop拡張機能から提供されています。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3292,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.it.md",
      "source_type": "git_repo"
    },
    "token_count": 869,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "cbbb13b37ea26ea8d7ae8ed3b4f03d62",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ\n講義前クイズ\n講義前クイズ\nはじめに\nこのモジュールの前回の2つのレッスンでは、APIから取得したデータを表示するためのフォームと表示エリアを作成する方法を学びました。これは、ウェブ上でウェブプレゼンスを作成する非常に標準的な方法です。また、非同期でデータを取得する方法も学びました。これで、ブラウザ拡張機能はほぼ完成です。\n残る課題は、拡張機能のアイコンの色を更新するなどのバックグラウンドタスクを管理することです。このタイミングで、ブラウザがこの種のタスクをどのように管理するかについて考えるのは良い機会です。ウェブ資産を構築する際に、これらのブラウザタスクをパフォーマンスの観点から考えてみましょう。\nウェブパフォーマンスの基本\n「ウェブサイトのパフォーマンスは2つのことに関するものです: ページの読み込み速度と、その上で動作するコードの速度。」 -- Zack Grossbart\nウェブサイトをあらゆるデバイス、あらゆるユーザー、あらゆる状況で驚くほど高速にする方法についての話題は、当然ながら広範です。標準的なウェブプロジェクトやブラウザ拡張機能を構築する際に覚えておくべきポイントを以下に示します。\nサイトが効率的に動作していることを確認するために最初に行うべきことは、そのパフォーマンスに関するデータを収集することです。これを行う最初の場所は、ウェブブラウザの開発者ツールです。Edgeでは、「設定とその他」ボタン（ブラウザ右上の三点アイコン）を選択し、[その他のツール] > [開発者ツール] に移動してパフォーマンスタブを開きます。Windowsでは Ctrl + Shift + I、Macでは Option + Command + I のキーボードショートカットを使用して開発者ツールを開くこともできます。\nパフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 796,
    "chunk_index": 0,
    "total_chunks": 34
  },
  {
    "id": "a0a8b46066fb95b15ec5c544103dbc56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ\n講義前クイズ\n講義前クイズ\nはじめに\nこのモジュールの前回の2つのレッスンでは、APIから取得したデータを表示するためのフォームと表示エリアを作成する方法を学びました。これは、ウェブ上でウェブプレゼンスを作成する非常に標準的な方法です。また、非同期でデータを取得する方法も学びました。これで、ブラウザ拡張機能はほぼ完成です。\n残る課題は、拡張機能のアイコンの色を更新するなどのバックグラウンドタスクを管理することです。このタイミングで、ブラウザがこの種のタスクをどのように管理するかについて考えるのは良い機会です。ウェブ資産を構築する際に、これらのブラウザタスクをパフォーマンスの観点から考えてみましょう。\nウェブパフォーマンスの基本\n「ウェブサイトのパフォーマンスは2つのことに関するものです: ページの読み込み速度と、その上で動作するコードの速度。」 -- Zack Grossbart\nウェブサイトをあらゆるデバイス、あらゆるユーザー、あらゆる状況で驚くほど高速にする方法についての話題は、当然ながら広範です。標準的なウェブプロジェクトやブラウザ拡張機能を構築する際に覚えておくべきポイントを以下に示します。\nサイトが効率的に動作していることを確認するために最初に行うべきことは、そのパフォーマンスに関するデータを収集することです。これを行う最初の場所は、ウェブブラウザの開発者ツールです。Edgeでは、「設定とその他」ボタン（ブラウザ右上の三点アイコン）を選択し、[その他のツール] > [開発者ツール] に移動してパフォーマンスタブを開きます。Windowsでは Ctrl + Shift + I、Macでは Option + Command + I のキーボードショートカットを使用して開発者ツールを開くこともできます。\nパフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://wwwmicrosoft",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 798,
    "chunk_index": 1,
    "total_chunks": 34
  },
  {
    "id": "44ddf3ce74dfefb0cd50646e9dac31e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ\n講義前クイズ\n講義前クイズ\nはじめに\nこのモジュールの前回の2つのレッスンでは、APIから取得したデータを表示するためのフォームと表示エリアを作成する方法を学びました。これは、ウェブ上でウェブプレゼンスを作成する非常に標準的な方法です。また、非同期でデータを取得する方法も学びました。これで、ブラウザ拡張機能はほぼ完成です。\n残る課題は、拡張機能のアイコンの色を更新するなどのバックグラウンドタスクを管理することです。このタイミングで、ブラウザがこの種のタスクをどのように管理するかについて考えるのは良い機会です。ウェブ資産を構築する際に、これらのブラウザタスクをパフォーマンスの観点から考えてみましょう。\nウェブパフォーマンスの基本\n「ウェブサイトのパフォーマンスは2つのことに関するものです: ページの読み込み速度と、その上で動作するコードの速度。」 -- Zack Grossbart\nウェブサイトをあらゆるデバイス、あらゆるユーザー、あらゆる状況で驚くほど高速にする方法についての話題は、当然ながら広範です。標準的なウェブプロジェクトやブラウザ拡張機能を構築する際に覚えておくべきポイントを以下に示します。\nサイトが効率的に動作していることを確認するために最初に行うべきことは、そのパフォーマンスに関するデータを収集することです。これを行う最初の場所は、ウェブブラウザの開発者ツールです。Edgeでは、「設定とその他」ボタン（ブラウザ右上の三点アイコン）を選択し、[その他のツール] > [開発者ツール] に移動してパフォーマンスタブを開きます。Windowsでは Ctrl + Shift + I、Macでは Option + Command + I のキーボードショートカットを使用して開発者ツールを開くこともできます。\nパフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://wwwmicrosoftcom を試してみてください）、「記録」ボタンをクリックしてサイトを更新します。記録をいつでも停止すると、サイトを「スクリプト」、「レンダー」、「ペイント」するために生成されたルーチンを確認できます。\n✅ Microsoft Documentation のEdgeのパフォーマンスタブについての情報を確認してください。\nヒント: サイトの起動時間を正確に測定するには、ブラウザのキャッシュをクリアしてください。\nプロファイルタイムラインの要素を選択して、ページの読み込み中に発生するイベントをズームインして確認します。\nプロファイルタイムラインの一部を選択して、ページのパフォーマンスのスナップショットを取得し、概要ペインを確認します。\nイベントログペインを確認して、15ms以上かかったイベントがあるかどうかを確認します。\n✅ プロファイラーを使いこなしてください！このサイトで開発者ツールを開き、ボトルネックがあるかどうか確認してください。最も遅い読み込み資産は何ですか？最も速いものは？\nプロファイリングチェック\n一般的に、ウェブ開発者がサイトを構築する際に注意すべき「問題領域」がいくつかあります。これにより、プロダクションにデプロイする際の予期せぬ問題を回避できます。\n資産サイズ: 過去数年間でウェブは「重く」、したがって遅くなっています。この重さの一部は画像の使用に関連しています。\n✅ Internet Archive を見て、ページの重さの歴史的な変化やその他の情報を確認してください。\n良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。\nDOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。\nJavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。\n✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。\nブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。\n色を計算する関数を作成する\n/src/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1853,
    "chunk_index": 2,
    "total_chunks": 34
  },
  {
    "id": "f0ca31e5cf9cc4dd9afd3f96f60149d3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ\n講義前クイズ\n講義前クイズ\nはじめに\nこのモジュールの前回の2つのレッスンでは、APIから取得したデータを表示するためのフォームと表示エリアを作成する方法を学びました。これは、ウェブ上でウェブプレゼンスを作成する非常に標準的な方法です。また、非同期でデータを取得する方法も学びました。これで、ブラウザ拡張機能はほぼ完成です。\n残る課題は、拡張機能のアイコンの色を更新するなどのバックグラウンドタスクを管理することです。このタイミングで、ブラウザがこの種のタスクをどのように管理するかについて考えるのは良い機会です。ウェブ資産を構築する際に、これらのブラウザタスクをパフォーマンスの観点から考えてみましょう。\nウェブパフォーマンスの基本\n「ウェブサイトのパフォーマンスは2つのことに関するものです: ページの読み込み速度と、その上で動作するコードの速度。」 -- Zack Grossbart\nウェブサイトをあらゆるデバイス、あらゆるユーザー、あらゆる状況で驚くほど高速にする方法についての話題は、当然ながら広範です。標準的なウェブプロジェクトやブラウザ拡張機能を構築する際に覚えておくべきポイントを以下に示します。\nサイトが効率的に動作していることを確認するために最初に行うべきことは、そのパフォーマンスに関するデータを収集することです。これを行う最初の場所は、ウェブブラウザの開発者ツールです。Edgeでは、「設定とその他」ボタン（ブラウザ右上の三点アイコン）を選択し、[その他のツール] > [開発者ツール] に移動してパフォーマンスタブを開きます。Windowsでは Ctrl + Shift + I、Macでは Option + Command + I のキーボードショートカットを使用して開発者ツールを開くこともできます。\nパフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://wwwmicrosoftcom を試してみてください）、「記録」ボタンをクリックしてサイトを更新します。記録をいつでも停止すると、サイトを「スクリプト」、「レンダー」、「ペイント」するために生成されたルーチンを確認できます。\n✅ Microsoft Documentation のEdgeのパフォーマンスタブについての情報を確認してください。\nヒント: サイトの起動時間を正確に測定するには、ブラウザのキャッシュをクリアしてください。\nプロファイルタイムラインの要素を選択して、ページの読み込み中に発生するイベントをズームインして確認します。\nプロファイルタイムラインの一部を選択して、ページのパフォーマンスのスナップショットを取得し、概要ペインを確認します。\nイベントログペインを確認して、15ms以上かかったイベントがあるかどうかを確認します。\n✅ プロファイラーを使いこなしてください！このサイトで開発者ツールを開き、ボトルネックがあるかどうか確認してください。最も遅い読み込み資産は何ですか？最も速いものは？\nプロファイリングチェック\n一般的に、ウェブ開発者がサイトを構築する際に注意すべき「問題領域」がいくつかあります。これにより、プロダクションにデプロイする際の予期せぬ問題を回避できます。\n資産サイズ: 過去数年間でウェブは「重く」、したがって遅くなっています。この重さの一部は画像の使用に関連しています。\n✅ Internet Archive を見て、ページの重さの歴史的な変化やその他の情報を確認してください。\n良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。\nDOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。\nJavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。\n✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。\nブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。\n色を計算する関数を作成する\n/src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。\n```JavaScript\nfunction calculateColor(value) {\nlet co2Scale = [0, 150, 600, 750, 800];\nlet colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02'];\nlet closestNum = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1963,
    "chunk_index": 3,
    "total_chunks": 34
  },
  {
    "id": "c34c478e8d55dcdf9de610769e0d263a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "Ctrl + Shift + I、Macでは Option + Command + I のキーボードショートカットを使用して開発者ツールを開くこともできます。 パフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://wwwmicrosoftcom を試してみてください）、「記録」ボタンをクリックしてサイトを更新します。記録をいつでも停止すると、サイトを「スクリプト」、「レンダー」、「ペイント」するために生成されたルーチンを確認できます。 ✅ Microsoft Documentation のEdgeのパフォーマンスタブについての情報を確認してください。 ヒント: サイトの起動時間を正確に測定するには、ブラウザのキャッシュをクリアしてください。 プロファイルタイムラインの要素を選択して、ページの読み込み中に発生するイベントをズームインして確認します。 プロファイルタイムラインの一部を選択して、ページのパフォーマンスのスナップショットを取得し、概要ペインを確認します。 イベントログペインを確認して、15ms以上かかったイベントがあるかどうかを確認します。 ✅ プロファイラーを使いこなしてください！このサイトで開発者ツールを開き、ボトルネックがあるかどうか確認してください。最も遅い読み込み資産は何ですか？最も速いものは？ プロファイリングチェック 一般的に、ウェブ開発者がサイトを構築する際に注意すべき「問題領域」がいくつかあります。これにより、プロダクションにデプロイする際の予期せぬ問題を回避できます。 資産サイズ: 過去数年間でウェブは「重く」、したがって遅くなっています。この重さの一部は画像の使用に関連しています。 ✅ Internet Archive を見て、ページの重さの歴史的な変化やその他の情報を確認してください。 良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。 DOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。 JavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => {\nreturn Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1272,
    "chunk_index": 4,
    "total_chunks": 34
  },
  {
    "id": "da1b55d9ca49c36bbbc09de3fb4b85e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "Option + Command + I のキーボードショートカットを使用して開発者ツールを開くこともできます。 パフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://wwwmicrosoftcom を試してみてください）、「記録」ボタンをクリックしてサイトを更新します。記録をいつでも停止すると、サイトを「スクリプト」、「レンダー」、「ペイント」するために生成されたルーチンを確認できます。 ✅ Microsoft Documentation のEdgeのパフォーマンスタブについての情報を確認してください。 ヒント: サイトの起動時間を正確に測定するには、ブラウザのキャッシュをクリアしてください。 プロファイルタイムラインの要素を選択して、ページの読み込み中に発生するイベントをズームインして確認します。 プロファイルタイムラインの一部を選択して、ページのパフォーマンスのスナップショットを取得し、概要ペインを確認します。 イベントログペインを確認して、15ms以上かかったイベントがあるかどうかを確認します。 ✅ プロファイラーを使いこなしてください！このサイトで開発者ツールを開き、ボトルネックがあるかどうか確認してください。最も遅い読み込み資産は何ですか？最も速いものは？ プロファイリングチェック 一般的に、ウェブ開発者がサイトを構築する際に注意すべき「問題領域」がいくつかあります。これにより、プロダクションにデプロイする際の予期せぬ問題を回避できます。 資産サイズ: 過去数年間でウェブは「重く」、したがって遅くなっています。この重さの一部は画像の使用に関連しています。 ✅ Internet Archive を見て、ページの重さの歴史的な変化やその他の情報を確認してください。 良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。 DOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。 JavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1271,
    "chunk_index": 5,
    "total_chunks": 34
  },
  {
    "id": "3b39f7057960c23fbe6c26b69d096f0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "I のキーボードショートカットを使用して開発者ツールを開くこともできます。 パフォーマンスタブにはプロファイリングツールが含まれています。ウェブサイトを開き（例えば https://wwwmicrosoftcom を試してみてください）、「記録」ボタンをクリックしてサイトを更新します。記録をいつでも停止すると、サイトを「スクリプト」、「レンダー」、「ペイント」するために生成されたルーチンを確認できます。 ✅ Microsoft Documentation のEdgeのパフォーマンスタブについての情報を確認してください。 ヒント: サイトの起動時間を正確に測定するには、ブラウザのキャッシュをクリアしてください。 プロファイルタイムラインの要素を選択して、ページの読み込み中に発生するイベントをズームインして確認します。 プロファイルタイムラインの一部を選択して、ページのパフォーマンスのスナップショットを取得し、概要ペインを確認します。 イベントログペインを確認して、15ms以上かかったイベントがあるかどうかを確認します。 ✅ プロファイラーを使いこなしてください！このサイトで開発者ツールを開き、ボトルネックがあるかどうか確認してください。最も遅い読み込み資産は何ですか？最も速いものは？ プロファイリングチェック 一般的に、ウェブ開発者がサイトを構築する際に注意すべき「問題領域」がいくつかあります。これにより、プロダクションにデプロイする際の予期せぬ問題を回避できます。 資産サイズ: 過去数年間でウェブは「重く」、したがって遅くなっています。この重さの一部は画像の使用に関連しています。 ✅ Internet Archive を見て、ページの重さの歴史的な変化やその他の情報を確認してください。 良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。 DOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。 JavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value);\n})[0];\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1277,
    "chunk_index": 6,
    "total_chunks": 34
  },
  {
    "id": "a66fbffb4609d6f4b094ccbb0a394527",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "を試してみてください）、「記録」ボタンをクリックしてサイトを更新します。記録をいつでも停止すると、サイトを「スクリプト」、「レンダー」、「ペイント」するために生成されたルーチンを確認できます。 ✅ Microsoft Documentation のEdgeのパフォーマンスタブについての情報を確認してください。 ヒント: サイトの起動時間を正確に測定するには、ブラウザのキャッシュをクリアしてください。 プロファイルタイムラインの要素を選択して、ページの読み込み中に発生するイベントをズームインして確認します。 プロファイルタイムラインの一部を選択して、ページのパフォーマンスのスナップショットを取得し、概要ペインを確認します。 イベントログペインを確認して、15ms以上かかったイベントがあるかどうかを確認します。 ✅ プロファイラーを使いこなしてください！このサイトで開発者ツールを開き、ボトルネックがあるかどうか確認してください。最も遅い読み込み資産は何ですか？最も速いものは？ プロファイリングチェック 一般的に、ウェブ開発者がサイトを構築する際に注意すべき「問題領域」がいくつかあります。これにより、プロダクションにデプロイする際の予期せぬ問題を回避できます。 資産サイズ: 過去数年間でウェブは「重く」、したがって遅くなっています。この重さの一部は画像の使用に関連しています。 ✅ Internet Archive を見て、ページの重さの歴史的な変化やその他の情報を確認してください。 良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。 DOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。 JavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum);\nlet num = (element) => element > closestNum;\nlet scaleIndex = co2Scale",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1230,
    "chunk_index": 7,
    "total_chunks": 34
  },
  {
    "id": "336818292d9ad3bb612634e32195f56e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "良いプラクティスとして、画像を最適化し、ユーザーに適したサイズと解像度で配信することを確認してください。 DOMのトラバーサル: ブラウザは、あなたが書いたコードに基づいてDocument Object Modelを構築する必要があります。そのため、タグを最小限に抑え、ページが必要とするものだけを使用してスタイリングすることが、良いページパフォーマンスのために重要です。この点で、ページに関連する過剰なCSSは最適化されるべきです。例えば、特定のページでのみ使用されるスタイルは、メインのスタイルシートに含める必要はありません。 JavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num);\nlet closestColor = colors[scaleIndex];\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 8,
    "total_chunks": 34
  },
  {
    "id": "b2c7414bc1329974ef8aa7e9d1427ab5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "JavaScript: すべてのJavaScript開発者は、DOMがトラバーサルされてブラウザにペイントされる前に読み込まれる必要がある「レンダーブロッキング」スクリプトに注意する必要があります。インラインスクリプトで defer を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor);\nchrome runtime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 9,
    "total_chunks": 34
  },
  {
    "id": "80c5ce204b2844c09bbde41c83fc063a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "を使用することを検討してください（Terrariumモジュールで行われているように）。 ✅ サイト速度テストウェブサイト を試して、サイトパフォーマンスを判断するために行われる一般的なチェックについて学んでください。 ブラウザが送信する資産をレンダリングする方法について理解したところで、拡張機能を完成させるために必要な最後のいくつかのことを見てみましょう。 色を計算する関数を作成する /src/indexjs で、DOMにアクセスするために設定した一連の const 変数の後に、calculateColor() という関数を追加します。 ```JavaScript function calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } });\n}\n```\nここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 10,
    "total_chunks": 34
  },
  {
    "id": "8a39a84deb8e6f22a07e81696ddf2e10",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "calculateColor(value) { let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。\n「chrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 314,
    "chunk_index": 11,
    "total_chunks": 34
  },
  {
    "id": "47bac95863dbbe7397843d4a34183739",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "{ let co2Scale = [0, 150, 600, 750, 800]; let colors = ['#2AA364', '#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」\n✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。\n注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。\nデフォルトのアイコン色を設定する\n次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。\nJavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 669,
    "chunk_index": 12,
    "total_chunks": 34
  },
  {
    "id": "79d165d23cd7e235f9c929a6526f19f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "'#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 642,
    "chunk_index": 13,
    "total_chunks": 34
  },
  {
    "id": "24559f8570b6223ec943da3efbe015ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "'#F5EB4D', '#9E4229', '#381D02', '#381D02']; let closestNum = co2Scalesort((a, b) => { return Mathabs(a - value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({\naction: 'updateIcon',\nvalue: {\ncolor: 'green',\n},\n});\n関数を呼び出し、APIコールを実行する\n次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。\nJavaScript\n//let CO2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 14,
    "total_chunks": 34
  },
  {
    "id": "c45ebec47fe8d30b06fdef49f7ee5f23",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "value) - Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2);\n最後に、/dist/background",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 696,
    "chunk_index": 15,
    "total_chunks": 34
  },
  {
    "id": "dd4f27196c9d66cbccaf55027d9fdad0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "- Mathabs(b - value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。\n```JavaScript\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 730,
    "chunk_index": 16,
    "total_chunks": 34
  },
  {
    "id": "c26b1ea003c62a76a20e7f94343a0753",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntime",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 726,
    "chunk_index": 17,
    "total_chunks": 34
  },
  {
    "id": "3b7d3aa348dbe6e1f62ddd8a8d8890b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 728,
    "chunk_index": 18,
    "total_chunks": 34
  },
  {
    "id": "546b315adb708037944cf02f0949900a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "value); })[0]; consolelog(value + ' is closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) {\nif (msg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 742,
    "chunk_index": 19,
    "total_chunks": 34
  },
  {
    "id": "509812e49d1263af2f3ab84c363654d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "closest to ' + closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') {\nchrome",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 738,
    "chunk_index": 20,
    "total_chunks": 34
  },
  {
    "id": "39aa3e80724adddb8d1e233d79d4ae28",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserAction",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 737,
    "chunk_index": 21,
    "total_chunks": 34
  },
  {
    "id": "33c4c784dc293ad99edfbe29fe67d446",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "closestNum); let num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 744,
    "chunk_index": 22,
    "total_chunks": 34
  },
  {
    "id": "643e3bd8018c13a29740fb9c356db6c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "num = (element) => element > closestNum; let scaleIndex = co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) });\n}\n});\n//borrowed from energy lollipop extension, nice feature",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 756,
    "chunk_index": 23,
    "total_chunks": 34
  },
  {
    "id": "10eb7cb9ba8376350a036db2483f2dcf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "co2ScalefindIndex(num); let closestColor = colors[scaleIndex]; consolelog(scaleIndex, closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) {\nlet canvas = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 751,
    "chunk_index": 24,
    "total_chunks": 34
  },
  {
    "id": "6c86690c31723e6086eb6719e9be3110",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "closestColor); chrome runtimesendMessage({ action: 'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas');\nlet context = canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 738,
    "chunk_index": 25,
    "total_chunks": 34
  },
  {
    "id": "fa9fd33cc039e4cf5d07c5513279ec5e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "'updateIcon', value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d');\ncontext",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 26,
    "total_chunks": 34
  },
  {
    "id": "aca735637871a60d11edba935489c72e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "value: { color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath();\ncontext",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 27,
    "total_chunks": 34
  },
  {
    "id": "41da465df975a671341ba846b7b3b93f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "{ color: closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath(); contextfillStyle = value",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 735,
    "chunk_index": 28,
    "total_chunks": 34
  },
  {
    "id": "bcfc94b7bd53876dafd301535173fe3c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "closestColor } }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath(); contextfillStyle = valuecolor;\ncontext",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 735,
    "chunk_index": 29,
    "total_chunks": 34
  },
  {
    "id": "d391b742ceea05421841b9f5a6696ad7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "} }); } ``` ここで何が起こっているのでしょうか？前回のレッスンで完了したAPIコールから値（炭素強度）を渡し、その値がcolors配列に提示されたインデックスにどれだけ近いかを計算します。そして、その最も近い色の値をchrome runtimeに送信します。 chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath(); contextfillStyle = valuecolor; contextarc(100, 100, 50, 0, 2 * Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 750,
    "chunk_index": 30,
    "total_chunks": 34
  },
  {
    "id": "083d3ee6e4303c01f30ca4d05afaaae6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "chromeruntimeには、さまざまなバックグラウンドタスクを処理するAPIがあります。あなたの拡張機能はこれを活用しています。 「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath(); contextfillStyle = valuecolor; contextarc(100, 100, 50, 0, 2 * MathPI);\ncontext",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 653,
    "chunk_index": 31,
    "total_chunks": 34
  },
  {
    "id": "e8fbbbccbc763d37b3ae319cc9f48cfe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "「chromeruntime APIを使用して、バックグラウンドページを取得し、マニフェストの詳細を返し、アプリまたは拡張機能のライフサイクル内のイベントをリッスンして応答します。また、このAPIを使用して、URLの相対パスを完全修飾URLに変換することもできます。」 ✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath(); contextfillStyle = valuecolor; contextarc(100, 100, 50, 0, 2 * MathPI); contextfill();\nreturn context",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 607,
    "chunk_index": 32,
    "total_chunks": 34
  },
  {
    "id": "c4e3c5e8cb96f353518bd59fe908b38c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート3: バックグラウンドタスクとパフォーマンスについて学ぶ",
    "content": "✅ Edge用にこのブラウザ拡張機能を開発している場合、chrome APIを使用していることに驚くかもしれません。新しいEdgeブラウザバージョンはChromiumブラウザエンジン上で動作するため、これらのツールを活用できます。 注意: ブラウザ拡張機能をプロファイリングする場合、拡張機能自体から開発者ツールを起動してください。拡張機能は独自のブラウザインスタンスとして動作します。 デフォルトのアイコン色を設定する 次に、init() 関数内で、chromeの updateIcon アクションを再度呼び出して、アイコンを最初に汎用的な緑色に設定します。 JavaScript chromeruntimesendMessage({ action: 'updateIcon', value: { color: 'green', }, }); 関数を呼び出し、APIコールを実行する 次に、前回作成した関数を、C02Signal APIから返されるプロミスに追加して呼び出します。 JavaScript //let CO2calculateColor(CO2); 最後に、/dist/backgroundjs で、これらのバックグラウンドアクションコールのリスナーを追加します。 ```JavaScript chromeruntimeonMessageaddListener(function (msg, sender, sendResponse) { if (msgaction === 'updateIcon') { chromebrowserActionsetIcon({ imageData: drawIcon(msgvalue) }); } }); //borrowed from energy lollipop extension, nice featurefunction drawIcon(value) { let canvas = documentcreateElement('canvas'); let context = canvasgetContext('2d'); contextbeginPath(); contextfillStyle = valuecolor; contextarc(100, 100, 50, 0, 2 * MathPI); contextfill(); return contextgetImageData(50, 50, 100, 100);\n}\n```\nこのコードでは、バックエンドタスクマネージャーに送信されるメッセージのリスナーを追加しています。メッセージが「updateIcon」と呼ばれる場合、次のコードが実行され、Canvas APIを使用して適切な色のアイコンを描画します。\n✅ Canvas APIについては、スペースゲームのレッスンでさらに学ぶことができます。\n次に、拡張機能を再構築します（npm run build）、拡張機能を更新して起動し、色の変化を確認します。今が買い物や皿洗いをするのに良いタイミングかどうかがわかりますね！\nおめでとうございます！便利なブラウザ拡張機能を構築し、ブラウザの動作やそのパフォーマンスをプロファイリングする方法についてさらに学びました。\n🚀 チャレンジ\n長い間存在しているオープンソースウェブサイトを調査し、そのGitHub履歴に基づいて、パフォーマンスのためにどのように最適化されたかを確認してください。最も一般的な問題点は何ですか？\n講義後クイズ\n講義後クイズ\n復習と自己学習\nパフォーマンスニュースレターに登録することを検討してください。\nブラウザがウェブパフォーマンスを評価する方法について、ウェブツールのパフォーマンスタブを調査してください。大きな違いは見つかりますか？\n課題\nサイトのパフォーマンスを分析する\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12812,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\3-background-tasks-and-performance\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1234,
    "chunk_index": 33,
    "total_chunks": 34
  },
  {
    "id": "d9347abf1ef8c432c0e11120e9eac38a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.ja.md",
    "source_type": "git_repo",
    "title": "カーボントリガーブラウザ拡張機能：完成したコード",
    "content": "カーボントリガーブラウザ拡張機能：完成したコード\ntmrow の CO2 シグナル API を使用して、地域の電力使用量を追跡し、ブラウザ上でリマインダーとして表示する拡張機能を構築します。この拡張機能を使うことで、電力使用量に基づいて日々の活動を調整することができます。\nはじめに\nnpm がインストールされている必要があります。このコードをコンピュータ上のフォルダにダウンロードしてください。\n必要なパッケージをすべてインストールします。\nnpm install\nwebpack を使用して拡張機能をビルドします。\nnpm run build\nEdge にインストールするには、ブラウザの右上にある「3つのドット」メニューから「拡張機能」パネルを開きます。そこから「Load Unpacked」を選択し、新しい拡張機能をロードします。プロンプトが表示されたら「dist」フォルダを選択してください。これで拡張機能が読み込まれます。使用するには、CO2 シグナル API の API キー (こちらでメールを通じて取得 - ページのボックスにメールアドレスを入力してください) と、Electricity Map に対応する 地域コード が必要です（例えば、ボストンでは 'US-NEISO' を使用します）。\nAPI キーと地域コードを拡張機能のインターフェイスに入力すると、ブラウザの拡張バーに表示される色付きのドットが、地域のエネルギー使用量を反映して変化します。このドットは、どのようなエネルギーを必要とする活動を行うのが適切かを示してくれます。この「ドット」システムのアイデアは、カリフォルニア州の排出量を可視化する Energy Lollipop extension にインスパイアされたものです。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 3164,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.ja.md",
      "source_type": "git_repo"
    },
    "token_count": 809,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "bbee97770e755abe34f8bdce40096e04",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.ms.md",
    "source_type": "git_repo",
    "title": "Carbon Trigger ブラウザー拡張機能: 完全なコード",
    "content": "Carbon Trigger ブラウザー拡張機能: 完全なコード\ntmrowのCO2 Signal APIを使用して電力消費を検出し、地域の電力使用状況に関する通知をブラウザーで受け取れる拡張機能を構築します。この拡張機能を利用することで、提供される情報に基づいて活動を検討する助けになります。\n始め方\nまず、npmをインストールしてください。このコードのコピーをコンピューターのフォルダーにダウンロードします。\n必要なパッケージをすべてインストールします:\nnpm install\nwebpackを使用して拡張機能をビルドします:\nnpm run build\nEdgeにインストールするには、ブラウザー右上の「三点メニュー」から拡張機能パネルを開きます。そこから「Load Unpacked」を選択して新しい拡張機能を読み込みます。「dist」フォルダーを選択すると拡張機能がロードされます。使用するには、CO2 Signal APIのAPIキーが必要です（こちらからメールで取得できます - ページのボックスにメールアドレスを入力してください）と、Electricity Mapに対応する地域コードが必要です（例えば、ボストンでは「US-NEISO」を使用します）。\nAPIキーと地域コードを拡張機能のインターフェースに入力すると、ブラウザー拡張バーの色付きドットが地域のエネルギー使用状況を反映して変化し、適切な活動の指針を提供します。この「ドット」システムのコンセプトは、カリフォルニア州向けにリリースされたEnergy Lollipopブラウザー拡張機能から着想を得ています。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2999,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\solution\\translation\\README.ms.md",
      "source_type": "git_repo"
    },
    "token_count": 770,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ac9a3f021f50dd9338ef6b0491142ba0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\solution\\README.md",
    "source_type": "git_repo",
    "title": "README",
    "content": "これはプレースホルダーであり、意図的に空白のままにされています\n免責事項:\nこの文書はAI翻訳サービスCo-op Translatorを使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 896,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 216,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "53e913814cb84a31e73ea2de70f68b88",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\assignment.md",
    "source_type": "git_repo",
    "title": "新しいキーボードゲームを作成する",
    "content": "新しいキーボードゲームを作成する\n手順\nキーボードイベントを使用してタスクを実行する小さなゲームを作成してください。タイピングゲームのようなものでも、キー入力で画面にピクセルを描画するアートタイプのゲームでも構いません。創造性を発揮してください！\n評価基準\n| 基準     | 優秀                     | 適切                     | 改善が必要         |\n| -------- | ------------------------ | ------------------------ | ----------------- |\n|          | 完成されたゲームが提示されている | ゲームが非常に簡素である | ゲームにバグがある |\n|          |                          |                          |                   |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳をお勧めします。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1664,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 425,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "a7eeed2a0f310a216e344ffaa147b3f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\assignment.md",
    "source_type": "git_repo",
    "title": "HTMLを練習しよう: ブログのモックアップを作成",
    "content": "HTMLを練習しよう: ブログのモックアップを作成\n手順\n自分の個人ウェブサイトをデザイン、または再デザインすることを想像してください。サイトのグラフィカルなモックアップを作成し、そのサイトのさまざまな要素を構築するために使用するHTMLマークアップを記述してください。これを紙に描いてスキャンするか、好きなソフトウェアを使用しても構いませんが、HTMLマークアップは必ず手書きで記述してください。\n評価基準\n| 基準     | 優秀                                                                                 | 適切                                                                         | 改善が必要                                                                         |\n| -------- | ----------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |\n|          | ブログのレイアウトが視覚的に表現され、少なくとも10個のマークアップ要素が表示されている | ブログのレイアウトが視覚的に表現され、約5個のマークアップ要素が表示されている | ブログのレイアウトが視覚的に表現され、最大で3個のマークアップ要素が表示されている |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された原文が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2371,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 564,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3276316deacf65bcef649e0ff0e1072c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用\n講義前クイズ\n講義前クイズ\nはじめに\nこのレッスンでは、ブラウザ拡張のフォームを使ってAPIを呼び出し、その結果を拡張内に表示する方法を学びます。また、ブラウザのローカルストレージにデータを保存し、後で参照・利用する方法についても学びます。\n✅ 適切なファイル内の番号付きセグメントに従ってコードを配置してください。\n拡張内で操作する要素を設定する\nここまでで、ブラウザ拡張のフォームと結果を表示する<div>のHTMLを作成しました。これ以降は、/src/index jsファイルで作業を進め、拡張を少しずつ構築していきます。プロジェクトのセットアップやビルドプロセスについては前回のレッスンを参照してください。\nindex jsファイルで作業を開始し、まずは各フィールドに関連付けられた値を保持するためのconst変数を作成します。\n```JavaScript\n// form fields\nconst form = document querySelector(' form-data');\nconst region = document querySelector(' region-name');\nconst apiKey = document querySelector(' api-key');\n// results\nconst errors = document querySelector(' errors');\nconst loading = document querySelector(' loading');\nconst results = document querySelector(' result-container');\nconst usage = document querySelector(' carbon-usage');\nconst fossilfuel = document querySelector(' fossil-fuel');\nconst myregion = document querySelector(' my-region');\nconst clearBtn = document querySelector('",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 0,
    "total_chunks": 45
  },
  {
    "id": "0bf59e552ae3b45689b362417efb9a91",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "講義前クイズ 講義前クイズ はじめに このレッスンでは、ブラウザ拡張のフォームを使ってAPIを呼び出し、その結果を拡張内に表示する方法を学びます。また、ブラウザのローカルストレージにデータを保存し、後で参照・利用する方法についても学びます。 ✅ 適切なファイル内の番号付きセグメントに従ってコードを配置してください。 拡張内で操作する要素を設定する ここまでで、ブラウザ拡張のフォームと結果を表示する<div>のHTMLを作成しました。これ以降は、/src/index jsファイルで作業を進め、拡張を少しずつ構築していきます。プロジェクトのセットアップやビルドプロセスについては前回のレッスンを参照してください。 index jsファイルで作業を開始し、まずは各フィールドに関連付けられた値を保持するためのconst変数を作成します。 ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn');\n```\nこれらのフィールドは、前回のレッスンでHTMLで設定したCSSクラスによって参照されます。\nリスナーを追加する\n次に、フォームとリセットボタンにイベントリスナーを追加します。これにより、ユーザーがフォームを送信したりリセットボタンをクリックしたりすると、何かが起こります。また、ファイルの末尾にアプリを初期化する呼び出しを追加します。\nJavaScript\nform",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 605,
    "chunk_index": 1,
    "total_chunks": 45
  },
  {
    "id": "1c89d83e7d8f871b56be60d391a03b80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "拡張内で操作する要素を設定する ここまでで、ブラウザ拡張のフォームと結果を表示する<div>のHTMLを作成しました。これ以降は、/src/index jsファイルで作業を進め、拡張を少しずつ構築していきます。プロジェクトのセットアップやビルドプロセスについては前回のレッスンを参照してください。 index jsファイルで作業を開始し、まずは各フィールドに関連付けられた値を保持するためのconst変数を作成します。 ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn'); ``` これらのフィールドは、前回のレッスンでHTMLで設定したCSSクラスによって参照されます。 リスナーを追加する 次に、フォームとリセットボタンにイベントリスナーを追加します。これにより、ユーザーがフォームを送信したりリセットボタンをクリックしたりすると、何かが起こります。また、ファイルの末尾にアプリを初期化する呼び出しを追加します。 JavaScript formaddEventListener('submit', (e) => handleSubmit(e));\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 2,
    "total_chunks": 45
  },
  {
    "id": "f16f9e36cfc9687868ac7bb8de25e5c2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "jsファイルで作業を開始し、まずは各フィールドに関連付けられた値を保持するためのconst変数を作成します。 ```JavaScript // form fields const form = document querySelector(' form-data'); const region = document querySelector(' region-name'); const apiKey = document querySelector(' api-key'); // results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn'); ``` これらのフィールドは、前回のレッスンでHTMLで設定したCSSクラスによって参照されます。 リスナーを追加する 次に、フォームとリセットボタンにイベントリスナーを追加します。これにより、ユーザーがフォームを送信したりリセットボタンをクリックしたりすると、何かが起こります。また、ファイルの末尾にアプリを初期化する呼び出しを追加します。 JavaScript formaddEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e));\ninit();\n✅ フォーム送信やクリックイベントをリスニングする際の省略形に注目してください。このイベントはhandleSubmitやreset関数に渡されます。この省略形を長い形式で書き換えることはできますか？どちらの形式が好みですか？\ninit()関数とreset()関数を構築する\n次に、拡張を初期化する関数init()を構築します。\n```JavaScript\nfunction init() {\n//if anything is in localStorage, pick it up\nconst storedApiKey = localStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 501,
    "chunk_index": 3,
    "total_chunks": 45
  },
  {
    "id": "8601cbbcf5e56b14a056cdd2f83e955a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "results const errors = document querySelector(' errors'); const loading = document querySelector(' loading'); const results = document querySelector(' result-container'); const usage = document querySelector(' carbon-usage'); const fossilfuel = document querySelector(' fossil-fuel'); const myregion = document querySelector(' my-region'); const clearBtn = document querySelector('clear-btn'); ``` これらのフィールドは、前回のレッスンでHTMLで設定したCSSクラスによって参照されます。 リスナーを追加する 次に、フォームとリセットボタンにイベントリスナーを追加します。これにより、ユーザーがフォームを送信したりリセットボタンをクリックしたりすると、何かが起こります。また、ファイルの末尾にアプリを初期化する呼び出しを追加します。 JavaScript formaddEventListener('submit', (e) => handleSubmit(e)); clearBtnaddEventListener('click', (e) => reset(e)); init(); ✅ フォーム送信やクリックイベントをリスニングする際の省略形に注目してください。このイベントはhandleSubmitやreset関数に渡されます。この省略形を長い形式で書き換えることはできますか？どちらの形式が好みですか？ init()関数とreset()関数を構築する 次に、拡張を初期化する関数init()を構築します。 ```JavaScript function init() { //if anything is in localStorage, pick it up const storedApiKey = localStoragegetItem('apiKey');\nconst storedRegion = localStorage getItem('regionName');\n//set icon to be generic green\n//todo\nif (storedApiKey === null || storedRegion === null) {\n//if we don't have the keys, show the form\nform style display = 'block';\nresults style display = 'none';\nloading style display = 'none';\nclearBtn style display = 'none';\nerrors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 4,
    "total_chunks": 45
  },
  {
    "id": "4dc8de640435048054f4dd76eddcbb52",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "clearBtnaddEventListener('click', (e) => reset(e)); init(); ✅ フォーム送信やクリックイベントをリスニングする際の省略形に注目してください。このイベントはhandleSubmitやreset関数に渡されます。この省略形を長い形式で書き換えることはできますか？どちらの形式が好みですか？ init()関数とreset()関数を構築する 次に、拡張を初期化する関数init()を構築します。 ```JavaScript function init() { //if anything is in localStorage, pick it up const storedApiKey = localStoragegetItem('apiKey'); const storedRegion = localStorage getItem('regionName'); //set icon to be generic green //todo if (storedApiKey === null || storedRegion === null) { //if we don't have the keys, show the form form style display = 'block'; results style display = 'none'; loading style display = 'none'; clearBtn style display = 'none'; errorstextContent = '';\n} else {\n//if we have saved keys/regions in localStorage, show results when they load\ndisplayCarbonUsage(storedApiKey, storedRegion);\nresults style display = 'none';\nform style display = 'none';\nclearBtn style display = 'block';\n}\n};\nfunction reset(e) {\ne preventDefault();\n//clear local storage for region only\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 326,
    "chunk_index": 5,
    "total_chunks": 45
  },
  {
    "id": "cf8ae4355ced06bcd115e25400621325",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "don't have the keys, show the form form style display = 'block'; results style display = 'none'; loading style display = 'none'; clearBtn style display = 'none'; errorstextContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName');\ninit();\n}\n```\nこの関数には興味深いロジックがあります。内容を読み解いてみてください。\nユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。\nどちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。\n結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。\nキーと地域が存在する場合、以下のルーチンを開始します：\nAPIを呼び出して炭素使用量データを取得する\n結果エリアを非表示にする\nフォームを非表示にする\nリセットボタンを表示する\n次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。\n注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。\nAPIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。\n✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。\nLocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。\ndisplayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。\nフォーム送信を処理する\nイベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 983,
    "chunk_index": 6,
    "total_chunks": 45
  },
  {
    "id": "11b6ccde32d1f6a9bf8480e6972a57a4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "= 'none'; errorstextContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregion",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 959,
    "chunk_index": 7,
    "total_chunks": 45
  },
  {
    "id": "f246d2d1591b8237876fc671ea41368c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "= 'none'; errorstextContent = ''; } else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。\nJavaScript\nfunction handleSubmit(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1017,
    "chunk_index": 8,
    "total_chunks": 45
  },
  {
    "id": "f8d1dce648857c833bd00a20a1bbeb91",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "} else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault();\nsetUpUser(apiKey",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1013,
    "chunk_index": 9,
    "total_chunks": 45
  },
  {
    "id": "16e0c6faab0272bd8491ba3328ad2276",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "else { //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, region",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1015,
    "chunk_index": 10,
    "total_chunks": 45
  },
  {
    "id": "18d26a979b1bc02d396b3d2ca11c44b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "{ //if we have saved keys/regions in localStorage, show results when they load displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue);\n}\n✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。\nユーザーを設定する\n次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します：\nJavaScript\nfunction setUpUser(apiKey, regionName) {\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1215,
    "chunk_index": 11,
    "total_chunks": 45
  },
  {
    "id": "416d3269f2f94f37e8420a2cfa3a23b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "displayCarbonUsage(storedApiKey, storedRegion); results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey);\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1209,
    "chunk_index": 12,
    "total_chunks": 45
  },
  {
    "id": "4109924ca5ff597eb005b6a625d1c2ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "results style display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName);\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1212,
    "chunk_index": 13,
    "total_chunks": 45
  },
  {
    "id": "56787252039cb473c2924feb5475d940",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1211,
    "chunk_index": 14,
    "total_chunks": 45
  },
  {
    "id": "dfa42ee7a2380e34cd3d90de18ea018c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "display = 'none'; form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block';\nerrors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1217,
    "chunk_index": 15,
    "total_chunks": 45
  },
  {
    "id": "7e70aa0c12c233d9c38f0c93b3f3f959",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "form style display = 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = '';\nclearBtn",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1219,
    "chunk_index": 16,
    "total_chunks": 45
  },
  {
    "id": "5b5e90114951412bc090968f8fce8c2a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "= 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1217,
    "chunk_index": 17,
    "total_chunks": 45
  },
  {
    "id": "09c686744bbe9259a1dc0f6a2f00aa66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "= 'none'; clearBtn style display = 'block'; } }; function reset(e) { e preventDefault(); //clear local storage for region only localStorageremoveItem('regionName'); init(); } ``` この関数には興味深いロジックがあります。内容を読み解いてみてください。 ユーザーがローカルストレージにAPIキーと地域コードを保存しているかどうかを確認するための2つのconstが設定されます。 どちらかがnullの場合、フォームのスタイルを変更して表示します（display: 'block'）。 結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block';\n//make initial call\ndisplayCarbonUsage(apiKey, regionName);\n}\nこの関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！\n炭素使用量を表示する\nいよいよAPIをクエリする時です！\n進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。\n✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？\nこの関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。\nこちらはasyncについての簡単な動画です：\n🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。\nC02Signal APIをクエリする新しい関数を作成します：\n```JavaScript\nimport axios from '",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1797,
    "chunk_index": 18,
    "total_chunks": 45
  },
  {
    "id": "6f650f5e9c748be2b47ca5c6fed5120b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "結果、ローディング、clearBtnを非表示にし、エラーテキストを空文字列に設定します。 キーと地域が存在する場合、以下のルーチンを開始します： APIを呼び出して炭素使用量データを取得する 結果エリアを非表示にする フォームを非表示にする リセットボタンを表示する 次に進む前に、ブラウザで利用可能な非常に重要な概念について学ぶのが役立ちます：LocalStorage。LocalStorageは、ブラウザ内で文字列をkey-valueペアとして保存する便利な方法です。このタイプのウェブストレージは、JavaScriptを使用してブラウザ内のデータを管理するために操作できます。LocalStorageは期限切れになりませんが、もう一つのウェブストレージであるSessionStorageは、ブラウザを閉じるとクリアされます。これらのストレージの種類には、それぞれ利点と欠点があります。 注意 - ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios';\nasync function displayCarbonUsage(apiKey, region) {\ntry {\nawait axios",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1654,
    "chunk_index": 19,
    "total_chunks": 45
  },
  {
    "id": "59a2302cfdae26f5954c5e1a105d6db0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://api",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1352,
    "chunk_index": 20,
    "total_chunks": 45
  },
  {
    "id": "047a8a47c2762886fa31c9c3edcb4c59",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signal",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1355,
    "chunk_index": 21,
    "total_chunks": 45
  },
  {
    "id": "dcc73b69059bbbf7f8291d1269ff0abb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "ブラウザ拡張には独自のローカルストレージがあります。メインブラウザウィンドウは別のインスタンスであり、別々に動作します。 APIキーを文字列値として設定すると、Edgeで「ウェブページを検査」（ブラウザを右クリックして検査）し、ストレージを確認することで設定されていることがわかります。 ✅ LocalStorageにデータを保存したくない状況について考えてみてください。一般的に、APIキーをLocalStorageに保存するのは良くないアイデアです！その理由がわかりますか？今回の場合、アプリは学習目的でのみ使用され、アプリストアに公開されることはないため、この方法を使用します。 LocalStorageを操作するには、Web APIを使用してgetItem()、setItem()、またはremoveItem()を使用します。これらはほとんどのブラウザで広くサポートされています。 displayCarbonUsage()関数を構築する前に、初期フォーム送信を処理する機能を構築しましょう。 フォーム送信を処理する イベント引数(e)を受け取るhandleSubmit関数を作成します。このイベントが伝播するのを止め（この場合、ブラウザのリフレッシュを止めたい）、新しい関数setUpUserを呼び出し、apiKeyvalueとregionvalueの引数を渡します。この方法で、適切なフィールドが入力された際に初期フォームから取得された2つの値を使用します。 JavaScript function handleSubmit(e) { epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', {\nparams: {\ncountryCode: region,\n},\nheaders: {\n'auth-token': apiKey,\n},\n})",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1381,
    "chunk_index": 22,
    "total_chunks": 45
  },
  {
    "id": "6467aa290c15a29b93dc6b7dcd80b51a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "{ epreventDefault(); setUpUser(apiKeyvalue, regionvalue); } ✅ 復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => {\nlet CO2 = Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 896,
    "chunk_index": 23,
    "total_chunks": 45
  },
  {
    "id": "cff93cae6b0d2d32f1ce05db16ab4918",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 881,
    "chunk_index": 24,
    "total_chunks": 45
  },
  {
    "id": "72dc5f6ab6f41a9d6a8336a9932a0026",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 883,
    "chunk_index": 25,
    "total_chunks": 45
  },
  {
    "id": "2302f420156d5a836154f87665e8ad18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 885,
    "chunk_index": 26,
    "total_chunks": 45
  },
  {
    "id": "3bfb4b6632b721e80b71c2ab2853e809",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "復習 - 前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity);\n//calculateColor(CO2);\nloading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 896,
    "chunk_index": 27,
    "total_chunks": 45
  },
  {
    "id": "8c83f71185541f2515e0daaa24d6e619",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 889,
    "chunk_index": 28,
    "total_chunks": 45
  },
  {
    "id": "4f8e01b19013340e2a639fefdda12b87",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "前回のレッスンで設定したHTMLには、valueがキャプチャされる2つの入力フィールドがあり、これらはファイルの冒頭で設定したconstによって取得されます。また、両方ともrequired属性が設定されているため、ブラウザはユーザーがnull値を入力するのを防ぎます。 ユーザーを設定する 次に進み、setUpUser関数を作成します。ここでは、APIキーと地域名のローカルストレージ値を設定します。新しい関数を追加します： JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none';\nform",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 895,
    "chunk_index": 29,
    "total_chunks": 45
  },
  {
    "id": "20314603786be350380173bfd879c890",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 720,
    "chunk_index": 30,
    "total_chunks": 45
  },
  {
    "id": "a3ed378472b1dd5cf8642e5bdcda70ab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "JavaScript function setUpUser(apiKey, regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none';\nmyregion",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 727,
    "chunk_index": 31,
    "total_chunks": 45
  },
  {
    "id": "8f22a8be1705e156746f3b5e3f20b3a2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "regionName) { localStoragesetItem('apiKey', apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region;\nusage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 725,
    "chunk_index": 32,
    "total_chunks": 45
  },
  {
    "id": "ce7c072f3fd69623b92a09d7f6399838",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "apiKey); localStoragesetItem('regionName', regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent =\nMath",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 717,
    "chunk_index": 33,
    "total_chunks": 45
  },
  {
    "id": "e71656ecdee57075b863616ac43ec1cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 707,
    "chunk_index": 34,
    "total_chunks": 45
  },
  {
    "id": "4cd6624e56c215dbd1a0db5c78fa89a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 709,
    "chunk_index": 35,
    "total_chunks": 45
  },
  {
    "id": "520ed3a19a011dd67042ddfdaf03848f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 711,
    "chunk_index": 36,
    "total_chunks": 45
  },
  {
    "id": "da5cdfc63beb19903c8dff891d19594b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "regionName); loadingstyledisplay = 'block'; errorstextContent = ''; clearBtnstyledisplay = 'block'; //make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)';\nfossilfuel",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 731,
    "chunk_index": 37,
    "total_chunks": 45
  },
  {
    "id": "8353557398ec867df0ff030cc727f421",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "//make initial call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent =\nresponse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 710,
    "chunk_index": 38,
    "total_chunks": 45
  },
  {
    "id": "123f99349266e91357c990c92fe18397",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = responsedata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 708,
    "chunk_index": 39,
    "total_chunks": 45
  },
  {
    "id": "27e5835b6436edc1f92bed1e75046074",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = responsedatadata",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 710,
    "chunk_index": 40,
    "total_chunks": 45
  },
  {
    "id": "0ba70e5acf06712955048c55249f01d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = responsedatadatafossilFuelPercentage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 714,
    "chunk_index": 41,
    "total_chunks": 45
  },
  {
    "id": "2e87775135f3fcd1ccd08dafaa0fa91f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "call displayCarbonUsage(apiKey, regionName); } この関数は、APIが呼び出される間に表示されるローディングメッセージを設定します。この時点で、このブラウザ拡張の最も重要な機能を作成する段階に到達しました！ 炭素使用量を表示する いよいよAPIをクエリする時です！ 進む前に、APIについて話しましょう。API、つまりアプリケーションプログラミングインターフェースは、ウェブ開発者のツールボックスにおける重要な要素です。APIは、プログラム同士が標準的な方法で相互作用し、インターフェースを提供する手段を提供します。例えば、データベースをクエリする必要があるウェブサイトを構築している場合、誰かが使用可能なAPIを作成しているかもしれません。APIには多くの種類がありますが、最も人気のあるものの一つがREST APIです。 ✅ 'REST'は'Representational State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = responsedatadatafossilFuelPercentagetoFixed(2) +\n'% (percentage of fossil fuels used to generate electricity)';\nresults",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 42,
    "total_chunks": 45
  },
  {
    "id": "04344adab86867c7bdcd92d33b1de754",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "State Transfer'の略で、さまざまに構成されたURLを使用してデータを取得する特徴があります。開発者が利用可能なさまざまな種類のAPIについて少し調べてみてください。どの形式が魅力的に感じますか？ この関数について重要な点があります。まず、asyncキーワードに注目してください。関数を非同期的に動作させることで、データが返されるなどのアクションが完了するまで待機してから処理を続行します。 こちらはasyncについての簡単な動画です： 🎥 上の画像をクリックすると、async/awaitに関する動画が再生されます。 C02Signal APIをクエリする新しい関数を作成します： ```JavaScript import axios from '/node_modules/axios'; async function displayCarbonUsage(apiKey, region) { try { await axiosget('https://apico2signalcom/v1/latest', { params: { countryCode: region, }, headers: { 'auth-token': apiKey, }, })then((response) => { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = responsedatadatafossilFuelPercentagetoFixed(2) + '% (percentage of fossil fuels used to generate electricity)'; resultsstyle display = 'block';\n});\n} catch (error) {\nconsole log(error);\nloading style display = 'none';\nresults style display = 'none';\nerrors textContent = 'Sorry, we have no data for the region you have requested",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 457,
    "chunk_index": 43,
    "total_chunks": 45
  },
  {
    "id": "9c4cbd76385cc30a088452c747956dff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
    "source_type": "git_repo",
    "title": "ブラウザ拡張プロジェクト パート2: APIの呼び出しとローカルストレージの利用",
    "content": "=> { let CO2 = Mathfloor(responsedatadatacarbonIntensity); //calculateColor(CO2); loadingstyledisplay = 'none'; formstyledisplay = 'none'; myregiontextContent = region; usagetextContent = Mathround(responsedatadatacarbonIntensity) + ' grams (grams C02 emitted per kilowatt hour)'; fossilfueltextContent = responsedatadatafossilFuelPercentagetoFixed(2) + '% (percentage of fossil fuels used to generate electricity)'; resultsstyle display = 'block'; }); } catch (error) { console log(error); loading style display = 'none'; results style display = 'none'; errors textContent = 'Sorry, we have no data for the region you have requested';\n}\n}\n```\nこの関数は大きなものです。何が行われているのでしょうか？\nベストプラクティスに従い、asyncキーワードを使用してこの関数を非同期的に動作させます。この関数にはtry/catchブロックが含まれており、APIがデータを返すとPromiseを返します。APIの応答速度を制御することはできないため（応答しない可能性もあります！）、非同期的に呼び出すことでこの不確実性を処理します。\nco2signal APIをクエリして地域のデータを取得し、APIキーを使用します。このキーを使用するには、ヘッダーのパラメータで認証を行う必要があります。\nAPIが応答すると、その応答データのさまざまな要素を画面の設定された部分に割り当てます。\nエラーが発生した場合や結果がない場合は、エラーメッセージを表示します。\n✅ 非同期プログラミングパターンを使用することは、ツールボックスにおける非常に有用なツールの一つです。さまざまな構成方法について読んでみてください。\nおめでとうございます！拡張をビルド（npm run build）し、拡張ペインでリフレッシュすると、動作する拡張が完成します！唯一動作していないのはアイコンで、次のレッスンで修正します。\n🚀 チャレンジ\nこれまでのレッスンでいくつかの種類のAPIについて話しました。ウェブAPIを選び、その提供内容を詳しく調べてみましょう。例えば、ブラウザ内で利用可能なHTML Drag and Drop APIを見てみてください。優れたAPIとは何だと思いますか？\n講義後クイズ\n講義後クイズ\n復習と自己学習\nこのレッスンでは、LocalStorageとAPIについて学びました。どちらもプロフェッショナルなウェブ開発者にとって非常に有用です。これら2つがどのように連携するかについて考えてみてください。APIを使用するウェブサイトを設計する際に、どのようにアイテムを保存するかを考えてみましょう。\n課題\nAPIを採用する\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された原文が公式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14833,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\5-browser-extension\\2-forms-browsers-local-storage\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1076,
    "chunk_index": 44,
    "total_chunks": 45
  },
  {
    "id": "2da8ca82b77e97e312875b06dee3f176",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\assignment.md",
    "source_type": "git_repo",
    "title": "CSSリファクタリング",
    "content": "CSSリファクタリング\n手順\nFlexboxまたはCSS Gridを使用してテラリウムを再スタイルし、複数のブラウザでテストしたことを示すスクリーンショットを撮影してください。マークアップを変更する必要がある場合は、リファクタリング用にアートを配置した新しいバージョンのアプリを作成してください。要素をドラッグ可能にすることは気にしなくて構いません。現時点ではHTMLとCSSのリファクタリングに集中してください。\n評価基準\n| 基準     | 優秀な例                                                         | 十分な例                      | 改善が必要な例                        |\n| -------- | ----------------------------------------------------------------- | ----------------------------- | ------------------------------------ |\n|          | FlexboxまたはCSS Gridを使用して完全に再スタイルされたテラリウムを提示 | 一部の要素を再スタイルする     | テラリウムを全く再スタイルしない      |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1953,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "3a05e2995ed8e88132ce8dd8adc9557a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 407,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "6b144dfb528e46630a82bbae23bbbd8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "589f3270f473b943d537c5bf779a3353",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 550,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "4b065992762c88f8db649ca3815edbd2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 556,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "63be8a4a4c2cf784058c6222e55fb617",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano indexhtml\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 559,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "1b03934d582105d4d014c9e475b71b25",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano indexhtml\nindexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysite",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 604,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "84a04b04f005090780391cf59e75da84",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano indexhtml\nindexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysitecom/testのようなURLは、testというフォルダとその中のindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 625,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "ae992f57ce3668a81cfa7d32cee33e43",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano indexhtml\nindexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysitecom/testのようなURLは、testというフォルダとその中のindexhtmlファイルを使用して構築される可能性があります。URLにはindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 650,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "f4aafbda844716ff4b53df57816d9f9f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano indexhtml\nindexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysitecom/testのようなURLは、testというフォルダとその中のindexhtmlファイルを使用して構築される可能性があります。URLにはindexhtmlが表示される必要はありません。\nDocTypeとhtmlタグ\nHTMLファイルの最初の行はDocTypeです。この行をファイルの最上部に配置する必要があるのは少し驚きですが、これは古いブラウザに現在のHTML仕様に従ってページを標準モードでレンダリングする必要があることを伝えます。\nヒント: VS Codeでは、タグにカーソルを合わせるとMDNリファレンスガイドからその使用に関する情報を取得できます。\n2行目には<html>タグの開始タグが続き、その後すぐに終了タグ</html>が続きます。これらのタグはインターフェースのルート要素です。\nタスク\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 881,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "f53062d11f9ffbc196894dbf596f9a50",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "テラリウムプロジェクト パート1: HTMLの紹介\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\n動画をチェック\n紹介\nHTML（HyperText Markup Language）はウェブの「骨格」です。CSSがHTMLを「装飾」し、JavaScriptが「命を吹き込む」なら、HTMLはウェブアプリケーションの「体」です。HTMLの構文はそのアイデアを反映しており、「head」、「body」、「footer」タグが含まれています。\nこのレッスンでは、HTMLを使って仮想テラリウムのインターフェースの「骨格」をレイアウトします。タイトルと3つの列を持つインターフェースを作成します。右と左の列にはドラッグ可能な植物が配置され、中央のエリアは実際のガラスのようなテラリウムになります。このレッスンの終わりには、列に植物が表示されますが、インターフェースは少し奇妙に見えるかもしれません。心配しないでください。次のセクションでCSSスタイルを追加してインターフェースを改善します。\nタスク\nコンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。\nまたは\nGit Bashで以下のコマンドを使用してください:\n* mkdir terrarium\n* cd terrarium\n* touch indexhtml\n* code indexhtml または nano indexhtml\nindexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysitecom/testのようなURLは、testというフォルダとその中のindexhtmlファイルを使用して構築される可能性があります。URLにはindexhtmlが表示される必要はありません。\nDocTypeとhtmlタグ\nHTMLファイルの最初の行はDocTypeです。この行をファイルの最上部に配置する必要があるのは少し驚きですが、これは古いブラウザに現在のHTML仕様に従ってページを標準モードでレンダリングする必要があることを伝えます。\nヒント: VS Codeでは、タグにカーソルを合わせるとMDNリファレンスガイドからその使用に関する情報を取得できます。\n2行目には<html>タグの開始タグが続き、その後すぐに終了タグ</html>が続きます。これらのタグはインターフェースのルート要素です。\nタスク\nindexhtmlファイルの最上部に以下の行を追加してください:\n```HTML\n```\n✅ DocTypeをクエリ文字列で設定することで決定されるいくつかの異なるモードがあります: Quirks ModeとStandards Mode。これらのモードは、通常は使用されない非常に古いブラウザ（Netscape Navigator 4やInternet Explorer 5）をサポートしていました。標準のDocType宣言を使用してください。\nドキュメントの「head」\nHTMLドキュメントの「head」エリアには、ウェブページに関する重要な情報、いわゆるメタデータが含まれています。私たちの場合、このページがレンダリングされるウェブサーバーに以下の4つの情報を伝えます:\nページのタイトル\nページのメタデータ:\n使用される文字エンコーディングを示す「文字セット」\nブラウザ情報（x-ua-compatibleを含む）、これはIE=edgeブラウザがサポートされていることを示します\nビューポートが読み込まれる際の動作に関する情報。ビューポートの初期スケールを1に設定することで、ページが最初に読み込まれる際のズームレベルを制御します。\nタスク\n<html>タグの開始タグと終了タグの間に「head」ブロックを追加してください。\nhtml\n<head>\n<title>Welcome to my Virtual Terrarium</title>\n<meta charset=\"utf-8\" />\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n</head>\n✅ ビューポートメタタグを次のように設定した場合、何が起こるでしょうか: <meta name=\"viewport\" content=\"width=600\">",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1403,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "c972b5b4b03e77c2340a35dd3685a6b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "コンピュータ上で「terrarium」というフォルダを作成し、その中に「indexhtml」というファイルを作成してください。Visual Studio Codeを使用してフォルダを作成した後、新しいVS Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。 または Git Bashで以下のコマンドを使用してください: * mkdir terrarium * cd terrarium * touch indexhtml * code indexhtml または nano indexhtml indexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysitecom/testのようなURLは、testというフォルダとその中のindexhtmlファイルを使用して構築される可能性があります。URLにはindexhtmlが表示される必要はありません。 DocTypeとhtmlタグ HTMLファイルの最初の行はDocTypeです。この行をファイルの最上部に配置する必要があるのは少し驚きですが、これは古いブラウザに現在のHTML仕様に従ってページを標準モードでレンダリングする必要があることを伝えます。 ヒント: VS Codeでは、タグにカーソルを合わせるとMDNリファレンスガイドからその使用に関する情報を取得できます。 2行目には<html>タグの開始タグが続き、その後すぐに終了タグ</html>が続きます。これらのタグはインターフェースのルート要素です。 タスク indexhtmlファイルの最上部に以下の行を追加してください: ```HTML ``` ✅ DocTypeをクエリ文字列で設定することで決定されるいくつかの異なるモードがあります: Quirks ModeとStandards Mode。これらのモードは、通常は使用されない非常に古いブラウザ（Netscape Navigator 4やInternet Explorer 5）をサポートしていました。標準のDocType宣言を使用してください。 ドキュメントの「head」 HTMLドキュメントの「head」エリアには、ウェブページに関する重要な情報、いわゆるメタデータが含まれています。私たちの場合、このページがレンダリングされるウェブサーバーに以下の4つの情報を伝えます: ページのタイトル ページのメタデータ: 使用される文字エンコーディングを示す「文字セット」 ブラウザ情報（x-ua-compatibleを含む）、これはIE=edgeブラウザがサポートされていることを示します ビューポートが読み込まれる際の動作に関する情報。ビューポートの初期スケールを1に設定することで、ページが最初に読み込まれる際のズームレベルを制御します。 タスク <html>タグの開始タグと終了タグの間に「head」ブロックを追加してください。 html <head> <title>Welcome to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ ビューポートメタタグを次のように設定した場合、何が起こるでしょうか: <meta name=\"viewport\" content=\"width=600\">ビューポートについてさらに詳しく読んでください。\nドキュメントのbody\nHTMLタグ\nHTMLでは、",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1058,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "92dd18ffbde58be101a4a3646f6462ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
    "source_type": "git_repo",
    "title": "Welcome to my Virtual Terrarium",
    "content": "Codeウィンドウを開き、「フォルダを開く」をクリックして新しいフォルダに移動します。エクスプローラペインの小さな「ファイル」ボタンをクリックして新しいファイルを作成します。 または Git Bashで以下のコマンドを使用してください: * mkdir terrarium * cd terrarium * touch indexhtml * code indexhtml または nano indexhtml indexhtmlファイルはブラウザにフォルダ内のデフォルトファイルであることを示します。例えば、https://anysitecom/testのようなURLは、testというフォルダとその中のindexhtmlファイルを使用して構築される可能性があります。URLにはindexhtmlが表示される必要はありません。 DocTypeとhtmlタグ HTMLファイルの最初の行はDocTypeです。この行をファイルの最上部に配置する必要があるのは少し驚きですが、これは古いブラウザに現在のHTML仕様に従ってページを標準モードでレンダリングする必要があることを伝えます。 ヒント: VS Codeでは、タグにカーソルを合わせるとMDNリファレンスガイドからその使用に関する情報を取得できます。 2行目には<html>タグの開始タグが続き、その後すぐに終了タグ</html>が続きます。これらのタグはインターフェースのルート要素です。 タスク indexhtmlファイルの最上部に以下の行を追加してください: ```HTML ``` ✅ DocTypeをクエリ文字列で設定することで決定されるいくつかの異なるモードがあります: Quirks ModeとStandards Mode。これらのモードは、通常は使用されない非常に古いブラウザ（Netscape Navigator 4やInternet Explorer 5）をサポートしていました。標準のDocType宣言を使用してください。 ドキュメントの「head」 HTMLドキュメントの「head」エリアには、ウェブページに関する重要な情報、いわゆるメタデータが含まれています。私たちの場合、このページがレンダリングされるウェブサーバーに以下の4つの情報を伝えます: ページのタイトル ページのメタデータ: 使用される文字エンコーディングを示す「文字セット」 ブラウザ情報（x-ua-compatibleを含む）、これはIE=edgeブラウザがサポートされていることを示します ビューポートが読み込まれる際の動作に関する情報。ビューポートの初期スケールを1に設定することで、ページが最初に読み込まれる際のズームレベルを制御します。 タスク <html>タグの開始タグと終了タグの間に「head」ブロックを追加してください。 html <head> <title>Welcome to my Virtual Terrarium</title> <meta charset=\"utf-8\" /> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> </head> ✅ ビューポートメタタグを次のように設定した場合、何が起こるでしょうか: <meta name=\"viewport\" content=\"width=600\">ビューポートについてさらに詳しく読んでください。 ドキュメントのbody HTMLタグ HTMLでは、htmlファイルにタグを追加してウェブページの要素を作成します。各タグは通常、開始タグと終了タグを持ちます。例えば、<p>hello</p>は段落を示します。<html>タグペアの内側に<body>タグを追加してインターフェースの本文を作成してください。現在のマークアップは次のようになります:\nタスク\n```html\nWelcome to my Virtual Terrarium\n```\nこれで、ページを構築し始めることができます。通常、ページ内の個別の要素を作成するために<div>タグを使用します。画像を含む一連の<div>要素を作成します。\n画像\n閉じタグを必要としないHTMLタグの1つは<img>タグです。これはsrc要素を持ち、ページがアイテムをレンダリングするために必要なすべての情報を含んでいます。\nアプリ内にimagesというフォルダを作成し、その中にソースコードフォルダにあるすべての画像を追加してください。（植物の画像が14枚あります）\nタスク\n<body></body>タグの間にこれらの植物画像を2つの列に追加してください:\n```html\n```\n注: SpansとDivs。Divsは「ブロック」要素と見なされ、Spansは「インライン」です。これらのdivをspanに変換した場合、何が起こるでしょうか？\nこのマークアップにより、植物が画面に表示されます。ただし、まだCSSでスタイルが設定されていないため、見た目はかなり悪いです。次のレッスンでCSSを使用してスタイルを設定します。\n各画像には、画像が表示されない場合でも表示されるaltテキストがあります。これはアクセシビリティのために含める重要な属性です。アクセシビリティについては今後のレッスンでさらに学びますが、alt属性は画像を表示できない場合に代替情報を提供します（接続が遅い場合、src属性にエラーがある場合、またはユーザーがスクリーンリーダーを使用している場合など）。\n✅ 各画像に同じaltタグがあることに気付きましたか？これは良いプラクティスでしょうか？なぜそうではないのでしょうか？このコードを改善できますか？\nセマンティックマークアップ\n一般的に、HTMLを書く際には意味のある「セマンティクス」を使用することが推奨されます。それはどういう意味でしょうか？それは、データやインタラクションの種類に応じて設計されたHTMLタグを使用することを意味します。例えば、ページのメインタイトルテキストには<h1>タグを使用するべきです。\n<body>タグの開始タグのすぐ下に次の行を追加してください:\n```html\nMy Terrarium\n```\nヘッダーを<h1>にし、順序なしリストを<ul>としてレンダリングするなど、セマンティックマークアップを使用することで、スクリーンリーダーがページをナビゲートしやすくなります。一般的に、ボタンは<button>として書かれるべきであり、リストは<li>として書かれるべきです。特別にスタイル設定された<span>要素をクリックハンドラーでボタンのように模倣することは可能ですが、ボタンがページのどこにあるかを判断し、それと対話するために技術を使用することができる障害のあるユーザーにとって、要素がボタンとして表示される方が良いです。この理由から、可能な限りセマンティックマークアップを使用するようにしてください。\n✅ スクリーンリーダーがウェブページとどのように対話するかを確認してください。セマンティックでないマークアップがユーザーをどのように苛立たせるかがわかりますか？\nテラリウム\nインターフェースの最後の部分では、テラリウムを作成するためにスタイル設定されるマークアップを作成します。\nタスク:\n最後の</div>タグの上に次のマークアップを追加してください:\n```html\n```\n✅ このマークアップを画面に追加したにもかかわらず、何も表示されないのはなぜでしょうか？\n🚀チャレンジ\nHTMLにはまだ遊べる「古い」タグがいくつかありますが、これらのタグのような廃止されたタグをマークアップで使用するべきではありません。それでも、古い<marquee>タグを使用してh1タイトルを横スクロールさせることはできますか？（もし使用した場合は、後で必ず削除してください）\n講義後クイズ\n講義後クイズ\n復習と自己学習\nHTMLはウェブを今日の姿に成長させた「信頼できる」構築ブロックシステムです。古いタグと新しいタグを学び、その歴史について少し学んでください。なぜ一部のタグが廃止され、一部が追加されたのかを理解できますか？将来どのようなタグが導入される可能性があるでしょうか？\nウェブとモバイルデバイス向けのサイト構築についてさらに学ぶには、Microsoft Learnをご覧ください。\n課題\nHTMLを練習: ブログのモックアップを作成\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14710,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\1-intro-to-html\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2965,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "3906ed6f90629f59dc8f851234dbfe9f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
    "source_type": "git_repo",
    "title": "DOMをもう少し深く学ぼう",
    "content": "DOMをもう少し深く学ぼう\n指示\nDOMについてさらに調べるために、DOM要素を「採用」してみましょう。MDNのDOMインターフェイス一覧を訪れ、1つ選んでください。それがウェブサイト上でどのように使われているかを見つけ、その使用方法について説明を書いてください。\n採点基準\n| 基準     | 優秀な状態                                   | 十分な状態                                     | 改善が必要な状態       |\n| -------- | --------------------------------------------- | ------------------------------------------------ | ----------------------- |\n|          | 例を含む段落形式の説明が提示されている         | 例を含まない段落形式の説明が提示されている       | 説明が提示されていない |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があります。原文（元の言語で記載された文書）が信頼できる情報源と見なされるべきです。重要な情報については、専門の人間による翻訳をお勧めします。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1809,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 452,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "2ff538ddbe217ea23d72f061f9de32fc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 394,
    "chunk_index": 0,
    "total_chunks": 23
  },
  {
    "id": "e7b3cdf46bc5b628728de23abeb1ac47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUsecomを参照して実装を確認することを忘れないでください。\nこのレッスンでは、オンラインテラリウムにスタイルを追加し、CSSのいくつかの概念について学びます。具体的には、カスケード、継承、セレクタの使用、配置、レイアウト構築にCSSを活用する方法について学びます。この過程で、テラリウムのレイアウトを作成し、実際のテラリウムを構築します。\n前提条件\nテラリウムのHTMLが完成しており、スタイルを適用する準備ができている必要があります。\n動画をチェック\nタスク\nテラリウムフォルダ内に新しいファイルstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 633,
    "chunk_index": 1,
    "total_chunks": 23
  },
  {
    "id": "0f4810c9c16fd42a17f52152e8053168",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUsecomを参照して実装を確認することを忘れないでください。\nこのレッスンでは、オンラインテラリウムにスタイルを追加し、CSSのいくつかの概念について学びます。具体的には、カスケード、継承、セレクタの使用、配置、レイアウト構築にCSSを活用する方法について学びます。この過程で、テラリウムのレイアウトを作成し、実際のテラリウムを構築します。\n前提条件\nテラリウムのHTMLが完成しており、スタイルを適用する準備ができている必要があります。\n動画をチェック\nタスク\nテラリウムフォルダ内に新しいファイルstylecssを作成し、それを<head>セクションにインポートします:\nhtml\n<link rel=\"stylesheet\" href=\"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 663,
    "chunk_index": 2,
    "total_chunks": 23
  },
  {
    "id": "271dd9ded2885e5d00199099f5a7af21",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUsecomを参照して実装を確認することを忘れないでください。\nこのレッスンでは、オンラインテラリウムにスタイルを追加し、CSSのいくつかの概念について学びます。具体的には、カスケード、継承、セレクタの使用、配置、レイアウト構築にCSSを活用する方法について学びます。この過程で、テラリウムのレイアウトを作成し、実際のテラリウムを構築します。\n前提条件\nテラリウムのHTMLが完成しており、スタイルを適用する準備ができている必要があります。\n動画をチェック\nタスク\nテラリウムフォルダ内に新しいファイルstylecssを作成し、それを<head>セクションにインポートします:\nhtml\n<link rel=\"stylesheet\" href=\"/style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 664,
    "chunk_index": 3,
    "total_chunks": 23
  },
  {
    "id": "650518da134e6534e417c70126e2240f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUsecomを参照して実装を確認することを忘れないでください。\nこのレッスンでは、オンラインテラリウムにスタイルを追加し、CSSのいくつかの概念について学びます。具体的には、カスケード、継承、セレクタの使用、配置、レイアウト構築にCSSを活用する方法について学びます。この過程で、テラリウムのレイアウトを作成し、実際のテラリウムを構築します。\n前提条件\nテラリウムのHTMLが完成しており、スタイルを適用する準備ができている必要があります。\n動画をチェック\nタスク\nテラリウムフォルダ内に新しいファイルstylecssを作成し、それを<head>セクションにインポートします:\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\nカスケード\nCascading Style Sheets（カスケーディングスタイルシート）は、スタイルが「カスケード」するという考え方を取り入れています。つまり、スタイルの適用はその優先順位によって決まります。ウェブサイトの作成者が設定したスタイルは、ブラウザが設定したスタイルよりも優先されます。また、インラインで設定されたスタイルは、外部スタイルシートで設定されたスタイルよりも優先されます。\nタスク\n<h1>タグにインラインスタイルcolor: redを追加します:\n```HTML\nMy Terrarium\n```\n次に、以下のコードをstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 885,
    "chunk_index": 4,
    "total_chunks": 23
  },
  {
    "id": "3e766a377b598f29b2566ff4b3bd747f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUsecomを参照して実装を確認することを忘れないでください。\nこのレッスンでは、オンラインテラリウムにスタイルを追加し、CSSのいくつかの概念について学びます。具体的には、カスケード、継承、セレクタの使用、配置、レイアウト構築にCSSを活用する方法について学びます。この過程で、テラリウムのレイアウトを作成し、実際のテラリウムを構築します。\n前提条件\nテラリウムのHTMLが完成しており、スタイルを適用する準備ができている必要があります。\n動画をチェック\nタスク\nテラリウムフォルダ内に新しいファイルstylecssを作成し、それを<head>セクションにインポートします:\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\nカスケード\nCascading Style Sheets（カスケーディングスタイルシート）は、スタイルが「カスケード」するという考え方を取り入れています。つまり、スタイルの適用はその優先順位によって決まります。ウェブサイトの作成者が設定したスタイルは、ブラウザが設定したスタイルよりも優先されます。また、インラインで設定されたスタイルは、外部スタイルシートで設定されたスタイルよりも優先されます。\nタスク\n<h1>タグにインラインスタイルcolor: redを追加します:\n```HTML\nMy Terrarium\n```\n次に、以下のコードをstylecssファイルに追加します:\nCSS\nh1 {\ncolor: blue;\n}\n✅ あなたのウェブアプリではどの色が表示されますか？なぜですか？スタイルを上書きする方法を見つけられますか？いつ、またはなぜこれを行う必要があるのでしょうか？\n継承\nスタイルは、祖先のスタイルから子孫に継承されます。つまり、ネストされた要素は親要素のスタイルを引き継ぎます。\nタスク\nbodyのフォントを指定し、ネストされた要素のフォントを確認します:\nCSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nブラウザのコンソールを開き、「Elements」タブで<h1>のフォントを観察してください。ブラウザ内で指定された通り、bodyからフォントを継承しています。\n✅ ネストされたスタイルが異なるプロパティを継承するようにできますか？\nCSSセレクタ\nタグ\nこれまでのstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1206,
    "chunk_index": 5,
    "total_chunks": 23
  },
  {
    "id": "ef51f39877f88e4abf7d13682fad8d66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "テラリウムプロジェクト パート2: CSS入門\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nCSS（Cascading Style Sheets）は、ウェブ開発における重要な課題、つまりウェブサイトを見栄え良くする方法を解決します。アプリにスタイルを適用することで、使いやすく、見た目も良くなります。また、CSSを使えばレスポンシブウェブデザイン（RWD）を実現でき、どの画面サイズでもアプリが美しく表示されるようになります。CSSは単に見た目を整えるだけでなく、アニメーションや変形を含む仕様もあり、アプリに高度なインタラクションを追加することが可能です。CSSワーキンググループは現在のCSS仕様を維持する役割を担っており、その活動はWorld Wide Web Consortiumのサイトで確認できます。\n[ NOTE]\nCSSはウェブの他の技術と同様に進化する言語であり、すべてのブラウザが最新の仕様をサポートしているわけではありません。CanIUsecomを参照して実装を確認することを忘れないでください。\nこのレッスンでは、オンラインテラリウムにスタイルを追加し、CSSのいくつかの概念について学びます。具体的には、カスケード、継承、セレクタの使用、配置、レイアウト構築にCSSを活用する方法について学びます。この過程で、テラリウムのレイアウトを作成し、実際のテラリウムを構築します。\n前提条件\nテラリウムのHTMLが完成しており、スタイルを適用する準備ができている必要があります。\n動画をチェック\nタスク\nテラリウムフォルダ内に新しいファイルstylecssを作成し、それを<head>セクションにインポートします:\nhtml\n<link rel=\"stylesheet\" href=\"/stylecss\" />\nカスケード\nCascading Style Sheets（カスケーディングスタイルシート）は、スタイルが「カスケード」するという考え方を取り入れています。つまり、スタイルの適用はその優先順位によって決まります。ウェブサイトの作成者が設定したスタイルは、ブラウザが設定したスタイルよりも優先されます。また、インラインで設定されたスタイルは、外部スタイルシートで設定されたスタイルよりも優先されます。\nタスク\n<h1>タグにインラインスタイルcolor: redを追加します:\n```HTML\nMy Terrarium\n```\n次に、以下のコードをstylecssファイルに追加します:\nCSS\nh1 {\ncolor: blue;\n}\n✅ あなたのウェブアプリではどの色が表示されますか？なぜですか？スタイルを上書きする方法を見つけられますか？いつ、またはなぜこれを行う必要があるのでしょうか？\n継承\nスタイルは、祖先のスタイルから子孫に継承されます。つまり、ネストされた要素は親要素のスタイルを引き継ぎます。\nタスク\nbodyのフォントを指定し、ネストされた要素のフォントを確認します:\nCSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nブラウザのコンソールを開き、「Elements」タブで<h1>のフォントを観察してください。ブラウザ内で指定された通り、bodyからフォントを継承しています。\n✅ ネストされたスタイルが異なるプロパティを継承するようにできますか？\nCSSセレクタ\nタグ\nこれまでのstylecssファイルでは、いくつかのタグにしかスタイルが適用されておらず、アプリの見た目が少し奇妙です:\n```CSS\nbody {\nfont-family: helvetica, arial, sans-serif;\n}\nh1 {\ncolor: #3a241d;\ntext-align: center;\n}\n```\nこのようにタグをスタイリングすることで、特定の要素を制御できますが、テラリウム内の多くの植物のスタイルを制御する必要があります。そのためには、CSSセレクタを活用する必要があります。\nID\n左と右のコンテナにスタイルを追加します。マークアップ内で左コンテナと右コンテナはそれぞれ1つしか存在しないため、IDが付けられています。これらをスタイリングするには、#を使用します:\n```CSS\nleft-container {\nbackground-color: #eee;\nwidth: 15%;\nleft: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\nright-container {\nbackground-color: #eee;\nwidth: 15%;\nright: 0px;\ntop: 0px;\nposition: absolute;\nheight: 100%;\npadding: 10px;\n}\n```\nここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。\n✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？\n```html\n```\nクラス\n上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。\nHTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。\n```html\n```\n以下をstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1930,
    "chunk_index": 6,
    "total_chunks": 23
  },
  {
    "id": "3c75809685723f48fe5a1147b9e948c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "} ブラウザのコンソールを開き、「Elements」タブで<h1>のフォントを観察してください。ブラウザ内で指定された通り、bodyからフォントを継承しています。 ✅ ネストされたスタイルが異なるプロパティを継承するようにできますか？ CSSセレクタ タグ これまでのstylecssファイルでは、いくつかのタグにしかスタイルが適用されておらず、アプリの見た目が少し奇妙です: ```CSS body { font-family: helvetica, arial, sans-serif; } h1 { color: #3a241d; text-align: center; } ``` このようにタグをスタイリングすることで、特定の要素を制御できますが、テラリウム内の多くの植物のスタイルを制御する必要があります。そのためには、CSSセレクタを活用する必要があります。 ID 左と右のコンテナにスタイルを追加します。マークアップ内で左コンテナと右コンテナはそれぞれ1つしか存在しないため、IDが付けられています。これらをスタイリングするには、#を使用します: ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します:\n```CSS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 847,
    "chunk_index": 7,
    "total_chunks": 23
  },
  {
    "id": "895d863598af332e37d6b6415a158e92",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "ブラウザのコンソールを開き、「Elements」タブで<h1>のフォントを観察してください。ブラウザ内で指定された通り、bodyからフォントを継承しています。 ✅ ネストされたスタイルが異なるプロパティを継承するようにできますか？ CSSセレクタ タグ これまでのstylecssファイルでは、いくつかのタグにしかスタイルが適用されておらず、アプリの見た目が少し奇妙です: ```CSS body { font-family: helvetica, arial, sans-serif; } h1 { color: #3a241d; text-align: center; } ``` このようにタグをスタイリングすることで、特定の要素を制御できますが、テラリウム内の多くの植物のスタイルを制御する必要があります。そのためには、CSSセレクタを活用する必要があります。 ID 左と右のコンテナにスタイルを追加します。マークアップ内で左コンテナと右コンテナはそれぞれ1つしか存在しないため、IDが付けられています。これらをスタイリングするには、#を使用します: ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder {\nposition: relative;\nheight: 13%;\nleft: -10px;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 864,
    "chunk_index": 8,
    "total_chunks": 23
  },
  {
    "id": "b3e4d6ba81266d591693e42c681dc416",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "{ font-family: helvetica, arial, sans-serif; } h1 { color: #3a241d; text-align: center; } ``` このようにタグをスタイリングすることで、特定の要素を制御できますが、テラリウム内の多くの植物のスタイルを制御する必要があります。そのためには、CSSセレクタを活用する必要があります。 ID 左と右のコンテナにスタイルを追加します。マークアップ内で左コンテナと右コンテナはそれぞれ1つしか存在しないため、IDが付けられています。これらをスタイリングするには、#を使用します: ```CSS left-container { background-color: #eee; width: 15%; left: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant {\nposition: absolute;\nmax-width: 150%;\nmax-height: 150%;\nz-index: 2;\n}\n```\nこのスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください:\n植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。\n植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。\n植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。\nまた、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。\n✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？\nCSSの配置\n位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。\n絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。\n相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。\nこのサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。\nplant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。\n✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？\nCSSレイアウト\nここで学んだことを使って、CSSだけでテラリウム自体を構築します！\nまず、",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1558,
    "chunk_index": 9,
    "total_chunks": 23
  },
  {
    "id": "d8356ccd49ecf53b7bfeaf11e67f2b56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "absolute; height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします:\n```CSS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1368,
    "chunk_index": 10,
    "total_chunks": 23
  },
  {
    "id": "a62149ba946fc174933651743236e491",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "height: 100%; padding: 10px; } right-container { background-color: #eee; width: 15%; right: 0px; top: 0px; position: absolute; height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls {\nheight: 80%;\nwidth: 60%;\nbackground: #d1e1df;\nborder-radius: 1rem;\nposition: absolute;\nbottom: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1404,
    "chunk_index": 11,
    "total_chunks": 23
  },
  {
    "id": "e83e91c056dda3cdd2e2388b6b6f34d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "top: 0px; position: absolute; height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1382,
    "chunk_index": 12,
    "total_chunks": 23
  },
  {
    "id": "59b182f52fc25fb7f6fd69709e3d71db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "height: 100%; padding: 10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05;\nz-index: 1;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1380,
    "chunk_index": 13,
    "total_chunks": 23
  },
  {
    "id": "834ef1c7f10787da319580092188cb72",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "10px; } ``` ここでは、これらのコンテナを絶対配置で画面の左端と右端に配置し、幅をパーセンテージで指定して、小さなモバイル画面にも対応できるようにしています。 ✅ このコードはかなり繰り返しが多く、「DRY」（Don't Repeat Yourself: 繰り返しを避ける）ではありません。マークアップを変更し、CSSをリファクタリングすることで、IDとクラスを組み合わせてより良い方法を見つけられますか？ ```html ``` クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top {\nwidth: 50%;\nheight: 5%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 80",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1402,
    "chunk_index": 14,
    "total_chunks": 23
  },
  {
    "id": "8342c2513b23eb8fe9ac4198c3eccf5f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "クラス 上記の例では、画面上の2つのユニークな要素をスタイリングしました。画面上の多くの要素にスタイルを適用したい場合は、CSSクラスを使用できます。これを使って、左と右のコンテナ内の植物をレイアウトします。 HTMLマークアップ内の各植物には、IDとクラスの組み合わせが含まれています。ここでのIDは、後で追加するJavaScriptによってテラリウム内の植物の配置を操作するために使用されます。一方、クラスはすべての植物に特定のスタイルを適用します。 ```html ``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%;\nleft: 25%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1230,
    "chunk_index": 15,
    "total_chunks": 23
  },
  {
    "id": "2c2734a77a9595f4a8393615d595ee21",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "``` 以下をstylecssファイルに追加します: ```CSSplant-holder { position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07;\nz-index: 1;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1035,
    "chunk_index": 16,
    "total_chunks": 23
  },
  {
    "id": "846a97e9035a18c7238f0a5e16a25d71",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "{ position: relative; height: 13%; left: -10px; }plant { position: absolute; max-width: 150%; max-height: 150%; z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom {\nwidth: 50%;\nheight: 1%;\nbackground: #d1e1df;\nposition: absolute;\nbottom: 0%;\nleft: 25%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1055,
    "chunk_index": 17,
    "total_chunks": 23
  },
  {
    "id": "25fc9fa52502cf442ca3c4b8d2f212af",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "z-index: 2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1022,
    "chunk_index": 18,
    "total_chunks": 23
  },
  {
    "id": "b158b6275014eceaa0728385049c375c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "2; } ``` このスニペットで注目すべき点は、相対配置と絶対配置の組み合わせです。この点については次のセクションで説明します。高さの扱いにパーセンテージを使用している点にも注目してください: 植物ホルダーの高さを13%に設定しています。これにより、各垂直コンテナ内にすべての植物がスクロールなしで表示されるようになります。 植物ホルダーを左に移動させ、植物がコンテナ内でより中央に配置されるようにしています。画像にはドラッグ可能にするための透明な背景が多く含まれているため、画面上でより適切に収まるよう左に寄せる必要があります。 植物自体には最大幅150%を設定しています。これにより、ブラウザが縮小されると植物も縮小されます。ブラウザのサイズを変更してみてください。植物はコンテナ内に収まり続け、縮小してフィットします。 また、z-indexの使用にも注目してください。これは要素の相対的な高さを制御し、植物がコンテナの上に配置され、テラリウム内に収まっているように見せます。 ✅ なぜ植物ホルダーと植物の両方にCSSセレクタが必要なのでしょうか？ CSSの配置 位置プロパティ（static、relative、fixed、absolute、sticky）を組み合わせるのは少し難しいですが、適切に行うとページ上の要素をうまく制御できます。 絶対配置された要素は、最も近い配置された祖先を基準に配置されます。祖先がない場合は、ドキュメントのボディを基準に配置されます。 相対配置された要素は、CSSの指示に基づいて元の位置から調整されます。 このサンプルでは、plant-holderは相対配置された要素で、絶対配置されたコンテナ内に配置されています。この結果、サイドバーコンテナは左右に固定され、plant-holderはサイドバー内で調整され、植物を縦に並べるスペースを確保します。 plant自体も絶対配置されており、次のレッスンで学ぶようにドラッグ可能にするために必要です。 ✅ サイドコンテナとplant-holderの配置タイプを切り替えてみてください。何が起こりますか？ CSSレイアウト ここで学んだことを使って、CSSだけでテラリウム自体を構築します！ まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; }dirt {\nwidth: 60%;\nheight: 5%;\nbackground: #3a241d;\nposition: absolute;\nborder-radius: 0 0 1rem 1rem;\nbottom: 1%;\nleft: 20%;\nopacity: 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1071,
    "chunk_index": 19,
    "total_chunks": 23
  },
  {
    "id": "855c4e74acdad1825acf96284efde2a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "まず、terrariumの子要素をCSSで丸みを帯びた長方形にスタイリングします: ```CSSjar-walls { height: 80%; width: 60%; background: #d1e1df; border-radius: 1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; }dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07;\nz-index: -1;\n}\n```\nここでのパーセンテージの使用に注目してください。ブラウザを縮小すると、ジャーも縮小する様子がわかります。また、ジャー要素の幅と高さのパーセンテージや、各要素が絶対配置されている方法にも注目してください。これにより、要素がビューの下部に固定され、中央に配置されます。\nまた、remを使用してborder-radiusを設定しています。これはフォント相対の長さです。この種の相対的な測定については、CSS仕様で詳しく読むことができます。\n✅ ジャーの色と不透明度を変更してみてください。何が起こりますか？なぜでしょうか？\n🚀チャレンジ\nジャーの左下部分に「バブル」のような光沢を追加して、ガラスのように見せてみましょう。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 531,
    "chunk_index": 20,
    "total_chunks": 23
  },
  {
    "id": "a7f16ab7f42c1012400784b5c016f9a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; }dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07; z-index: -1; } ``` ここでのパーセンテージの使用に注目してください。ブラウザを縮小すると、ジャーも縮小する様子がわかります。また、ジャー要素の幅と高さのパーセンテージや、各要素が絶対配置されている方法にも注目してください。これにより、要素がビューの下部に固定され、中央に配置されます。 また、remを使用してborder-radiusを設定しています。これはフォント相対の長さです。この種の相対的な測定については、CSS仕様で詳しく読むことができます。 ✅ ジャーの色と不透明度を変更してみてください。何が起こりますか？なぜでしょうか？ 🚀チャレンジ ジャーの左下部分に「バブル」のような光沢を追加して、ガラスのように見せてみましょう。jar-glossy-longと",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 475,
    "chunk_index": 21,
    "total_chunks": 23
  },
  {
    "id": "343721554b2f655b7140cbdbcef4b7ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート2: CSS入門",
    "content": "1rem; position: absolute; bottom: 05%; left: 20%; opacity: 05; z-index: 1; }jar-top { width: 50%; height: 5%; background: #d1e1df; position: absolute; bottom: 805%; left: 25%; opacity: 07; z-index: 1; }jar-bottom { width: 50%; height: 1%; background: #d1e1df; position: absolute; bottom: 0%; left: 25%; opacity: 07; }dirt { width: 60%; height: 5%; background: #3a241d; position: absolute; border-radius: 0 0 1rem 1rem; bottom: 1%; left: 20%; opacity: 07; z-index: -1; } ``` ここでのパーセンテージの使用に注目してください。ブラウザを縮小すると、ジャーも縮小する様子がわかります。また、ジャー要素の幅と高さのパーセンテージや、各要素が絶対配置されている方法にも注目してください。これにより、要素がビューの下部に固定され、中央に配置されます。 また、remを使用してborder-radiusを設定しています。これはフォント相対の長さです。この種の相対的な測定については、CSS仕様で詳しく読むことができます。 ✅ ジャーの色と不透明度を変更してみてください。何が起こりますか？なぜでしょうか？ 🚀チャレンジ ジャーの左下部分に「バブル」のような光沢を追加して、ガラスのように見せてみましょう。jar-glossy-longとjar-glossy-shortをスタイリングして、反射した光沢のように見せます。以下のような仕上がりになります:\n講義後のクイズを完了するには、このLearnモジュールを進めてください: HTMLアプリをCSSでスタイリングする\n講義後クイズ\n講義後クイズ\n復習と自己学習\nCSSは一見すると簡単そうに見えますが、すべてのブラウザや画面サイズに完璧にスタイルを適用するのは多くの課題があります。CSS-GridやFlexboxは、この作業をより構造化し、信頼性を高めるために開発されたツールです。Flexbox FroggyやGrid Gardenをプレイして、これらのツールについて学びましょう。\n課題\nCSSリファクタリング\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された原文が公式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 13388,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\2-intro-to-css\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 944,
    "chunk_index": 22,
    "total_chunks": 23
  },
  {
    "id": "7b4d2168855d824dbf56244dda63c251",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\solution\\README.md",
    "source_type": "git_repo",
    "title": "私のテラリウム: HTML、CSS、そしてJavaScriptを使ったDOM操作を学ぶプロジェクト 🌵🌱",
    "content": "私のテラリウム: HTML、CSS、そしてJavaScriptを使ったDOM操作を学ぶプロジェクト 🌵🌱\n小さなドラッグ＆ドロップのコード瞑想。少しのHTML、JS、CSSを使って、ウェブインターフェースを構築し、スタイルを付け、インタラクションを追加できます。\nクレジット\n♥️を込めてJen Looperが執筆。\nCSSで作成されたテラリウムは、Jakub Mandraのガラス瓶codepenにインスパイアされました。\nアートワークはJen LooperがProcreateを使用して手描きしました。\nテラリウムをデプロイする\nAzure Static Web Appsを使用して、テラリウムをウェブにデプロイ（公開）することができます。\nこのリポジトリをフォークする\nこのボタンを押す\nウィザードを進めてアプリを作成します。アプリのルートを/solutionまたはコードベースのルートに設定することを忘れないでください。このアプリにはAPIがないので、それを追加する必要はありません。フォークしたリポジトリに",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2531,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 353,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "b1d06eb4c39f8681e0a72edc42ed40e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\solution\\README.md",
    "source_type": "git_repo",
    "title": "私のテラリウム: HTML、CSS、そしてJavaScriptを使ったDOM操作を学ぶプロジェクト 🌵🌱",
    "content": "私のテラリウム: HTML、CSS、そしてJavaScriptを使ったDOM操作を学ぶプロジェクト 🌵🌱\n小さなドラッグ＆ドロップのコード瞑想。少しのHTML、JS、CSSを使って、ウェブインターフェースを構築し、スタイルを付け、インタラクションを追加できます。\nクレジット\n♥️を込めてJen Looperが執筆。\nCSSで作成されたテラリウムは、Jakub Mandraのガラス瓶codepenにインスパイアされました。\nアートワークはJen LooperがProcreateを使用して手描きしました。\nテラリウムをデプロイする\nAzure Static Web Appsを使用して、テラリウムをウェブにデプロイ（公開）することができます。\nこのリポジトリをフォークする\nこのボタンを押す\nウィザードを進めてアプリを作成します。アプリのルートを/solutionまたはコードベースのルートに設定することを忘れないでください。このアプリにはAPIがないので、それを追加する必要はありません。フォークしたリポジトリにgithubフォルダーが作成され、Azure Static Web Appsのビルドサービスがアプリをビルドして新しいURLに公開するのを助けます。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2531,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 600,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "e9b93754e6552082e3db0f9d320040f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\assignment.md",
    "source_type": "git_repo",
    "title": "データ型の練習",
    "content": "データ型の練習\n指示\nショッピングカートを作成していると想像してください。ショッピング体験を完成させるために必要なデータ型についてドキュメントを作成してください。どのようにしてその選択に至ったのかを説明してください。\n評価基準\n基準 | 優秀 | 適切 | 改善が必要\n--- | --- | --- | --- |\n||6つのデータ型が詳細に記載され、それぞれの用途が文書化されている|4つのデータ型が記載されている|2つのデータ型が記載されている|\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1458,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 409,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ef8927bb8e7300c4c5adb3f42ee7df3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1454,
    "chunk_index": 0,
    "total_chunks": 42
  },
  {
    "id": "92991a1fa733207a0a9b75a39e74a9c9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1457,
    "chunk_index": 1,
    "total_chunks": 42
  },
  {
    "id": "2579bd1a5ad439e97d0d389157c04d18",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1460,
    "chunk_index": 2,
    "total_chunks": 42
  },
  {
    "id": "3cd7b08e590bac524be1b22f534a14de",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1570,
    "chunk_index": 3,
    "total_chunks": 42
  },
  {
    "id": "6eadd5fac2bc7a2aaba37324179a11b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncodeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します：\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1598,
    "chunk_index": 4,
    "total_chunks": 42
  },
  {
    "id": "4b8f17038be9883f5895fed28506a4a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncodeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します：\nindexhtml\nscript",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1601,
    "chunk_index": 5,
    "total_chunks": 42
  },
  {
    "id": "699f3a35929f28719cbf68eb3399c42b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncodeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します：\nindexhtml\nscriptjs\nstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1604,
    "chunk_index": 6,
    "total_chunks": 42
  },
  {
    "id": "28a055a024d1d7ef62da193ebc28160a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncodeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します：\nindexhtml\nscriptjs\nstylecss\nユーザーインターフェースの作成\n要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です：\nユーザーが入力するための引用文を表示する場所\n成功メッセージなどのメッセージを表示する場所\n入力用のテキストボックス\nスタートボタン\nこれらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。\nindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1793,
    "chunk_index": 7,
    "total_chunks": 42
  },
  {
    "id": "2f81f6b945160fd753a7cecf9aec81bd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncodeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します：\nindexhtml\nscriptjs\nstylecss\nユーザーインターフェースの作成\n要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です：\nユーザーが入力するための引用文を表示する場所\n成功メッセージなどのメッセージを表示する場所\n入力用のテキストボックス\nスタートボタン\nこれらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。\nindexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します：\n```html\nTyping game\nTyping game",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1830,
    "chunk_index": 8,
    "total_chunks": 42
  },
  {
    "id": "f1f59464d1339270e36fe31930e1602e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベントを使ったゲームの作成\n講義前クイズ\n講義前クイズ\nイベント駆動型プログラミング\nブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！\nイベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。\nコードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。\nイベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。\nNOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。\n一般的なイベント\nアプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）：\nclick: ユーザーが何かをクリックした（通常はボタンやハイパーリンク）\ncontextmenu: ユーザーが右クリックした\nselect: ユーザーがテキストを選択した\ninput: ユーザーがテキストを入力した\nゲームの作成\nJavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります：\nプレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される\nプレイヤーは引用文をできるだけ早くテキストボックスに入力する\n各単語が完了すると、次の単語がハイライトされる\nプレイヤーがタイプミスをすると、テキストボックスが赤くなる\nプレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される\nそれでは、ゲームを作成しながらイベントについて学びましょう！\nファイル構成\n合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。\nコンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します：\n```bash\nLinux or macOS\nmkdir typing-game && cd typing-game\nWindows\nmd typing-game && cd typing-game\n```\nVisual Studio Codeを開きます\nbash\ncodeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します：\nindexhtml\nscriptjs\nstylecss\nユーザーインターフェースの作成\n要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です：\nユーザーが入力するための引用文を表示する場所\n成功メッセージなどのメッセージを表示する場所\n入力用のテキストボックス\nスタートボタン\nこれらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。\nindexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します：\n```html\nTyping game\nTyping gamePractice your typing skills with a quote from Sherlock Holmes",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1840,
    "chunk_index": 9,
    "total_chunks": 42
  },
  {
    "id": "4f7fac06bdac3f3a1c05480c7a46d1b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "イベント駆動型プログラミング ブラウザベースのアプリケーションを作成する際、ユーザーが操作するためのグラフィカルユーザーインターフェース（GUI）を提供します。ブラウザとやり取りする最も一般的な方法は、さまざまな要素をクリックしたり入力したりすることです。しかし、開発者としての課題は、ユーザーがいつこれらの操作を行うのか分からないことです！ イベント駆動型プログラミングは、GUIを作成するために必要なプログラミングの種類を指します。このフレーズを少し分解すると、核心となる単語はイベントです。イベントは、Merriam-Websterによると「何かが起こること」と定義されています。これは私たちの状況を完璧に説明しています。何かが起こることは分かっていますが、それがいつ起こるのかは分かりません。 コードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。 イベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。 NOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。 一般的なイベント アプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）： click: ユーザーが何かをクリックした（通常はボタンやハイパーリンク） contextmenu: ユーザーが右クリックした select: ユーザーがテキストを選択した input: ユーザーがテキストを入力した ゲームの作成 JavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります： プレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される プレイヤーは引用文をできるだけ早くテキストボックスに入力する 各単語が完了すると、次の単語がハイライトされる プレイヤーがタイプミスをすると、テキストボックスが赤くなる プレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される それでは、ゲームを作成しながらイベントについて学びましょう！ ファイル構成 合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。 コンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` Visual Studio Codeを開きます bash codeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します： indexhtml scriptjs stylecss ユーザーインターフェースの作成 要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です： ユーザーが入力するための引用文を表示する場所 成功メッセージなどのメッセージを表示する場所 入力用のテキストボックス スタートボタン これらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。 indexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to begin",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1795,
    "chunk_index": 10,
    "total_chunks": 42
  },
  {
    "id": "e5615cd6516a964d972231c9af3d7ec6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "コードの特定のセクションを実行したい場合、関数を作成します。手続き型プログラミングでは、関数は特定の順序で呼び出されます。イベント駆動型プログラミングでも同じことが言えますが、違いは関数がどのように呼び出されるかです。 イベント（ボタンのクリックや入力など）を処理するために、イベントリスナーを登録します。イベントリスナーは、イベントが発生するのを待ち、それに応じて実行される関数です。イベントリスナーは、UIの更新、サーバーへの呼び出し、またはユーザーのアクションに応じて必要な他の処理を行うことができます。addEventListenerを使用してイベントリスナーを追加し、実行する関数を提供します。 NOTE: イベントリスナーを作成する方法は多数あります。無名関数を使用したり、名前付き関数を作成したりできます。また、clickプロパティを設定したり、addEventListenerを使用したりするショートカットもあります。この演習では、addEventListenerと無名関数に焦点を当てます。これはおそらくウェブ開発者が最も一般的に使用する手法であり、最も柔軟性があります。addEventListenerはすべてのイベントに対応しており、イベント名をパラメータとして提供できます。 一般的なイベント アプリケーションを作成する際にリッスンできる多数のイベントがあります。基本的に、ユーザーがページ上で行うほぼすべての操作がイベントを発生させます。これにより、ユーザーに望む体験を提供するための大きな力を得ることができます。幸いなことに、通常はほんの一握りのイベントだけを使用すれば十分です。以下は一般的なイベントのいくつかです（ゲーム作成時に使用する2つを含む）： click: ユーザーが何かをクリックした（通常はボタンやハイパーリンク） contextmenu: ユーザーが右クリックした select: ユーザーがテキストを選択した input: ユーザーがテキストを入力した ゲームの作成 JavaScriptのイベントの仕組みを探るためにゲームを作成します。このゲームは、プレイヤーのタイピングスキルをテストします。タイピングスキルは、すべての開発者が持つべき最も過小評価されているスキルの1つです。私たちは皆、タイピングを練習するべきです！ゲームの全体的な流れは次のようになります： プレイヤーがスタートボタンをクリックすると、入力するための引用文が表示される プレイヤーは引用文をできるだけ早くテキストボックスに入力する 各単語が完了すると、次の単語がハイライトされる プレイヤーがタイプミスをすると、テキストボックスが赤くなる プレイヤーが引用文を完了すると、成功メッセージと経過時間が表示される それでは、ゲームを作成しながらイベントについて学びましょう！ ファイル構成 合計で3つのファイルが必要です：indexhtml、scriptjs、stylecss。これらをセットアップして作業を簡単にしましょう。 コンソールまたはターミナルウィンドウを開き、以下のコマンドを実行して新しいフォルダを作成します： ```bash Linux or macOS mkdir typing-game && cd typing-game Windows md typing-game && cd typing-game ``` Visual Studio Codeを開きます bash codeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します： indexhtml scriptjs stylecss ユーザーインターフェースの作成 要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です： ユーザーが入力するための引用文を表示する場所 成功メッセージなどのメッセージを表示する場所 入力用のテキストボックス スタートボタン これらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。 indexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart\n```\nアプリケーションの起動\n開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。\nLive Serverをインストールします。リンクをクリックしてInstallを選択してください。\nブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。\n必要に応じてVisual Studio Codeを再起動してください。\nインストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。\nLive Server: Open with Live Serverと入力します。\nLive Serverがアプリケーションをホストします。\nブラウザを開き、https://localhost:5500に移動します。\n作成したページが表示されるはずです！\n次に、機能を追加していきましょう。\nCSSの追加\nHTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。\nstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1927,
    "chunk_index": 11,
    "total_chunks": 42
  },
  {
    "id": "f450e85a7512b1b6d620ac623c05ecf7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "typing-game Windows md typing-game && cd typing-game ``` Visual Studio Codeを開きます bash codeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します： indexhtml scriptjs stylecss ユーザーインターフェースの作成 要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です： ユーザーが入力するための引用文を表示する場所 成功メッセージなどのメッセージを表示する場所 入力用のテキストボックス スタートボタン これらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。 indexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` アプリケーションの起動 開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。 Live Serverをインストールします。リンクをクリックしてInstallを選択してください。 ブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。 必要に応じてVisual Studio Codeを再起動してください。 インストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。 Live Server: Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。\n```css\n/ inside style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 784,
    "chunk_index": 12,
    "total_chunks": 42
  },
  {
    "id": "6a5263e2da65f14517131eb6757895ae",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "&& cd typing-game ``` Visual Studio Codeを開きます bash codeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します： indexhtml scriptjs stylecss ユーザーインターフェースの作成 要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です： ユーザーが入力するための引用文を表示する場所 成功メッセージなどのメッセージを表示する場所 入力用のテキストボックス スタートボタン これらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。 indexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` アプリケーションの起動 開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。 Live Serverをインストールします。リンクをクリックしてInstallを選択してください。 ブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。 必要に応じてVisual Studio Codeを再起動してください。 インストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。 Live Server: Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 779,
    "chunk_index": 13,
    "total_chunks": 42
  },
  {
    "id": "7efa85dd8b3ec07ea73b73750181ead2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "cd typing-game ``` Visual Studio Codeを開きます bash codeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します： indexhtml scriptjs stylecss ユーザーインターフェースの作成 要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です： ユーザーが入力するための引用文を表示する場所 成功メッセージなどのメッセージを表示する場所 入力用のテキストボックス スタートボタン これらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。 indexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` アプリケーションの起動 開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。 Live Serverをインストールします。リンクをクリックしてInstallを選択してください。 ブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。 必要に応じてVisual Studio Codeを再起動してください。 インストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。 Live Server: Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /highlight {\nbackground-color: yellow;\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 786,
    "chunk_index": 14,
    "total_chunks": 42
  },
  {
    "id": "4ada2358b55bc4a36a5aea38ff2320f9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Studio Codeを開きます bash codeVisual Studio Codeでフォルダに以下の名前の3つのファイルを追加します： indexhtml scriptjs stylecss ユーザーインターフェースの作成 要件を確認すると、HTMLページにいくつかの要素が必要であることが分かります。これはレシピのようなもので、いくつかの材料が必要です： ユーザーが入力するための引用文を表示する場所 成功メッセージなどのメッセージを表示する場所 入力用のテキストボックス スタートボタン これらの各要素には、JavaScriptで操作するためのIDが必要です。また、作成するCSSファイルとJavaScriptファイルへの参照も追加します。 indexhtmlという名前の新しいファイルを作成し、以下のHTMLを追加します： ```html Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` アプリケーションの起動 開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。 Live Serverをインストールします。リンクをクリックしてInstallを選択してください。 ブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。 必要に応じてVisual Studio Codeを再起動してください。 インストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。 Live Server: Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /highlight { background-color: yellow; }error {\nbackground-color: lightcoral;\nborder: red;\n}\n```\n✅ CSSに関しては、ページを好きなようにレイアウトできます。少し時間をかけてページをより魅力的にしてみてください：\n別のフォントを選ぶ\nヘッダーに色を付ける\nアイテムのサイズを変更する\nJavaScript\nUIが作成できたので、次はロジックを提供するJavaScriptに注目します。これをいくつかのステップに分けて進めます：\n定数の作成\nゲーム開始のイベントリスナー\nタイピングのイベントリスナー\nまず、script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 972,
    "chunk_index": 15,
    "total_chunks": 42
  },
  {
    "id": "325e27272a88a1eb41d36ccb908d713f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Typing game Typing gamePractice your typing skills with a quote from Sherlock HolmesClick **start** to beginStart ``` アプリケーションの起動 開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。 Live Serverをインストールします。リンクをクリックしてInstallを選択してください。 ブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。 必要に応じてVisual Studio Codeを再起動してください。 インストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。 Live Server: Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ CSSに関しては、ページを好きなようにレイアウトできます。少し時間をかけてページをより魅力的にしてみてください： 別のフォントを選ぶ ヘッダーに色を付ける アイテムのサイズを変更する JavaScript UIが作成できたので、次はロジックを提供するJavaScriptに注目します。これをいくつかのステップに分けて進めます： 定数の作成 ゲーム開始のイベントリスナー タイピングのイベントリスナー まず、scriptjsという名前の新しいファイルを作成します。\n定数の追加\nプログラミングを簡単にするために、いくつかのアイテムが必要です。これもレシピのようなもので、以下が必要です：\nすべての引用文を含む配列\n現在の引用文のすべての単語を格納する空の配列\nプレイヤーが現在入力している単語のインデックスを格納するスペース\nプレイヤーがスタートをクリックした時間\nまた、UI要素への参照も必要です：\nテキストボックス（typed-value）\n引用文の表示（quote）\nメッセージ（message）\njavascript\n// inside script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 925,
    "chunk_index": 16,
    "total_chunks": 42
  },
  {
    "id": "e8806e847734dfbbfc02999ed2525e8a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "to beginStart ``` アプリケーションの起動 開発中は、見た目を確認するために反復的に作業するのが最善です。アプリケーションを起動してみましょう。Visual Studio Codeには、Live Serverという素晴らしい拡張機能があります。この拡張機能は、アプリケーションをローカルでホストし、保存するたびにブラウザを更新してくれます。 Live Serverをインストールします。リンクをクリックしてInstallを選択してください。 ブラウザからVisual Studio Codeを開くように求められ、その後Visual Studio Codeからインストールを実行するように求められます。 必要に応じてVisual Studio Codeを再起動してください。 インストール後、Visual Studio CodeでCtrl-Shift-P（またはCmd-Shift-P）を押してコマンドパレットを開きます。 Live Server: Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ CSSに関しては、ページを好きなようにレイアウトできます。少し時間をかけてページをより魅力的にしてみてください： 別のフォントを選ぶ ヘッダーに色を付ける アイテムのサイズを変更する JavaScript UIが作成できたので、次はロジックを提供するJavaScriptに注目します。これをいくつかのステップに分けて進めます： 定数の作成 ゲーム開始のイベントリスナー タイピングのイベントリスナー まず、scriptjsという名前の新しいファイルを作成します。 定数の追加 プログラミングを簡単にするために、いくつかのアイテムが必要です。これもレシピのようなもので、以下が必要です： すべての引用文を含む配列 現在の引用文のすべての単語を格納する空の配列 プレイヤーが現在入力している単語のインデックスを格納するスペース プレイヤーがスタートをクリックした時間 また、UI要素への参照も必要です： テキストボックス（typed-value） 引用文の表示（quote） メッセージ（message） javascript // inside scriptjs\n// all of our quotes\nconst quotes = [\n'When you have eliminated the impossible, whatever remains, however improbable, must be the truth",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 939,
    "chunk_index": 17,
    "total_chunks": 42
  },
  {
    "id": "410282c6695493cb5f297bf862970ef2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Open with Live Serverと入力します。 Live Serverがアプリケーションをホストします。 ブラウザを開き、https://localhost:5500に移動します。 作成したページが表示されるはずです！ 次に、機能を追加していきましょう。 CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ CSSに関しては、ページを好きなようにレイアウトできます。少し時間をかけてページをより魅力的にしてみてください： 別のフォントを選ぶ ヘッダーに色を付ける アイテムのサイズを変更する JavaScript UIが作成できたので、次はロジックを提供するJavaScriptに注目します。これをいくつかのステップに分けて進めます： 定数の作成 ゲーム開始のイベントリスナー タイピングのイベントリスナー まず、scriptjsという名前の新しいファイルを作成します。 定数の追加 プログラミングを簡単にするために、いくつかのアイテムが必要です。これもレシピのようなもので、以下が必要です： すべての引用文を含む配列 現在の引用文のすべての単語を格納する空の配列 プレイヤーが現在入力している単語のインデックスを格納するスペース プレイヤーがスタートをクリックした時間 また、UI要素への参照も必要です： テキストボックス（typed-value） 引用文の表示（quote） メッセージ（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth',\n'There is nothing more deceptive than an obvious fact",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 672,
    "chunk_index": 18,
    "total_chunks": 42
  },
  {
    "id": "62a0e3795392910c4afcd8926cf47688",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "CSSの追加 HTMLが作成できたので、コアスタイリングのためのCSSを追加します。プレイヤーが入力すべき単語をハイライトし、入力が間違っている場合にテキストボックスを色付けします。これを2つのクラスで実現します。 stylecssという名前の新しいファイルを作成し、以下の構文を追加します。 ```css / inside stylecss /highlight { background-color: yellow; }error { background-color: lightcoral; border: red; } ``` ✅ CSSに関しては、ページを好きなようにレイアウトできます。少し時間をかけてページをより魅力的にしてみてください： 別のフォントを選ぶ ヘッダーに色を付ける アイテムのサイズを変更する JavaScript UIが作成できたので、次はロジックを提供するJavaScriptに注目します。これをいくつかのステップに分けて進めます： 定数の作成 ゲーム開始のイベントリスナー タイピングのイベントリスナー まず、scriptjsという名前の新しいファイルを作成します。 定数の追加 プログラミングを簡単にするために、いくつかのアイテムが必要です。これもレシピのようなもので、以下が必要です： すべての引用文を含む配列 現在の引用文のすべての単語を格納する空の配列 プレイヤーが現在入力している単語のインデックスを格納するスペース プレイヤーがスタートをクリックした時間 また、UI要素への参照も必要です： テキストボックス（typed-value） 引用文の表示（quote） メッセージ（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth', 'There is nothing more deceptive than an obvious fact',\n'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 19,
    "total_chunks": 42
  },
  {
    "id": "9ac94eb3405292f796e93879bce773a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "すべての引用文を含む配列 現在の引用文のすべての単語を格納する空の配列 プレイヤーが現在入力している単語のインデックスを格納するスペース プレイヤーがスタートをクリックした時間 また、UI要素への参照も必要です： テキストボックス（typed-value） 引用文の表示（quote） メッセージ（message） javascript // inside scriptjs // all of our quotes const quotes = [ 'When you have eliminated the impossible, whatever remains, however improbable, must be the truth', 'There is nothing more deceptive than an obvious fact', 'I ought to know by this time that when a fact appears to be opposed to a long train of deductions it invariably proves to be capable of bearing some other interpretation',\n'I never make exceptions An exception disproves the rule ',\n'What one man can invent another can discover ',\n'Nothing clears up a case so much as stating it to another person ',\n'Education never ends, Watson It is a series of lessons, with the greatest for the last ',\n];\n// store the list of words and the index of the word the player is currently typing\nlet words = [];\nlet wordIndex = 0;\n// the starting time\nlet startTime = Date now();\n// page elements\nconst quoteElement = document getElementById('quote');\nconst messageElement = document getElementById('message');\nconst typedValueElement = document getElementById('typed-value');\n✅ ゲームにもっと引用文を追加してみましょう\nNOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。Vue",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 443,
    "chunk_index": 20,
    "total_chunks": 42
  },
  {
    "id": "9707b9d06f23d4258ebaa693610b8e10",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "', 'Education never ends, Watson It is a series of lessons, with the greatest for the last ', ]; // store the list of words and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。\nconst、let、varの使用方法についてのビデオを見てみましょう。\n🎥 上の画像をクリックすると、変数についてのビデオが再生されます。\nゲーム開始ロジックの追加\nゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。\nユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。\n```javascript\n// at the end of script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 560,
    "chunk_index": 21,
    "total_chunks": 42
  },
  {
    "id": "9f24623f3bc1c55a3ec90a4862ab4a4a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "greatest for the last ', ]; // store the list of words and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 546,
    "chunk_index": 22,
    "total_chunks": 42
  },
  {
    "id": "ae38836397a165638a9b79c849fefd37",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "for the last ', ]; // store the list of words and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 548,
    "chunk_index": 23,
    "total_chunks": 42
  },
  {
    "id": "1a93e72cd3b0f67d4c00f254d5eda2e4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "for the last ', ]; // store the list of words and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => {\n// get a quote\nconst quoteIndex = Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 565,
    "chunk_index": 24,
    "total_chunks": 42
  },
  {
    "id": "ab85519c319c230214d3d90f06267969",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Math",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 555,
    "chunk_index": 25,
    "total_chunks": 42
  },
  {
    "id": "4dcf62f2b11aa7a999c9300fc7b61520",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "and the index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quotes",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 559,
    "chunk_index": 26,
    "total_chunks": 42
  },
  {
    "id": "c2e092909736739e755482d12e807d37",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "index of the word the player is currently typing let words = []; let wordIndex = 0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength);\nconst quote = quotes[quoteIndex];\n// Put the quote into an array of words\nwords = quote",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 580,
    "chunk_index": 27,
    "total_chunks": 42
  },
  {
    "id": "1d90dab98a5435011c8e7d5bccc296a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "0; // the starting time let startTime = Date now(); // page elements const quoteElement = document getElementById('quote'); const messageElement = document getElementById('message'); const typedValueElement = document getElementById('typed-value'); ✅ ゲームにもっと引用文を追加してみましょう NOTE: document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' ');\n// reset the word index for tracking\nwordIndex = 0;\n// UI updates\n// Create an array of span elements so we can set a class\nconst spanWords = words",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 28,
    "total_chunks": 42
  },
  {
    "id": "8a5dee631c6ac38f06fcc7ff4d4c2704",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "document getElementByIdを使用して、コード内でいつでも要素を取得できます。これらの要素を定期的に参照するため、文字列リテラルのタイプミスを避けるために定数を使用します。VuejsやReactのようなフレームワークは、コードの集中管理をより効率的に行うのに役立ちます。 const、let、varの使用方法についてのビデオを見てみましょう。 🎥 上の画像をクリックすると、変数についてのビデオが再生されます。 ゲーム開始ロジックの追加 ゲームを開始するには、プレイヤーがスタートをクリックします。当然ながら、プレイヤーがいつスタートをクリックするのかは分かりません。ここでイベントリスナーが役立ちます。イベントリスナーは、何かが発生するのを待ち、それに応じてコードを実行します。この場合、ユーザーがスタートをクリックしたときにコードを実行したいのです。 ユーザーがスタートをクリックしたとき、引用文を選択し、ユーザーインターフェースを設定し、現在の単語とタイミングの追跡を設定する必要があります。以下は追加する必要のあるJavaScriptです。スクリプトブロックの後に説明します。 ```javascript // at the end of scriptjs documentgetElementById('start')addEventListener('click', () => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' '); // reset the word index for tracking wordIndex = 0; // UI updates // Create an array of span elements so we can set a class const spanWords = wordsmap(function(word) { return <span>${word} </span>});\n// Convert into string and set as innerHTML on quote display\nquoteElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 555,
    "chunk_index": 29,
    "total_chunks": 42
  },
  {
    "id": "ff2616f09169a48cc78075cf8d503498",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "() => { // get a quote const quoteIndex = Mathfloor(Mathrandom() * quoteslength); const quote = quotes[quoteIndex]; // Put the quote into an array of words words = quotesplit(' '); // reset the word index for tracking wordIndex = 0; // UI updates // Create an array of span elements so we can set a class const spanWords = wordsmap(function(word) { return <span>${word} </span>}); // Convert into string and set as innerHTML on quote display quoteElementinnerHTML = spanWords join('');\n// Highlight the first word\nquoteElement childNodes[0] className = 'highlight';\n// Clear any prior messages\nmessageElement innerText = '';\n// Setup the textbox\n// Clear the textbox\ntypedValueElement value = '';\n// set focus\ntypedValueElement focus();\n// set the event handler\n// Start the timer\nstartTime = new Date() getTime();\n});\n```\nコードを分解してみましょう！\n単語の追跡を設定\nMath floorとMath",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 220,
    "chunk_index": 30,
    "total_chunks": 42
  },
  {
    "id": "c460c1e70ab873044e9a1234f8856bb7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "wordsmap(function(word) { return <span>${word} </span>}); // Convert into string and set as innerHTML on quote display quoteElementinnerHTML = spanWords join(''); // Highlight the first word quoteElement childNodes[0] className = 'highlight'; // Clear any prior messages messageElement innerText = ''; // Setup the textbox // Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します\nquoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します\nプレイヤーが最初の単語から始めるため、wordIndexを0に設定します\nUIを設定\n各単語をspan要素内に含むspanWords配列を作成します\nこれにより、表示される単語をハイライトできます\n配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します\nこれにより、引用文がプレイヤーに表示されます\n最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします\nmessageElementのinnerTextを''に設定してクリアします\nテキストボックスを設定\n現在のtypedValueElementのvalueをクリアします\ntypedValueElementにfocusを設定します\nタイマーをgetTimeで開始します\nタイピングロジックの追加\nプレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 509,
    "chunk_index": 31,
    "total_chunks": 42
  },
  {
    "id": "0acbf5db957ec3493a14de717240538a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "display quoteElementinnerHTML = spanWords join(''); // Highlight the first word quoteElement childNodes[0] className = 'highlight'; // Clear any prior messages messageElement innerText = ''; // Setup the textbox // Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。\n```javascript\n// at the end of script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 519,
    "chunk_index": 32,
    "total_chunks": 42
  },
  {
    "id": "1571a5ac69a34bea5d5bf68a419f99d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "the first word quoteElement childNodes[0] className = 'highlight'; // Clear any prior messages messageElement innerText = ''; // Setup the textbox // Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs\ntypedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 511,
    "chunk_index": 33,
    "total_chunks": 42
  },
  {
    "id": "052c4f514e3ce485697f6188aa4a4167",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "first word quoteElement childNodes[0] className = 'highlight'; // Clear any prior messages messageElement innerText = ''; // Setup the textbox // Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs typedValueElementaddEventListener('input', () => {\n// Get the current word\nconst currentWord = words[wordIndex];\n// get the current value\nconst typedValue = typedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 34,
    "total_chunks": 42
  },
  {
    "id": "6c00fe50081c9250e8867be664747994",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Clear the textbox typedValueElement value = ''; // set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue;\nif (typedValue === currentWord && wordIndex === words",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 525,
    "chunk_index": 35,
    "total_chunks": 42
  },
  {
    "id": "e466aa00d4e1e13c30f7ca9034a020be",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "set focus typedValueElement focus(); // set the event handler // Start the timer startTime = new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue; if (typedValue === currentWord && wordIndex === wordslength - 1) {\n// end of sentence\n// Display success\nconst elapsedTime = new Date()",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 536,
    "chunk_index": 36,
    "total_chunks": 42
  },
  {
    "id": "b178d47914da5bbd80120ff45de09727",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "new Date() getTime(); }); ``` コードを分解してみましょう！ 単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue; if (typedValue === currentWord && wordIndex === wordslength - 1) { // end of sentence // Display success const elapsedTime = new Date()getTime() - startTime;\nconst message = CONGRATULATIONS",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 529,
    "chunk_index": 37,
    "total_chunks": 42
  },
  {
    "id": "967c88a931a0a8bb30cb0ee910fd34ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "単語の追跡を設定 Math floorとMathrandomを使用して、quotes配列からランダムに引用文を選択します quoteをwords配列に変換して、プレイヤーが現在入力している単語を追跡します プレイヤーが最初の単語から始めるため、wordIndexを0に設定します UIを設定 各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue; if (typedValue === currentWord && wordIndex === wordslength - 1) { // end of sentence // Display success const elapsedTime = new Date()getTime() - startTime; const message = CONGRATULATIONSYou finished in ${elapsedTime / 1000} seconds",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 38,
    "total_chunks": 42
  },
  {
    "id": "02ca30cfb584fb40fa7f7b652c0b4e2e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "各単語をspan要素内に含むspanWords配列を作成します これにより、表示される単語をハイライトできます 配列をjoinして、quoteElementのinnerHTMLを更新するための文字列を作成します これにより、引用文がプレイヤーに表示されます 最初のspan要素のclassNameをhighlightに設定して、黄色でハイライトします messageElementのinnerTextを''に設定してクリアします テキストボックスを設定 現在のtypedValueElementのvalueをクリアします typedValueElementにfocusを設定します タイマーをgetTimeで開始します タイピングロジックの追加 プレイヤーが入力すると、inputイベントが発生します。このイベントリスナーは、プレイヤーが単語を正しく入力しているかを確認し、ゲームの現在の状態を処理します。scriptjsに戻り、以下のコードを末尾に追加します。その後、詳細を説明します。 ```javascript // at the end of scriptjs typedValueElementaddEventListener('input', () => { // Get the current word const currentWord = words[wordIndex]; // get the current value const typedValue = typedValueElementvalue; if (typedValue === currentWord && wordIndex === wordslength - 1) { // end of sentence // Display success const elapsedTime = new Date()getTime() - startTime; const message = CONGRATULATIONSYou finished in ${elapsedTime / 1000} seconds;\nmessageElement innerText = message;\n} else if (typedValue endsWith(' ') && typedValue trim() === currentWord) {\n// end of word\n// clear the typedValueElement for the new word\ntypedValueElement value = '';\n// move to the next word\nwordIndex++;\n// reset the class name for all elements in quote\nfor (const wordElement of quoteElement childNodes) {\nwordElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 494,
    "chunk_index": 39,
    "total_chunks": 42
  },
  {
    "id": "f1ac70c1e9444bf727fae236d35c0b69",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "Display success const elapsedTime = new Date()getTime() - startTime; const message = CONGRATULATIONSYou finished in ${elapsedTime / 1000} seconds; messageElement innerText = message; } else if (typedValue endsWith(' ') && typedValue trim() === currentWord) { // end of word // clear the typedValueElement for the new word typedValueElement value = ''; // move to the next word wordIndex++; // reset the class name for all elements in quote for (const wordElement of quoteElement childNodes) { wordElementclassName = '';\n}\n// highlight the new word\nquoteElement childNodes[wordIndex] className = 'highlight';\n} else if (currentWord startsWith(typedValue)) {\n// currently correct\n// highlight the next word\ntypedValueElement className = '';\n} else {\n// error state\ntypedValueElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 175,
    "chunk_index": 40,
    "total_chunks": 42
  },
  {
    "id": "b01a9cf5f3f5ab92e3b68f2bec3e388d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
    "source_type": "git_repo",
    "title": "Typing game",
    "content": "word // clear the typedValueElement for the new word typedValueElement value = ''; // move to the next word wordIndex++; // reset the class name for all elements in quote for (const wordElement of quoteElement childNodes) { wordElementclassName = ''; } // highlight the new word quoteElement childNodes[wordIndex] className = 'highlight'; } else if (currentWord startsWith(typedValue)) { // currently correct // highlight the next word typedValueElement className = ''; } else { // error state typedValueElementclassName = 'error';\n}\n});\n```\nコードを分解してみましょう！まず、現在の単語とプレイヤーがこれまでに入力した値を取得します。その後、ウォーターフォールロジックを使用して、引用文が完了したか、単語が完了したか、単語が正しいか、またはエラーがあるかを確認します。\n引用文が完了した場合（typedValueがcurrentWordと等しく、wordIndexがwordsのlengthより1少ない場合）\n現在の時間からstartTimeを引いてelapsedTimeを計算します\nelapsedTimeを1,000で割ってミリ秒を秒に変換します\n成功メッセージを表示します\n単語が完了した場合（typedValueがスペースで終わり、typedValueがcurrentWordと等しい場合）\n次の単語を入力できるようにtypedElementのvalueを''に設定します\nwordIndexをインクリメントして次の単語に移動します\nquoteElementのすべてのchildNodesをループしてclassNameを''に設定し、デフォルト表示に戻します\n現在の単語のclassNameをhighlightに設定して、次に入力すべき単語としてフラグを立てます\n現在の単語が正しく入力されている場合（ただし完了していない場合）、currentWordがtypedValueで始まる\ntypedValueElementをデフォルト表示にするためにclassNameをクリアします\nここまで到達した場合、エラーがある\ntypedValueElementのclassNameをerrorに設定します\nアプリケーションのテスト\nここまで来ました！最後のステップは、アプリケーションが動作することを確認することです。試してみてください！エラーがあっても心配しないでください。すべての開発者がエラーを経験します。メッセージを確認し、必要に応じてデバッグしてください。\nスタートをクリックして、タイピングを始めてみましょう！以下のアニメーションのように動作するはずです。\n🚀 チャレンジ\nさらに機能を追加してみましょう：\n完了時にinputイベントリスナーを無効化し、ボタンがクリックされたときに再有効化する\nプレイヤーが引用文を完了したときにテキストボックスを無効化する\n成功メッセージを表示するモーダルダイアログボックスを追加する\nlocalStorage を使用してハイスコアを保存する\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\nウェブブラウザを通じて開発者が利用できるすべてのイベントについて調べ、それぞれのイベントをどのようなシナリオで使用するかを考えてみてください。\n課題\n新しいキーボードゲームを作成する\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があります。元の言語で記載された原文が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 21601,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\4-typing-game\\typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1189,
    "chunk_index": 41,
    "total_chunks": 42
  },
  {
    "id": "b6e9cbc05eca0dd268ef75972e1de67f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\assignment.md",
    "source_type": "git_repo",
    "title": "関数で遊ぼう",
    "content": "関数で遊ぼう\n手順\nさまざまな関数を作成してみましょう。戻り値がある関数と、戻り値がない関数の両方を作成してください。\nパラメーターとデフォルト値付きのパラメーターを組み合わせた関数を作れるか試してみてください。\n評価基準\n| 基準     | 優秀                                                                                   | 適切                                                         | 改善が必要         |\n| -------- | -------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ----------------- |\n|          | 2つ以上の多様なパラメーターを持つ、性能の良い関数が提供されている                       | 1つの関数と少数のパラメーターで動作する解決策が提供されている   | 解決策にバグがある |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があることをご承知おきください。原文（元の言語で記載された文書）が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1866,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 450,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "eb73dc49b75dc9d31083fd587927e611",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "JavaScriptの基本: データ型\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nこのレッスンでは、ウェブ上でインタラクティブ性を提供する言語であるJavaScriptの基本を学びます。\nこのレッスンはMicrosoft Learnで受講できます！\n🎥 上記の画像をクリックすると、変数とデータ型に関する動画が視聴できます\nまずは変数と、それに格納されるデータ型から始めましょう！\n変数\n変数はコード内で使用したり変更したりできる値を格納します。\n変数を宣言する際の構文は [キーワード] [名前] です。これは以下の2つの部分で構成されています:\nキーワード: キーワードにはletやvarが使用できます。\n✅ ES6で導入されたletキーワードは、変数にいわゆる_ブロックスコープ_を与えます。varよりもletを使用することが推奨されます。ブロックスコープについては後のレッスンで詳しく説明します。\n- 変数名: これは自分で選んだ名前です。\nタスク - 変数を操作する\n変数を宣言する: letキーワードを使用して変数を宣言してみましょう:\njavascript\nlet myVariable;\nmyVariableはletキーワードを使用して宣言されましたが、現在は値が設定されていません。\n値を代入する: =演算子を使用して変数に値を格納します。その後に期待される値を記述します。\njavascript\nmyVariable = 123;\n注意: このレッスンでの=の使用は、変数に値を設定するための「代入演算子」を意味します。これは等号を意味するものではありません。\nmyVariableは現在123という値で初期化されています。\nリファクタリング: 次のコードに置き換えてみましょう。\njavascript\nlet myVariable = 123;\n上記は_明示的初期化_と呼ばれ、変数を宣言すると同時に値を代入する方法です。\n変数の値を変更する: 次の方法で変数の値を変更してみましょう:\njavascript\nmyVariable = 321;\n変数が宣言されると、コード内の任意のポイントで=演算子と新しい値を使用してその値を変更することができます。\n✅ 試してみましょう！ブラウザでJavaScriptを直接書くことができます。ブラウザウィンドウを開き、開発者ツールに移動してください。コンソールでプロンプトが表示されます。let myVariable = 123と入力してリターンキーを押し、その後myVariableと入力してください。何が起こりますか？これらの概念については後のレッスンでさらに学びます。\n定数\n定数の宣言と初期化は変数と同じ概念に従いますが、constキーワードを使用する点が異なります。定数は通常、すべて大文字で宣言されます。\njavascript\nconst MY_VARIABLE = 123;\n定数は変数と似ていますが、以下の2つの例外があります:\n値が必要: 定数は初期化されていなければならず、コードを実行するとエラーが発生します。\n参照を変更できない: 定数が初期化されると、その参照を変更することはできず、コードを実行するとエラーが発生します。以下の例を見てみましょう:\n単純な値: 次のコードは許可されません:\njavascript\nconst PI = 3;\nPI = 4; // not allowed\nオブジェクト参照が保護される: 次のコードは許可されません:\njavascript\nconst obj = { a: 3 };\nobj = { b: 5 } // not allowed\nオブジェクトの値は保護されない: 次のコードは許可されます:\njavascript\nconst obj = { a: 3 };\nobj",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1247,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "28d9e62f0cb207f104a85e2a4b287178",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "myVariableは現在123という値で初期化されています。 リファクタリング: 次のコードに置き換えてみましょう。 javascript let myVariable = 123; 上記は_明示的初期化_と呼ばれ、変数を宣言すると同時に値を代入する方法です。 変数の値を変更する: 次の方法で変数の値を変更してみましょう: javascript myVariable = 321; 変数が宣言されると、コード内の任意のポイントで=演算子と新しい値を使用してその値を変更することができます。 ✅ 試してみましょう！ブラウザでJavaScriptを直接書くことができます。ブラウザウィンドウを開き、開発者ツールに移動してください。コンソールでプロンプトが表示されます。let myVariable = 123と入力してリターンキーを押し、その後myVariableと入力してください。何が起こりますか？これらの概念については後のレッスンでさらに学びます。 定数 定数の宣言と初期化は変数と同じ概念に従いますが、constキーワードを使用する点が異なります。定数は通常、すべて大文字で宣言されます。 javascript const MY_VARIABLE = 123; 定数は変数と似ていますが、以下の2つの例外があります: 値が必要: 定数は初期化されていなければならず、コードを実行するとエラーが発生します。 参照を変更できない: 定数が初期化されると、その参照を変更することはできず、コードを実行するとエラーが発生します。以下の例を見てみましょう: 単純な値: 次のコードは許可されません: javascript const PI = 3; PI = 4; // not allowed オブジェクト参照が保護される: 次のコードは許可されません: javascript const obj = { a: 3 }; obj = { b: 5 } // not allowed オブジェクトの値は保護されない: 次のコードは許可されます: javascript const obj = { a: 3 }; obja = 5;  // allowed\n上記ではオブジェクトの値を変更していますが、参照自体は変更していないため許可されます。\n注意: constは参照が再代入から保護されることを意味します。ただし、値が_不変_であるわけではなく、特にオブジェクトのような複雑な構造の場合は変更可能です。\nデータ型\n変数には、数値やテキストなどさまざまな種類の値を格納できます。これらの異なる種類の値はデータ型として知られています。データ型はソフトウェア開発において重要な要素であり、コードの書き方やソフトウェアの動作方法に関する判断を助けます。さらに、一部のデータ型には、値を変換したり追加情報を抽出したりするための独自の機能があります。\n✅ データ型はJavaScriptのデータプリミティブとも呼ばれ、言語によって提供される最も低レベルのデータ型です。プリミティブデータ型には、string、number、bigint、boolean、undefined、null、symbolの7種類があります。それぞれが何を表しているかをイメージしてみてください。zebraとは何でしょう？0は？trueは？\n数値\n前のセクションでは、myVariableの値が数値データ型でした。\nlet myVariable = 123;\n変数には、小数や負の数を含むすべての種類の数値を格納できます。数値はまた、次のセクションで説明する算術演算子とともに使用することができます。\n算術演算子\n算術関数を実行する際に使用する演算子にはいくつかの種類があり、以下にその一部を示します:\n| 記号   | 説明                                                                 | 例                              |\n| ------ | -------------------------------------------------------------------- | -------------------------------- |\n| +    | 加算: 2つの数値の合計を計算                                      | 1 + 2 //期待される答えは3      |\n| -    | 減算: 2つの数値の差を計算                                        | 1 - 2 //期待される答えは-1     |\n| *    | 乗算: 2つの数値の積を計算                                        | 1 * 2 //期待される答えは2      |\n| /    | 除算: 2つの数値の商を計算                                        | 1 / 2 //期待される答えは0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1449,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "defc7a72a1bfbef2344f39f8f5ac03d4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "5; // allowed 上記ではオブジェクトの値を変更していますが、参照自体は変更していないため許可されます。 注意: constは参照が再代入から保護されることを意味します。ただし、値が_不変_であるわけではなく、特にオブジェクトのような複雑な構造の場合は変更可能です。 データ型 変数には、数値やテキストなどさまざまな種類の値を格納できます。これらの異なる種類の値はデータ型として知られています。データ型はソフトウェア開発において重要な要素であり、コードの書き方やソフトウェアの動作方法に関する判断を助けます。さらに、一部のデータ型には、値を変換したり追加情報を抽出したりするための独自の機能があります。 ✅ データ型はJavaScriptのデータプリミティブとも呼ばれ、言語によって提供される最も低レベルのデータ型です。プリミティブデータ型には、string、number、bigint、boolean、undefined、null、symbolの7種類があります。それぞれが何を表しているかをイメージしてみてください。zebraとは何でしょう？0は？trueは？ 数値 前のセクションでは、myVariableの値が数値データ型でした。 let myVariable = 123; 変数には、小数や負の数を含むすべての種類の数値を格納できます。数値はまた、次のセクションで説明する算術演算子とともに使用することができます。 算術演算子 算術関数を実行する際に使用する演算子にはいくつかの種類があり、以下にその一部を示します: | 記号 | 説明 | 例 | | ------ | -------------------------------------------------------------------- | -------------------------------- | | + | 加算: 2つの数値の合計を計算 | 1 + 2 //期待される答えは3 | | - | 減算: 2つの数値の差を計算 | 1 - 2 //期待される答えは-1 | | * | 乗算: 2つの数値の積を計算 | 1 * 2 //期待される答えは2 | | / | 除算: 2つの数値の商を計算 | 1 / 2 //期待される答えは05    |\n| %    | 剰余: 2つの数値の除算から得られる余りを計算                      | 1 % 2 //期待される答えは1      |\n✅ 試してみましょう！ブラウザのコンソールで算術演算を試してみてください。結果に驚きましたか？\n文字列\n文字列は、シングルクォートまたはダブルクォートで囲まれた文字のセットです。\n'これは文字列です'\n\"これも文字列です\"\nlet myString = 'これは変数に格納された文字列値です';\n文字列を書く際にはクォートを使用することを忘れないでください。そうしないと、JavaScriptはそれを変数名とみなしてしまいます。\n文字列のフォーマット\n文字列はテキストであり、時折フォーマットが必要になります。\n2つ以上の文字列を結合するには、+演算子を使用します。\n```javascript\nlet myString1 = \"Hello\";\nlet myString2 = \"World\";\nmyString1 + myString2 + \"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1064,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "7d578b6c43a73112e88b025626540319",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "+ 2 //期待される答えは3 | | - | 減算: 2つの数値の差を計算 | 1 - 2 //期待される答えは-1 | | * | 乗算: 2つの数値の積を計算 | 1 * 2 //期待される答えは2 | | / | 除算: 2つの数値の商を計算 | 1 / 2 //期待される答えは05 | | % | 剰余: 2つの数値の除算から得られる余りを計算 | 1 % 2 //期待される答えは1 | ✅ 試してみましょう！ブラウザのコンソールで算術演算を試してみてください。結果に驚きましたか？ 文字列 文字列は、シングルクォートまたはダブルクォートで囲まれた文字のセットです。 'これは文字列です' \"これも文字列です\" let myString = 'これは変数に格納された文字列値です'; 文字列を書く際にはクォートを使用することを忘れないでください。そうしないと、JavaScriptはそれを変数名とみなしてしまいます。 文字列のフォーマット 文字列はテキストであり、時折フォーマットが必要になります。 2つ以上の文字列を結合するには、+演算子を使用します。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "61367c032cb5f226ac1c38f4ab499944",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "2 //期待される答えは2 | | / | 除算: 2つの数値の商を計算 | 1 / 2 //期待される答えは05 | | % | 剰余: 2つの数値の除算から得られる余りを計算 | 1 % 2 //期待される答えは1 | ✅ 試してみましょう！ブラウザのコンソールで算術演算を試してみてください。結果に驚きましたか？ 文字列 文字列は、シングルクォートまたはダブルクォートで囲まれた文字のセットです。 'これは文字列です' \"これも文字列です\" let myString = 'これは変数に格納された文字列値です'; 文字列を書く際にはクォートを使用することを忘れないでください。そうしないと、JavaScriptはそれを変数名とみなしてしまいます。 文字列のフォーマット 文字列はテキストであり、時折フォーマットが必要になります。 2つ以上の文字列を結合するには、+演算子を使用します。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World```\n✅ なぜJavaScriptでは1 + 1 = 2ですが、'1' + '1' = 11になるのでしょう？考えてみてください。では'1' + 1はどうでしょう？\nテンプレートリテラルは文字列をフォーマットするもう一つの方法で、クォートの代わりにバックティックを使用します。プレーンテキスト以外のものはすべて${ }の中に入れる必要があります。これには文字列である可能性のある変数も含まれます。\n```javascript\nlet myString1 = \"Hello\";\nlet myString2 = \"World\";\n${myString1} ${myString2}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 578,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "aee7b6bedc20919c988afb1c64f3d797",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "✅ 試してみましょう！ブラウザのコンソールで算術演算を試してみてください。結果に驚きましたか？ 文字列 文字列は、シングルクォートまたはダブルクォートで囲まれた文字のセットです。 'これは文字列です' \"これも文字列です\" let myString = 'これは変数に格納された文字列値です'; 文字列を書く際にはクォートを使用することを忘れないでください。そうしないと、JavaScriptはそれを変数名とみなしてしまいます。 文字列のフォーマット 文字列はテキストであり、時折フォーマットが必要になります。 2つ以上の文字列を結合するには、+演算子を使用します。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World``` ✅ なぜJavaScriptでは1 + 1 = 2ですが、'1' + '1' = 11になるのでしょう？考えてみてください。では'1' + 1はどうでしょう？ テンプレートリテラルは文字列をフォーマットするもう一つの方法で、クォートの代わりにバックティックを使用します。プレーンテキスト以外のものはすべて${ }の中に入れる必要があります。これには文字列である可能性のある変数も含まれます。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; ${myString1} ${myString2}//Hello World ${myString1}, ${myString2} //Hello, World",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "75dd258058efe651ec0650e1e68b34ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: データ型",
    "content": "\"これも文字列です\" let myString = 'これは変数に格納された文字列値です'; 文字列を書く際にはクォートを使用することを忘れないでください。そうしないと、JavaScriptはそれを変数名とみなしてしまいます。 文字列のフォーマット 文字列はテキストであり、時折フォーマットが必要になります。 2つ以上の文字列を結合するには、+演算子を使用します。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; myString1 + myString2 + \"\"; //HelloWorld myString1 + \" \" + myString2 + \" \"; //Hello World myString1 + \", \" + myString2 + \" \"; //Hello, World``` ✅ なぜJavaScriptでは1 + 1 = 2ですが、'1' + '1' = 11になるのでしょう？考えてみてください。では'1' + 1はどうでしょう？ テンプレートリテラルは文字列をフォーマットするもう一つの方法で、クォートの代わりにバックティックを使用します。プレーンテキスト以外のものはすべて${ }の中に入れる必要があります。これには文字列である可能性のある変数も含まれます。 ```javascript let myString1 = \"Hello\"; let myString2 = \"World\"; ${myString1} ${myString2}//Hello World ${myString1}, ${myString2} //Hello, World```\nどちらの方法でもフォーマットの目的を達成できますが、テンプレートリテラルはスペースや改行を尊重します。\n✅ テンプレートリテラルとプレーン文字列を使い分けるのはどんな場合でしょう？\nブール値\nブール値はtrueまたはfalseの2つの値のみを持つことができます。ブール値は、特定の条件が満たされた場合にどのコード行を実行するかを決定するのに役立ちます。多くの場合、演算子がブール値の設定を助け、変数が初期化されたりその値が更新されたりする際に演算子が頻繁に使用されることに気付くでしょう。\nlet myTrueBool = true\nlet myFalseBool = false\n✅ 変数は、ブール値trueに評価される場合「truthy」と見なされます。興味深いことに、JavaScriptではすべての値はfalsyと定義されない限りtruthyです。\n🚀 チャレンジ\nJavaScriptは時折データ型を扱う際に驚くべき挙動を示すことで有名です。これらの「落とし穴」について少し調べてみましょう。例えば: 大文字小文字の区別に注意！コンソールで次を試してみてください: let age = 1; let Age = 2; age == Age (結果はfalse -- なぜでしょう？)。他にどんな落とし穴が見つかりますか？\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\nJavaScriptの練習問題一覧を見て、1つ試してみましょう。何を学びましたか？\n課題\nデータ型の練習\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解について、当社は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 12025,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\1-data-types\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1154,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "e2c4226c490228b815926802f17a7170",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\assignment.md",
    "source_type": "git_repo",
    "title": "演算子",
    "content": "演算子\n手順\n演算子を試してみましょう。以下のプログラムを実装することを提案します：\n異なる評価システムを持つ学生のセットがあります。\n第一の評価システム\n1～5の評価で、3以上がコース合格を意味する評価システムです。\n第二の評価システム\nもう一つの評価システムでは、A, A-, B, B-, C, C-という評価があり、Aが最高評価で、Cが最低の合格評価です。\nタスク\n以下の配列 allStudents がすべての学生とその評価を表しているとします。この配列を基に、合格した学生のみを含む新しい配列 studentsWhoPass を作成してください。\nTIP: forループ、if",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2227,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 246,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "751aca9f2863427e8486f13629ef1a86",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\assignment.md",
    "source_type": "git_repo",
    "title": "演算子",
    "content": "演算子\n手順\n演算子を試してみましょう。以下のプログラムを実装することを提案します：\n異なる評価システムを持つ学生のセットがあります。\n第一の評価システム\n1～5の評価で、3以上がコース合格を意味する評価システムです。\n第二の評価システム\nもう一つの評価システムでは、A, A-, B, B-, C, C-という評価があり、Aが最高評価で、Cが最低の合格評価です。\nタスク\n以下の配列 allStudents がすべての学生とその評価を表しているとします。この配列を基に、合格した学生のみを含む新しい配列 studentsWhoPass を作成してください。\nTIP: forループ、ifelse、比較演算子を使用してください：\n```javascript\nlet allStudents = [\n'A',\n'B-',\n1,\n4,\n5,\n2\n]\nlet studentsWhoPass = [];\n```\n評価基準\n| 基準     | 優秀な例                      | 適切な例                      | 改善が必要な例                  |\n| -------- | ----------------------------- | ----------------------------- | ------------------------------- |\n|          | 完全な解決策が提示されている | 部分的な解決策が提示されている | バグのある解決策が提示されている |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2227,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 598,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "062b391b688f3d068ab4ce7b95b4f721",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "JavaScriptの基本: 判断を行う\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\n判断を行い、コードの実行順序を制御することで、コードを再利用可能で堅牢なものにすることができます。このセクションでは、JavaScriptでデータフローを制御するための構文と、Booleanデータ型と組み合わせた際の重要性について説明します。\n🎥 上の画像をクリックすると、判断を行う方法についての動画が再生されます。\nこのレッスンはMicrosoft Learnで受講できます！\nBooleanの簡単な復習\nBooleanはtrueまたはfalseの2つの値しか持ちません。Booleanは、特定の条件が満たされた場合にどのコード行を実行するかを判断するのに役立ちます。\nBooleanをtrueまたはfalseに設定するには、以下のように記述します:\nlet myTrueBool = true\nlet myFalseBool = false\n✅ Booleanは、イギリスの数学者、哲学者、論理学者であるジョージ・ブール（1815–1864）にちなんで名付けられました。\n比較演算子とBoolean\n演算子は条件を評価し、Boolean値を生成するために使用されます。以下はよく使用される演算子の一覧です。\n| 記号   | 説明                                                                                                                                                   | 例                  |\n| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- |\n| <    | より小さい: 2つの値を比較し、左側の値が右側より小さい場合にtrueを返します                                                                       | 5 < 6 // true     |\n| <=   | 以下: 2つの値を比較し、左側の値が右側以下の場合にtrueを返します                                                                                | 5 <= 6 // true    |\n| >    | より大きい: 2つの値を比較し、左側の値が右側より大きい場合にtrueを返します                                                                       | 5 > 6 // false    |\n| >=   | 以上: 2つの値を比較し、左側の値が右側以上の場合にtrueを返します                                                                                | 5 >= 6 // false   |\n| ===  | 厳密な等価性: 2つの値を比較し、値が等しく、かつデータ型も同じ場合にtrueを返します                                                              | 5 === 6 // false  |\n|",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 727,
    "chunk_index": 0,
    "total_chunks": 10
  },
  {
    "id": "e6f8949bde54463ce6115cb42e0803f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "演算子は条件を評価し、Boolean値を生成するために使用されます。以下はよく使用される演算子の一覧です。 | 記号 | 説明 | 例 | | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- | | < | より小さい: 2つの値を比較し、左側の値が右側より小さい場合にtrueを返します | 5 < 6 // true | | <= | 以下: 2つの値を比較し、左側の値が右側以下の場合にtrueを返します | 5 <= 6 // true | | > | より大きい: 2つの値を比較し、左側の値が右側より大きい場合にtrueを返します | 5 > 6 // false | | >= | 以上: 2つの値を比較し、左側の値が右側以上の場合にtrueを返します | 5 >= 6 // false | | === | 厳密な等価性: 2つの値を比較し、値が等しく、かつデータ型も同じ場合にtrueを返します | 5 === 6 // false | |==  | 不等価性: 2つの値を比較し、厳密な等価性演算子が返す値の逆を返します                                                                             | 5 == 6 // true   |\n✅ ブラウザのコンソールでいくつかの比較を書いてみて、返されるデータに驚くことがあるか確認してください。\nIf文\nIf文は、条件がtrueの場合にブロック内のコードを実行します。\njavascript\nif (condition) {\n//Condition is true Code in this block will run",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 1,
    "total_chunks": 10
  },
  {
    "id": "6df6fcc45118116f74a2c61215f941b5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "| <= | 以下: 2つの値を比較し、左側の値が右側以下の場合にtrueを返します | 5 <= 6 // true | | > | より大きい: 2つの値を比較し、左側の値が右側より大きい場合にtrueを返します | 5 > 6 // false | | >= | 以上: 2つの値を比較し、左側の値が右側以上の場合にtrueを返します | 5 >= 6 // false | | === | 厳密な等価性: 2つの値を比較し、値が等しく、かつデータ型も同じ場合にtrueを返します | 5 === 6 // false | |== | 不等価性: 2つの値を比較し、厳密な等価性演算子が返す値の逆を返します | 5 == 6 // true | ✅ ブラウザのコンソールでいくつかの比較を書いてみて、返されるデータに驚くことがあるか確認してください。 If文 If文は、条件がtrueの場合にブロック内のコードを実行します。 javascript if (condition) { //Condition is true Code in this block will run}\n論理演算子は、条件を形成するためによく使用されます。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nif (currentMoney >= laptopPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n}\n```\nIf",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 428,
    "chunk_index": 2,
    "total_chunks": 10
  },
  {
    "id": "afd9af343fcffc465a1c5318899884cc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "| 5 >= 6 // false | | === | 厳密な等価性: 2つの値を比較し、値が等しく、かつデータ型も同じ場合にtrueを返します | 5 === 6 // false | |== | 不等価性: 2つの値を比較し、厳密な等価性演算子が返す値の逆を返します | 5 == 6 // true | ✅ ブラウザのコンソールでいくつかの比較を書いてみて、返されるデータに驚くことがあるか確認してください。 If文 If文は、条件がtrueの場合にブロック内のコードを実行します。 javascript if (condition) { //Condition is true Code in this block will run} 論理演算子は、条件を形成するためによく使用されます。 ```javascript let currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } ``` IfElse文\nelse文は、条件がfalseの場合にブロック内のコードを実行します。if文と組み合わせて使用することができますが、必須ではありません。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nif (currentMoney >= laptopPrice) {\n//Condition is true Code in this block will run console log(\"Getting a new laptop \");\n} else {\n//Condition is false Code in this block will run console log(\"Can't afford a new laptop, yet \");\n}\n```\n✅ このコードと以下のコードをブラウザのコンソールで実行して理解を深めてください。currentMoneyとlaptopPrice変数の値を変更して、console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 462,
    "chunk_index": 3,
    "total_chunks": 10
  },
  {
    "id": "ea209bd01882c561c81fc199b1f7b960",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } ``` IfElse文 else文は、条件がfalseの場合にブロック内のコードを実行します。if文と組み合わせて使用することができますが、必須ではありません。 ```javascript let currentMoney; let laptopPrice; if (currentMoney >= laptopPrice) { //Condition is true Code in this block will run console log(\"Getting a new laptop \"); } else { //Condition is false Code in this block will run console log(\"Can't afford a new laptop, yet \"); } ``` ✅ このコードと以下のコードをブラウザのコンソールで実行して理解を深めてください。currentMoneyとlaptopPrice変数の値を変更して、consolelog()の結果を変えてみましょう。\nSwitch文\nswitch文は、異なる条件に基づいて異なるアクションを実行するために使用されます。switch文を使用して、実行するコードブロックを選択します。\njavascript\nswitch (expression) {\ncase x:\n// code block\nbreak;\ncase y:\n// code block\nbreak;\ndefault:\n// code block\n}\n```javascript\n// program using switch statement\nlet a = 2;\nswitch (a) {\ncase 1:\na = \"one\";\nbreak;\ncase 2:\na = \"two\";\nbreak;\ndefault:\na = \"not found\";\nbreak;\n}\nconsole log(The value is ${a});\n```\n✅ このコードと以下のコードをブラウザのコンソールで実行して理解を深めてください。変数aの値を変更して、console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 437,
    "chunk_index": 4,
    "total_chunks": 10
  },
  {
    "id": "f6f8aa143fb2f41d3cfd96ccbf5236e5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "run console log(\"Can't afford a new laptop, yet \"); } ``` ✅ このコードと以下のコードをブラウザのコンソールで実行して理解を深めてください。currentMoneyとlaptopPrice変数の値を変更して、consolelog()の結果を変えてみましょう。 Switch文 switch文は、異なる条件に基づいて異なるアクションを実行するために使用されます。switch文を使用して、実行するコードブロックを選択します。 javascript switch (expression) { case x: // code block break; case y: // code block break; default: // code block } ```javascript // program using switch statement let a = 2; switch (a) { case 1: a = \"one\"; break; case 2: a = \"two\"; break; default: a = \"not found\"; break; } console log(The value is ${a}); ``` ✅ このコードと以下のコードをブラウザのコンソールで実行して理解を深めてください。変数aの値を変更して、consolelog()の結果を変えてみましょう。\n論理演算子とBoolean\n判断には複数の比較が必要な場合があり、論理演算子を使ってBoolean値を生成することができます。\n| 記号   | 説明                                                                                     | 例                                                                         |\n| ------ | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |\n| &&   | 論理AND: 2つのBoolean式を比較します。両方がtrueの場合にのみtrueを返します         | (5 > 6) && (5 < 6 ) //片方はfalse、もう片方はtrue。結果はfalse           |\n| \\|\\| | 論理OR: 2つのBoolean式を比較します。少なくとも片方がtrueの場合にtrueを返します    | (5 > 6) \\|\\| (5 < 6) //片方はfalse、もう片方はtrue。結果はtrue          |\n|",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 5,
    "total_chunks": 10
  },
  {
    "id": "b2d9d6ac7aeff6de923510c427ca77fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "{ case 1: a = \"one\"; break; case 2: a = \"two\"; break; default: a = \"not found\"; break; } console log(The value is ${a}); ``` ✅ このコードと以下のコードをブラウザのコンソールで実行して理解を深めてください。変数aの値を変更して、consolelog()の結果を変えてみましょう。 論理演算子とBoolean 判断には複数の比較が必要な場合があり、論理演算子を使ってBoolean値を生成することができます。 | 記号 | 説明 | 例 | | ------ | ---------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | | && | 論理AND: 2つのBoolean式を比較します。両方がtrueの場合にのみtrueを返します | (5 > 6) && (5 < 6 ) //片方はfalse、もう片方はtrue。結果はfalse | | \\|\\| | 論理OR: 2つのBoolean式を比較します。少なくとも片方がtrueの場合にtrueを返します | (5 > 6) \\|\\| (5 < 6) //片方はfalse、もう片方はtrue。結果はtrue | || 論理NOT: Boolean式の値を反転して返します                                              | (5 > 6) // 5は6より大きくないが、\" \"はtrueを返します                    |\n論理演算子を使った条件と判断\n論理演算子は、if else文の条件を形成するために使用できます。\n```javascript\nlet currentMoney;\nlet laptopPrice;\nlet laptopDiscountPrice = laptopPrice - laptopPrice * 0 2; //Laptop price at 20 percent off\nif (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) {\n//Condition is true Code in this block will run console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 6,
    "total_chunks": 10
  },
  {
    "id": "66285939bfc6a86f59a7643b6e2cf9c8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "6) && (5 < 6 ) //片方はfalse、もう片方はtrue。結果はfalse | | \\|\\| | 論理OR: 2つのBoolean式を比較します。少なくとも片方がtrueの場合にtrueを返します | (5 > 6) \\|\\| (5 < 6) //片方はfalse、もう片方はtrue。結果はtrue | || 論理NOT: Boolean式の値を反転して返します | (5 > 6) // 5は6より大きくないが、\" \"はtrueを返します | 論理演算子を使った条件と判断 論理演算子は、if else文の条件を形成するために使用できます。 ```javascript let currentMoney; let laptopPrice; let laptopDiscountPrice = laptopPrice - laptopPrice * 0 2; //Laptop price at 20 percent off if (currentMoney >= laptopPrice || currentMoney >= laptopDiscountPrice) { //Condition is true Code in this block will run consolelog(\"Getting a new laptop \");\n} else {\n//Condition is true Code in this block will run console log(\"Can't afford a new laptop, yet \");\n}\n```\n否定演算子\nこれまでにif else文を使って条件付きロジックを作成する方法を見てきました。ifに入るものはすべてtrueまたはfalseに評価される必要があります。 演算子を使用することで、式を反転（否定）することができます。以下のように記述します:\njavascript\nif ( condition) {\n// runs if condition is false\n} else {\n// runs if condition is true\n}\n三項演算子\nif elseは判断ロジックを表現する唯一の方法ではありません。三項演算子と呼ばれるものを使用することもできます。その構文は以下のようになります:\njavascript\nlet variable = condition",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 7,
    "total_chunks": 10
  },
  {
    "id": "b6fdeb65d9d58975906216af9894e0f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": ">= laptopPrice || currentMoney >= laptopDiscountPrice) { //Condition is true Code in this block will run consolelog(\"Getting a new laptop \"); } else { //Condition is true Code in this block will run console log(\"Can't afford a new laptop, yet \"); } ``` 否定演算子 これまでにif else文を使って条件付きロジックを作成する方法を見てきました。ifに入るものはすべてtrueまたはfalseに評価される必要があります。 演算子を使用することで、式を反転（否定）することができます。以下のように記述します: javascript if ( condition) { // runs if condition is false } else { // runs if condition is true } 三項演算子 if elseは判断ロジックを表現する唯一の方法ではありません。三項演算子と呼ばれるものを使用することもできます。その構文は以下のようになります: javascript let variable = condition<return this if true> : <return this if false>\n以下はより具体的な例です:\njavascript\nlet firstNumber = 20;\nlet secondNumber = 10;\nlet biggestNumber = firstNumber > secondNumber",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 306,
    "chunk_index": 8,
    "total_chunks": 10
  },
  {
    "id": "8472d54f63bed4b2cb4d1684dff4cbe2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: 判断を行う",
    "content": "//Condition is true Code in this block will run console log(\"Can't afford a new laptop, yet \"); } ``` 否定演算子 これまでにif else文を使って条件付きロジックを作成する方法を見てきました。ifに入るものはすべてtrueまたはfalseに評価される必要があります。 演算子を使用することで、式を反転（否定）することができます。以下のように記述します: javascript if ( condition) { // runs if condition is false } else { // runs if condition is true } 三項演算子 if elseは判断ロジックを表現する唯一の方法ではありません。三項演算子と呼ばれるものを使用することもできます。その構文は以下のようになります: javascript let variable = condition<return this if true> : <return this if false> 以下はより具体的な例です: javascript let firstNumber = 20; let secondNumber = 10; let biggestNumber = firstNumber > secondNumberfirstNumber : secondNumber;\n✅ このコードを数回読んでみてください。これらの演算子がどのように動作しているか理解できますか？\n上記のコードは以下を意味します:\nfirstNumberがsecondNumberより大きい場合\nfirstNumberをbiggestNumberに代入する\nそうでない場合はsecondNumberを代入する\n三項演算子は以下のコードを簡潔に書く方法です:\njavascript\nlet biggestNumber;\nif (firstNumber > secondNumber) {\nbiggestNumber = firstNumber;\n} else {\nbiggestNumber = secondNumber;\n}\n🚀 チャレンジ\nまず論理演算子を使ってプログラムを書き、その後三項演算子を使って書き直してください。どちらの構文が好みですか？\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\n利用可能な多くの演算子についてさらに学ぶには、MDNを参照してください。\nJosh Comeauの素晴らしい演算子検索ツールを試してみてください！\n課題\nOperators\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確さが含まれる可能性があります。元の言語で記載された原文が公式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳をお勧めします。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10602,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\3-making-decisions\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 796,
    "chunk_index": 9,
    "total_chunks": 10
  },
  {
    "id": "7d481aa40a3acab04bd77a5aca725911",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\assignment.md",
    "source_type": "git_repo",
    "title": "配列をループする",
    "content": "配列をループする\n手順\n1から20までの数字のうち、3番目ごとの数字をリスト化し、それをコンソールに出力するプログラムを作成してください。\nTIP: forループを使用し、イテレーション式を変更してください\n採点基準\n| 基準     | 優秀                                   | 適切                     | 改善が必要                     |\n| -------- | --------------------------------------- | ------------------------ | ------------------------------ |\n|          | プログラムが正しく動作し、コメントがある | コメントがないプログラム | プログラムが不完全またはバグがある |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があります。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1559,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 377,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "6a37852d657530752b40199f39917e38",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 601,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "d60f98b54ee398dd7896bd3e31745f6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 606,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "424f29407d6f99c786cba24597b62594",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 753,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "8a75a0d5d16046cb742ba39fbff4c3f3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsolelogを使用したときがそうです。メソッドと関数の違いは、メソッドがオブジェクト（この場合はconsole）に関連付けられているのに対し、関数は自由に存在する点です。多くの開発者がこれらの用語を混同して使うことがあります。\n関数のベストプラクティス\n関数を作成する際に覚えておくべきベストプラクティスがいくつかあります：\n常にわかりやすい名前を付けて、関数が何をするのかを明確にする\n複数の単語を組み合わせる場合はキャメルケースを使用する\n関数は特定のタスクに集中させる\n関数に情報を渡す\n関数をより再利用可能にするために、情報を渡すことがよくあります。上記のdisplayGreetingの例を考えると、Hello, world",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1032,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "98781c26d98fa9f69395333e06a17d0a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsolelogを使用したときがそうです。メソッドと関数の違いは、メソッドがオブジェクト（この場合はconsole）に関連付けられているのに対し、関数は自由に存在する点です。多くの開発者がこれらの用語を混同して使うことがあります。\n関数のベストプラクティス\n関数を作成する際に覚えておくべきベストプラクティスがいくつかあります：\n常にわかりやすい名前を付けて、関数が何をするのかを明確にする\n複数の単語を組み合わせる場合はキャメルケースを使用する\n関数は特定のタスクに集中させる\n関数に情報を渡す\n関数をより再利用可能にするために、情報を渡すことがよくあります。上記のdisplayGreetingの例を考えると、Hello, worldしか表示しません。これではあまり役に立つ関数とは言えません。例えば、挨拶する相手の名前を指定できるようにしたい場合、パラメータを追加します。パラメータ（引数とも呼ばれることがあります）は、関数に送られる追加情報です。\nパラメータは定義部分で括弧内にカンマ区切りで記述します：\n```javascript\nfunction name(param, param2, param3) {\n}\n```\ndisplayGreetingを更新して名前を受け取り、それを表示するようにできます。\njavascript\nfunction displayGreeting(name) {\nconst message = `Hello, ${name}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1226,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "66ea84e11cd9c78b9e29264d3283024b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsolelogを使用したときがそうです。メソッドと関数の違いは、メソッドがオブジェクト（この場合はconsole）に関連付けられているのに対し、関数は自由に存在する点です。多くの開発者がこれらの用語を混同して使うことがあります。\n関数のベストプラクティス\n関数を作成する際に覚えておくべきベストプラクティスがいくつかあります：\n常にわかりやすい名前を付けて、関数が何をするのかを明確にする\n複数の単語を組み合わせる場合はキャメルケースを使用する\n関数は特定のタスクに集中させる\n関数に情報を渡す\n関数をより再利用可能にするために、情報を渡すことがよくあります。上記のdisplayGreetingの例を考えると、Hello, worldしか表示しません。これではあまり役に立つ関数とは言えません。例えば、挨拶する相手の名前を指定できるようにしたい場合、パラメータを追加します。パラメータ（引数とも呼ばれることがあります）は、関数に送られる追加情報です。\nパラメータは定義部分で括弧内にカンマ区切りで記述します：\n```javascript\nfunction name(param, param2, param3) {\n}\n```\ndisplayGreetingを更新して名前を受け取り、それを表示するようにできます。\njavascript\nfunction displayGreeting(name) {\nconst message = `Hello, ${name}`;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1227,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "eb5399d99be0b505fb73dbf3e50dd57d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "JavaScriptの基本: メソッドと関数\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nコードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。\n🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。\nこのレッスンはMicrosoft Learnでも受講できます！\n関数\n関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。\n関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。\n関数の作成と呼び出し\n関数の構文は次のようになります：\njavascript\nfunction nameOfFunction() { // function definition\n// function definition/body\n}\n例えば、挨拶を表示する関数を作成したい場合、次のようになります：\njavascript\nfunction displayGreeting() {\nconsolelog('Hello, world');\n}\n関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。\njavascript\n// calling our function\ndisplayGreeting();\nNOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsolelogを使用したときがそうです。メソッドと関数の違いは、メソッドがオブジェクト（この場合はconsole）に関連付けられているのに対し、関数は自由に存在する点です。多くの開発者がこれらの用語を混同して使うことがあります。\n関数のベストプラクティス\n関数を作成する際に覚えておくべきベストプラクティスがいくつかあります：\n常にわかりやすい名前を付けて、関数が何をするのかを明確にする\n複数の単語を組み合わせる場合はキャメルケースを使用する\n関数は特定のタスクに集中させる\n関数に情報を渡す\n関数をより再利用可能にするために、情報を渡すことがよくあります。上記のdisplayGreetingの例を考えると、Hello, worldしか表示しません。これではあまり役に立つ関数とは言えません。例えば、挨拶する相手の名前を指定できるようにしたい場合、パラメータを追加します。パラメータ（引数とも呼ばれることがあります）は、関数に送られる追加情報です。\nパラメータは定義部分で括弧内にカンマ区切りで記述します：\n```javascript\nfunction name(param, param2, param3) {\n}\n```\ndisplayGreetingを更新して名前を受け取り、それを表示するようにできます。\njavascript\nfunction displayGreeting(name) {\nconst message = `Hello, ${name}`;\nconsolelog(message);\n}\n関数を呼び出してパラメータを渡すときは、括弧内に指定します。\njavascript\ndisplayGreeting('Christopher');\n// displays \"Hello, Christopher",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1277,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "861d7ef5b599e3a703097fcf974762c4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "講義前クイズ 講義前クイズ コードを書くとき、常にコードが読みやすいことを意識する必要があります。一見矛盾しているように思えるかもしれませんが、コードは書かれる回数よりも読む回数の方が圧倒的に多いのです。開発者がメンテナンスしやすいコードを書くための重要なツールの1つが関数です。 🎥 上の画像をクリックすると、メソッドと関数に関する動画が視聴できます。 このレッスンはMicrosoft Learnでも受講できます！ 関数 関数の基本は、必要に応じて実行できるコードのブロックです。同じタスクを何度も実行する必要がある場合に最適です。ロジックを複数の場所に重複して記述するのではなく（後で更新が難しくなります）、1か所に集中させて必要なときに呼び出すことができます。さらに、他の関数から関数を呼び出すことも可能です。 関数に名前を付けることも重要です。一見些細なことのように思えるかもしれませんが、名前を付けることでコードのセクションを簡単にドキュメント化できます。これはボタンにラベルを付けるようなものです。「タイマーをキャンセル」と書かれたボタンをクリックすれば、時計が停止することがわかります。 関数の作成と呼び出し 関数の構文は次のようになります： javascript function nameOfFunction() { // function definition // function definition/body } 例えば、挨拶を表示する関数を作成したい場合、次のようになります： javascript function displayGreeting() { consolelog('Hello, world'); } 関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。 javascript // calling our function displayGreeting(); NOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsolelogを使用したときがそうです。メソッドと関数の違いは、メソッドがオブジェクト（この場合はconsole）に関連付けられているのに対し、関数は自由に存在する点です。多くの開発者がこれらの用語を混同して使うことがあります。 関数のベストプラクティス 関数を作成する際に覚えておくべきベストプラクティスがいくつかあります： 常にわかりやすい名前を付けて、関数が何をするのかを明確にする 複数の単語を組み合わせる場合はキャメルケースを使用する 関数は特定のタスクに集中させる 関数に情報を渡す 関数をより再利用可能にするために、情報を渡すことがよくあります。上記のdisplayGreetingの例を考えると、Hello, worldしか表示しません。これではあまり役に立つ関数とは言えません。例えば、挨拶する相手の名前を指定できるようにしたい場合、パラメータを追加します。パラメータ（引数とも呼ばれることがあります）は、関数に送られる追加情報です。 パラメータは定義部分で括弧内にカンマ区切りで記述します： ```javascript function name(param, param2, param3) { } ``` displayGreetingを更新して名前を受け取り、それを表示するようにできます。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message); } 関数を呼び出してパラメータを渡すときは、括弧内に指定します。 javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" when run\nデフォルト値\n関数をさらに柔軟にするために、パラメータを増やすことができます。しかし、すべての値を必須にしたくない場合はどうすればよいでしょうか？挨拶の例を続けると、名前は必須（誰に挨拶するのかを知る必要があります）が、挨拶の内容はカスタマイズ可能にしたい場合があります。その場合、デフォルト値を提供します。パラメータにデフォルト値を設定するには、変数に値を設定するのと同じ方法で行います - parameterName = 'defaultValue'。完全な例を見てみましょう：\njavascript\nfunction displayGreeting(name, salutation='Hello') {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1496,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "ca59aad4cae5c801b6f73418a0e4d4b7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "nameOfFunction() { // function definition // function definition/body } 例えば、挨拶を表示する関数を作成したい場合、次のようになります： javascript function displayGreeting() { consolelog('Hello, world'); } 関数を呼び出す（または実行する）ときは、関数名の後に()を付けます。関数は定義される前でも後でも呼び出すことができる点に注目してください。JavaScriptのコンパイラがそれを見つけてくれます。 javascript // calling our function displayGreeting(); NOTE: メソッドと呼ばれる特別な種類の関数があります。実は、すでに使っています！例えば、上記のデモでconsolelogを使用したときがそうです。メソッドと関数の違いは、メソッドがオブジェクト（この場合はconsole）に関連付けられているのに対し、関数は自由に存在する点です。多くの開発者がこれらの用語を混同して使うことがあります。 関数のベストプラクティス 関数を作成する際に覚えておくべきベストプラクティスがいくつかあります： 常にわかりやすい名前を付けて、関数が何をするのかを明確にする 複数の単語を組み合わせる場合はキャメルケースを使用する 関数は特定のタスクに集中させる 関数に情報を渡す 関数をより再利用可能にするために、情報を渡すことがよくあります。上記のdisplayGreetingの例を考えると、Hello, worldしか表示しません。これではあまり役に立つ関数とは言えません。例えば、挨拶する相手の名前を指定できるようにしたい場合、パラメータを追加します。パラメータ（引数とも呼ばれることがあります）は、関数に送られる追加情報です。 パラメータは定義部分で括弧内にカンマ区切りで記述します： ```javascript function name(param, param2, param3) { } ``` displayGreetingを更新して名前を受け取り、それを表示するようにできます。 javascript function displayGreeting(name) { const message = `Hello, ${name}`; consolelog(message); } 関数を呼び出してパラメータを渡すときは、括弧内に指定します。 javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" when run デフォルト値 関数をさらに柔軟にするために、パラメータを増やすことができます。しかし、すべての値を必須にしたくない場合はどうすればよいでしょうか？挨拶の例を続けると、名前は必須（誰に挨拶するのかを知る必要があります）が、挨拶の内容はカスタマイズ可能にしたい場合があります。その場合、デフォルト値を提供します。パラメータにデフォルト値を設定するには、変数に値を設定するのと同じ方法で行います - parameterName = 'defaultValue'。完全な例を見てみましょう： javascript function displayGreeting(name, salutation='Hello') { consolelog(`${salutation}, ${name}`);\n}\n関数を呼び出すとき、salutationの値を設定するかどうかを選択できます。\n```javascript\ndisplayGreeting('Christopher');\n// displays \"Hello, Christopher\"\ndisplayGreeting('Christopher', 'Hi');\n// displays \"Hi, Christopher\"\n```\n戻り値\nこれまでに作成した関数は常にコンソールに出力されます。これは、他のサービスを呼び出す関数を作成する場合には理想的です。しかし、計算を行い、その値を他の場所で使用するために返したい場合はどうすればよいでしょうか？\nこれを実現するには、戻り値を使用します。戻り値は関数から返され、文字列や数値のようなリテラル値と同じように変数に格納できます。\n関数が何かを返す場合、returnキーワードを使用します。returnキーワードは返される値や参照を期待します：\njavascript\nreturn myVariable;\n挨拶メッセージを作成してその値を呼び出し元に返す関数を作成できます。\njavascript\nfunction createGreetingMessage(name) {\nconst message = `Hello, ${name}`;\nreturn message;\n}\nこの関数を呼び出すとき、その値を変数に格納します。これは、静的な値（例: const name = 'Christopher'）を変数に設定するのと同じ方法です。\njavascript\nconst greetingMessage = createGreetingMessage('Christopher');\n関数を関数のパラメータとして使用する\nプログラミングのキャリアを進める中で、関数をパラメータとして受け取る関数に出会うことがあります。この便利なトリックは、何かがいつ発生するのか、または完了するのかがわからない場合に、何かに応答して操作を実行する必要があるときによく使われます。\n例として、setTimeoutを考えてみましょう。これはタイマーを開始し、完了したときにコードを実行します。どのコードを実行するかを指定する必要があります。これは関数にぴったりの仕事です！\n以下のコードを実行すると、3秒後に3 seconds has elapsedというメッセージが表示されます。\njavascript\nfunction displayDone() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1646,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "216aeb5609eb944519bc4b45901ae68b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "// displays \"Hello, Christopher\" when run デフォルト値 関数をさらに柔軟にするために、パラメータを増やすことができます。しかし、すべての値を必須にしたくない場合はどうすればよいでしょうか？挨拶の例を続けると、名前は必須（誰に挨拶するのかを知る必要があります）が、挨拶の内容はカスタマイズ可能にしたい場合があります。その場合、デフォルト値を提供します。パラメータにデフォルト値を設定するには、変数に値を設定するのと同じ方法で行います - parameterName = 'defaultValue'。完全な例を見てみましょう： javascript function displayGreeting(name, salutation='Hello') { consolelog(`${salutation}, ${name}`); } 関数を呼び出すとき、salutationの値を設定するかどうかを選択できます。 ```javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" displayGreeting('Christopher', 'Hi'); // displays \"Hi, Christopher\" ``` 戻り値 これまでに作成した関数は常にコンソールに出力されます。これは、他のサービスを呼び出す関数を作成する場合には理想的です。しかし、計算を行い、その値を他の場所で使用するために返したい場合はどうすればよいでしょうか？ これを実現するには、戻り値を使用します。戻り値は関数から返され、文字列や数値のようなリテラル値と同じように変数に格納できます。 関数が何かを返す場合、returnキーワードを使用します。returnキーワードは返される値や参照を期待します： javascript return myVariable; 挨拶メッセージを作成してその値を呼び出し元に返す関数を作成できます。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } この関数を呼び出すとき、その値を変数に格納します。これは、静的な値（例: const name = 'Christopher'）を変数に設定するのと同じ方法です。 javascript const greetingMessage = createGreetingMessage('Christopher'); 関数を関数のパラメータとして使用する プログラミングのキャリアを進める中で、関数をパラメータとして受け取る関数に出会うことがあります。この便利なトリックは、何かがいつ発生するのか、または完了するのかがわからない場合に、何かに応答して操作を実行する必要があるときによく使われます。 例として、setTimeoutを考えてみましょう。これはタイマーを開始し、完了したときにコードを実行します。どのコードを実行するかを指定する必要があります。これは関数にぴったりの仕事です！ 以下のコードを実行すると、3秒後に3 seconds has elapsedというメッセージが表示されます。 javascript function displayDone() { consolelog('3 seconds has elapsed');\n}\n// timer value is in milliseconds\nsetTimeout(displayDone, 3000);\n無名関数\n作成したコードをもう一度見てみましょう。一度だけ使用される名前付き関数を作成しています。アプリケーションが複雑になるにつれて、一度しか呼び出されない関数をたくさん作成することになるかもしれません。これは理想的ではありません。実は、名前を付ける必要がない場合もあります！\n関数をパラメータとして渡す場合、事前に作成するのではなく、パラメータの一部として作成することができます。同じfunctionキーワードを使用しますが、パラメータとして構築します。\n上記のコードを無名関数を使用するように書き換えてみましょう：\njavascript\nsetTimeout(function() {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1188,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "8011e9767a903196b3e2e940039c49d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "関数を呼び出すとき、salutationの値を設定するかどうかを選択できます。 ```javascript displayGreeting('Christopher'); // displays \"Hello, Christopher\" displayGreeting('Christopher', 'Hi'); // displays \"Hi, Christopher\" ``` 戻り値 これまでに作成した関数は常にコンソールに出力されます。これは、他のサービスを呼び出す関数を作成する場合には理想的です。しかし、計算を行い、その値を他の場所で使用するために返したい場合はどうすればよいでしょうか？ これを実現するには、戻り値を使用します。戻り値は関数から返され、文字列や数値のようなリテラル値と同じように変数に格納できます。 関数が何かを返す場合、returnキーワードを使用します。returnキーワードは返される値や参照を期待します： javascript return myVariable; 挨拶メッセージを作成してその値を呼び出し元に返す関数を作成できます。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } この関数を呼び出すとき、その値を変数に格納します。これは、静的な値（例: const name = 'Christopher'）を変数に設定するのと同じ方法です。 javascript const greetingMessage = createGreetingMessage('Christopher'); 関数を関数のパラメータとして使用する プログラミングのキャリアを進める中で、関数をパラメータとして受け取る関数に出会うことがあります。この便利なトリックは、何かがいつ発生するのか、または完了するのかがわからない場合に、何かに応答して操作を実行する必要があるときによく使われます。 例として、setTimeoutを考えてみましょう。これはタイマーを開始し、完了したときにコードを実行します。どのコードを実行するかを指定する必要があります。これは関数にぴったりの仕事です！ 以下のコードを実行すると、3秒後に3 seconds has elapsedというメッセージが表示されます。 javascript function displayDone() { consolelog('3 seconds has elapsed'); } // timer value is in milliseconds setTimeout(displayDone, 3000); 無名関数 作成したコードをもう一度見てみましょう。一度だけ使用される名前付き関数を作成しています。アプリケーションが複雑になるにつれて、一度しか呼び出されない関数をたくさん作成することになるかもしれません。これは理想的ではありません。実は、名前を付ける必要がない場合もあります！ 関数をパラメータとして渡す場合、事前に作成するのではなく、パラメータの一部として作成することができます。同じfunctionキーワードを使用しますが、パラメータとして構築します。 上記のコードを無名関数を使用するように書き換えてみましょう： javascript setTimeout(function() { consolelog('3 seconds has elapsed');\n}, 3000);\n新しいコードを実行すると、同じ結果が得られることに気付くでしょう。関数を作成しましたが、名前を付ける必要はありませんでした！\nファットアロー関数\n多くのプログラミング言語（JavaScriptを含む）で一般的なショートカットとして、アロー関数またはファットアロー関数と呼ばれるものがあります。これは=>という特別な記号を使用します。この記号が矢印のように見えるため、この名前が付けられています！=>を使用することで、functionキーワードを省略できます。\nもう一度コードを書き換えて、ファットアロー関数を使用してみましょう：\njavascript\nsetTimeout(() => {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1180,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "48b1d58ba38a097d59b6ababc08fb83c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
    "source_type": "git_repo",
    "title": "JavaScriptの基本: メソッドと関数",
    "content": "戻り値 これまでに作成した関数は常にコンソールに出力されます。これは、他のサービスを呼び出す関数を作成する場合には理想的です。しかし、計算を行い、その値を他の場所で使用するために返したい場合はどうすればよいでしょうか？ これを実現するには、戻り値を使用します。戻り値は関数から返され、文字列や数値のようなリテラル値と同じように変数に格納できます。 関数が何かを返す場合、returnキーワードを使用します。returnキーワードは返される値や参照を期待します： javascript return myVariable; 挨拶メッセージを作成してその値を呼び出し元に返す関数を作成できます。 javascript function createGreetingMessage(name) { const message = `Hello, ${name}`; return message; } この関数を呼び出すとき、その値を変数に格納します。これは、静的な値（例: const name = 'Christopher'）を変数に設定するのと同じ方法です。 javascript const greetingMessage = createGreetingMessage('Christopher'); 関数を関数のパラメータとして使用する プログラミングのキャリアを進める中で、関数をパラメータとして受け取る関数に出会うことがあります。この便利なトリックは、何かがいつ発生するのか、または完了するのかがわからない場合に、何かに応答して操作を実行する必要があるときによく使われます。 例として、setTimeoutを考えてみましょう。これはタイマーを開始し、完了したときにコードを実行します。どのコードを実行するかを指定する必要があります。これは関数にぴったりの仕事です！ 以下のコードを実行すると、3秒後に3 seconds has elapsedというメッセージが表示されます。 javascript function displayDone() { consolelog('3 seconds has elapsed'); } // timer value is in milliseconds setTimeout(displayDone, 3000); 無名関数 作成したコードをもう一度見てみましょう。一度だけ使用される名前付き関数を作成しています。アプリケーションが複雑になるにつれて、一度しか呼び出されない関数をたくさん作成することになるかもしれません。これは理想的ではありません。実は、名前を付ける必要がない場合もあります！ 関数をパラメータとして渡す場合、事前に作成するのではなく、パラメータの一部として作成することができます。同じfunctionキーワードを使用しますが、パラメータとして構築します。 上記のコードを無名関数を使用するように書き換えてみましょう： javascript setTimeout(function() { consolelog('3 seconds has elapsed'); }, 3000); 新しいコードを実行すると、同じ結果が得られることに気付くでしょう。関数を作成しましたが、名前を付ける必要はありませんでした！ ファットアロー関数 多くのプログラミング言語（JavaScriptを含む）で一般的なショートカットとして、アロー関数またはファットアロー関数と呼ばれるものがあります。これは=>という特別な記号を使用します。この記号が矢印のように見えるため、この名前が付けられています！=>を使用することで、functionキーワードを省略できます。 もう一度コードを書き換えて、ファットアロー関数を使用してみましょう： javascript setTimeout(() => { consolelog('3 seconds has elapsed');\n}, 3000);\n各戦略を使うタイミング\n関数をパラメータとして渡す方法を3つ見てきましたが、それぞれをいつ使うべきか疑問に思うかもしれません。関数を複数回使用することがわかっている場合は、通常通り作成します。1か所でしか使用しない場合は、無名関数を使用するのが一般的です。ファットアロー関数を使うか、従来のfunction構文を使うかは好みの問題ですが、ほとんどの現代の開発者は=>を好む傾向があります。\n🚀 チャレンジ\n関数とメソッドの違いを1文で説明できますか？挑戦してみてください！\n講義後クイズ\n講義後クイズ\n復習と自己学習\nアロー関数についてもう少し読む価値があります。コードベースでますます使用されるようになっています。関数を1つ書いてみて、その後この構文で書き直してみてください。\n課題\nFun with Functions\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された原文が正式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 11899,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\2-functions-methods\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1665,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "da36259eea6ee07095184dddee871d31",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\assignment.md",
    "source_type": "git_repo",
    "title": "ドキュメントを読む",
    "content": "ドキュメントを読む\n手順\nウェブ開発者が必要とする多くのツールは、クライアントサイドツールのためのMDNドキュメントに記載されています。レッスンで取り上げられていないツールを3つ選び、それぞれについてウェブ開発者がなぜそのツールを使用するのかを説明してください。また、このカテゴリに該当するツールを1つ探し、そのドキュメントを共有してください。MDNドキュメントに記載されている同じツールの例は使用しないでください。\n採点基準\n優秀 | 十分 | 改善が必要\n--- | --- | -- |\n| ウェブ開発者がなぜツールを使用するのかを説明している | ツールの使い方を説明しているが、なぜ使用するのかを説明していない | ツールの使い方や使用理由について言及していない |\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な表現が含まれる可能性があることをご承知おきください。原文（元の言語で記載された文書）が信頼できる情報源として優先されるべきです。重要な情報については、専門の人間による翻訳を推奨します。本翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いかねます。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1955,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 516,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "5553487fe5fdb33096c4eb39cdb2733c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "JavaScript 基礎: 配列とループ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nこのレッスンでは、ウェブ上でインタラクティブ性を提供する言語であるJavaScriptの基礎を学びます。このレッスンでは、データを操作するために使用される配列とループについて学びます。\n🎥 上記の画像をクリックすると、配列とループに関する動画が視聴できます。\nこのレッスンは Microsoft Learn でも受講できます！\n配列\nデータを扱うことはどのプログラミング言語でも一般的なタスクであり、配列のような構造化された形式でデータが整理されていると、作業がはるかに簡単になります。配列を使うと、リストのような構造でデータを保存できます。配列の大きな利点の1つは、1つの配列に異なる種類のデータを保存できることです。\n✅ 配列は私たちの身の回りにたくさんあります！例えば、ソーラーパネルの配列のような実生活の例を思い浮かべられますか？\n配列の構文は、角括弧のペアです。\njavascript\nlet myArray = [];\nこれは空の配列ですが、配列はデータをすでに格納した状態で宣言することもできます。配列内の複数の値はカンマで区切られます。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\n配列の値には、インデックスと呼ばれる一意の値が割り当てられます。インデックスは配列の先頭からの距離に基づいて割り当てられる整数です。上記の例では、文字列値 \"Chocolate\" のインデックスは0で、\"Rocky Road\" のインデックスは4です。インデックスを角括弧とともに使用して、配列の値を取得、変更、または挿入できます。\n✅ 配列がゼロインデックスから始まることに驚きましたか？一部のプログラミング言語では、インデックスは1から始まります。この歴史については、Wikipedia で読むことができます。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\niceCreamFlavors[2]; //\"Vanilla\"\nインデックスを利用して値を変更することもできます。例えば、次のようにします：\njavascript\niceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\"\nまた、指定したインデックスに新しい値を挿入することもできます：\njavascript\niceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\"\n✅ 配列に値を追加するより一般的な方法は、array",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 906,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "51db6bfb0485969ac67c52025b4431e8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "スケッチノート: Tomomi Imura 講義前クイズ 講義前クイズ このレッスンでは、ウェブ上でインタラクティブ性を提供する言語であるJavaScriptの基礎を学びます。このレッスンでは、データを操作するために使用される配列とループについて学びます。 🎥 上記の画像をクリックすると、配列とループに関する動画が視聴できます。 このレッスンは Microsoft Learn でも受講できます！ 配列 データを扱うことはどのプログラミング言語でも一般的なタスクであり、配列のような構造化された形式でデータが整理されていると、作業がはるかに簡単になります。配列を使うと、リストのような構造でデータを保存できます。配列の大きな利点の1つは、1つの配列に異なる種類のデータを保存できることです。 ✅ 配列は私たちの身の回りにたくさんあります！例えば、ソーラーパネルの配列のような実生活の例を思い浮かべられますか？ 配列の構文は、角括弧のペアです。 javascript let myArray = []; これは空の配列ですが、配列はデータをすでに格納した状態で宣言することもできます。配列内の複数の値はカンマで区切られます。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; 配列の値には、インデックスと呼ばれる一意の値が割り当てられます。インデックスは配列の先頭からの距離に基づいて割り当てられる整数です。上記の例では、文字列値 \"Chocolate\" のインデックスは0で、\"Rocky Road\" のインデックスは4です。インデックスを角括弧とともに使用して、配列の値を取得、変更、または挿入できます。 ✅ 配列がゼロインデックスから始まることに驚きましたか？一部のプログラミング言語では、インデックスは1から始まります。この歴史については、Wikipedia で読むことができます。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" インデックスを利用して値を変更することもできます。例えば、次のようにします： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" また、指定したインデックスに新しい値を挿入することもできます： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 配列に値を追加するより一般的な方法は、arraypush() のような配列演算子を使用することです。\n配列内の項目数を調べるには、length プロパティを使用します。\njavascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\niceCreamFlavors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 973,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "8a9242f16fa009c0f184456a8f2b9f75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "✅ 配列は私たちの身の回りにたくさんあります！例えば、ソーラーパネルの配列のような実生活の例を思い浮かべられますか？ 配列の構文は、角括弧のペアです。 javascript let myArray = []; これは空の配列ですが、配列はデータをすでに格納した状態で宣言することもできます。配列内の複数の値はカンマで区切られます。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; 配列の値には、インデックスと呼ばれる一意の値が割り当てられます。インデックスは配列の先頭からの距離に基づいて割り当てられる整数です。上記の例では、文字列値 \"Chocolate\" のインデックスは0で、\"Rocky Road\" のインデックスは4です。インデックスを角括弧とともに使用して、配列の値を取得、変更、または挿入できます。 ✅ 配列がゼロインデックスから始まることに驚きましたか？一部のプログラミング言語では、インデックスは1から始まります。この歴史については、Wikipedia で読むことができます。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" インデックスを利用して値を変更することもできます。例えば、次のようにします： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" また、指定したインデックスに新しい値を挿入することもできます： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 配列に値を追加するより一般的な方法は、arraypush() のような配列演算子を使用することです。 配列内の項目数を調べるには、length プロパティを使用します。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5\n✅ 自分で試してみましょう！ブラウザのコンソールを使って、自分で作成した配列を操作してみてください。\nループ\nループを使用すると、繰り返しまたは反復的なタスクを実行でき、時間とコードを大幅に節約できます。各反復では、変数、値、条件が異なる場合があります。JavaScriptにはさまざまな種類のループがあり、それぞれに小さな違いがありますが、本質的には同じことを行います：データをループすることです。\nForループ\nfor ループは、反復するために次の3つの部分が必要です：\n- counter 通常、反復回数を数えるために数値で初期化される変数\n- condition 比較演算子を使用して、false になったときにループを停止させる式\n- iteration-expression 各反復の最後に実行され、通常はカウンター値を変更するために使用される\njavascript\n// Counting up to 10\nfor (let i = 0; i < 10; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1015,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "a9f15d26cf0cc673c007f25e2d82f806",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "\"Rocky Road\"]; iceCreamFlavors[2]; //\"Vanilla\" インデックスを利用して値を変更することもできます。例えば、次のようにします： javascript iceCreamFlavors[4] = \"Butter Pecan\"; //Changed \"Rocky Road\" to \"Butter Pecan\" また、指定したインデックスに新しい値を挿入することもできます： javascript iceCreamFlavors[5] = \"Cookie Dough\"; //Added \"Cookie Dough\" ✅ 配列に値を追加するより一般的な方法は、arraypush() のような配列演算子を使用することです。 配列内の項目数を調べるには、length プロパティを使用します。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5 ✅ 自分で試してみましょう！ブラウザのコンソールを使って、自分で作成した配列を操作してみてください。 ループ ループを使用すると、繰り返しまたは反復的なタスクを実行でき、時間とコードを大幅に節約できます。各反復では、変数、値、条件が異なる場合があります。JavaScriptにはさまざまな種類のループがあり、それぞれに小さな違いがありますが、本質的には同じことを行います：データをループすることです。 Forループ for ループは、反復するために次の3つの部分が必要です： - counter 通常、反復回数を数えるために数値で初期化される変数 - condition 比較演算子を使用して、false になったときにループを停止させる式 - iteration-expression 各反復の最後に実行され、通常はカウンター値を変更するために使用される javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i);\n}\n✅ このコードをブラウザのコンソールで実行してみてください。カウンター、条件、または反復式を少し変更するとどうなりますか？逆方向に実行してカウントダウンを作成できますか？\nWhileループ\nfor ループの構文とは異なり、while ループは条件だけを必要とし、その条件が false になるとループが停止します。ループ内の条件は通常、カウンターのような他の値に依存し、ループ中に管理する必要があります。カウンターの初期値はループの外で作成する必要があり、条件を満たすための式（カウンターの変更を含む）はループ内で維持する必要があります。\njavascript\n//Counting up to 10\nlet i = 0;\nwhile (i < 10) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 854,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "5d4420076e11b6391890827a052d4ae6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "Dough\" ✅ 配列に値を追加するより一般的な方法は、arraypush() のような配列演算子を使用することです。 配列内の項目数を調べるには、length プロパティを使用します。 javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; iceCreamFlavorslength; //5 ✅ 自分で試してみましょう！ブラウザのコンソールを使って、自分で作成した配列を操作してみてください。 ループ ループを使用すると、繰り返しまたは反復的なタスクを実行でき、時間とコードを大幅に節約できます。各反復では、変数、値、条件が異なる場合があります。JavaScriptにはさまざまな種類のループがあり、それぞれに小さな違いがありますが、本質的には同じことを行います：データをループすることです。 Forループ for ループは、反復するために次の3つの部分が必要です： - counter 通常、反復回数を数えるために数値で初期化される変数 - condition 比較演算子を使用して、false になったときにループを停止させる式 - iteration-expression 各反復の最後に実行され、通常はカウンター値を変更するために使用される javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ このコードをブラウザのコンソールで実行してみてください。カウンター、条件、または反復式を少し変更するとどうなりますか？逆方向に実行してカウントダウンを作成できますか？ Whileループ for ループの構文とは異なり、while ループは条件だけを必要とし、その条件が false になるとループが停止します。ループ内の条件は通常、カウンターのような他の値に依存し、ループ中に管理する必要があります。カウンターの初期値はループの外で作成する必要があり、条件を満たすための式（カウンターの変更を含む）はループ内で維持する必要があります。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i);\ni++;\n}\n✅ なぜforループを選ぶのか、またはwhileループを選ぶのか？17,000人の視聴者がStackOverflowで同じ質問をしました。その意見のいくつかはこちらで興味深く読めます。\nループと配列\n配列はループと一緒に使用されることが多いです。ほとんどの条件はループを停止するために配列の長さを必要とし、インデックスもカウンター値として使用できます。\n```javascript\nlet iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"];\nfor (let i = 0; i < iceCreamFlavors",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 934,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "0be6d317e92de1a505aa01bff9521bf0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "ループは、反復するために次の3つの部分が必要です： - counter 通常、反復回数を数えるために数値で初期化される変数 - condition 比較演算子を使用して、false になったときにループを停止させる式 - iteration-expression 各反復の最後に実行され、通常はカウンター値を変更するために使用される javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ このコードをブラウザのコンソールで実行してみてください。カウンター、条件、または反復式を少し変更するとどうなりますか？逆方向に実行してカウントダウンを作成できますか？ Whileループ for ループの構文とは異なり、while ループは条件だけを必要とし、その条件が false になるとループが停止します。ループ内の条件は通常、カウンターのような他の値に依存し、ループ中に管理する必要があります。カウンターの初期値はループの外で作成する必要があり、条件を満たすための式（カウンターの変更を含む）はループ内で維持する必要があります。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i); i++; } ✅ なぜforループを選ぶのか、またはwhileループを選ぶのか？17,000人の視聴者がStackOverflowで同じ質問をしました。その意見のいくつかはこちらで興味深く読めます。 ループと配列 配列はループと一緒に使用されることが多いです。ほとんどの条件はループを停止するために配列の長さを必要とし、インデックスもカウンター値として使用できます。 ```javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; for (let i = 0; i < iceCreamFlavorslength; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 635,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "705d2ebd60187cb6f227d6c4b96f2dac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 基礎: 配列とループ",
    "content": "通常、反復回数を数えるために数値で初期化される変数 - condition 比較演算子を使用して、false になったときにループを停止させる式 - iteration-expression 各反復の最後に実行され、通常はカウンター値を変更するために使用される javascript // Counting up to 10 for (let i = 0; i < 10; i++) { consolelog(i); } ✅ このコードをブラウザのコンソールで実行してみてください。カウンター、条件、または反復式を少し変更するとどうなりますか？逆方向に実行してカウントダウンを作成できますか？ Whileループ for ループの構文とは異なり、while ループは条件だけを必要とし、その条件が false になるとループが停止します。ループ内の条件は通常、カウンターのような他の値に依存し、ループ中に管理する必要があります。カウンターの初期値はループの外で作成する必要があり、条件を満たすための式（カウンターの変更を含む）はループ内で維持する必要があります。 javascript //Counting up to 10 let i = 0; while (i < 10) { consolelog(i); i++; } ✅ なぜforループを選ぶのか、またはwhileループを選ぶのか？17,000人の視聴者がStackOverflowで同じ質問をしました。その意見のいくつかはこちらで興味深く読めます。 ループと配列 配列はループと一緒に使用されることが多いです。ほとんどの条件はループを停止するために配列の長さを必要とし、インデックスもカウンター値として使用できます。 ```javascript let iceCreamFlavors = [\"Chocolate\", \"Strawberry\", \"Vanilla\", \"Pistachio\", \"Rocky Road\"]; for (let i = 0; i < iceCreamFlavorslength; i++) { consolelog(iceCreamFlavors[i]);\n} //Ends when all flavors are printed\n```\n✅ 自分で作成した配列をブラウザのコンソールでループしてみてください。\n🚀 チャレンジ\nforやwhileループ以外にも配列をループする方法があります。forEach、for-of、map などです。これらの技術の1つを使って、配列ループを書き直してみましょう。\n講義後クイズ\n講義後クイズ\n復習と自己学習\nJavaScriptの配列には、データ操作に非常に便利な多くのメソッドが付属しています。これらのメソッドについて調べる とともに、（push、pop、slice、spliceなど）自分で作成した配列で試してみてください。\n課題\n配列をループする\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8577,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\2-js-basics\\4-arrays-loops\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1065,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "89149ad894adb076f9ee63c0635df470",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "プログラミング言語とツールの基礎",
    "content": "プログラミング言語とツールの基礎\nこのレッスンでは、プログラミング言語の基本を学びます。ここで扱うトピックは、今日のほとんどの現代的なプログラミング言語に適用されます。「ツールの基礎」セクションでは、開発者として役立つソフトウェアについて学びます。\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nはじめに\nこのレッスンでは以下を学びます:\nプログラミングとは何か？\nプログラミング言語の種類\nプログラムの基本要素\nプロフェッショナルな開発者に役立つソフトウェアとツール\nこのレッスンは Microsoft Learn で受講できます！\nプログラミングとは？\nプログラミング（コーディングとも呼ばれる）は、コンピュータやモバイルデバイスなどの機器に指示を与えるプロセスです。これらの指示はプログラミング言語を使って記述され、デバイスによって解釈されます。これらの指示セットはさまざまな名前で呼ばれることがありますが、プログラム、コンピュータプログラム、アプリケーション（アプリ）、実行可能ファイル などが一般的です。\nプログラム はコードで書かれたものすべてを指します。ウェブサイト、ゲーム、スマホアプリなどがプログラムです。コードを書かずにプログラムを作成することも可能ですが、その基盤となるロジックはデバイスによって解釈され、そのロジックはほとんどの場合コードで書かれています。実行中 または 実行している プログラムは指示を実行しています。このレッスンを読んでいるデバイスも、画面に表示するためのプログラムを実行しています。\n✅ 少し調べてみましょう: 世界初のコンピュータプログラマーとされる人物は誰でしょう？\nプログラミング言語\nプログラミング言語は、開発者がデバイスに指示を与えるための手段です。デバイスはバイナリ（1と0）しか理解できませんが、ほとんどの 開発者にとってそれは効率的なコミュニケーション方法ではありません。プログラミング言語は、人間とコンピュータの間のコミュニケーション手段です。\nプログラミング言語にはさまざまな形式があり、目的も異なる場合があります。例えば、JavaScriptは主にウェブアプリケーションに使用され、Bashは主にオペレーティングシステムに使用されます。\n低水準言語 は通常、デバイスが指示を解釈するために必要なステップが少なくなります。しかし、高水準言語 が人気なのは、その読みやすさとサポートの充実度です。JavaScriptは高水準言語とされています。\n以下のコードは、高水準言語であるJavaScriptと低水準言語であるARMアセンブリコードの違いを示しています。\n```javascript\nlet number = 10\nlet n1 = 0, n2 = 1, nextTerm;\nfor (let i = 1; i <= number; i++) {\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16257,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1081,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "7d1fd0c00c6cd82de1385440d09a3267",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "プログラミング言語とツールの基礎",
    "content": "プログラミング言語とツールの基礎\nこのレッスンでは、プログラミング言語の基本を学びます。ここで扱うトピックは、今日のほとんどの現代的なプログラミング言語に適用されます。「ツールの基礎」セクションでは、開発者として役立つソフトウェアについて学びます。\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nはじめに\nこのレッスンでは以下を学びます:\nプログラミングとは何か？\nプログラミング言語の種類\nプログラムの基本要素\nプロフェッショナルな開発者に役立つソフトウェアとツール\nこのレッスンは Microsoft Learn で受講できます！\nプログラミングとは？\nプログラミング（コーディングとも呼ばれる）は、コンピュータやモバイルデバイスなどの機器に指示を与えるプロセスです。これらの指示はプログラミング言語を使って記述され、デバイスによって解釈されます。これらの指示セットはさまざまな名前で呼ばれることがありますが、プログラム、コンピュータプログラム、アプリケーション（アプリ）、実行可能ファイル などが一般的です。\nプログラム はコードで書かれたものすべてを指します。ウェブサイト、ゲーム、スマホアプリなどがプログラムです。コードを書かずにプログラムを作成することも可能ですが、その基盤となるロジックはデバイスによって解釈され、そのロジックはほとんどの場合コードで書かれています。実行中 または 実行している プログラムは指示を実行しています。このレッスンを読んでいるデバイスも、画面に表示するためのプログラムを実行しています。\n✅ 少し調べてみましょう: 世界初のコンピュータプログラマーとされる人物は誰でしょう？\nプログラミング言語\nプログラミング言語は、開発者がデバイスに指示を与えるための手段です。デバイスはバイナリ（1と0）しか理解できませんが、ほとんどの 開発者にとってそれは効率的なコミュニケーション方法ではありません。プログラミング言語は、人間とコンピュータの間のコミュニケーション手段です。\nプログラミング言語にはさまざまな形式があり、目的も異なる場合があります。例えば、JavaScriptは主にウェブアプリケーションに使用され、Bashは主にオペレーティングシステムに使用されます。\n低水準言語 は通常、デバイスが指示を解釈するために必要なステップが少なくなります。しかし、高水準言語 が人気なのは、その読みやすさとサポートの充実度です。JavaScriptは高水準言語とされています。\n以下のコードは、高水準言語であるJavaScriptと低水準言語であるARMアセンブリコードの違いを示しています。\n```javascript\nlet number = 10\nlet n1 = 0, n2 = 1, nextTerm;\nfor (let i = 1; i <= number; i++) {\nconsolelog(n1);\nnextTerm = n1 + n2;\nn1 = n2;\nn2 = nextTerm;\n}\n```\nc\narea ascen,code,readonly\nentry\ncode32\nadr r0,thumb+1\nbx r0\ncode16\nthumb\nmov r0,#00\nsub r0,r0,#01\nmov r1,#01\nmov r4,#10\nldr r2,=0x40000000\nback add r0,r1\nstr r0,[r2]\nadd r2,#04\nmov r3,r0\nmov r0,r1\nmov r1,r3\nsub r4,#01\ncmp r4,#00\nbne back\nend\n信じられないかもしれませんが、どちらも同じことをしています: フィボナッチ数列を10まで表示しています。\n✅ フィボナッチ数列は 定義 によると、0と1から始まり、各数がその前の2つの数の合計となる数列です。フィボナッチ数列の最初の10個の数字は、0, 1, 1, 2, 3, 5, 8, 13, 21, 34です。\nプログラムの要素\nプログラム内の単一の指示は ステートメント と呼ばれ、通常は指示が終了する場所、つまり 終端 を示す文字や行間隔があります。プログラムの終端方法は言語によって異なります。\nプログラム内のステートメントは、ユーザーやその他の場所から提供されるデータに依存して指示を実行することがあります。データはプログラムの動作を変える可能性があるため、プログラミング言語にはデータを一時的に保存して後で使用できる方法が備わっています。これを 変数 と呼びます。変数は、デバイスにデータをメモリに保存するよう指示するステートメントです。プログラム内の変数は代数の変数に似ており、ユニークな名前を持ち、その値は時間とともに変化する可能性があります。\n一部のステートメントがデバイスによって実行されない可能性があります。これは通常、開発者によって意図的に書かれた場合や、予期しないエラーが発生した場合に起こります。このようなアプリケーションの制御は、より堅牢で保守性の高いものにします。通常、これらの制御の変更は特定の条件が満たされたときに発生します。現代のプログラミングでよく使われるステートメントの1つに if",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16257,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1846,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "9a78daccdeeff0f4b4ed74fda19a884a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "プログラミング言語とツールの基礎",
    "content": "n2; n1 = n2; n2 = nextTerm; } ``` c area ascen,code,readonly entry code32 adr r0,thumb+1 bx r0 code16 thumb mov r0,#00 sub r0,r0,#01 mov r1,#01 mov r4,#10 ldr r2,=0x40000000 back add r0,r1 str r0,[r2] add r2,#04 mov r3,r0 mov r0,r1 mov r1,r3 sub r4,#01 cmp r4,#00 bne back end 信じられないかもしれませんが、どちらも同じことをしています: フィボナッチ数列を10まで表示しています。 ✅ フィボナッチ数列は 定義 によると、0と1から始まり、各数がその前の2つの数の合計となる数列です。フィボナッチ数列の最初の10個の数字は、0, 1, 1, 2, 3, 5, 8, 13, 21, 34です。 プログラムの要素 プログラム内の単一の指示は ステートメント と呼ばれ、通常は指示が終了する場所、つまり 終端 を示す文字や行間隔があります。プログラムの終端方法は言語によって異なります。 プログラム内のステートメントは、ユーザーやその他の場所から提供されるデータに依存して指示を実行することがあります。データはプログラムの動作を変える可能性があるため、プログラミング言語にはデータを一時的に保存して後で使用できる方法が備わっています。これを 変数 と呼びます。変数は、デバイスにデータをメモリに保存するよう指示するステートメントです。プログラム内の変数は代数の変数に似ており、ユニークな名前を持ち、その値は時間とともに変化する可能性があります。 一部のステートメントがデバイスによって実行されない可能性があります。これは通常、開発者によって意図的に書かれた場合や、予期しないエラーが発生した場合に起こります。このようなアプリケーションの制御は、より堅牢で保守性の高いものにします。通常、これらの制御の変更は特定の条件が満たされたときに発生します。現代のプログラミングでよく使われるステートメントの1つに ifelse ステートメントがあります。\n✅ このタイプのステートメントについては、後のレッスンでさらに学びます。\nツールの基礎\n🎥 上の画像をクリックしてツールに関する動画を視聴\nこのセクションでは、プロフェッショナルな開発の旅を始める際に非常に役立つソフトウェアについて学びます。\n開発環境 とは、開発者がソフトウェアを書く際に頻繁に使用するツールや機能の独自のセットです。これらのツールは開発者の特定のニーズに合わせてカスタマイズされている場合があり、開発者が仕事や個人プロジェクトの優先順位を変更したり、異なるプログラミング言語を使用したりする場合に変化することがあります。開発環境は、それを使用する開発者と同じくらいユニークです。\nエディタ\nソフトウェア開発において最も重要なツールの1つがエディタです。エディタはコードを書く場所であり、時にはコードを実行する場所でもあります。\n開発者がエディタを利用する理由は以下の通りです:\nデバッグ は、コードを1行ずつステップ実行してバグやエラーを見つけるのに役立ちます。一部のエディタにはデバッグ機能があり、特定のプログラミング言語に合わせてカスタマイズして追加することができます。\n構文ハイライト は、コードに色やテキストのフォーマットを追加し、読みやすくします。ほとんどのエディタはカスタマイズ可能な構文ハイライトを提供しています。\n拡張機能と統合 は、開発者による開発者のための専門的なツールです。これらのツールは基本エディタに組み込まれていません。例えば、多くの開発者はコードの動作を説明するためにドキュメントを作成します。彼らはスペルチェック拡張機能をインストールして、ドキュメント内の誤字を見つけることができます。ほとんどの拡張機能は特定のエディタ内で使用することを目的としており、ほとんどのエディタには利用可能な拡張機能を検索する方法が備わっています。\nカスタマイズ により、開発者は自分のニーズに合わせた独自の開発環境を作成できます。ほとんどのエディタは非常にカスタマイズ可能で、開発者が独自の拡張機能を作成することも可能です。\n人気のエディタとウェブ開発拡張機能\nVisual Studio Code\nCode Spell Checker\nLive Share\nPrettier - Code formatter\nAtom\nspell-check\nteletype\natom-beautify\nSublimetext\nemmet\nSublimeLinter\nブラウザ\nもう1つの重要なツールがブラウザです。ウェブ開発者は、ウェブ上でコードがどのように動作するかを確認するためにブラウザを利用します。また、HTMLのようにエディタで書かれたウェブページの視覚的要素を表示するためにも使用されます。\n多くのブラウザには 開発者ツール (DevTools) が搭載されており、アプリケーションに関する重要な情報を収集・キャプチャするための便利な機能が含まれています。例えば、ウェブページにエラーがある場合、エラーが発生したタイミングを知ることが役立つことがあります。ブラウザのDevToolsはこの情報をキャプチャするように設定できます。\n人気のブラウザとDevTools\nEdge\nChrome\nFirefox\nコマンドラインツール\n一部の開発者は、日常の作業においてグラフィカルなビューをあまり必要とせず、コマンドラインを利用することを好みます。コードを書くには大量のタイピングが必要であり、一部の開発者はキーボードでの作業の流れを中断したくないと考えます。彼らはキーボードショートカットを使ってデスクトップウィンドウを切り替えたり、異なるファイルで作業したり、ツールを使用したりします。ほとんどのタスクはマウスで完了できますが、コマンドラインを使用する利点の1つは、マウスとキーボードを切り替える必要なく多くの作業をコマンドラインツールで完了できることです。コマンドラインのもう1つの利点は、カスタマイズ可能であり、カスタム設定を保存して後で変更したり、他の開発マシンにインポートしたりできることです。開発環境は開発者ごとに非常にユニークであるため、コマンドラインを完全に避ける人もいれば、完全に依存する人もおり、その両方を好む人もいます。\n人気のコマンドラインオプション\nコマンドラインのオプションは使用するオペレーティングシステムによって異なります。\n💻 = オペレーティングシステムにプリインストールされています。\nWindows\nPowershell 💻\nCommand Line (CMDとも呼ばれる) 💻\nWindows Terminal\nmintty\nMacOS\nTerminal 💻\niTerm\nPowershell\nLinux\nBash 💻\nKDE Konsole\nPowershell\n人気のコマンドラインツール\nGit (💻 ほとんどのオペレーティングシステムにプリインストール)\nNPM\nYarn\nドキュメント\n開発者が新しいことを学びたいとき、最も頼りにするのはドキュメントです。開発者はツールや言語を正しく使用する方法を学ぶため、またその仕組みを深く理解するためにドキュメントを利用します。\nウェブ開発に関する人気のドキュメント\nMozilla Developer Network (MDN) - Mozillaによる、Firefoxブラウザの発行元\nFrontend Masters\nWeb",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16257,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2708,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "cc4c600dde5d8bf3c653fda6738729ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
    "source_type": "git_repo",
    "title": "プログラミング言語とツールの基礎",
    "content": "人気のエディタとウェブ開発拡張機能 Visual Studio Code Code Spell Checker Live Share Prettier - Code formatter Atom spell-check teletype atom-beautify Sublimetext emmet SublimeLinter ブラウザ もう1つの重要なツールがブラウザです。ウェブ開発者は、ウェブ上でコードがどのように動作するかを確認するためにブラウザを利用します。また、HTMLのようにエディタで書かれたウェブページの視覚的要素を表示するためにも使用されます。 多くのブラウザには 開発者ツール (DevTools) が搭載されており、アプリケーションに関する重要な情報を収集・キャプチャするための便利な機能が含まれています。例えば、ウェブページにエラーがある場合、エラーが発生したタイミングを知ることが役立つことがあります。ブラウザのDevToolsはこの情報をキャプチャするように設定できます。 人気のブラウザとDevTools Edge Chrome Firefox コマンドラインツール 一部の開発者は、日常の作業においてグラフィカルなビューをあまり必要とせず、コマンドラインを利用することを好みます。コードを書くには大量のタイピングが必要であり、一部の開発者はキーボードでの作業の流れを中断したくないと考えます。彼らはキーボードショートカットを使ってデスクトップウィンドウを切り替えたり、異なるファイルで作業したり、ツールを使用したりします。ほとんどのタスクはマウスで完了できますが、コマンドラインを使用する利点の1つは、マウスとキーボードを切り替える必要なく多くの作業をコマンドラインツールで完了できることです。コマンドラインのもう1つの利点は、カスタマイズ可能であり、カスタム設定を保存して後で変更したり、他の開発マシンにインポートしたりできることです。開発環境は開発者ごとに非常にユニークであるため、コマンドラインを完全に避ける人もいれば、完全に依存する人もおり、その両方を好む人もいます。 人気のコマンドラインオプション コマンドラインのオプションは使用するオペレーティングシステムによって異なります。 💻 = オペレーティングシステムにプリインストールされています。 Windows Powershell 💻 Command Line (CMDとも呼ばれる) 💻 Windows Terminal mintty MacOS Terminal 💻 iTerm Powershell Linux Bash 💻 KDE Konsole Powershell 人気のコマンドラインツール Git (💻 ほとんどのオペレーティングシステムにプリインストール) NPM Yarn ドキュメント 開発者が新しいことを学びたいとき、最も頼りにするのはドキュメントです。開発者はツールや言語を正しく使用する方法を学ぶため、またその仕組みを深く理解するためにドキュメントを利用します。 ウェブ開発に関する人気のドキュメント Mozilla Developer Network (MDN) - Mozillaによる、Firefoxブラウザの発行元 Frontend Masters Webdev - Googleによる、Chromeの発行元\nMicrosoftの開発者向けドキュメント - Microsoft Edge向け\nW3 Schools\n✅ 調査してみましょう: ウェブ開発者の環境の基本を理解した今、ウェブデザイナーの環境と比較してみましょう。\n🚀 チャレンジ\nいくつかのプログラミング言語を比較してみましょう。JavaScriptとJavaのユニークな特徴は何ですか？COBOLとGoではどうでしょう？\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\nプログラマーが利用できるさまざまな言語について少し学びましょう。1つの言語で1行を書き、それを別の2つの言語で書き直してみてください。何を学びましたか？\n課題\nドキュメントを読む\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を期すよう努めておりますが、自動翻訳には誤りや不正確さが含まれる可能性があります。元の言語で記載された原文が公式な情報源と見なされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16257,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\1-intro-to-programming-languages\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1533,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "03c99bad33d24c66213b1d5ce025166a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\assignment.md",
    "source_type": "git_repo",
    "title": "アクセシブルでないサイトを分析する",
    "content": "アクセシブルでないサイトを分析する\n手順\nアクセシブルでないと思われるウェブサイトを特定し、そのアクセシビリティを改善するためのアクションプランを作成してください。\n最初のタスクは、このサイトを特定し、分析ツールを使用せずにそのアクセシビリティが不足している点を詳細に記述することです。その後、Lighthouse分析を実行し、その結果をPDFとして保存してください。そして、サイトを改善するための具体的な10項目以上の詳細な計画を作成してください。\nサイトのアクセシビリティをテストするための表\n| 基準 | 優秀 | 適切 | 改善が必要 |\n|------|------|------|------------|\n|      | 必要な項目の<10%が不足 | 必要な項目の20%が不足 | 必要な項目の50%が不足 |\n学生レポート: サイトがどれほどアクセシブルでないかについての段落、PDF形式で保存されたLighthouseレポート、改善するための10項目のリストとその詳細\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2004,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 565,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "f5aeaf6ade095950d6eb86f2be3fc332",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscript",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 769,
    "chunk_index": 0,
    "total_chunks": 49
  },
  {
    "id": "6cf3384adeabc9fa572c4240845a5f05",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 799,
    "chunk_index": 1,
    "total_chunks": 49
  },
  {
    "id": "ffd845a39936bfdc40c813f30ad1c932",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/script",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 800,
    "chunk_index": 2,
    "total_chunks": 49
  },
  {
    "id": "1484aac14d407868237e341112962606",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1020,
    "chunk_index": 3,
    "total_chunks": 49
  },
  {
    "id": "4a36e4c961d4d973ae590dec5d58afaa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1029,
    "chunk_index": 4,
    "total_chunks": 49
  },
  {
    "id": "f8b9780c32225d2b59222d2f6c362d66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1038,
    "chunk_index": 5,
    "total_chunks": 49
  },
  {
    "id": "d41d73f2201f64f09ed51fe72f2f913c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1047,
    "chunk_index": 6,
    "total_chunks": 49
  },
  {
    "id": "cf173eed029aaf9a6cdd7716e562a1ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1056,
    "chunk_index": 7,
    "total_chunks": 49
  },
  {
    "id": "72bc1b80ffeef1e891cf58053135c8e0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1065,
    "chunk_index": 8,
    "total_chunks": 49
  },
  {
    "id": "0117428c5bd06c19b617018b566820e8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1074,
    "chunk_index": 9,
    "total_chunks": 49
  },
  {
    "id": "0a61cfa5c9e5c9ea877bdea2a3bc5e67",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1083,
    "chunk_index": 10,
    "total_chunks": 49
  },
  {
    "id": "a4de2d3a4fac1a72cd0d2e35374c4e06",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1092,
    "chunk_index": 11,
    "total_chunks": 49
  },
  {
    "id": "5cabed97efa424e40b9e39f955421057",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1101,
    "chunk_index": 12,
    "total_chunks": 49
  },
  {
    "id": "b2dff7f7f2cbcf2ffc5078fe60d66b83",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1110,
    "chunk_index": 13,
    "total_chunks": 49
  },
  {
    "id": "1ec650233f2452905c098e1039f830f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1119,
    "chunk_index": 14,
    "total_chunks": 49
  },
  {
    "id": "12af48da1136bacd4e21ac8513c3b3d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1128,
    "chunk_index": 15,
    "total_chunks": 49
  },
  {
    "id": "6da50d73d94170a61bc99bfe3d1c20f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(documentgetElementById('plant13'));\ndragElement(document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1137,
    "chunk_index": 16,
    "total_chunks": 49
  },
  {
    "id": "939f83b28192772c8a1828775d31bb05",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(documentgetElementById('plant13'));\ndragElement(documentgetElementById('plant14'));\nここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。\n✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。\nクロージャ\n次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。\nクロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です：\njavascript\nfunction displayCandy(){\nlet candy = ['jellybeans'];\nfunction addCandy(candyType) {\ncandy",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1518,
    "chunk_index": 17,
    "total_chunks": 49
  },
  {
    "id": "186934455f108d41d57054fa94020a0b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(documentgetElementById('plant13'));\ndragElement(documentgetElementById('plant14'));\nここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。\n✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。\nクロージャ\n次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。\nクロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です：\njavascript\nfunction displayCandy(){\nlet candy = ['jellybeans'];\nfunction addCandy(candyType) {\ncandypush(candyType)\n}\naddCandy('gumdrops');\n}\ndisplayCandy();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1539,
    "chunk_index": 18,
    "total_chunks": 49
  },
  {
    "id": "6e7b4cb1c1cae1410a7d22a823342958",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "テラリウムプロジェクト パート3: DOM操作とクロージャ\nスケッチノート: Tomomi Imura\n講義前クイズ\n講義前クイズ\nはじめに\nDOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！\nさらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。\nJavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。\nこのレッスンでは、クロージャを使用してDOMを操作します。\nDOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。\nDOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより\nこのレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。\n前提条件\nテラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。\nタスク\nテラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします：\nhtml\n<script src=\"/scriptjs\" defer></script>\n注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。\nDOM要素\n最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。\nタスク\nhtml\ndragElement(documentgetElementById('plant1'));\ndragElement(documentgetElementById('plant2'));\ndragElement(documentgetElementById('plant3'));\ndragElement(documentgetElementById('plant4'));\ndragElement(documentgetElementById('plant5'));\ndragElement(documentgetElementById('plant6'));\ndragElement(documentgetElementById('plant7'));\ndragElement(documentgetElementById('plant8'));\ndragElement(documentgetElementById('plant9'));\ndragElement(documentgetElementById('plant10'));\ndragElement(documentgetElementById('plant11'));\ndragElement(documentgetElementById('plant12'));\ndragElement(documentgetElementById('plant13'));\ndragElement(documentgetElementById('plant14'));\nここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。\n✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。\nクロージャ\n次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。\nクロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です：\njavascript\nfunction displayCandy(){\nlet candy = ['jellybeans'];\nfunction addCandy(candyType) {\ncandypush(candyType)\n}\naddCandy('gumdrops');\n}\ndisplayCandy();\nconsolelog(candy)\nこの例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。\n✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。\nタスク\nscript",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1734,
    "chunk_index": 19,
    "total_chunks": 49
  },
  {
    "id": "99d1adf39f069f3c3a73c44fcb8daf5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "DOM操作とクロージャ スケッチノート: Tomomi Imura 講義前クイズ 講義前クイズ はじめに DOM（\"Document Object Model\"）の操作は、ウェブ開発の重要な側面です。MDNによると、「Document Object Model (DOM) は、ウェブ上のドキュメントの構造と内容を構成するオブジェクトのデータ表現です。」DOM操作の課題は、しばしばJavaScriptフレームワークを使用してDOMを管理する理由となっていますが、ここではバニラJavaScriptで対応します！ さらに、このレッスンではJavaScriptクロージャの概念を紹介します。クロージャとは、ある関数が別の関数に囲まれており、内側の関数が外側の関数のスコープにアクセスできるようにするものです。 JavaScriptのクロージャは非常に広範で複雑なトピックです。このレッスンでは、基本的なアイデアに触れるだけです。このテラリウムのコード内で、クロージャ（内側の関数と外側の関数が構築され、内側の関数が外側のスコープにアクセスできるようになっているもの）を見つけることができます。詳細については、詳細なドキュメントをご覧ください。 このレッスンでは、クロージャを使用してDOMを操作します。 DOMを木構造として考えてみてください。これは、ウェブページのドキュメントを操作するためのすべての方法を表しています。さまざまなAPI（アプリケーションプログラムインターフェース）が作成されており、プログラマーは選択したプログラミング言語を使用してDOMにアクセスし、編集、変更、再配置、その他の管理を行うことができます。 DOMとそれを参照するHTMLマークアップの表現。Olfa Nasraouiより このレッスンでは、ページ上の植物を操作できるJavaScriptを作成することで、インタラクティブなテラリウムプロジェクトを完成させます。 前提条件 テラリウムのHTMLとCSSが完成している必要があります。このレッスンの終わりまでに、植物をドラッグしてテラリウムに出し入れできるようになります。 タスク テラリウムフォルダ内に新しいファイルscriptjsを作成します。このファイルを<head>セクションでインポートします： html <script src=\"/scriptjs\" defer></script> 注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。 DOM要素 最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。 タスク html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); ここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。 ✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します：\njavascript\nfunction dragElement(terrariumElement) {\n//set 4 positions for positioning on the screen\nlet pos1 = 0,\npos2 = 0,\npos3 = 0,\npos4 = 0;\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1789,
    "chunk_index": 20,
    "total_chunks": 49
  },
  {
    "id": "cafe5e0660a6a605cc7ddfec5bc54d80",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "<script src=\"/scriptjs\" defer></script> 注: 外部JavaScriptファイルをHTMLファイルにインポートする際には、deferを使用して、HTMLファイルが完全に読み込まれた後にJavaScriptが実行されるようにします。また、async属性を使用して、HTMLファイルの解析中にスクリプトを実行することもできますが、今回の場合、ドラッグスクリプトを実行する前にHTML要素が完全に利用可能であることが重要です。 DOM要素 最初に行うべきことは、DOM内で操作したい要素への参照を作成することです。今回の場合、サイドバーにある14個の植物が対象です。 タスク html dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); ここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。 ✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag;\n}\ndragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。\nさらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。\n✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。\nPointerdrag関数\nterrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1478,
    "chunk_index": 21,
    "total_chunks": 49
  },
  {
    "id": "64251a9d551a1a5844904a59f50fe876",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "dragElement(documentgetElementById('plant1')); dragElement(documentgetElementById('plant2')); dragElement(documentgetElementById('plant3')); dragElement(documentgetElementById('plant4')); dragElement(documentgetElementById('plant5')); dragElement(documentgetElementById('plant6')); dragElement(documentgetElementById('plant7')); dragElement(documentgetElementById('plant8')); dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); ここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。 ✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;：\nタスク\njavascript\nfunction pointerDrag(e) {\ne",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1280,
    "chunk_index": 22,
    "total_chunks": 49
  },
  {
    "id": "4706406c7bac515d25be4154c5f268b5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "dragElement(documentgetElementById('plant9')); dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); ここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。 ✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault();\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1211,
    "chunk_index": 23,
    "total_chunks": 49
  },
  {
    "id": "971f589de7e4af0bd93df52546673a92",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "dragElement(documentgetElementById('plant10')); dragElement(documentgetElementById('plant11')); dragElement(documentgetElementById('plant12')); dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); ここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。 ✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e);\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1209,
    "chunk_index": 24,
    "total_chunks": 49
  },
  {
    "id": "2f4967010d5a168a8ed534c14e7e7e8f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "dragElement(documentgetElementById('plant13')); dragElement(documentgetElementById('plant14')); ここで何が起きているのでしょうか？ドキュメントを参照し、そのDOMを検索して特定のIdを持つ要素を見つけています。HTMLの最初のレッスンで、各植物画像に個別のId（id=\"plant1\"）を付けたことを思い出してください。その作業がここで役立ちます。各要素を特定した後、そのアイテムをdragElementという関数に渡します。この関数は後で作成します。これにより、HTML内の要素がドラッグ可能になります（または、すぐにドラッグ可能になります）。 ✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1189,
    "chunk_index": 25,
    "total_chunks": 49
  },
  {
    "id": "63d63204faf7f0382e0c33ff527b654e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "✅ なぜ要素をIdで参照するのでしょうか？CSSクラスではなく？CSSに関する前回のレッスンを参考にして、この質問に答えてみてください。 クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY;\n}\nいくつかのことが起きています。まず、e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1005,
    "chunk_index": 26,
    "total_chunks": 49
  },
  {
    "id": "65957bb0c4f5738bb78b2b2b0533e328",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "クロージャ 次に、dragElementクロージャを作成します。これは、内側の関数（今回の場合は3つ）を囲む外側の関数です。 クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。\nスクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？\n次に、ブラウザウィンドウでindex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1065,
    "chunk_index": 27,
    "total_chunks": 49
  },
  {
    "id": "ee8eea6f967081f40fe3a18a2e1fe5f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "クロージャは、1つ以上の関数が外側の関数のスコープにアクセスする必要がある場合に便利です。以下はその例です： javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。\n次に、ローカル変数pos3とpos4がe",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1134,
    "chunk_index": 28,
    "total_chunks": 49
  },
  {
    "id": "6cd7c0fa89a6d25058a0e9f082c4771e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "javascript function displayCandy(){ let candy = ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。\n✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。\nこの初期関数を完成させるために、pos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1322,
    "chunk_index": 29,
    "total_chunks": 49
  },
  {
    "id": "efd604c166d4f6f7d93b39065f8ac4cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "= ['jellybeans']; function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します：\nhtml\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1338,
    "chunk_index": 30,
    "total_chunks": 49
  },
  {
    "id": "1f3e9822e2b54b8da116ec5a1e238ff9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "function addCandy(candyType) { candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1339,
    "chunk_index": 31,
    "total_chunks": 49
  },
  {
    "id": "9346c80b2bcbd2d6cf3e1275bab9ca9d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "candypush(candyType) } addCandy('gumdrops'); } displayCandy(); consolelog(candy) この例では、displayCandy関数が、既存の配列に新しいキャンディタイプを追加する関数を囲んでいます。このコードを実行すると、candy配列は未定義になります。これは、candyがローカル変数（クロージャにローカル）であるためです。 ✅ candy配列をアクセス可能にするにはどうすればよいでしょうか？配列をクロージャの外側に移動してみてください。これにより、配列はグローバルになり、クロージャのローカルスコープに限定されなくなります。 タスク scriptjs内の要素宣言の下に、次の関数を作成します： javascript function dragElement(terrariumElement) { //set 4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag;\nこれで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。\nelementDragとstopElementDrag関数\nクロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。\nタスク\npointerDragの閉じ中括弧の直後にelementDrag関数を追加します：\njavascript\nfunction elementDrag(e) {\npos1 = pos3 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1707,
    "chunk_index": 32,
    "total_chunks": 49
  },
  {
    "id": "ea655b6972cc208233dd2d7d19b85d6b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "4 positions for positioning on the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX;\npos2 = pos4 - e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1464,
    "chunk_index": 33,
    "total_chunks": 49
  },
  {
    "id": "833553c1426ed2bf88e3806b492c116e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "the screen let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY;\npos3 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1466,
    "chunk_index": 34,
    "total_chunks": 49
  },
  {
    "id": "9888dfa48ce092eab5c1990d41108c2c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX;\npos4 = e",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1470,
    "chunk_index": 35,
    "total_chunks": 49
  },
  {
    "id": "705109a6367bfc2bd5070b11425296d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "pos2 = 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY;\nconsole",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1468,
    "chunk_index": 36,
    "total_chunks": 49
  },
  {
    "id": "56def70dd615459f9a689662546d4680",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "= 0, pos3 = 0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4);\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1482,
    "chunk_index": 37,
    "total_chunks": 49
  },
  {
    "id": "c43997678803a9dcefcab404947059e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1475,
    "chunk_index": 38,
    "total_chunks": 49
  },
  {
    "id": "39d3176892723651fec363c5b328be84",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "0, pos4 = 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1480,
    "chunk_index": 39,
    "total_chunks": 49
  },
  {
    "id": "3c2299d3dab945dfd47a094aabaf95b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "= 0; terrariumElementonpointerdown = pointerDrag; } dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px';\nterrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1488,
    "chunk_index": 40,
    "total_chunks": 49
  },
  {
    "id": "e53fe7722ec761ec7dafc4e41e8fb927",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "} dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyle",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1475,
    "chunk_index": 41,
    "total_chunks": 49
  },
  {
    "id": "ca9f199f7dd120a97f310565d7dfe919",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "} dragElementは、スクリプトの冒頭で宣言されたterrariumElementオブジェクトを取得します。そして、関数に渡されたオブジェクトのローカル位置を0に設定します。これらは、ドラッグ＆ドロップ機能を各要素に追加する際に操作されるローカル変数です。テラリウムはこれらのドラッグされた要素によって埋められるため、配置場所を追跡する必要があります。 さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElement",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1480,
    "chunk_index": 42,
    "total_chunks": 49
  },
  {
    "id": "d444c121567188edaa8983192cf8803d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "さらに、この関数に渡されたterrariumElementは、pointerdownイベントを割り当てられます。これは、ウェブAPIの一部で、DOM管理を支援するために設計されています。onpointerdownはボタンが押されたとき、または今回の場合はドラッグ可能な要素がタッチされたときに発火します。このイベントハンドラーは、いくつかの例外を除き、ウェブおよびモバイルブラウザの両方で動作します。 ✅ イベントハンドラーonclickは、クロスブラウザでのサポートがはるかに広範です。なぜここで使用しないのでしょうか？作成しようとしている画面インタラクションの正確なタイプを考えてみてください。 Pointerdrag関数 terrariumElementはドラッグ可能になりました。onpointerdownイベントが発火すると、pointerDrag関数が呼び出されます。この関数を次の行の下に追加します：terrariumElementonpointerdown = pointerDrag;： タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px';\n}\nこの関数では、冒頭で設定したローカル変数1～4を大幅に編集しています。ここで何が起きているのでしょうか？\nドラッグ中に、pos1をpos3（以前にe",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1409,
    "chunk_index": 43,
    "total_chunks": 49
  },
  {
    "id": "159464cf9bd9dc26ebbb39a001b6b850",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } この関数では、冒頭で設定したローカル変数1～4を大幅に編集しています。ここで何が起きているのでしょうか？ ドラッグ中に、pos1をpos3（以前にeclientXとして設定）から現在のe",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1103,
    "chunk_index": 44,
    "total_chunks": 49
  },
  {
    "id": "a0f50e5b3ff389bc7e9e212690569c44",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "タスク javascript function pointerDrag(e) { epreventDefault(); consolelog(e); pos3 = eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } この関数では、冒頭で設定したローカル変数1～4を大幅に編集しています。ここで何が起きているのでしょうか？ ドラッグ中に、pos1をpos3（以前にeclientXとして設定）から現在のeclientX値を引いたものに再割り当てします。同様の操作をpos2にも行います。その後、pos3とpos4を要素の新しいX座標とY座標にリセットします。これらの変更をドラッグ中にコンソールで確認できます。その後、植物のCSSスタイルを操作して、新しい位置に基づいて植物の位置を設定します。これは、pos1とpos2の新しい位置を比較して植物の上部と左側のX座標とY座標を計算することで行います。\noffsetTopとoffsetLeftは、親要素の位置に基づいて要素の位置を設定するCSSプロパティです。親要素はstatic以外の位置指定がされている必要があります。\nこれらの位置の再計算により、テラリウムとその植物の動作を細かく調整できます。\nタスク\nインターフェースを完成させる最後のタスクは、elementDragの閉じ中括弧の後にstopElementDrag関数を追加することです：\njavascript\nfunction stopElementDrag() {\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1447,
    "chunk_index": 45,
    "total_chunks": 49
  },
  {
    "id": "a3047b2aa39c982b8fcfb115026c06e1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "eclientX; pos4 = eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } この関数では、冒頭で設定したローカル変数1～4を大幅に編集しています。ここで何が起きているのでしょうか？ ドラッグ中に、pos1をpos3（以前にeclientXとして設定）から現在のeclientX値を引いたものに再割り当てします。同様の操作をpos2にも行います。その後、pos3とpos4を要素の新しいX座標とY座標にリセットします。これらの変更をドラッグ中にコンソールで確認できます。その後、植物のCSSスタイルを操作して、新しい位置に基づいて植物の位置を設定します。これは、pos1とpos2の新しい位置を比較して植物の上部と左側のX座標とY座標を計算することで行います。 offsetTopとoffsetLeftは、親要素の位置に基づいて要素の位置を設定するCSSプロパティです。親要素はstatic以外の位置指定がされている必要があります。 これらの位置の再計算により、テラリウムとその植物の動作を細かく調整できます。 タスク インターフェースを完成させる最後のタスクは、elementDragの閉じ中括弧の後にstopElementDrag関数を追加することです： javascript function stopElementDrag() { documentonpointerup = null;\ndocument",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1435,
    "chunk_index": 46,
    "total_chunks": 49
  },
  {
    "id": "a052a46202144032de04880660fc2df8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "eclientY; } いくつかのことが起きています。まず、epreventDefault();を使用して、pointerdown時に通常発生するデフォルトイベントを防ぎます。これにより、インターフェースの動作をより細かく制御できます。 スクリプトファイルを完全に構築した後、この行を削除してみてください。何が起きるでしょうか？ 次に、ブラウザウィンドウでindexhtmlを開き、インターフェースを検査します。植物をクリックすると、'e'イベントがどのようにキャプチャされるかがわかります。このイベントを掘り下げて、1回のpointerdownイベントでどれだけの情報が収集されるかを確認してください。 次に、ローカル変数pos3とpos4がeclientXに設定されていることに注目してください。これらの値は、クリックまたはタッチした瞬間の植物のx座標とy座標をキャプチャします。クリックしてドラッグする際の植物の動作を細かく制御する必要があるため、その座標を追跡します。 ✅ なぜこのアプリ全体が1つの大きなクロージャで構築されているのか、少しずつ明確になってきましたか？もしそうでなければ、14個のドラッグ可能な植物それぞれのスコープをどのように維持するかを考えてみてください。 この初期関数を完成させるために、pos4 = eclientYの下に2つのpointerイベント操作を追加します： html documentonpointermove = elementDrag; documentonpointerup = stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } この関数では、冒頭で設定したローカル変数1～4を大幅に編集しています。ここで何が起きているのでしょうか？ ドラッグ中に、pos1をpos3（以前にeclientXとして設定）から現在のeclientX値を引いたものに再割り当てします。同様の操作をpos2にも行います。その後、pos3とpos4を要素の新しいX座標とY座標にリセットします。これらの変更をドラッグ中にコンソールで確認できます。その後、植物のCSSスタイルを操作して、新しい位置に基づいて植物の位置を設定します。これは、pos1とpos2の新しい位置を比較して植物の上部と左側のX座標とY座標を計算することで行います。 offsetTopとoffsetLeftは、親要素の位置に基づいて要素の位置を設定するCSSプロパティです。親要素はstatic以外の位置指定がされている必要があります。 これらの位置の再計算により、テラリウムとその植物の動作を細かく調整できます。 タスク インターフェースを完成させる最後のタスクは、elementDragの閉じ中括弧の後にstopElementDrag関数を追加することです： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null;\n}\nこの小さな関数は、onpointerupとonpointermoveイベントをリセットします。これにより、植物のドラッグを再開したり、新しい植物のドラッグを開始したりできます。\n✅ これらのイベントをnullに設定しないとどうなるでしょうか？\nこれでプロジェクトが完成しました！\n🥇おめでとうございます！美しいテラリウムが完成しました。\n🚀チャレンジ\nクロージャに新しいイベントハンドラーを追加して、植物にさらに何かをさせてみましょう。たとえば、植物をダブルクリックして最前面に移動させるなどです。創造力を発揮してください！\n講義後クイズ\n講義後クイズ\n復習と自己学習\n画面上の要素をドラッグすることは一見簡単そうに見えますが、目的とする効果によってはさまざまな方法や落とし穴があります。実際、ドラッグ＆ドロップAPIというものがあり、試してみることができます。このモジュールでは、求める効果が少し異なるため使用しませんでしたが、自分のプロジェクトでこのAPIを試してみてください。\nポインターイベントに関する詳細は、W3CドキュメントやMDNウェブドキュメントで確認できます。\n常にブラウザの対応状況をCanIUse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1908,
    "chunk_index": 47,
    "total_chunks": 49
  },
  {
    "id": "ddce33c3cb8c415753b1306f39215382",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
    "source_type": "git_repo",
    "title": "テラリウムプロジェクト パート3: DOM操作とクロージャ",
    "content": "= stopElementDrag; これで、ポインタを動かすと植物が一緒にドラッグされ、植物の選択を解除するとドラッグジェスチャが停止するように指定しています。onpointermoveとonpointerupは、onpointerdownと同じAPIの一部です。インターフェースは現在エラーをスローしますが、これはまだelementDragとstopElementDrag関数を定義していないためです。次にそれらを構築します。 elementDragとstopElementDrag関数 クロージャを完成させるために、植物をドラッグしたときとドラッグを停止したときに何が起きるかを処理する2つの内部関数を追加します。目指す動作は、いつでもどの植物でもドラッグでき、画面上のどこにでも配置できることです。このインターフェースは非常に自由度が高く（ドロップゾーンなどはありません）、植物を追加、削除、再配置することでテラリウムを自由にデザインできるようにしています。 タスク pointerDragの閉じ中括弧の直後にelementDrag関数を追加します： javascript function elementDrag(e) { pos1 = pos3 - eclientX; pos2 = pos4 - eclientY; pos3 = eclientX; pos4 = eclientY; consolelog(pos1, pos2, pos3, pos4); terrariumElementstyletop = terrariumElementoffsetTop - pos2 + 'px'; terrariumElementstyleleft = terrariumElementoffsetLeft - pos1 + 'px'; } この関数では、冒頭で設定したローカル変数1～4を大幅に編集しています。ここで何が起きているのでしょうか？ ドラッグ中に、pos1をpos3（以前にeclientXとして設定）から現在のeclientX値を引いたものに再割り当てします。同様の操作をpos2にも行います。その後、pos3とpos4を要素の新しいX座標とY座標にリセットします。これらの変更をドラッグ中にコンソールで確認できます。その後、植物のCSSスタイルを操作して、新しい位置に基づいて植物の位置を設定します。これは、pos1とpos2の新しい位置を比較して植物の上部と左側のX座標とY座標を計算することで行います。 offsetTopとoffsetLeftは、親要素の位置に基づいて要素の位置を設定するCSSプロパティです。親要素はstatic以外の位置指定がされている必要があります。 これらの位置の再計算により、テラリウムとその植物の動作を細かく調整できます。 タスク インターフェースを完成させる最後のタスクは、elementDragの閉じ中括弧の後にstopElementDrag関数を追加することです： javascript function stopElementDrag() { documentonpointerup = null; documentonpointermove = null; } この小さな関数は、onpointerupとonpointermoveイベントをリセットします。これにより、植物のドラッグを再開したり、新しい植物のドラッグを開始したりできます。 ✅ これらのイベントをnullに設定しないとどうなるでしょうか？ これでプロジェクトが完成しました！ 🥇おめでとうございます！美しいテラリウムが完成しました。 🚀チャレンジ クロージャに新しいイベントハンドラーを追加して、植物にさらに何かをさせてみましょう。たとえば、植物をダブルクリックして最前面に移動させるなどです。創造力を発揮してください！ 講義後クイズ 講義後クイズ 復習と自己学習 画面上の要素をドラッグすることは一見簡単そうに見えますが、目的とする効果によってはさまざまな方法や落とし穴があります。実際、ドラッグ＆ドロップAPIというものがあり、試してみることができます。このモジュールでは、求める効果が少し異なるため使用しませんでしたが、自分のプロジェクトでこのAPIを試してみてください。 ポインターイベントに関する詳細は、W3CドキュメントやMDNウェブドキュメントで確認できます。 常にブラウザの対応状況をCanIUsecomで確認してください。\n課題\nDOMを使ったさらなる作業\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知おきください。元の言語で記載された文書が公式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤認について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16290,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\3-terrarium\\3-intro-to-DOM-and-closures\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1599,
    "chunk_index": 48,
    "total_chunks": 49
  },
  {
    "id": "9bb46aa76c0f872a12246daf75c2ed2a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\README.md",
    "source_type": "git_repo",
    "title": "網頁開發入門",
    "content": "網頁開發入門\n在本課程部分，你將會學習一些非專案基礎的重要概念，這些概念對成為專業開發者至關重要。\n主題\n程式語言與工具入門\nGitHub 基礎介紹\n無障礙設計基礎\n致謝\n程式語言與工具入門由 Jasmine Greenaway 用 ♥️ 撰寫\nGitHub 基礎介紹由 Floor Drees 用 ♥️ 撰寫\n無障礙設計基礎由 Christopher Harrison 用 ♥️ 撰寫\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1322,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\1-getting-started-lessons\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 371,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "80469ccd36e592fe4a5f4578c162f123",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\README.md",
    "source_type": "git_repo",
    "title": "JavaScript 簡介",
    "content": "JavaScript 簡介\nJavaScript 是網絡的語言。在這四節課中，你將學習它的基礎知識。\n主題\n變數和數據類型\n函數和方法\n使用 JavaScript 作出決策\n陣列和迴圈\n致謝\n這些課程由 Jasmine Greenaway、Christopher Harrison 和 Chris Noring 用 ♥️ 編寫。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1229,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\2-js-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 305,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "61f71be3439097a42332627ca677e61f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\README.md",
    "source_type": "git_repo",
    "title": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的項目 🌵🌱",
    "content": "我的微型植物園：一個學習 HTML、CSS 和使用 JavaScript 操控 DOM 的項目 🌵🌱\n一個小型的拖放式程式冥想。只需少量的 HTML、JS 和 CSS，你就能建立一個網頁介面，為其設計樣式，甚至添加多種互動功能。\n課程\nHTML 入門\nCSS 入門\nDOM 和 JS 閉包入門\n致謝\n由 Jen Looper 用 ♥️ 編寫。\n透過 CSS 創建的微型植物園靈感來自 Jakub Mandra 的玻璃罐 codepen。\n藝術作品由 Jen Looper 手繪，並使用 Procreate 協助完成。\n部署你的微型植物園\n你可以使用 Azure 靜態網頁應用程式將你的微型植物園部署或發布到網絡上。\nFork 此倉庫\n按下這個按鈕\n按照向導步驟創建你的應用程式。請確保將應用程式根目錄設置為 /solution 或你的代碼庫根目錄。此應用程式中沒有 API，因此不需要添加相關內容。一個 GitHub 文件夾將會在你 Fork 的倉庫中創建，幫助 Azure 靜態網頁應用程式的構建服務，構建並發布你的應用程式到一個新的 URL。\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2221,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\3-terrarium\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 644,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "8390d035bbe27448acfa377b65ff23ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\README.md",
    "source_type": "git_repo",
    "title": "事件驅動編程 - 建立一個打字遊戲",
    "content": "事件驅動編程 - 建立一個打字遊戲\n簡介\n打字是開發者最被低估的技能之一。能夠快速將腦海中的想法轉移到編輯器中，能讓創意自由流動。學習的最佳方式之一就是玩遊戲！\n那麼，讓我們來建立一個打字遊戲吧！\n你將使用迄今為止學到的 JavaScript、HTML 和 CSS 技能來創建一個打字遊戲。遊戲會向玩家展示一段隨機的名言（我們使用的是 福爾摩斯 的名言），並計算玩家準確輸入這段文字所需的時間。你將使用迄今為止學到的 JavaScript、HTML 和 CSS 技能來創建一個打字遊戲。\n先決條件\n本課假設你已熟悉以下概念：\n創建文字輸入框和按鈕控件\nCSS 和使用類別設置樣式\nJavaScript 基礎\n創建數組\n生成隨機數\n獲取當前時間\n課程\n使用事件驅動編程創建打字遊戲\n致謝\n由 Christopher Harrison 用 ♥️ 編寫\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1795,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\4-typing-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 591,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "023050f65a8ae01f57761e9439aca697",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\README.md",
    "source_type": "git_repo",
    "title": "建立瀏覽器擴充功能",
    "content": "建立瀏覽器擴充功能\n建立瀏覽器擴充功能是一種有趣且新穎的方式，可以在開發不同類型的網頁資產時，思考應用程式的效能。本模組包含有關瀏覽器運作方式以及如何部署瀏覽器擴充功能的課程，還有如何建立表單、呼叫 API、使用本地存儲，以及如何評估網站效能並進行改進。\n你將建立一個可在 Edge、Chrome 和 Firefox 上運作的瀏覽器擴充功能。這個擴充功能類似於一個專門針對特定任務的小型網站，它會檢查 C02 Signal API 以了解指定地區的電力使用情況和碳強度，並返回該地區的碳足跡讀數。\n使用者可以在輸入 API 金鑰和地區代碼到表單後，隨時呼叫此擴充功能，以確定當地的電力使用情況，從而提供數據來影響使用者的電力決策。例如，在地區電力使用量高的時段，可能更適合延遲使用衣物烘乾機（屬於高碳排活動）。\n主題\n關於瀏覽器\n表單與本地存儲\n背景任務與效能\n致謝\n致謝\n這個網頁碳觸發器的想法由 Microsoft 的綠色雲倡導團隊負責人 Asim Hussain 提供，他也是 Green Principles 的作者。最初它是一個 網站專案。\n瀏覽器擴充功能的結構受到 Adebola Adeniran 的 COVID 擴充功能 的影響。\n「點」圖標系統的概念則受到 Energy Lollipop 瀏覽器擴充功能（針對加州排放）的圖標結構啟發。\n這些課程由 Jen Looper 用 ♥️ 編寫。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2646,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\5-browser-extension\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 861,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "d2ed50a93f4b5ede0a9b2f3f41aa679c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲",
    "content": "建造太空遊戲\n一個教導更高級 JavaScript 基礎的太空遊戲\n在這節課中，你將學習如何建立自己的太空遊戲。如果你曾玩過「Space Invaders」這款遊戲，這款遊戲的概念與其相似：操控一艘太空船並射擊從上方降下的怪物。以下是完成後的遊戲樣子：\n在這六節課中，你將學到以下內容：\n互動 Canvas 元素以在螢幕上繪製物件\n理解 笛卡爾座標系統\n學習 Pub-Sub 模式以建立更易於維護和擴展的遊戲架構\n運用 Async/Await 來載入遊戲資源\n處理 鍵盤事件\n概覽\n理論\n使用 JavaScript 建造遊戲的介紹\n實踐\n在 Canvas 上繪製\n在螢幕上移動元素\n碰撞檢測\n計分\n結束並重新開始遊戲\n致謝\n本遊戲使用的資源來自 https://www kenney",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1920,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 388,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "5b01056fb153563f38480c1a65868404",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\README.md",
    "source_type": "git_repo",
    "title": "建造太空遊戲",
    "content": "建造太空遊戲\n一個教導更高級 JavaScript 基礎的太空遊戲\n在這節課中，你將學習如何建立自己的太空遊戲。如果你曾玩過「Space Invaders」這款遊戲，這款遊戲的概念與其相似：操控一艘太空船並射擊從上方降下的怪物。以下是完成後的遊戲樣子：\n在這六節課中，你將學到以下內容：\n互動 Canvas 元素以在螢幕上繪製物件\n理解 笛卡爾座標系統\n學習 Pub-Sub 模式以建立更易於維護和擴展的遊戲架構\n運用 Async/Await 來載入遊戲資源\n處理 鍵盤事件\n概覽\n理論\n使用 JavaScript 建造遊戲的介紹\n實踐\n在 Canvas 上繪製\n在螢幕上移動元素\n碰撞檢測\n計分\n結束並重新開始遊戲\n致謝\n本遊戲使用的資源來自 https://www kenneynl/。\n如果你對製作遊戲感興趣，這裡有非常棒的資源，許多是免費的，也有一些是付費的。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1920,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 619,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "ad4173cad3a14c992656dcd5d231b2b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "アクセシブルなウェブページの作成",
    "content": "アクセシブルなウェブページの作成\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nウェブの力はその普遍性にあります。障害の有無にかかわらず、誰もがアクセスできることが重要です。\n- Sir Timothy Berners-Lee, W3Cディレクター、ワールドワイドウェブの発明者\nこの引用は、アクセシブルなウェブサイトを作成する重要性を完璧に強調しています。すべての人がアクセスできないアプリケーションは、定義上排他的です。ウェブ開発者として、常にアクセシビリティを念頭に置くべきです。最初からこの点に焦点を当てることで、作成するページがすべての人にアクセス可能であることを確保する道を進むことができます。このレッスンでは、ウェブ資産がアクセシブルであることを確認するためのツールと、アクセシビリティを考慮して構築する方法について学びます。\nこのレッスンはMicrosoft Learnで受講できます！\n使用するツール\nスクリーンリーダー\n最もよく知られているアクセシビリティツールの1つがスクリーンリーダーです。\nスクリーンリーダーは、視覚障害のある人々がよく使用するクライアントです。ブラウザが共有したい情報を適切に伝えるようにするのと同様に、スクリーンリーダーが同じように情報を伝えることを確認する必要があります。\nスクリーンリーダーの基本的な機能は、ページを上から下まで音声で読み上げることです。ページがすべてテキストで構成されている場合、リーダーはブラウザと同様に情報を伝えます。しかし、ウェブページは純粋にテキストだけで構成されることはほとんどありません。リンク、グラフィック、色、その他の視覚的要素が含まれることが一般的です。これらの情報がスクリーンリーダーによって正しく読み取られるように注意を払う必要があります。\nすべてのウェブ開発者はスクリーンリーダーに慣れるべきです。上記で強調したように、それはユーザーが利用するクライアントです。ブラウザの操作方法に慣れているのと同じように、スクリーンリーダーの操作方法を学ぶべきです。幸いなことに、ほとんどのオペレーティングシステムにはスクリーンリーダーが組み込まれています。\n一部のブラウザには、テキストを音声で読み上げたり、基本的なナビゲーション機能を提供するアクセシビリティツールが組み込まれている場合があります。例えば、Edgeブラウザのアクセシビリティツールなどです。これらも重要なアクセシビリティツールですが、スクリーンリーダーとは異なる機能を持ち、スクリーンリーダーのテストツールとして誤解してはいけません。\n✅ スクリーンリーダーとブラウザのテキストリーダーを試してみましょう。Windowsではナレーターがデフォルトで含まれており、JAWSやNVDAもインストール可能です。macOSやiOSではVoiceOverがデフォルトでインストールされています。\nズーム\n視覚障害のある人々がよく使用するもう1つのツールがズーム機能です。最も基本的なズームは静的ズームで、Control + プラス記号 (+)を使用するか、画面解像度を下げることで制御されます。このタイプのズームはページ全体をリサイズするため、レスポンシブデザインを使用して、ズームレベルが高い場合でも良好なユーザー体験を提供することが重要です。\nもう1つのタイプのズームは、特定の画面領域を拡大してパンする特殊なソフトウェアを使用するもので、実際の拡大鏡を使用するようなものです。Windowsでは拡大鏡が組み込まれており、ZoomTextはより多くの機能を持つサードパーティ製の拡大ソフトウェアです。macOSやiOSにはZoomという拡大ソフトウェアが組み込まれています。\nコントラストチェッカー\nウェブサイトの色は、色覚異常のあるユーザーや低コントラストの色が見づらい人々のニーズに応えるよう慎重に選ぶ必要があります。\n✅ お気に入りのウェブサイトをブラウザ拡張機能（例: WCAGのコントラストチェッカー）で色の使用をテストしてみましょう。何が学べますか？\nLighthouse\nブラウザの開発者ツールエリアにはLighthouseツールがあります。このツールは、ウェブサイトのアクセシビリティ（およびその他の分析）を初めて確認するために重要です。Lighthouseだけに頼るべきではありませんが、100%のスコアは基準として非常に役立ちます。\n✅ ブラウザの開発者ツールパネルでLighthouseを見つけ、任意のサイトを分析してみましょう。何がわかりますか？\nアクセシビリティを考慮したデザイン\nアクセシビリティは比較的大きなトピックです。役立つリソースが多数あります。\nAccessible U - ミネソタ大学\nすべてのアクセシブルなサイト作成の側面をカバーすることはできませんが、以下は実装したい重要な原則の一部です。最初からアクセシブルなページを設計することは、既存のページを後からアクセシブルにするよりも常に簡単です。\n良い表示の原則\n色の安全なパレット\n人々は世界をさまざまな方法で見ていますが、これには色も含まれます。サイトのカラースキームを選択する際には、すべての人にとってアクセシブルであることを確認する必要があります。優れたカラーパレット生成ツールはColor Safeです。\n✅ 色の使用が非常に問題のあるウェブサイトを特定してください。なぜ問題なのでしょうか？\n正しいHTMLを使用する\nCSSやJavaScriptを使用すると、任意の要素を任意のタイプのコントロールのように見せることができます。例えば、<span>を使用して<button>を作成したり、<b>を使用してハイパーリンクを作成することが可能です。しかし、これではスクリーンリーダーに何も伝えられません。ページ上のコントロールを作成する際には適切なHTMLを使用してください。ハイパーリンクを作成したい場合は<a>を使用してください。適切なHTMLを使用することは、セマンティックHTMLを活用することと呼ばれます。\n✅ 任意のウェブサイトにアクセスし、デザイナーや開発者がHTMLを正しく使用しているか確認してください。リンクであるべきボタンを見つけることができますか？ヒント: ブラウザで右クリックして「ページのソースを表示」を選択し、基礎となるコードを確認してください。\n説明的な見出し階層を作成する\nスクリーンリーダーのユーザーは、見出しに大きく依存しています。情報を見つけたり、ページをナビゲートしたりするためです。説明的な見出しコンテンツを作成し、セマンティックな見出しタグを使用することは、スクリーンリーダーのユーザーにとって簡単にナビゲート可能なサイトを作成するために重要です。\n良い視覚的手がかりを使用する\nCSSはページ上の任意の要素の外観を完全に制御できます。アウトラインのないテキストボックスや下線のないハイパーリンクを作成することが可能です。しかし、これらの手がかりを削除すると、それに依存する人々がコントロールの種類を認識するのが難しくなる可能性があります。\nリンクテキストの重要性\nハイパーリンクはウェブをナビゲートするための中心的な要素です。そのため、スクリーンリーダーがリンクを適切に読み取れるようにすることで、すべてのユーザーがサイトをナビゲートできるようになります。\nスクリーンリーダーとリンク\n予想通り、スクリーンリーダーはリンクテキストをページ上の他のテキストと同じように読み取ります。この点を考慮すると、以下のようなテキストは完全に許容されるように感じるかもしれません。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。こちらをクリックして詳細をご覧ください。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。詳細についてはhttps://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18945,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 3057,
    "chunk_index": 0,
    "total_chunks": 4
  },
  {
    "id": "d509e7c333780fd229b9e6b86d30236d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "アクセシブルなウェブページの作成",
    "content": "アクセシブルなウェブページの作成\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nウェブの力はその普遍性にあります。障害の有無にかかわらず、誰もがアクセスできることが重要です。\n- Sir Timothy Berners-Lee, W3Cディレクター、ワールドワイドウェブの発明者\nこの引用は、アクセシブルなウェブサイトを作成する重要性を完璧に強調しています。すべての人がアクセスできないアプリケーションは、定義上排他的です。ウェブ開発者として、常にアクセシビリティを念頭に置くべきです。最初からこの点に焦点を当てることで、作成するページがすべての人にアクセス可能であることを確保する道を進むことができます。このレッスンでは、ウェブ資産がアクセシブルであることを確認するためのツールと、アクセシビリティを考慮して構築する方法について学びます。\nこのレッスンはMicrosoft Learnで受講できます！\n使用するツール\nスクリーンリーダー\n最もよく知られているアクセシビリティツールの1つがスクリーンリーダーです。\nスクリーンリーダーは、視覚障害のある人々がよく使用するクライアントです。ブラウザが共有したい情報を適切に伝えるようにするのと同様に、スクリーンリーダーが同じように情報を伝えることを確認する必要があります。\nスクリーンリーダーの基本的な機能は、ページを上から下まで音声で読み上げることです。ページがすべてテキストで構成されている場合、リーダーはブラウザと同様に情報を伝えます。しかし、ウェブページは純粋にテキストだけで構成されることはほとんどありません。リンク、グラフィック、色、その他の視覚的要素が含まれることが一般的です。これらの情報がスクリーンリーダーによって正しく読み取られるように注意を払う必要があります。\nすべてのウェブ開発者はスクリーンリーダーに慣れるべきです。上記で強調したように、それはユーザーが利用するクライアントです。ブラウザの操作方法に慣れているのと同じように、スクリーンリーダーの操作方法を学ぶべきです。幸いなことに、ほとんどのオペレーティングシステムにはスクリーンリーダーが組み込まれています。\n一部のブラウザには、テキストを音声で読み上げたり、基本的なナビゲーション機能を提供するアクセシビリティツールが組み込まれている場合があります。例えば、Edgeブラウザのアクセシビリティツールなどです。これらも重要なアクセシビリティツールですが、スクリーンリーダーとは異なる機能を持ち、スクリーンリーダーのテストツールとして誤解してはいけません。\n✅ スクリーンリーダーとブラウザのテキストリーダーを試してみましょう。Windowsではナレーターがデフォルトで含まれており、JAWSやNVDAもインストール可能です。macOSやiOSではVoiceOverがデフォルトでインストールされています。\nズーム\n視覚障害のある人々がよく使用するもう1つのツールがズーム機能です。最も基本的なズームは静的ズームで、Control + プラス記号 (+)を使用するか、画面解像度を下げることで制御されます。このタイプのズームはページ全体をリサイズするため、レスポンシブデザインを使用して、ズームレベルが高い場合でも良好なユーザー体験を提供することが重要です。\nもう1つのタイプのズームは、特定の画面領域を拡大してパンする特殊なソフトウェアを使用するもので、実際の拡大鏡を使用するようなものです。Windowsでは拡大鏡が組み込まれており、ZoomTextはより多くの機能を持つサードパーティ製の拡大ソフトウェアです。macOSやiOSにはZoomという拡大ソフトウェアが組み込まれています。\nコントラストチェッカー\nウェブサイトの色は、色覚異常のあるユーザーや低コントラストの色が見づらい人々のニーズに応えるよう慎重に選ぶ必要があります。\n✅ お気に入りのウェブサイトをブラウザ拡張機能（例: WCAGのコントラストチェッカー）で色の使用をテストしてみましょう。何が学べますか？\nLighthouse\nブラウザの開発者ツールエリアにはLighthouseツールがあります。このツールは、ウェブサイトのアクセシビリティ（およびその他の分析）を初めて確認するために重要です。Lighthouseだけに頼るべきではありませんが、100%のスコアは基準として非常に役立ちます。\n✅ ブラウザの開発者ツールパネルでLighthouseを見つけ、任意のサイトを分析してみましょう。何がわかりますか？\nアクセシビリティを考慮したデザイン\nアクセシビリティは比較的大きなトピックです。役立つリソースが多数あります。\nAccessible U - ミネソタ大学\nすべてのアクセシブルなサイト作成の側面をカバーすることはできませんが、以下は実装したい重要な原則の一部です。最初からアクセシブルなページを設計することは、既存のページを後からアクセシブルにするよりも常に簡単です。\n良い表示の原則\n色の安全なパレット\n人々は世界をさまざまな方法で見ていますが、これには色も含まれます。サイトのカラースキームを選択する際には、すべての人にとってアクセシブルであることを確認する必要があります。優れたカラーパレット生成ツールはColor Safeです。\n✅ 色の使用が非常に問題のあるウェブサイトを特定してください。なぜ問題なのでしょうか？\n正しいHTMLを使用する\nCSSやJavaScriptを使用すると、任意の要素を任意のタイプのコントロールのように見せることができます。例えば、<span>を使用して<button>を作成したり、<b>を使用してハイパーリンクを作成することが可能です。しかし、これではスクリーンリーダーに何も伝えられません。ページ上のコントロールを作成する際には適切なHTMLを使用してください。ハイパーリンクを作成したい場合は<a>を使用してください。適切なHTMLを使用することは、セマンティックHTMLを活用することと呼ばれます。\n✅ 任意のウェブサイトにアクセスし、デザイナーや開発者がHTMLを正しく使用しているか確認してください。リンクであるべきボタンを見つけることができますか？ヒント: ブラウザで右クリックして「ページのソースを表示」を選択し、基礎となるコードを確認してください。\n説明的な見出し階層を作成する\nスクリーンリーダーのユーザーは、見出しに大きく依存しています。情報を見つけたり、ページをナビゲートしたりするためです。説明的な見出しコンテンツを作成し、セマンティックな見出しタグを使用することは、スクリーンリーダーのユーザーにとって簡単にナビゲート可能なサイトを作成するために重要です。\n良い視覚的手がかりを使用する\nCSSはページ上の任意の要素の外観を完全に制御できます。アウトラインのないテキストボックスや下線のないハイパーリンクを作成することが可能です。しかし、これらの手がかりを削除すると、それに依存する人々がコントロールの種類を認識するのが難しくなる可能性があります。\nリンクテキストの重要性\nハイパーリンクはウェブをナビゲートするための中心的な要素です。そのため、スクリーンリーダーがリンクを適切に読み取れるようにすることで、すべてのユーザーがサイトをナビゲートできるようになります。\nスクリーンリーダーとリンク\n予想通り、スクリーンリーダーはリンクテキストをページ上の他のテキストと同じように読み取ります。この点を考慮すると、以下のようなテキストは完全に許容されるように感じるかもしれません。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。こちらをクリックして詳細をご覧ください。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。詳細についてはhttps://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18945,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 3059,
    "chunk_index": 1,
    "total_chunks": 4
  },
  {
    "id": "95afa8eef9e95b71f0ae5227dc84e276",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "アクセシブルなウェブページの作成",
    "content": "アクセシブルなウェブページの作成\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nウェブの力はその普遍性にあります。障害の有無にかかわらず、誰もがアクセスできることが重要です。\n- Sir Timothy Berners-Lee, W3Cディレクター、ワールドワイドウェブの発明者\nこの引用は、アクセシブルなウェブサイトを作成する重要性を完璧に強調しています。すべての人がアクセスできないアプリケーションは、定義上排他的です。ウェブ開発者として、常にアクセシビリティを念頭に置くべきです。最初からこの点に焦点を当てることで、作成するページがすべての人にアクセス可能であることを確保する道を進むことができます。このレッスンでは、ウェブ資産がアクセシブルであることを確認するためのツールと、アクセシビリティを考慮して構築する方法について学びます。\nこのレッスンはMicrosoft Learnで受講できます！\n使用するツール\nスクリーンリーダー\n最もよく知られているアクセシビリティツールの1つがスクリーンリーダーです。\nスクリーンリーダーは、視覚障害のある人々がよく使用するクライアントです。ブラウザが共有したい情報を適切に伝えるようにするのと同様に、スクリーンリーダーが同じように情報を伝えることを確認する必要があります。\nスクリーンリーダーの基本的な機能は、ページを上から下まで音声で読み上げることです。ページがすべてテキストで構成されている場合、リーダーはブラウザと同様に情報を伝えます。しかし、ウェブページは純粋にテキストだけで構成されることはほとんどありません。リンク、グラフィック、色、その他の視覚的要素が含まれることが一般的です。これらの情報がスクリーンリーダーによって正しく読み取られるように注意を払う必要があります。\nすべてのウェブ開発者はスクリーンリーダーに慣れるべきです。上記で強調したように、それはユーザーが利用するクライアントです。ブラウザの操作方法に慣れているのと同じように、スクリーンリーダーの操作方法を学ぶべきです。幸いなことに、ほとんどのオペレーティングシステムにはスクリーンリーダーが組み込まれています。\n一部のブラウザには、テキストを音声で読み上げたり、基本的なナビゲーション機能を提供するアクセシビリティツールが組み込まれている場合があります。例えば、Edgeブラウザのアクセシビリティツールなどです。これらも重要なアクセシビリティツールですが、スクリーンリーダーとは異なる機能を持ち、スクリーンリーダーのテストツールとして誤解してはいけません。\n✅ スクリーンリーダーとブラウザのテキストリーダーを試してみましょう。Windowsではナレーターがデフォルトで含まれており、JAWSやNVDAもインストール可能です。macOSやiOSではVoiceOverがデフォルトでインストールされています。\nズーム\n視覚障害のある人々がよく使用するもう1つのツールがズーム機能です。最も基本的なズームは静的ズームで、Control + プラス記号 (+)を使用するか、画面解像度を下げることで制御されます。このタイプのズームはページ全体をリサイズするため、レスポンシブデザインを使用して、ズームレベルが高い場合でも良好なユーザー体験を提供することが重要です。\nもう1つのタイプのズームは、特定の画面領域を拡大してパンする特殊なソフトウェアを使用するもので、実際の拡大鏡を使用するようなものです。Windowsでは拡大鏡が組み込まれており、ZoomTextはより多くの機能を持つサードパーティ製の拡大ソフトウェアです。macOSやiOSにはZoomという拡大ソフトウェアが組み込まれています。\nコントラストチェッカー\nウェブサイトの色は、色覚異常のあるユーザーや低コントラストの色が見づらい人々のニーズに応えるよう慎重に選ぶ必要があります。\n✅ お気に入りのウェブサイトをブラウザ拡張機能（例: WCAGのコントラストチェッカー）で色の使用をテストしてみましょう。何が学べますか？\nLighthouse\nブラウザの開発者ツールエリアにはLighthouseツールがあります。このツールは、ウェブサイトのアクセシビリティ（およびその他の分析）を初めて確認するために重要です。Lighthouseだけに頼るべきではありませんが、100%のスコアは基準として非常に役立ちます。\n✅ ブラウザの開発者ツールパネルでLighthouseを見つけ、任意のサイトを分析してみましょう。何がわかりますか？\nアクセシビリティを考慮したデザイン\nアクセシビリティは比較的大きなトピックです。役立つリソースが多数あります。\nAccessible U - ミネソタ大学\nすべてのアクセシブルなサイト作成の側面をカバーすることはできませんが、以下は実装したい重要な原則の一部です。最初からアクセシブルなページを設計することは、既存のページを後からアクセシブルにするよりも常に簡単です。\n良い表示の原則\n色の安全なパレット\n人々は世界をさまざまな方法で見ていますが、これには色も含まれます。サイトのカラースキームを選択する際には、すべての人にとってアクセシブルであることを確認する必要があります。優れたカラーパレット生成ツールはColor Safeです。\n✅ 色の使用が非常に問題のあるウェブサイトを特定してください。なぜ問題なのでしょうか？\n正しいHTMLを使用する\nCSSやJavaScriptを使用すると、任意の要素を任意のタイプのコントロールのように見せることができます。例えば、<span>を使用して<button>を作成したり、<b>を使用してハイパーリンクを作成することが可能です。しかし、これではスクリーンリーダーに何も伝えられません。ページ上のコントロールを作成する際には適切なHTMLを使用してください。ハイパーリンクを作成したい場合は<a>を使用してください。適切なHTMLを使用することは、セマンティックHTMLを活用することと呼ばれます。\n✅ 任意のウェブサイトにアクセスし、デザイナーや開発者がHTMLを正しく使用しているか確認してください。リンクであるべきボタンを見つけることができますか？ヒント: ブラウザで右クリックして「ページのソースを表示」を選択し、基礎となるコードを確認してください。\n説明的な見出し階層を作成する\nスクリーンリーダーのユーザーは、見出しに大きく依存しています。情報を見つけたり、ページをナビゲートしたりするためです。説明的な見出しコンテンツを作成し、セマンティックな見出しタグを使用することは、スクリーンリーダーのユーザーにとって簡単にナビゲート可能なサイトを作成するために重要です。\n良い視覚的手がかりを使用する\nCSSはページ上の任意の要素の外観を完全に制御できます。アウトラインのないテキストボックスや下線のないハイパーリンクを作成することが可能です。しかし、これらの手がかりを削除すると、それに依存する人々がコントロールの種類を認識するのが難しくなる可能性があります。\nリンクテキストの重要性\nハイパーリンクはウェブをナビゲートするための中心的な要素です。そのため、スクリーンリーダーがリンクを適切に読み取れるようにすることで、すべてのユーザーがサイトをナビゲートできるようになります。\nスクリーンリーダーとリンク\n予想通り、スクリーンリーダーはリンクテキストをページ上の他のテキストと同じように読み取ります。この点を考慮すると、以下のようなテキストは完全に許容されるように感じるかもしれません。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。こちらをクリックして詳細をご覧ください。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。詳細についてはhttps://enwikipediaorg/wiki/Little_penguinをご覧ください。\nNOTE 以下で説明するように、上記のようなリンクを絶対に作成してはいけません。\nスクリーンリーダーはブラウザとは異なるインターフェースであり、異なる機能セットを持っています。\nURLを使用する問題点\nスクリーンリーダーはテキストを読み取ります。テキストにURLが含まれている場合、スクリーンリーダーはURLを読み上げます。一般的に、URLは意味のある情報を伝えず、煩わしく聞こえることがあります。携帯電話がテキストメッセージ内のURLを音声で読み上げた経験があるかもしれません。\n「こちらをクリック」の問題点\nスクリーンリーダーはページ上のハイパーリンクのみを読み取る機能も持っています。視覚的なユーザーがページをスキャンしてリンクを探すのと同じようにです。リンクテキストがすべて「こちらをクリック」である場合、ユーザーは「こちらをクリック、こちらをクリック、こちらをクリック、こちらをクリック、こちらをクリック、",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18945,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 3461,
    "chunk_index": 2,
    "total_chunks": 4
  },
  {
    "id": "4de37f285ec38380cbcce7f02857e520",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
    "source_type": "git_repo",
    "title": "アクセシブルなウェブページの作成",
    "content": "アクセシブルなウェブページの作成\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nウェブの力はその普遍性にあります。障害の有無にかかわらず、誰もがアクセスできることが重要です。\n- Sir Timothy Berners-Lee, W3Cディレクター、ワールドワイドウェブの発明者\nこの引用は、アクセシブルなウェブサイトを作成する重要性を完璧に強調しています。すべての人がアクセスできないアプリケーションは、定義上排他的です。ウェブ開発者として、常にアクセシビリティを念頭に置くべきです。最初からこの点に焦点を当てることで、作成するページがすべての人にアクセス可能であることを確保する道を進むことができます。このレッスンでは、ウェブ資産がアクセシブルであることを確認するためのツールと、アクセシビリティを考慮して構築する方法について学びます。\nこのレッスンはMicrosoft Learnで受講できます！\n使用するツール\nスクリーンリーダー\n最もよく知られているアクセシビリティツールの1つがスクリーンリーダーです。\nスクリーンリーダーは、視覚障害のある人々がよく使用するクライアントです。ブラウザが共有したい情報を適切に伝えるようにするのと同様に、スクリーンリーダーが同じように情報を伝えることを確認する必要があります。\nスクリーンリーダーの基本的な機能は、ページを上から下まで音声で読み上げることです。ページがすべてテキストで構成されている場合、リーダーはブラウザと同様に情報を伝えます。しかし、ウェブページは純粋にテキストだけで構成されることはほとんどありません。リンク、グラフィック、色、その他の視覚的要素が含まれることが一般的です。これらの情報がスクリーンリーダーによって正しく読み取られるように注意を払う必要があります。\nすべてのウェブ開発者はスクリーンリーダーに慣れるべきです。上記で強調したように、それはユーザーが利用するクライアントです。ブラウザの操作方法に慣れているのと同じように、スクリーンリーダーの操作方法を学ぶべきです。幸いなことに、ほとんどのオペレーティングシステムにはスクリーンリーダーが組み込まれています。\n一部のブラウザには、テキストを音声で読み上げたり、基本的なナビゲーション機能を提供するアクセシビリティツールが組み込まれている場合があります。例えば、Edgeブラウザのアクセシビリティツールなどです。これらも重要なアクセシビリティツールですが、スクリーンリーダーとは異なる機能を持ち、スクリーンリーダーのテストツールとして誤解してはいけません。\n✅ スクリーンリーダーとブラウザのテキストリーダーを試してみましょう。Windowsではナレーターがデフォルトで含まれており、JAWSやNVDAもインストール可能です。macOSやiOSではVoiceOverがデフォルトでインストールされています。\nズーム\n視覚障害のある人々がよく使用するもう1つのツールがズーム機能です。最も基本的なズームは静的ズームで、Control + プラス記号 (+)を使用するか、画面解像度を下げることで制御されます。このタイプのズームはページ全体をリサイズするため、レスポンシブデザインを使用して、ズームレベルが高い場合でも良好なユーザー体験を提供することが重要です。\nもう1つのタイプのズームは、特定の画面領域を拡大してパンする特殊なソフトウェアを使用するもので、実際の拡大鏡を使用するようなものです。Windowsでは拡大鏡が組み込まれており、ZoomTextはより多くの機能を持つサードパーティ製の拡大ソフトウェアです。macOSやiOSにはZoomという拡大ソフトウェアが組み込まれています。\nコントラストチェッカー\nウェブサイトの色は、色覚異常のあるユーザーや低コントラストの色が見づらい人々のニーズに応えるよう慎重に選ぶ必要があります。\n✅ お気に入りのウェブサイトをブラウザ拡張機能（例: WCAGのコントラストチェッカー）で色の使用をテストしてみましょう。何が学べますか？\nLighthouse\nブラウザの開発者ツールエリアにはLighthouseツールがあります。このツールは、ウェブサイトのアクセシビリティ（およびその他の分析）を初めて確認するために重要です。Lighthouseだけに頼るべきではありませんが、100%のスコアは基準として非常に役立ちます。\n✅ ブラウザの開発者ツールパネルでLighthouseを見つけ、任意のサイトを分析してみましょう。何がわかりますか？\nアクセシビリティを考慮したデザイン\nアクセシビリティは比較的大きなトピックです。役立つリソースが多数あります。\nAccessible U - ミネソタ大学\nすべてのアクセシブルなサイト作成の側面をカバーすることはできませんが、以下は実装したい重要な原則の一部です。最初からアクセシブルなページを設計することは、既存のページを後からアクセシブルにするよりも常に簡単です。\n良い表示の原則\n色の安全なパレット\n人々は世界をさまざまな方法で見ていますが、これには色も含まれます。サイトのカラースキームを選択する際には、すべての人にとってアクセシブルであることを確認する必要があります。優れたカラーパレット生成ツールはColor Safeです。\n✅ 色の使用が非常に問題のあるウェブサイトを特定してください。なぜ問題なのでしょうか？\n正しいHTMLを使用する\nCSSやJavaScriptを使用すると、任意の要素を任意のタイプのコントロールのように見せることができます。例えば、<span>を使用して<button>を作成したり、<b>を使用してハイパーリンクを作成することが可能です。しかし、これではスクリーンリーダーに何も伝えられません。ページ上のコントロールを作成する際には適切なHTMLを使用してください。ハイパーリンクを作成したい場合は<a>を使用してください。適切なHTMLを使用することは、セマンティックHTMLを活用することと呼ばれます。\n✅ 任意のウェブサイトにアクセスし、デザイナーや開発者がHTMLを正しく使用しているか確認してください。リンクであるべきボタンを見つけることができますか？ヒント: ブラウザで右クリックして「ページのソースを表示」を選択し、基礎となるコードを確認してください。\n説明的な見出し階層を作成する\nスクリーンリーダーのユーザーは、見出しに大きく依存しています。情報を見つけたり、ページをナビゲートしたりするためです。説明的な見出しコンテンツを作成し、セマンティックな見出しタグを使用することは、スクリーンリーダーのユーザーにとって簡単にナビゲート可能なサイトを作成するために重要です。\n良い視覚的手がかりを使用する\nCSSはページ上の任意の要素の外観を完全に制御できます。アウトラインのないテキストボックスや下線のないハイパーリンクを作成することが可能です。しかし、これらの手がかりを削除すると、それに依存する人々がコントロールの種類を認識するのが難しくなる可能性があります。\nリンクテキストの重要性\nハイパーリンクはウェブをナビゲートするための中心的な要素です。そのため、スクリーンリーダーがリンクを適切に読み取れるようにすることで、すべてのユーザーがサイトをナビゲートできるようになります。\nスクリーンリーダーとリンク\n予想通り、スクリーンリーダーはリンクテキストをページ上の他のテキストと同じように読み取ります。この点を考慮すると、以下のようなテキストは完全に許容されるように感じるかもしれません。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。こちらをクリックして詳細をご覧ください。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。詳細についてはhttps://enwikipediaorg/wiki/Little_penguinをご覧ください。\nNOTE 以下で説明するように、上記のようなリンクを絶対に作成してはいけません。\nスクリーンリーダーはブラウザとは異なるインターフェースであり、異なる機能セットを持っています。\nURLを使用する問題点\nスクリーンリーダーはテキストを読み取ります。テキストにURLが含まれている場合、スクリーンリーダーはURLを読み上げます。一般的に、URLは意味のある情報を伝えず、煩わしく聞こえることがあります。携帯電話がテキストメッセージ内のURLを音声で読み上げた経験があるかもしれません。\n「こちらをクリック」の問題点\nスクリーンリーダーはページ上のハイパーリンクのみを読み取る機能も持っています。視覚的なユーザーがページをスキャンしてリンクを探すのと同じようにです。リンクテキストがすべて「こちらをクリック」である場合、ユーザーは「こちらをクリック、こちらをクリック、こちらをクリック、こちらをクリック、こちらをクリック、」としか聞こえません。すべてのリンクが区別できなくなります。\n良いリンクテキスト\n良いリンクテキストは、リンク先の内容を簡潔に説明します。上記のリトルペンギンに関する例では、リンクはその種に関するWikipediaページに向けられています。「リトルペンギン」というフレーズは、リンク先で何を学べるかを明確に示しているため、完璧なリンクテキストになります。\nリトルペンギンは、フェアリーペンギンとも呼ばれ、世界で最も小さいペンギンです。リトルペンギンについてさらに詳しく知る。\n✅ 数分間ウェブを閲覧して、曖昧なリンク戦略を使用しているページを見つけてください。それらをより良いリンクを使用しているサイトと比較してください。何が学べますか？\n検索エンジンに関する注意点\nすべての人にとってアクセシブルなサイトを確保することで、検索エンジンがサイトをナビゲートするのにも役立ちます。検索エンジンはリンクテキストを使用してページのトピックを学びます。そのため、良いリンクテキストを使用することはすべての人に役立ちます！\nARIA\n以下のページを想像してください：\n| 商品          | 説明              | 注文          |\n| ------------ | ------------------ | ------------ |\n| Widget       | 説明  |\n| Super widget | 説明  |\nこの例では、説明と注文のテキストを重複させることはブラウザを使用する人にとっては理にかなっています。しかし、スクリーンリーダーを使用する人にとっては、説明と注文という言葉が文脈なしで繰り返されるだけです。\nこのようなシナリオをサポートするために、HTMLはアクセシブルリッチインターネットアプリケーション (ARIA)と呼ばれる属性セットをサポートしています。これらの属性を使用すると、スクリーンリーダーに追加情報を提供できます。\nNOTE: HTMLの多くの側面と同様に、ブラウザやスクリーンリーダーのサポートは異なる場合があります。ただし、ほとんどの主要なクライアントはARIA属性をサポートしています。\naria-labelを使用して、ページの形式がそれを許さない場合にリンクを説明できます。Widgetの説明は以下のように設定できます：\nhtml\n<a href=\"#\" aria-label=\"Widget description\">description</a>\n✅ 一般的に、上記で説明したセマンティックマークアップを使用することはARIAの使用に優先しますが、HTMLウィジェットにセマンティックな同等物がない場合があります。良い例はツリーです。ツリーに対応するHTMLの同等物はないため、この要素の汎用的な<div>を適切な役割とARIA値で識別します。MDNのARIAに関するドキュメントにはさらに役立つ情報が含まれています。\n```html\nFile Viewer\nUploads\n```\n画像\nスクリーンリーダーが画像内の内容を自動的に読み取ることができないのは言うまでもありません。画像がアクセシブルであることを確保するのはそれほど手間がかかりません。それがalt属性の目的です。すべての意味のある画像には、それが何であるかを説明するaltを設定する必要があります。純粋に装飾的な画像の場合、alt属性を空の文字列に設定します：alt=\"\"。これにより、スクリーンリーダーが装飾的な画像を不必要に読み上げることを防ぎます。\n✅ 予想通り、検索エンジンも画像内の内容を理解することができません。検索エンジンもaltテキストを使用します。そのため、ページがアクセシブルであることを確保することで追加のメリットが得られます！\nキーボード\n一部のユーザーはマウスやトラックパッドを使用できず、代わりにキーボード操作に依存してタブキーで要素を移動します。キーボードユーザーが文書を下に移動する際に各インタラクティブ要素にアクセスできるよう、ウェブサイトのコンテンツを論理的な順序で提示することが重要です。セマンティックマークアップを使用してウェブページを構築し、CSSを使用して視覚的なレイアウト\n多くの政府はアクセシビリティ要件に関する法律を制定しています。自国のアクセシビリティに関する法律について調べてみましょう。どのような内容が含まれていて、どのような内容が含まれていないのかを確認してください。例えば、この政府のウェブサイトがあります。\n課題\nアクセシビリティが低いウェブサイトを分析する\nクレジット: Turtle Ipsum by Instrument\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 18945,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\3-accessibility\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 5290,
    "chunk_index": 3,
    "total_chunks": 4
  },
  {
    "id": "92fb060a5015b5c6801810b0422a8d11",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\README.md",
    "source_type": "git_repo",
    "title": ":dollar: 建立一間銀行",
    "content": ":dollar: 建立一間銀行\n在這個項目中，你將學習如何建立一間虛構的銀行。這些課程包括如何設計一個網頁應用程式並提供路由、建立表單、管理狀態，以及從 API 獲取數據以取得銀行的相關資料。\n|  |  |\n|--------------------------------|--------------------------------|\n課程\n網頁應用程式中的 HTML 模板與路由\n建立登入與註冊表單\n獲取與使用數據的方法\n狀態管理的概念\n鳴謝\n這些課程由 Yohan Lasorsa 用 :hearts: 編寫。\n如果你有興趣學習如何建立這些課程中使用的 伺服器 API，你可以觀看 這系列影片（特別是第 17 至 21 集）。\n你也可以參考 這個互動式的 Learn 教學。\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1762,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 495,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "ea836fc323007883f4809fc55560a0f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\docs\\_navbar.md",
    "source_type": "git_repo",
    "title": "_navbar",
    "content": "翻譯\nEnglish (United States)\nবাংলা\n中文(中国)\n中文(台灣)\nEspañol\nFrançais\nΕλληνικά\nहिन्दी\nBahasa Melayu\nമലയാളം\nதமிழ்\nతెలుగు\nBahasa Indonesia\nItaliano\n日本語\nNederlands\nनेपाली\nPortuguês\nРусский\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1566,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\docs\\_navbar.md",
      "source_type": "git_repo"
    },
    "token_count": 314,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "46eebadfc6fa117351559061fff728d4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\docs\\_sidebar.md",
    "source_type": "git_repo",
    "title": "_sidebar",
    "content": "介紹\n1\n2\n3\nJS 基礎\n4\n5\n6\n7\nHTML, CSS, JS\n8\n9\n10\n打字遊戲\n11\n瀏覽器擴展\n12\n13\n14\n太空遊戲\n15\n16\n17\n18\n19\n20\n銀行項目\n21\n22\n23\n24\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2149,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\docs\\_sidebar.md",
      "source_type": "git_repo"
    },
    "token_count": 276,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "7161b5c10d9bb29c6e4049862c3dcfe1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\lesson-template\\assignment.md",
    "source_type": "git_repo",
    "title": "[Assignment Name]",
    "content": "[Assignment Name]\n指示\n評分標準\n| 評分標準 | 優秀 | 合格 | 需要改進 |\n| -------- | ----- | ---- | -------- |\n|          |       |      |          |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 836,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\lesson-template\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 241,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "00a70c19b37de39f48b8493da963bba3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\lesson-template\\README.md",
    "source_type": "git_repo",
    "title": "[課堂主題]",
    "content": "[課堂主題]\n課前測驗\n[描述我們將學習的內容]\n簡介\n描述將涵蓋的內容\n備註\n先決條件\n在這節課之前應該已完成哪些步驟？\n準備工作\n開始這節課的準備步驟\n[逐步以區塊形式講解內容]\n[主題 1]\n任務：\n共同合作逐步改進你的代碼庫，使用共享代碼來構建項目：\nhtml\ncode blocks\n✅ 知識檢查 - 利用這個時機通過開放性問題來擴展學生的知識\n[主題 2]\n[主題 3]\n🚀 挑戰：為學生設計一個課堂內合作完成的挑戰，以改進項目\n可選：如果合適，添加完成課程後的用戶界面截圖\n課後測驗\n回顧與自學\n作業截止日期 [MM/YY]：作業名稱\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1603,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\lesson-template\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 528,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "e2fe8fc3280918b1c53dd02c098a9317",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "測驗應用程式\n這些測驗是數據科學課程的課前和課後測驗，課程網址為：https://aka ms/webdev-beginners\n新增翻譯測驗集\n透過在 assets/translations 資料夾中建立相應的測驗結構來新增測驗翻譯。原始測驗位於 assets/translations/en。測驗被分成幾個組別。請確保編號與正確的測驗部分對齊。整個課程共有 40 個測驗，編號從 0 開始。\n以下是翻譯檔案的結構範例：\n```\n[\n{\n\"title\": \"A title\",\n\"complete\": \"A complete button title\",\n\"error\": \"An error message upon selecting the wrong answer\",\n\"quizzes\": [\n{\n\"id\": 1,\n\"title\": \"Title\",\n\"quiz\": [\n{\n\"questionText\": \"The question asked\",\n\"answerOptions\": [\n{\n\"answerText\": \"Option 1 title\",\n\"isCorrect\": true\n},\n{\n\"answerText\": \"Option 2 title\",\n\"isCorrect\": false\n}\n]\n}\n]\n}\n]\n}\n]\n```\n編輯翻譯後，請編輯翻譯資料夾中的 index js 檔案，按照 en 的慣例匯入所有檔案。\n編輯 assets/translations 中的 index js 檔案以匯入新的翻譯檔案。\n例如，如果你的翻譯 JSON 檔案是 ex json，請將 'ex' 設為本地化鍵，然後按照以下方式匯入：\nindex js\n```\nimport ex from \" /ex",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 491,
    "chunk_index": 0,
    "total_chunks": 7
  },
  {
    "id": "60980451ae1715356aa986050f054245",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "\"error\": \"An error message upon selecting the wrong answer\", \"quizzes\": [ { \"id\": 1, \"title\": \"Title\", \"quiz\": [ { \"questionText\": \"The question asked\", \"answerOptions\": [ { \"answerText\": \"Option 1 title\", \"isCorrect\": true }, { \"answerText\": \"Option 2 title\", \"isCorrect\": false } ] } ] } ] } ] ``` 編輯翻譯後，請編輯翻譯資料夾中的 index js 檔案，按照 en 的慣例匯入所有檔案。 編輯 assets/translations 中的 index js 檔案以匯入新的翻譯檔案。 例如，如果你的翻譯 JSON 檔案是 ex json，請將 'ex' 設為本地化鍵，然後按照以下方式匯入： index js ``` import ex from \" /exjson\";\n// if 'ex' is localization key then enter it like so in `messages` to expose it\nconst messages = {\nex: ex[0],\n};\nexport default messages;\n```\n在本地運行測驗應用程式\n先決條件\n一個 GitHub 帳戶\nNode js 和 Git\n安裝與設置\n從這個 範本 建立一個儲存庫\n複製你的新儲存庫，並導航到 quiz-app\nbash\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 387,
    "chunk_index": 1,
    "total_chunks": 7
  },
  {
    "id": "8dee5fbfca55d8e0c66a9b123d0bfb56",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "} ] ``` 編輯翻譯後，請編輯翻譯資料夾中的 index js 檔案，按照 en 的慣例匯入所有檔案。 編輯 assets/translations 中的 index js 檔案以匯入新的翻譯檔案。 例如，如果你的翻譯 JSON 檔案是 ex json，請將 'ex' 設為本地化鍵，然後按照以下方式匯入： index js ``` import ex from \" /exjson\"; // if 'ex' is localization key then enter it like so in `messages` to expose it const messages = { ex: ex[0], }; export default messages; ``` 在本地運行測驗應用程式 先決條件 一個 GitHub 帳戶 Node js 和 Git 安裝與設置 從這個 範本 建立一個儲存庫 複製你的新儲存庫，並導航到 quiz-app bash git clone https://githubcom/your-github-organization/repo-name\ncd repo-name/quiz-app\n安裝 npm 套件與依賴項\nbash\nnpm install\n建置應用程式\n要建置解決方案，執行以下指令：\nbash\nnpm run build\n啟動應用程式\n要運行解決方案，執行以下指令：\nbash\nnpm run dev\n[可選] 程式碼檢查\n為確保程式碼通過檢查，執行以下指令：\nbash\nnpm run lint\n部署測驗應用程式到 Azure\n先決條件\n一個 Azure 訂閱。你可以在 這裡 免費註冊。\n部署此測驗應用程式的成本估算：免費\n登入 Azure 後，選擇一個訂閱和資源群組，然後：\n靜態網頁應用程式詳細資訊：提供一個名稱並選擇一個託管計劃\nGitHub 登入：將部署來源設置為 GitHub，然後登入並填寫表單中的必要欄位：\n組織 – 選擇你的組織。\n儲存庫 – 選擇 Web Dev for Beginners 課程的儲存庫。\n分支 - 選擇一個分支（main）\n建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測應用程式中使用的框架。\n應用程式位置 -",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 771,
    "chunk_index": 2,
    "total_chunks": 7
  },
  {
    "id": "90951fc09062ed7ab44a49c12d2bc6f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "帳戶 Node js 和 Git 安裝與設置 從這個 範本 建立一個儲存庫 複製你的新儲存庫，並導航到 quiz-app bash git clone https://githubcom/your-github-organization/repo-name cd repo-name/quiz-app 安裝 npm 套件與依賴項 bash npm install 建置應用程式 要建置解決方案，執行以下指令： bash npm run build 啟動應用程式 要運行解決方案，執行以下指令： bash npm run dev [可選] 程式碼檢查 為確保程式碼通過檢查，執行以下指令： bash npm run lint 部署測驗應用程式到 Azure 先決條件 一個 Azure 訂閱。你可以在 這裡 免費註冊。 部署此測驗應用程式的成本估算：免費 登入 Azure 後，選擇一個訂閱和資源群組，然後： 靜態網頁應用程式詳細資訊：提供一個名稱並選擇一個託管計劃 GitHub 登入：將部署來源設置為 GitHub，然後登入並填寫表單中的必要欄位： 組織 – 選擇你的組織。 儲存庫 – 選擇 Web Dev for Beginners 課程的儲存庫。 分支 - 選擇一個分支（main） 建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測應用程式中使用的框架。 應用程式位置 -/quiz-app\nAPI 位置 -\n輸出位置 - dist\n部署：點擊 'Review + Create'，然後點擊 'Create'\n部署完成後，一個工作流程檔案將會在你的儲存庫的",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 3,
    "total_chunks": 7
  },
  {
    "id": "fa52561cdf81c39cf5686d76c12b42fc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "git clone https://githubcom/your-github-organization/repo-name cd repo-name/quiz-app 安裝 npm 套件與依賴項 bash npm install 建置應用程式 要建置解決方案，執行以下指令： bash npm run build 啟動應用程式 要運行解決方案，執行以下指令： bash npm run dev [可選] 程式碼檢查 為確保程式碼通過檢查，執行以下指令： bash npm run lint 部署測驗應用程式到 Azure 先決條件 一個 Azure 訂閱。你可以在 這裡 免費註冊。 部署此測驗應用程式的成本估算：免費 登入 Azure 後，選擇一個訂閱和資源群組，然後： 靜態網頁應用程式詳細資訊：提供一個名稱並選擇一個託管計劃 GitHub 登入：將部署來源設置為 GitHub，然後登入並填寫表單中的必要欄位： 組織 – 選擇你的組織。 儲存庫 – 選擇 Web Dev for Beginners 課程的儲存庫。 分支 - 選擇一個分支（main） 建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測應用程式中使用的框架。 應用程式位置 -/quiz-app API 位置 - 輸出位置 - dist 部署：點擊 'Review + Create'，然後點擊 'Create' 部署完成後，一個工作流程檔案將會在你的儲存庫的github 目錄中建立。此工作流程檔案包含觸發應用程式重新部署到 Azure 的事件指令，例如，在 main 分支上的 push 等。\n範例工作流程檔案\n以下是 GitHub Actions 工作流程檔案的範例：\nname: Azure Static Web Apps CI/CD\n```\non:\npush:\nbranches:\n- main\npull_request:\ntypes: [opened, synchronize, reopened, closed]\nbranches:\n- main\njobs:\nbuild_and_deploy_job:\nruns-on: ubuntu-latest\nname: Build and Deploy Job\nsteps:\n- uses: actions/checkout@v2\n- name: Build And Deploy\nid: builddeploy\nuses: Azure/static-web-apps-deploy@v1\nwith:\nazure_static_web_apps_api_token: ${{ secrets",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 752,
    "chunk_index": 4,
    "total_chunks": 7
  },
  {
    "id": "1c5b3eca8decb4abc75b85164784a2a7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "選擇一個分支（main） 建置預設值：Azure 靜態網頁應用程式使用檢測算法來檢測應用程式中使用的框架。 應用程式位置 -/quiz-app API 位置 - 輸出位置 - dist 部署：點擊 'Review + Create'，然後點擊 'Create' 部署完成後，一個工作流程檔案將會在你的儲存庫的github 目錄中建立。此工作流程檔案包含觸發應用程式重新部署到 Azure 的事件指令，例如，在 main 分支上的 push 等。 範例工作流程檔案 以下是 GitHub Actions 工作流程檔案的範例： name: Azure Static Web Apps CI/CD ``` on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v2 - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secretsAZURE_STATIC_WEB_APPS_API_TOKEN }}\nrepo_token: ${{ secrets",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 351,
    "chunk_index": 5,
    "total_chunks": 7
  },
  {
    "id": "3eac80df2e6031a9b00e8d0fcb34cabf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
    "source_type": "git_repo",
    "title": "測驗應用程式",
    "content": "-/quiz-app API 位置 - 輸出位置 - dist 部署：點擊 'Review + Create'，然後點擊 'Create' 部署完成後，一個工作流程檔案將會在你的儲存庫的github 目錄中建立。此工作流程檔案包含觸發應用程式重新部署到 Azure 的事件指令，例如，在 main 分支上的 push 等。 範例工作流程檔案 以下是 GitHub Actions 工作流程檔案的範例： name: Azure Static Web Apps CI/CD ``` on: push: branches: - main pull_request: types: [opened, synchronize, reopened, closed] branches: - main jobs: build_and_deploy_job: runs-on: ubuntu-latest name: Build and Deploy Job steps: - uses: actions/checkout@v2 - name: Build And Deploy id: builddeploy uses: Azure/static-web-apps-deploy@v1 with: azure_static_web_apps_api_token: ${{ secretsAZURE_STATIC_WEB_APPS_API_TOKEN }} repo_token: ${{ secretsGITHUB_TOKEN }}\naction: \"upload\"\napp_location: \"quiz-app\" # App source code path\napi_location: \"\"API source code path optional\noutput_location: \"dist\" #Built app content directory - optional\n```\n部署後：部署完成後，點擊 'Go to Deployment'，然後點擊 'View app in browser'。\n當你的 GitHub Action（工作流程）成功執行後，刷新線上頁面以查看你的應用程式。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 6058,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\quiz-app\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 582,
    "chunk_index": 6,
    "total_chunks": 7
  },
  {
    "id": "c4db50ec6669df67c0798d0f85cd600b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "GitHubの概要\nこのレッスンでは、コードのホスティングと変更管理を行うプラットフォームであるGitHubの基本を学びます。\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nはじめに\nこのレッスンでは以下を学びます：\n自分のマシンでの作業を追跡する方法\n他の人とプロジェクトを進める方法\nオープンソースソフトウェアに貢献する方法\n前提条件\n始める前に、Gitがインストールされているか確認してください。ターミナルで以下を入力します：\ngit --version\nGitがインストールされていない場合は、Gitをダウンロードしてください。その後、ターミナルでローカルGitプロファイルを設定します：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\nGitがすでに設定されているか確認するには以下を入力します：\ngit config --list\nまた、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。\ngithub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 354,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "6e0d83c80e7add5f7753af903464c89c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "GitHubの概要\nこのレッスンでは、コードのホスティングと変更管理を行うプラットフォームであるGitHubの基本を学びます。\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nはじめに\nこのレッスンでは以下を学びます：\n自分のマシンでの作業を追跡する方法\n他の人とプロジェクトを進める方法\nオープンソースソフトウェアに貢献する方法\n前提条件\n始める前に、Gitがインストールされているか確認してください。ターミナルで以下を入力します：\ngit --version\nGitがインストールされていない場合は、Gitをダウンロードしてください。その後、ターミナルでローカルGitプロファイルを設定します：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\nGitがすでに設定されているか確認するには以下を入力します：\ngit config --list\nまた、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。\ngithubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。\n✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。\n準備\nローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。\nコード管理\nローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。\nタスク: リポジトリを作成してコードをコミットする\n動画をチェック\nGitHubでリポジトリを作成。GitHub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 761,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "5c5302c2daa7d35cdc0ff23b156635f5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "GitHubの概要\nこのレッスンでは、コードのホスティングと変更管理を行うプラットフォームであるGitHubの基本を学びます。\nスケッチノート: Tomomi Imura\n講義前のクイズ\n講義前のクイズ\nはじめに\nこのレッスンでは以下を学びます：\n自分のマシンでの作業を追跡する方法\n他の人とプロジェクトを進める方法\nオープンソースソフトウェアに貢献する方法\n前提条件\n始める前に、Gitがインストールされているか確認してください。ターミナルで以下を入力します：\ngit --version\nGitがインストールされていない場合は、Gitをダウンロードしてください。その後、ターミナルでローカルGitプロファイルを設定します：\n* git config --global user name \"your-name\"\n* git config --global user email \"your-email\"\nGitがすでに設定されているか確認するには以下を入力します：\ngit config --list\nまた、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。\ngithubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。\n✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。\n準備\nローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。\nコード管理\nローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。\nタスク: リポジトリを作成してコードをコミットする\n動画をチェック\nGitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。\nリポジトリ（フォルダ）に名前を付けます。\nリポジトリを作成を選択します。\n作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します：\nbash\ncd [name of your folder]\nGitリポジトリを初期化。プロジェクトで以下を入力します：\nbash\ngit init\nステータスを確認。リポジトリのステータスを確認するには以下を入力します：\nbash\ngit status\n出力は以下のようになることがあります：\n```output\nChanges not staged for commit:\n(use \"git add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 997,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "98a109c5d50d7ece5c80bdf6c7291fa7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "このレッスンでは、コードのホスティングと変更管理を行うプラットフォームであるGitHubの基本を学びます。 スケッチノート: Tomomi Imura 講義前のクイズ 講義前のクイズ はじめに このレッスンでは以下を学びます： 自分のマシンでの作業を追跡する方法 他の人とプロジェクトを進める方法 オープンソースソフトウェアに貢献する方法 前提条件 始める前に、Gitがインストールされているか確認してください。ターミナルで以下を入力します： git --version Gitがインストールされていない場合は、Gitをダウンロードしてください。その後、ターミナルでローカルGitプロファイルを設定します： * git config --global user name \"your-name\" * git config --global user email \"your-email\" Gitがすでに設定されているか確認するには以下を入力します： git config --list また、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。 githubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。 ✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。 準備 ローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。 コード管理 ローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。 タスク: リポジトリを作成してコードをコミットする 動画をチェック GitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。 リポジトリ（フォルダ）に名前を付けます。 リポジトリを作成を選択します。 作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します： bash cd [name of your folder] Gitリポジトリを初期化。プロジェクトで以下を入力します： bash git init ステータスを確認。リポジトリのステータスを確認するには以下を入力します： bash git status 出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed)\n(use \"git checkout --",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1004,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "afccf09f182c6f066bfc7809a681042b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "オープンソースソフトウェアに貢献する方法 前提条件 始める前に、Gitがインストールされているか確認してください。ターミナルで以下を入力します： git --version Gitがインストールされていない場合は、Gitをダウンロードしてください。その後、ターミナルでローカルGitプロファイルを設定します： * git config --global user name \"your-name\" * git config --global user email \"your-email\" Gitがすでに設定されているか確認するには以下を入力します： git config --list また、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。 githubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。 ✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。 準備 ローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。 コード管理 ローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。 タスク: リポジトリを作成してコードをコミットする 動画をチェック GitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。 リポジトリ（フォルダ）に名前を付けます。 リポジトリを作成を選択します。 作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します： bash cd [name of your folder] Gitリポジトリを初期化。プロジェクトで以下を入力します： bash git init ステータスを確認。リポジトリのステータスを確認するには以下を入力します： bash git status 出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory)\nmodified:   file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 885,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "1cad6564b7bd7a1b01399bccb1f3d7e3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "config --global user name \"your-name\" * git config --global user email \"your-email\" Gitがすでに設定されているか確認するには以下を入力します： git config --list また、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。 githubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。 ✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。 準備 ローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。 コード管理 ローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。 タスク: リポジトリを作成してコードをコミットする 動画をチェック GitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。 リポジトリ（フォルダ）に名前を付けます。 リポジトリを作成を選択します。 作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します： bash cd [name of your folder] Gitリポジトリを初期化。プロジェクトで以下を入力します： bash git init ステータスを確認。リポジトリのステータスを確認するには以下を入力します： bash git status 出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt\nmodified:   file2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 772,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "c444d2f3b32a1e6d82213317109fea48",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "user name \"your-name\" * git config --global user email \"your-email\" Gitがすでに設定されているか確認するには以下を入力します： git config --list また、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。 githubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。 ✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。 準備 ローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。 コード管理 ローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。 タスク: リポジトリを作成してコードをコミットする 動画をチェック GitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。 リポジトリ（フォルダ）に名前を付けます。 リポジトリを作成を選択します。 作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します： bash cd [name of your folder] Gitリポジトリを初期化。プロジェクトで以下を入力します： bash git init ステータスを確認。リポジトリのステータスを確認するには以下を入力します： bash git status 出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt\n```\n通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。\nすべてのファイルを追跡対象に追加\nこれはファイルをステージングエリアに追加することを意味します。\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 878,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "8f68d0b4dcb0285fdaf5f104e31da93a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "email \"your-email\" Gitがすでに設定されているか確認するには以下を入力します： git config --list また、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。 githubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。 ✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。 準備 ローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。 コード管理 ローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。 タスク: リポジトリを作成してコードをコミットする 動画をチェック GitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。 リポジトリ（フォルダ）に名前を付けます。 リポジトリを作成を選択します。 作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します： bash cd [name of your folder] Gitリポジトリを初期化。プロジェクトで以下を入力します： bash git init ステータスを確認。リポジトリのステータスを確認するには以下を入力します： bash git status 出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addと",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 868,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "a50fc561a87f6735ba1cd3ba11e6396a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "\"your-email\" Gitがすでに設定されているか確認するには以下を入力します： git config --list また、GitHubアカウント、コードエディタ（例: Visual Studio Code）、ターミナル（またはコマンドプロンプト）が必要です。 githubcomにアクセスして、まだアカウントを作成していない場合は作成し、ログインしてプロファイルを完成させてください。 ✅ GitHubは世界で唯一のコードリポジトリではありません。他にもありますが、GitHubが最もよく知られています。 準備 ローカルマシン（ノートPCまたはPC）にコードプロジェクトのフォルダと、他の人のプロジェクトに貢献する方法を学ぶための例として使用するGitHub上の公開リポジトリが必要です。 コード管理 ローカルにコードプロジェクトのフォルダがあり、その進捗をバージョン管理システムであるGitを使って追跡したいとします。Gitを使うことは、未来の自分へのラブレターを書くようなものだと例えられることがあります。数日、数週間、数ヶ月後にコミットメッセージを読むことで、なぜその決定をしたのかを思い出したり、変更を「巻き戻す」ことができます。ただし、良い「コミットメッセージ」を書いた場合に限ります。 タスク: リポジトリを作成してコードをコミットする 動画をチェック GitHubでリポジトリを作成。GitHubcomで、リポジトリタブまたは右上のナビゲーションバーから新しいリポジトリボタンを見つけます。 リポジトリ（フォルダ）に名前を付けます。 リポジトリを作成を選択します。 作業フォルダに移動。ターミナルで、追跡を開始したいフォルダ（ディレクトリ）に移動します。以下を入力します： bash cd [name of your folder] Gitリポジトリを初期化。プロジェクトで以下を入力します： bash git init ステータスを確認。リポジトリのステータスを確認するには以下を入力します： bash git status 出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。\n選択したファイルを追跡対象に追加\nbash\ngit add [file or folder name]\nすべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。\nすべてのファイルをステージング解除\nbash\ngit reset\nこのコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。\n特定のファイルをステージング解除\nbash\ngit reset [file or folder name]\nこのコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。\n作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します：\nbash\ngit commit -m \"first commit\"\nこれにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。\nローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください：\n注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1574,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "c671a4f336ac0930cc07fdb43198fc7f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 885,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "788eb164000e16f53b8c14fbfdfc0fff",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "出力は以下のようになることがあります： ```output Changes not staged for commit: (use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。\nbash\ngit remote add origin https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 907,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "8dd07e836ec553753f22c6509c0a2277",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "(use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。 bash git remote add origin https://githubcom/username/repository_name",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 886,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "1e820223ea840a0bb7c1a355032dd15f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "(use \"git add\" to update what will be committed) (use \"git checkout --\" to discard changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。 bash git remote add origin https://githubcom/username/repository_namegit\nこれにより、「origin」という名前のリモート接続が作成され、先ほど作成したGitHubリポジトリを指します。\nローカルファイルをGitHubに送信。これまでのところ、ローカルリポジトリとGitHubリポジトリの間に接続を作成しました。次に、これらのファイルをGitHubに送信します。以下のgit pushコマンドを使用します：\n注意：デフォルトのブランチ名がmainと異なる場合があります。\nbash\ngit push -u origin main\nこれにより、「main」ブランチのコミットがGitHubに送信されます。\nさらに変更を加える。変更を続けてGitHubにプッシュしたい場合は、以下の3つのコマンドを使用するだけです：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1115,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "3751f7733889afdc9f1664b7937d0463",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "changes in working directory) modified: filetxt modified: file2txt ``` 通常、git statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。 bash git remote add origin https://githubcom/username/repository_namegit これにより、「origin」という名前のリモート接続が作成され、先ほど作成したGitHubリポジトリを指します。 ローカルファイルをGitHubに送信。これまでのところ、ローカルリポジトリとGitHubリポジトリの間に接続を作成しました。次に、これらのファイルをGitHubに送信します。以下のgit pushコマンドを使用します： 注意：デフォルトのブランチ名がmainと異なる場合があります。 bash git push -u origin main これにより、「main」ブランチのコミットがGitHubに送信されます。 さらに変更を加える。変更を続けてGitHubにプッシュしたい場合は、以下の3つのコマンドを使用するだけです： bash git addgit commit -m \"type your commit message here\"\ngit push\nヒント：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1112,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "9626cf8cdb93609e24094dc7fa30c8ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。 bash git remote add origin https://githubcom/username/repository_namegit これにより、「origin」という名前のリモート接続が作成され、先ほど作成したGitHubリポジトリを指します。 ローカルファイルをGitHubに送信。これまでのところ、ローカルリポジトリとGitHubリポジトリの間に接続を作成しました。次に、これらのファイルをGitHubに送信します。以下のgit pushコマンドを使用します： 注意：デフォルトのブランチ名がmainと異なる場合があります。 bash git push -u origin main これにより、「main」ブランチのコミットがGitHubに送信されます。 さらに変更を加える。変更を続けてGitHubにプッシュしたい場合は、以下の3つのコマンドを使用するだけです： bash git addgit commit -m \"type your commit message here\" git push ヒント：gitignoreファイルを採用して、GitHubに表示したくないファイルを追跡対象から除外することを検討してください。例えば、同じフォルダに保存しているメモファイルなどで、公開リポジトリには不要なものです。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1179,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "55400f8d7df4b107e13e69194d9b7581",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。 bash git remote add origin https://githubcom/username/repository_namegit これにより、「origin」という名前のリモート接続が作成され、先ほど作成したGitHubリポジトリを指します。 ローカルファイルをGitHubに送信。これまでのところ、ローカルリポジトリとGitHubリポジトリの間に接続を作成しました。次に、これらのファイルをGitHubに送信します。以下のgit pushコマンドを使用します： 注意：デフォルトのブランチ名がmainと異なる場合があります。 bash git push -u origin main これにより、「main」ブランチのコミットがGitHubに送信されます。 さらに変更を加える。変更を続けてGitHubにプッシュしたい場合は、以下の3つのコマンドを使用するだけです： bash git addgit commit -m \"type your commit message here\" git push ヒント：gitignoreファイルを採用して、GitHubに表示したくないファイルを追跡対象から除外することを検討してください。例えば、同じフォルダに保存しているメモファイルなどで、公開リポジトリには不要なものです。gitignoreファイルのテンプレートは",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1192,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "a6926b2e4ddfb0e5f406de598e8f8581",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "statusコマンドは、リポジトリに保存する準備ができたファイルや変更があるファイルなどを教えてくれます。 すべてのファイルを追跡対象に追加 これはファイルをステージングエリアに追加することを意味します。 bash git addgit addとの引数は、すべてのファイルと変更を追跡対象にすることを示します。 選択したファイルを追跡対象に追加 bash git add [file or folder name] すべてのファイルを一度にコミットしたくない場合に、選択したファイルだけをステージングエリアに追加するのに役立ちます。 すべてのファイルをステージング解除 bash git reset このコマンドは、すべてのファイルを一度にステージング解除するのに役立ちます。 特定のファイルをステージング解除 bash git reset [file or folder name] このコマンドは、次のコミットに含めたくない特定のファイルだけをステージング解除するのに役立ちます。 作業を永続化。この時点で、ファイルをいわゆるステージングエリアに追加しました。Gitがファイルを追跡している場所です。変更を永続化するには、ファイルをコミットする必要があります。コミットを作成するには、git commitコマンドを使用します。コミットはリポジトリの履歴における保存ポイントを表します。以下を入力してコミットを作成します： bash git commit -m \"first commit\" これにより、すべてのファイルがコミットされ、「first commit」というメッセージが追加されます。将来のコミットメッセージでは、変更の種類を伝えるためにもっと具体的な説明をすることをお勧めします。 ローカルGitリポジトリをGitHubと接続。ローカルリポジトリはマシン上で便利ですが、ファイルのバックアップをどこかに保存したり、他の人をリポジトリに招待したりしたい場合があります。そのための素晴らしい場所がGitHubです。すでにGitHubでリポジトリを作成しているので、ローカルGitリポジトリをGitHubと接続するだけです。git remote addコマンドを使用します。以下のコマンドを入力してください： 注意：コマンドを入力する前に、GitHubリポジトリページに移動してリポジトリURLを見つけてください。このURLを以下のコマンドで使用します。https://githubcom/username/repository_namegitをGitHub URLに置き換えてください。 bash git remote add origin https://githubcom/username/repository_namegit これにより、「origin」という名前のリモート接続が作成され、先ほど作成したGitHubリポジトリを指します。 ローカルファイルをGitHubに送信。これまでのところ、ローカルリポジトリとGitHubリポジトリの間に接続を作成しました。次に、これらのファイルをGitHubに送信します。以下のgit pushコマンドを使用します： 注意：デフォルトのブランチ名がmainと異なる場合があります。 bash git push -u origin main これにより、「main」ブランチのコミットがGitHubに送信されます。 さらに変更を加える。変更を続けてGitHubにプッシュしたい場合は、以下の3つのコマンドを使用するだけです： bash git addgit commit -m \"type your commit message here\" git push ヒント：gitignoreファイルを採用して、GitHubに表示したくないファイルを追跡対象から除外することを検討してください。例えば、同じフォルダに保存しているメモファイルなどで、公開リポジトリには不要なものです。gitignoreファイルのテンプレートはgitignore templatesで見つけることができます。\nコミットメッセージ\n優れたGitコミットの件名は以下の文を完成させます：\n「このコミットが適用されると、<件名>」\n件名では命令形の現在形を使用します。「変更する」ではなく「変更した」や「変更する予定」ではありません。\n件名と同様に、本文（オプション）でも命令形の現在形を使用します。本文には変更の動機を含め、以前の動作と対比させます。なぜを説明するのであって、どのようにではありません。\n✅ GitHubを少し探索してみてください。非常に優れたコミットメッセージを見つけることができますか？非常に簡素なものはどうですか？コミットメッセージで伝えるべき最も重要で有用な情報は何だと思いますか？\nタスク: コラボレーション\nGitHubにコードをアップロードする主な理由は、他の開発者とコラボレーションを可能にすることです。\n他の人とプロジェクトを進める\n動画をチェック\nリポジトリ内で、Insights > Communityに移動して、プロジェクトが推奨されるコミュニティ標準とどのように比較されるかを確認します。\n以下はGitHubリポジトリを改善するためのポイントです：\n- 説明。プロジェクトに説明を追加しましたか？\n- README。READMEを追加しましたか？GitHubはREADMEの書き方についてのガイダンスを提供しています。\n- 貢献ガイドライン。プロジェクトに貢献ガイドラインがありますか？\n- 行動規範。行動規範がありますか？\n- ライセンス。おそらく最も重要なライセンスがありますか？\nこれらのリソースは新しいチームメンバーのオンボーディングに役立ちます。そして、これらは通常、新しい貢献者がコードを見る前にプロジェクトが自分の時間を費やす価値があるかどうかを判断するために見るものです。\n✅ READMEファイルは準備に時間がかかることがありますが、忙しいメンテナーによってしばしば無視されます。特に説明的なREADMEの例を見つけることができますか？注：良いREADMEを作成するためのツールがいくつかありますので、試してみてください。\nタスク: コードをマージする\n貢献ドキュメントは人々がプロジェクトに貢献するのを助けます。どのような種類の貢献を求めているか、プロセスがどのように機能するかを説明します。貢献者はGitHubのリポジトリに貢献するために一連のステップを踏む必要があります：\nリポジトリをフォークする。通常、プロジェクトをフォークするように求めます。フォークとは、リポジトリの複製を自分のGitHubプロファイルに作成することを意味します。\nクローン。そこからプロジェクトをローカルマシンにクローンします。\nブランチを作成。作業用のブランチを作成するように求めます。\n変更を1つの領域に集中。貢献者に1度に1つのことに集中するように求めます。そうすることで、彼らの作業をマージする可能性が高くなります。例えば、バグ修正、新機能の追加、複数のテストの更新を行った場合、3つのうち2つまたは1つしか実装できない場合はどうしますか？\n✅ ブランチが特に重要になる状況を想像してみてください。どのようなユースケースが考えられますか？\n注意：自分自身もブランチを作成して作業することで、他の人に良い例を示しましょう。現在「チェックアウト」しているブランチにコミットが行われます。git statusを使用して、どのブランチにいるか確認してください。\n貢献者のワークフローを見てみましょう。貢献者がすでにリポジトリをフォークし、クローンしていると仮定します。つまり、ローカルマシンで作業可能なGitリポジトリが準備されています：\nブランチを作成。git branchコマンドを使用して、貢献する変更を含むブランチを作成します：\nbash\ngit branch [branch-name]\n作業ブランチに切り替え。指定したブランチに切り替え、git switchで作業ディレクトリを更新します：\nbash\ngit switch [branch-name]\n作業を行う。この時点で変更を加えます。以下のコマンドを使用してGitに変更を伝えるのを忘れないでください：\nbash\ngit add",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2758,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "a1830a24864cc9bf9713d33604347452",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "-u origin main これにより、「main」ブランチのコミットがGitHubに送信されます。 さらに変更を加える。変更を続けてGitHubにプッシュしたい場合は、以下の3つのコマンドを使用するだけです： bash git addgit commit -m \"type your commit message here\" git push ヒント：gitignoreファイルを採用して、GitHubに表示したくないファイルを追跡対象から除外することを検討してください。例えば、同じフォルダに保存しているメモファイルなどで、公開リポジトリには不要なものです。gitignoreファイルのテンプレートはgitignore templatesで見つけることができます。 コミットメッセージ 優れたGitコミットの件名は以下の文を完成させます： 「このコミットが適用されると、<件名>」 件名では命令形の現在形を使用します。「変更する」ではなく「変更した」や「変更する予定」ではありません。 件名と同様に、本文（オプション）でも命令形の現在形を使用します。本文には変更の動機を含め、以前の動作と対比させます。なぜを説明するのであって、どのようにではありません。 ✅ GitHubを少し探索してみてください。非常に優れたコミットメッセージを見つけることができますか？非常に簡素なものはどうですか？コミットメッセージで伝えるべき最も重要で有用な情報は何だと思いますか？ タスク: コラボレーション GitHubにコードをアップロードする主な理由は、他の開発者とコラボレーションを可能にすることです。 他の人とプロジェクトを進める 動画をチェック リポジトリ内で、Insights > Communityに移動して、プロジェクトが推奨されるコミュニティ標準とどのように比較されるかを確認します。 以下はGitHubリポジトリを改善するためのポイントです： - 説明。プロジェクトに説明を追加しましたか？ - README。READMEを追加しましたか？GitHubはREADMEの書き方についてのガイダンスを提供しています。 - 貢献ガイドライン。プロジェクトに貢献ガイドラインがありますか？ - 行動規範。行動規範がありますか？ - ライセンス。おそらく最も重要なライセンスがありますか？ これらのリソースは新しいチームメンバーのオンボーディングに役立ちます。そして、これらは通常、新しい貢献者がコードを見る前にプロジェクトが自分の時間を費やす価値があるかどうかを判断するために見るものです。 ✅ READMEファイルは準備に時間がかかることがありますが、忙しいメンテナーによってしばしば無視されます。特に説明的なREADMEの例を見つけることができますか？注：良いREADMEを作成するためのツールがいくつかありますので、試してみてください。 タスク: コードをマージする 貢献ドキュメントは人々がプロジェクトに貢献するのを助けます。どのような種類の貢献を求めているか、プロセスがどのように機能するかを説明します。貢献者はGitHubのリポジトリに貢献するために一連のステップを踏む必要があります： リポジトリをフォークする。通常、プロジェクトをフォークするように求めます。フォークとは、リポジトリの複製を自分のGitHubプロファイルに作成することを意味します。 クローン。そこからプロジェクトをローカルマシンにクローンします。 ブランチを作成。作業用のブランチを作成するように求めます。 変更を1つの領域に集中。貢献者に1度に1つのことに集中するように求めます。そうすることで、彼らの作業をマージする可能性が高くなります。例えば、バグ修正、新機能の追加、複数のテストの更新を行った場合、3つのうち2つまたは1つしか実装できない場合はどうしますか？ ✅ ブランチが特に重要になる状況を想像してみてください。どのようなユースケースが考えられますか？ 注意：自分自身もブランチを作成して作業することで、他の人に良い例を示しましょう。現在「チェックアウト」しているブランチにコミットが行われます。git statusを使用して、どのブランチにいるか確認してください。 貢献者のワークフローを見てみましょう。貢献者がすでにリポジトリをフォークし、クローンしていると仮定します。つまり、ローカルマシンで作業可能なGitリポジトリが準備されています： ブランチを作成。git branchコマンドを使用して、貢献する変更を含むブランチを作成します： bash git branch [branch-name] 作業ブランチに切り替え。指定したブランチに切り替え、git switchで作業ディレクトリを更新します： bash git switch [branch-name] 作業を行う。この時点で変更を加えます。以下のコマンドを使用してGitに変更を伝えるのを忘れないでください： bash git addgit commit -m \"my changes\"\nコミットに良い名前を付けることを忘れないでください。自分のためにも、リポジトリのメンテナーのためにも役立ちます。\n作業をmainブランチと統合。作業が完了したら、mainブランチと作業を統合したいと思います。mainブランチはその間に変更されている可能性があるので、以下のコマンドで最新の状態に更新してください：\nbash\ngit switch main\ngit pull\nこの時点で、競合（Gitが変更を簡単に統合できない状況）が作業ブランチで発生することを確認してください。そのため、以下のコマンドを実行します：\nbash\ngit switch [branch_name]\ngit merge main\nこれにより、mainブランチからすべての変更がブランチに取り込まれ、問題なく作業を続けることができます。もし競合が発生した場合は、VS CodeがGitが混乱している箇所を教えてくれるので、影響を受けたファイルを変更して最も正確な内容を指定します。\n作業をGitHubに送信。作業をGitHubに送信するには2つのことが必要です。ブランチをリポジトリにプッシュし、PR（プルリクエスト）を開くことです。\nbash\ngit push --set-upstream origin [branch-name]\n上記のコマンドはフォークしたリポジトリにブランチを作成します。\nPRを開く。次に、PRを開きます。フォークしたリポジトリのGitHubページに移動します。GitHubで新しいPRを作成するかどうかを尋ねる表示があり、それをクリックすると、コミットメッセージのタイトルを変更したり、より適切な説明を追加したりするインターフェースに移動します。これで、フォークしたリポジトリのメンテナーがこのPRを確認し、うまくいけば PRを評価してマージしてくれるでしょう。これで貢献者になりました、やったね！\nクリーンアップ。PRが正常にマージされた後は、クリーンアップすることが良い習慣とされています。ローカルブランチとGitHubにプッシュしたブランチの両方をクリーンアップしたいと思います。まず、以下のコマンドでローカルブランチを削除します：\nbash\ngit branch -d [branch-name]\nGitHub のフォークしたリポジトリのページに移動し、先ほどプッシュしたリモートブランチを削除してください。\nPull request（プルリクエスト）という言葉は少し変に思えるかもしれません。実際にはプロジェクトに変更を「プッシュ」したいわけですが、メンテナー（プロジェクトの所有者）やコアチームがその変更をプロジェクトの「メイン」ブランチにマージする前に検討する必要があります。つまり、メンテナーに変更の判断を「リクエスト」しているのです。\nプルリクエストは、ブランチで導入された差分をレビュー、コメント、統合テストなどを通じて比較・議論する場です。良いプルリクエストは、コミットメッセージとほぼ同じルールに従います。例えば、作業が特定の課題を解決する場合、課題トラッカーの課題番号を参照として追加できます。これは # に続けて課題番号を記載することで行います。例: #97\n🤞すべてのチェックが通り、プロジェクトの所有者があなたの変更をプロジェクトにマージしてくれることを祈りましょう🤞\n現在のローカル作業ブランチを GitHub 上の対応するリモートブランチの新しいコミットで更新するには、以下を実行します：\ngit pull\nオープンソースへの貢献方法\nまず、GitHub 上で興味のあるリポジトリ（または repo）を見つけ、そこに変更を加えたいと思ったら、その内容を自分のマシンにコピーします。\n✅ '初心者向け' のリポジトリを見つける良い方法は、タグ 'good-first-issue' で検索することです。\nコードをコピーする方法はいくつかあります。一つの方法は、HTTPS、SSH、または GitHub CLI（コマンドラインインターフェース）を使用してリポジトリの内容を「クローン」することです。\nターミナルを開き、以下のようにリポジトリをクローンします：\ngit clone https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 3228,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "bced90c57749d08f6d0b8aa83dc622a0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "bash git switch [branch-name] 作業を行う。この時点で変更を加えます。以下のコマンドを使用してGitに変更を伝えるのを忘れないでください： bash git addgit commit -m \"my changes\" コミットに良い名前を付けることを忘れないでください。自分のためにも、リポジトリのメンテナーのためにも役立ちます。 作業をmainブランチと統合。作業が完了したら、mainブランチと作業を統合したいと思います。mainブランチはその間に変更されている可能性があるので、以下のコマンドで最新の状態に更新してください： bash git switch main git pull この時点で、競合（Gitが変更を簡単に統合できない状況）が作業ブランチで発生することを確認してください。そのため、以下のコマンドを実行します： bash git switch [branch_name] git merge main これにより、mainブランチからすべての変更がブランチに取り込まれ、問題なく作業を続けることができます。もし競合が発生した場合は、VS CodeがGitが混乱している箇所を教えてくれるので、影響を受けたファイルを変更して最も正確な内容を指定します。 作業をGitHubに送信。作業をGitHubに送信するには2つのことが必要です。ブランチをリポジトリにプッシュし、PR（プルリクエスト）を開くことです。 bash git push --set-upstream origin [branch-name] 上記のコマンドはフォークしたリポジトリにブランチを作成します。 PRを開く。次に、PRを開きます。フォークしたリポジトリのGitHubページに移動します。GitHubで新しいPRを作成するかどうかを尋ねる表示があり、それをクリックすると、コミットメッセージのタイトルを変更したり、より適切な説明を追加したりするインターフェースに移動します。これで、フォークしたリポジトリのメンテナーがこのPRを確認し、うまくいけば PRを評価してマージしてくれるでしょう。これで貢献者になりました、やったね！ クリーンアップ。PRが正常にマージされた後は、クリーンアップすることが良い習慣とされています。ローカルブランチとGitHubにプッシュしたブランチの両方をクリーンアップしたいと思います。まず、以下のコマンドでローカルブランチを削除します： bash git branch -d [branch-name] GitHub のフォークしたリポジトリのページに移動し、先ほどプッシュしたリモートブランチを削除してください。 Pull request（プルリクエスト）という言葉は少し変に思えるかもしれません。実際にはプロジェクトに変更を「プッシュ」したいわけですが、メンテナー（プロジェクトの所有者）やコアチームがその変更をプロジェクトの「メイン」ブランチにマージする前に検討する必要があります。つまり、メンテナーに変更の判断を「リクエスト」しているのです。 プルリクエストは、ブランチで導入された差分をレビュー、コメント、統合テストなどを通じて比較・議論する場です。良いプルリクエストは、コミットメッセージとほぼ同じルールに従います。例えば、作業が特定の課題を解決する場合、課題トラッカーの課題番号を参照として追加できます。これは # に続けて課題番号を記載することで行います。例: #97 🤞すべてのチェックが通り、プロジェクトの所有者があなたの変更をプロジェクトにマージしてくれることを祈りましょう🤞 現在のローカル作業ブランチを GitHub 上の対応するリモートブランチの新しいコミットで更新するには、以下を実行します： git pull オープンソースへの貢献方法 まず、GitHub 上で興味のあるリポジトリ（または repo）を見つけ、そこに変更を加えたいと思ったら、その内容を自分のマシンにコピーします。 ✅ '初心者向け' のリポジトリを見つける良い方法は、タグ 'good-first-issue' で検索することです。 コードをコピーする方法はいくつかあります。一つの方法は、HTTPS、SSH、または GitHub CLI（コマンドラインインターフェース）を使用してリポジトリの内容を「クローン」することです。 ターミナルを開き、以下のようにリポジトリをクローンします： git clone https://githubcom/ProjectURL\nプロジェクトで作業するには、正しいフォルダに移動します：\ncd ProjectURL\nまた、Codespaces（GitHub の組み込みコードエディタ/クラウド開発環境）や GitHub Desktop を使用してプロジェクト全体を開くこともできます。\n最後に、コードを zip フォルダとしてダウンロードすることも可能です。\nGitHub に関するいくつかの興味深いポイント\nGitHub 上の公開リポジトリは、スターを付けたり、ウォッチしたり、「フォーク」したりすることができます。スターを付けたリポジトリは、右上のドロップダウンメニューから確認できます。これはコードのブックマークのようなものです。\nプロジェクトには、通常 GitHub の「Issues」タブにある課題トラッカーがあり、そこでプロジェクトに関連する問題について議論します。また、「Pull Requests」タブでは、進行中の変更について議論やレビューが行われます。\nプロジェクトによっては、フォーラム、メーリングリスト、Slack、Discord、IRC などのチャットチャンネルで議論が行われることもあります。\n✅ 新しい GitHub リポジトリを見て回り、設定を編集したり、リポジトリに情報を追加したり、プロジェクト（例えばカンバンボード）を作成したりしてみてください。できることはたくさんあります！\n🚀 チャレンジ\n友達とペアを組んでお互いのコードに取り組みましょう。共同でプロジェクトを作成し、コードをフォークし、ブランチを作成し、変更をマージしてください。\n講義後のクイズ\n講義後のクイズ\n復習と自己学習\nオープンソースソフトウェアへの貢献についてをさらに読んでみましょう。\nGit チートシート。\n練習、練習、練習。GitHub には skills",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2185,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "de0497ec0853e5d9ca663169495198ea",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "上記のコマンドはフォークしたリポジトリにブランチを作成します。 PRを開く。次に、PRを開きます。フォークしたリポジトリのGitHubページに移動します。GitHubで新しいPRを作成するかどうかを尋ねる表示があり、それをクリックすると、コミットメッセージのタイトルを変更したり、より適切な説明を追加したりするインターフェースに移動します。これで、フォークしたリポジトリのメンテナーがこのPRを確認し、うまくいけば PRを評価してマージしてくれるでしょう。これで貢献者になりました、やったね！ クリーンアップ。PRが正常にマージされた後は、クリーンアップすることが良い習慣とされています。ローカルブランチとGitHubにプッシュしたブランチの両方をクリーンアップしたいと思います。まず、以下のコマンドでローカルブランチを削除します： bash git branch -d [branch-name] GitHub のフォークしたリポジトリのページに移動し、先ほどプッシュしたリモートブランチを削除してください。 Pull request（プルリクエスト）という言葉は少し変に思えるかもしれません。実際にはプロジェクトに変更を「プッシュ」したいわけですが、メンテナー（プロジェクトの所有者）やコアチームがその変更をプロジェクトの「メイン」ブランチにマージする前に検討する必要があります。つまり、メンテナーに変更の判断を「リクエスト」しているのです。 プルリクエストは、ブランチで導入された差分をレビュー、コメント、統合テストなどを通じて比較・議論する場です。良いプルリクエストは、コミットメッセージとほぼ同じルールに従います。例えば、作業が特定の課題を解決する場合、課題トラッカーの課題番号を参照として追加できます。これは # に続けて課題番号を記載することで行います。例: #97 🤞すべてのチェックが通り、プロジェクトの所有者があなたの変更をプロジェクトにマージしてくれることを祈りましょう🤞 現在のローカル作業ブランチを GitHub 上の対応するリモートブランチの新しいコミットで更新するには、以下を実行します： git pull オープンソースへの貢献方法 まず、GitHub 上で興味のあるリポジトリ（または repo）を見つけ、そこに変更を加えたいと思ったら、その内容を自分のマシンにコピーします。 ✅ '初心者向け' のリポジトリを見つける良い方法は、タグ 'good-first-issue' で検索することです。 コードをコピーする方法はいくつかあります。一つの方法は、HTTPS、SSH、または GitHub CLI（コマンドラインインターフェース）を使用してリポジトリの内容を「クローン」することです。 ターミナルを開き、以下のようにリポジトリをクローンします： git clone https://githubcom/ProjectURL プロジェクトで作業するには、正しいフォルダに移動します： cd ProjectURL また、Codespaces（GitHub の組み込みコードエディタ/クラウド開発環境）や GitHub Desktop を使用してプロジェクト全体を開くこともできます。 最後に、コードを zip フォルダとしてダウンロードすることも可能です。 GitHub に関するいくつかの興味深いポイント GitHub 上の公開リポジトリは、スターを付けたり、ウォッチしたり、「フォーク」したりすることができます。スターを付けたリポジトリは、右上のドロップダウンメニューから確認できます。これはコードのブックマークのようなものです。 プロジェクトには、通常 GitHub の「Issues」タブにある課題トラッカーがあり、そこでプロジェクトに関連する問題について議論します。また、「Pull Requests」タブでは、進行中の変更について議論やレビューが行われます。 プロジェクトによっては、フォーラム、メーリングリスト、Slack、Discord、IRC などのチャットチャンネルで議論が行われることもあります。 ✅ 新しい GitHub リポジトリを見て回り、設定を編集したり、リポジトリに情報を追加したり、プロジェクト（例えばカンバンボード）を作成したりしてみてください。できることはたくさんあります！ 🚀 チャレンジ 友達とペアを組んでお互いのコードに取り組みましょう。共同でプロジェクトを作成し、コードをフォークし、ブランチを作成し、変更をマージしてください。 講義後のクイズ 講義後のクイズ 復習と自己学習 オープンソースソフトウェアへの貢献についてをさらに読んでみましょう。 Git チートシート。 練習、練習、練習。GitHub には skillsgithub",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1695,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "0f73ae2d7b8812c39437fcea0dc4df34",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
    "source_type": "git_repo",
    "title": "GitHubの概要",
    "content": "上記のコマンドはフォークしたリポジトリにブランチを作成します。 PRを開く。次に、PRを開きます。フォークしたリポジトリのGitHubページに移動します。GitHubで新しいPRを作成するかどうかを尋ねる表示があり、それをクリックすると、コミットメッセージのタイトルを変更したり、より適切な説明を追加したりするインターフェースに移動します。これで、フォークしたリポジトリのメンテナーがこのPRを確認し、うまくいけば PRを評価してマージしてくれるでしょう。これで貢献者になりました、やったね！ クリーンアップ。PRが正常にマージされた後は、クリーンアップすることが良い習慣とされています。ローカルブランチとGitHubにプッシュしたブランチの両方をクリーンアップしたいと思います。まず、以下のコマンドでローカルブランチを削除します： bash git branch -d [branch-name] GitHub のフォークしたリポジトリのページに移動し、先ほどプッシュしたリモートブランチを削除してください。 Pull request（プルリクエスト）という言葉は少し変に思えるかもしれません。実際にはプロジェクトに変更を「プッシュ」したいわけですが、メンテナー（プロジェクトの所有者）やコアチームがその変更をプロジェクトの「メイン」ブランチにマージする前に検討する必要があります。つまり、メンテナーに変更の判断を「リクエスト」しているのです。 プルリクエストは、ブランチで導入された差分をレビュー、コメント、統合テストなどを通じて比較・議論する場です。良いプルリクエストは、コミットメッセージとほぼ同じルールに従います。例えば、作業が特定の課題を解決する場合、課題トラッカーの課題番号を参照として追加できます。これは # に続けて課題番号を記載することで行います。例: #97 🤞すべてのチェックが通り、プロジェクトの所有者があなたの変更をプロジェクトにマージしてくれることを祈りましょう🤞 現在のローカル作業ブランチを GitHub 上の対応するリモートブランチの新しいコミットで更新するには、以下を実行します： git pull オープンソースへの貢献方法 まず、GitHub 上で興味のあるリポジトリ（または repo）を見つけ、そこに変更を加えたいと思ったら、その内容を自分のマシンにコピーします。 ✅ '初心者向け' のリポジトリを見つける良い方法は、タグ 'good-first-issue' で検索することです。 コードをコピーする方法はいくつかあります。一つの方法は、HTTPS、SSH、または GitHub CLI（コマンドラインインターフェース）を使用してリポジトリの内容を「クローン」することです。 ターミナルを開き、以下のようにリポジトリをクローンします： git clone https://githubcom/ProjectURL プロジェクトで作業するには、正しいフォルダに移動します： cd ProjectURL また、Codespaces（GitHub の組み込みコードエディタ/クラウド開発環境）や GitHub Desktop を使用してプロジェクト全体を開くこともできます。 最後に、コードを zip フォルダとしてダウンロードすることも可能です。 GitHub に関するいくつかの興味深いポイント GitHub 上の公開リポジトリは、スターを付けたり、ウォッチしたり、「フォーク」したりすることができます。スターを付けたリポジトリは、右上のドロップダウンメニューから確認できます。これはコードのブックマークのようなものです。 プロジェクトには、通常 GitHub の「Issues」タブにある課題トラッカーがあり、そこでプロジェクトに関連する問題について議論します。また、「Pull Requests」タブでは、進行中の変更について議論やレビューが行われます。 プロジェクトによっては、フォーラム、メーリングリスト、Slack、Discord、IRC などのチャットチャンネルで議論が行われることもあります。 ✅ 新しい GitHub リポジトリを見て回り、設定を編集したり、リポジトリに情報を追加したり、プロジェクト（例えばカンバンボード）を作成したりしてみてください。できることはたくさんあります！ 🚀 チャレンジ 友達とペアを組んでお互いのコードに取り組みましょう。共同でプロジェクトを作成し、コードをフォークし、ブランチを作成し、変更をマージしてください。 講義後のクイズ 講義後のクイズ 復習と自己学習 オープンソースソフトウェアへの貢献についてをさらに読んでみましょう。 Git チートシート。 練習、練習、練習。GitHub には skillsgithubcom を通じて素晴らしい学習パスが用意されています：\nGitHub の最初の一週間\nさらに高度なコースも見つかります。\n課題\nGitHub の最初の一週間コースを完了してください。\n免責事項:\nこの文書は、AI翻訳サービス Co-op Translator を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があることをご承知ください。元の言語で記載された文書が正式な情報源とみなされるべきです。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当方は一切の責任を負いません。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 22663,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\ja\\1-getting-started-lessons\\2-github-basics\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1966,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "a9bef3c963d402919e1ebed36e19a254",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\assignment.md",
    "source_type": "git_repo",
    "title": "改善路由",
    "content": "改善路由\n指引\n目前的路由宣告僅包含要使用的模板 ID，但在顯示新頁面時，有時需要更多功能。讓我們透過以下兩個額外功能來改進路由的實現：\n為每個模板設定標題，並在模板變更時更新窗口標題為新標題。\n增加一個選項，在模板變更後執行一些程式碼。我們希望每次顯示儀表板頁面時，在開發者主控台中打印 'Dashboard is shown'。\n評分標準\n| 評分標準 | 卓越                                                                                                                          | 合格                                                                                                                                                                                  | 需要改進                                       |\n| -------- | ----------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |\n|          | 兩個功能均已實現並正常運作。標題和程式碼新增功能也適用於在 routes 宣告中新增的路由。                                           | 兩個功能均正常運作，但行為是硬編碼的，無法透過 routes 宣告進行配置。新增第三個具有標題和程式碼新增功能的路由無法運作或僅部分運作。                                                   | 其中一個功能缺失或未正常運作。                 |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2409,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 577,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "cc4e8bd25a779cfdf48cdec54627f064",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "使用 vscode dev 建立履歷網站\n有沒有想過，當招聘人員要求你的履歷時，你可以直接給他們一個網址？ 😎\n目標\n完成這個任務後，你將學會：\n建立一個網站來展示你的履歷\n先決條件\n一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n步驟\n步驟 1： 建立一個新的 GitHub 儲存庫，命名為 my-resume\n步驟 2： 在你的儲存庫中建立一個 index html 文件。我們需要在 github com 上至少新增一個文件，因為空的儲存庫無法在 vscode dev 中打開。\n點擊 creating a new file 連結，輸入文件名稱 index html，然後選擇 Commit new file 按鈕。\n步驟 3： 打開 VSCode dev，選擇 Open Remote Repository 按鈕。\n複製你剛剛為履歷網站建立的儲存庫網址，並將其貼到輸入框中：\n將 your-username 替換為你的 GitHub 使用者名稱\nhttps://github com/your-username/my-resume\n✅ 如果成功，你將在瀏覽器的文字編輯器中看到你的專案和 index html 文件。\n步驟 4： 打開 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 448,
    "chunk_index": 0,
    "total_chunks": 12
  },
  {
    "id": "e7d9fab574445ce72084cb79782f540a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "使用 vscode dev 建立履歷網站\n有沒有想過，當招聘人員要求你的履歷時，你可以直接給他們一個網址？ 😎\n目標\n完成這個任務後，你將學會：\n建立一個網站來展示你的履歷\n先決條件\n一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n步驟\n步驟 1： 建立一個新的 GitHub 儲存庫，命名為 my-resume\n步驟 2： 在你的儲存庫中建立一個 index html 文件。我們需要在 github com 上至少新增一個文件，因為空的儲存庫無法在 vscode dev 中打開。\n點擊 creating a new file 連結，輸入文件名稱 index html，然後選擇 Commit new file 按鈕。\n步驟 3： 打開 VSCode dev，選擇 Open Remote Repository 按鈕。\n複製你剛剛為履歷網站建立的儲存庫網址，並將其貼到輸入框中：\n將 your-username 替換為你的 GitHub 使用者名稱\nhttps://github com/your-username/my-resume\n✅ 如果成功，你將在瀏覽器的文字編輯器中看到你的專案和 index html 文件。\n步驟 4： 打開 indexhtml 文件，將以下代碼貼到你的代碼區域並保存。\n負責履歷網站內容的 HTML 代碼。\n你的名字在這裡！\n你的名字在這裡！\n你的角色！\n聯絡方式\n在這裡填寫你的電子郵件\n在這裡填寫你的 GitHub 使用者名稱！\n在這裡填寫你的 LinkedIn 使用者名稱！\n技能\n技能 1！\n技能 2！\n技能 3！\n技能 4！\n教育背景\n在這裡填寫你的課程！\n在這裡填寫你的學校名稱！\n開始日期 - 結束日期\n關於我\n在這裡寫一些關於自己的簡介！\n工作經驗\n職位名稱\n在這裡填寫公司名稱 | 開始月份 – 結束月份\n任務 1 - 在這裡填寫你做了什麼！\n任務 2 - 在這裡填寫你做了什麼！\n填寫你的貢獻成果/影響\n職位名稱 2\n在這裡填寫公司名稱 | 開始月份 – 結束月份\n任務 1 - 在這裡填寫你做了什麼！\n任務 2 - 在這裡填寫你做了什麼！\n填寫你的貢獻成果/影響\n將你的履歷細節替換掉 HTML 代碼中的 佔位文字。\n步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 965,
    "chunk_index": 1,
    "total_chunks": 12
  },
  {
    "id": "51d7fa3144e818827482d3565d786330",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "indexhtml 文件，將以下代碼貼到你的代碼區域並保存。 負責履歷網站內容的 HTML 代碼。 你的名字在這裡！ 你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始日期 - 結束日期 關於我 在這裡寫一些關於自己的簡介！ 工作經驗 職位名稱 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 職位名稱 2 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 將你的履歷細節替換掉 HTML 代碼中的 佔位文字。 步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File圖標，並在你的專案中建立兩個新文件：style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 539,
    "chunk_index": 2,
    "total_chunks": 12
  },
  {
    "id": "da68b247697124dbecfaec4fc405f6df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "indexhtml 文件，將以下代碼貼到你的代碼區域並保存。 負責履歷網站內容的 HTML 代碼。 你的名字在這裡！ 你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始日期 - 結束日期 關於我 在這裡寫一些關於自己的簡介！ 工作經驗 職位名稱 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 職位名稱 2 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 將你的履歷細節替換掉 HTML 代碼中的 佔位文字。 步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File圖標，並在你的專案中建立兩個新文件：stylecss 和 codeswing",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 543,
    "chunk_index": 3,
    "total_chunks": 12
  },
  {
    "id": "17579a10fdacf0e9b2ba2fdcfff1bc66",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "負責履歷網站內容的 HTML 代碼。 你的名字在這裡！ 你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始日期 - 結束日期 關於我 在這裡寫一些關於自己的簡介！ 工作經驗 職位名稱 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 職位名稱 2 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 將你的履歷細節替換掉 HTML 代碼中的 佔位文字。 步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File圖標，並在你的專案中建立兩個新文件：stylecss 和 codeswingjson。\n步驟 6： 打開 style",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 528,
    "chunk_index": 4,
    "total_chunks": 12
  },
  {
    "id": "0bc549a3c5f96cfa7372df4b9338f0a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "你的名字在這裡！ 你的角色！ 聯絡方式 在這裡填寫你的電子郵件 在這裡填寫你的 GitHub 使用者名稱！ 在這裡填寫你的 LinkedIn 使用者名稱！ 技能 技能 1！ 技能 2！ 技能 3！ 技能 4！ 教育背景 在這裡填寫你的課程！ 在這裡填寫你的學校名稱！ 開始日期 - 結束日期 關於我 在這裡寫一些關於自己的簡介！ 工作經驗 職位名稱 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 職位名稱 2 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 將你的履歷細節替換掉 HTML 代碼中的 佔位文字。 步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File圖標，並在你的專案中建立兩個新文件：stylecss 和 codeswingjson。 步驟 6： 打開 stylecss 文件，將以下代碼貼上並保存。\n格式化網站佈局的 CSS 代碼。\nbody {\nfont-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\nfont-size: 16px;\nmax-width: 960px;\nmargin: auto;\n}\nh1 {\nfont-size: 3em;\nletter-spacing:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 579,
    "chunk_index": 5,
    "total_chunks": 12
  },
  {
    "id": "c50026c95b1d761a3cba5eb5b30f0dc3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "關於我 在這裡寫一些關於自己的簡介！ 工作經驗 職位名稱 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 職位名稱 2 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 將你的履歷細節替換掉 HTML 代碼中的 佔位文字。 步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File圖標，並在你的專案中建立兩個新文件：stylecss 和 codeswingjson。 步驟 6： 打開 stylecss 文件，將以下代碼貼上並保存。 格式化網站佈局的 CSS 代碼。 body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em;\npadding-top: 1em;\npadding-bottom: 1em;\n}\nh2 {\nfont-size: 1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 457,
    "chunk_index": 6,
    "total_chunks": 12
  },
  {
    "id": "a7dd40eda48fccebce4e7654c879da67",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 職位名稱 2 在這裡填寫公司名稱 | 開始月份 – 結束月份 任務 1 - 在這裡填寫你做了什麼！ 任務 2 - 在這裡填寫你做了什麼！ 填寫你的貢獻成果/影響 將你的履歷細節替換掉 HTML 代碼中的 佔位文字。 步驟 5： 在 My-Resume 資料夾上方懸停，點擊 New File圖標，並在你的專案中建立兩個新文件：stylecss 和 codeswingjson。 步驟 6： 打開 stylecss 文件，將以下代碼貼上並保存。 格式化網站佈局的 CSS 代碼。 body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em; padding-top: 1em; padding-bottom: 1em; } h2 { font-size: 15em;\npadding-bottom: 1em;\n}\nh3 {\nfont-size: 1em;\npadding-bottom: 1em;\n}\nmain {\ndisplay: grid;\ngrid-template-columns: 40% 60%;\nmargin-top: 3em;\n}\nheader {\ntext-align: center;\nmargin: auto 2em;\n}\nsection {\nmargin: auto 1em 4em 2em;\n}\ni {\nmargin-right: 5em;\n}\np {\nmargin:",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 485,
    "chunk_index": 7,
    "total_chunks": 12
  },
  {
    "id": "8ec5336413d38f31286837ab2ae9a4c0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "CSS 代碼。 body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 16px; max-width: 960px; margin: auto; } h1 { font-size: 3em; letter-spacing:6em; padding-top: 1em; padding-bottom: 1em; } h2 { font-size: 15em; padding-bottom: 1em; } h3 { font-size: 1em; padding-bottom: 1em; } main { display: grid; grid-template-columns: 40% 60%; margin-top: 3em; } header { text-align: center; margin: auto 2em; } section { margin: auto 1em 4em 2em; } i { margin-right: 5em; } p { margin:2em auto\n}\nhr {\nborder: none;\nbackground-color: lightgray;\nheight: 1px;\n}\nh1, h2, h3 {\nfont-weight: 100;\nmargin-bottom: 0;\n}\n#mainLeft {\nborder-right: 1px solid lightgray;\n}\n步驟 6： 打開 codeswing",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 253,
    "chunk_index": 8,
    "total_chunks": 12
  },
  {
    "id": "48814b7054f5ba52e4e03ea8350a1c61",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "15em; padding-bottom: 1em; } h3 { font-size: 1em; padding-bottom: 1em; } main { display: grid; grid-template-columns: 40% 60%; margin-top: 3em; } header { text-align: center; margin: auto 2em; } section { margin: auto 1em 4em 2em; } i { margin-right: 5em; } p { margin:2em auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } 步驟 6： 打開 codeswingjson 文件，將以下代碼貼上並保存。\n{\n\"scripts\": [],\n\"styles\": []\n}\n步驟 7： 安裝 Codeswing extension 以在代碼區域中預覽履歷網站。\n點擊活動欄上的 Extensions 圖標，輸入 Codeswing。點擊擴展活動欄上的 藍色安裝按鈕 或在選擇擴展後使用代碼區域中出現的安裝按鈕來安裝。安裝擴展後，觀察你的代碼區域以查看專案的變化 😃\n安裝擴展後，你的屏幕上將看到以下內容。\n如果你對所做的更改感到滿意，懸停在 Changes 資料夾上，點擊 + 按鈕以暫存更改。\n輸入提交訊息 (描述你對專案所做的更改)，並點擊 check 提交更改。完成專案後，選擇左上角的漢堡菜單圖標返回 GitHub 上的儲存庫。\n恭喜 🎉 你已經使用 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 521,
    "chunk_index": 9,
    "total_chunks": 12
  },
  {
    "id": "eacc6073add176c1a437530c0547efc6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "} i { margin-right: 5em; } p { margin:2em auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } 步驟 6： 打開 codeswingjson 文件，將以下代碼貼上並保存。 { \"scripts\": [], \"styles\": [] } 步驟 7： 安裝 Codeswing extension 以在代碼區域中預覽履歷網站。 點擊活動欄上的 Extensions 圖標，輸入 Codeswing。點擊擴展活動欄上的 藍色安裝按鈕 或在選擇擴展後使用代碼區域中出現的安裝按鈕來安裝。安裝擴展後，觀察你的代碼區域以查看專案的變化 😃 安裝擴展後，你的屏幕上將看到以下內容。 如果你對所做的更改感到滿意，懸停在 Changes 資料夾上，點擊 + 按鈕以暫存更改。 輸入提交訊息 (描述你對專案所做的更改)，並點擊 check 提交更改。完成專案後，選擇左上角的漢堡菜單圖標返回 GitHub 上的儲存庫。 恭喜 🎉 你已經使用 vscodedev 在幾個步驟內建立了你的履歷網站。\n🚀 挑戰\n打開一個你有權限進行更改的遠端儲存庫，更新一些文件。接下來，嘗試建立一個包含更改的新分支並提交 Pull Request。\n回顧與自學\n閱讀更多關於 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 557,
    "chunk_index": 10,
    "total_chunks": 12
  },
  {
    "id": "ee1894bf7750728a0e3fb0f760c32281",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
    "source_type": "git_repo",
    "title": "你的名字在這裡！",
    "content": "auto } hr { border: none; background-color: lightgray; height: 1px; } h1, h2, h3 { font-weight: 100; margin-bottom: 0; } #mainLeft { border-right: 1px solid lightgray; } 步驟 6： 打開 codeswingjson 文件，將以下代碼貼上並保存。 { \"scripts\": [], \"styles\": [] } 步驟 7： 安裝 Codeswing extension 以在代碼區域中預覽履歷網站。 點擊活動欄上的 Extensions 圖標，輸入 Codeswing。點擊擴展活動欄上的 藍色安裝按鈕 或在選擇擴展後使用代碼區域中出現的安裝按鈕來安裝。安裝擴展後，觀察你的代碼區域以查看專案的變化 😃 安裝擴展後，你的屏幕上將看到以下內容。 如果你對所做的更改感到滿意，懸停在 Changes 資料夾上，點擊 + 按鈕以暫存更改。 輸入提交訊息 (描述你對專案所做的更改)，並點擊 check 提交更改。完成專案後，選擇左上角的漢堡菜單圖標返回 GitHub 上的儲存庫。 恭喜 🎉 你已經使用 vscodedev 在幾個步驟內建立了你的履歷網站。 🚀 挑戰 打開一個你有權限進行更改的遠端儲存庫，更新一些文件。接下來，嘗試建立一個包含更改的新分支並提交 Pull Request。 回顧與自學 閱讀更多關於 VSCodedev 及其其他功能的資訊。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 10048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 733,
    "chunk_index": 11,
    "total_chunks": 12
  },
  {
    "id": "5b6d3f8dba8e73d46c48e1661f0022f8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "為你的銀行應用程式設計樣式",
    "content": "為你的銀行應用程式設計樣式\n指引\n建立一個新的 styles css 檔案，並在你現有的 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2171,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 49,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "ea861a7648590b5dd75abafe4be9139b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\assignment.md",
    "source_type": "git_repo",
    "title": "為你的銀行應用程式設計樣式",
    "content": "為你的銀行應用程式設計樣式\n指引\n建立一個新的 styles css 檔案，並在你現有的 indexhtml 檔案中加入一個連結到該檔案。在你剛建立的 CSS 檔案中，加入一些樣式，讓 登入 和 儀表板 頁面看起來整潔美觀。嘗試設計一個色彩主題，為你的應用程式打造專屬的品牌形象。\n提示：如果需要，你可以修改 HTML 並新增新的元素和類別。\n評分標準\n| 評分標準 | 優異                                                                                                                   | 合格                                                                         | 需要改進                                                                                     |\n| -------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------- |\n|          | 所有頁面看起來整潔易讀，擁有一致的色彩主題，不同的區塊能夠清晰地突顯出來。                                               | 頁面有樣式，但缺乏主題，或者區塊未能清楚地劃分。                               | 頁面缺乏樣式，區塊看起來雜亂無章，資訊難以閱讀。                                             |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2171,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 552,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "0593676db1ef753d2465f76f3cbd3974",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 422,
    "chunk_index": 0,
    "total_chunks": 21
  },
  {
    "id": "26d242ba4bcb2f4f5fd0f4d53848cde5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似於以下圖片：\n主要有三個區域，從最左邊到右邊依次為：\n活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動欄，預設為 檔案總管，稱為 側邊欄。\n最右邊是程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。\n當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。\n開啟 GitHub 儲存庫\n首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 811,
    "chunk_index": 1,
    "total_chunks": 21
  },
  {
    "id": "589ca72cd7c30af89b85a709ce7c9c3c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似於以下圖片：\n主要有三個區域，從最左邊到右邊依次為：\n活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動欄，預設為 檔案總管，稱為 側邊欄。\n最右邊是程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。\n當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。\n開啟 GitHub 儲存庫\n首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。\n1使用編輯器\n使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 850,
    "chunk_index": 2,
    "total_chunks": 21
  },
  {
    "id": "f70ce8e5287da646e6e5e06a82da4b86",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似於以下圖片：\n主要有三個區域，從最左邊到右邊依次為：\n活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動欄，預設為 檔案總管，稱為 側邊欄。\n最右邊是程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。\n當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。\n開啟 GitHub 儲存庫\n首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。\n1使用編輯器\n使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕：\n你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。\n當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中：\nhttps://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1120,
    "chunk_index": 3,
    "total_chunks": 21
  },
  {
    "id": "3a38a803238f3c10477b39f4004f3b5c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似於以下圖片：\n主要有三個區域，從最左邊到右邊依次為：\n活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動欄，預設為 檔案總管，稱為 側邊欄。\n最右邊是程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。\n當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。\n開啟 GitHub 儲存庫\n首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。\n1使用編輯器\n使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕：\n你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。\n當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中：\nhttps://githubcom/microsoft/Web-Dev-For-Beginners\n✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1171,
    "chunk_index": 4,
    "total_chunks": 21
  },
  {
    "id": "c91d98c398451885353359b55f6ee7b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似於以下圖片：\n主要有三個區域，從最左邊到右邊依次為：\n活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動欄，預設為 檔案總管，稱為 側邊欄。\n最右邊是程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。\n當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。\n開啟 GitHub 儲存庫\n首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。\n1使用編輯器\n使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕：\n你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。\n當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中：\nhttps://githubcom/microsoft/Web-Dev-For-Beginners\n✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。\n2使用 URL\n你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1213,
    "chunk_index": 5,
    "total_chunks": 21
  },
  {
    "id": "49e98e95577bdfd6df4f013f963b04df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "使用程式碼編輯器\n本課程涵蓋了使用 VSCode dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。\n學習目標\n在本課程中，你將學會：\n在程式碼專案中使用程式碼編輯器\n使用版本控制追蹤變更\n自訂編輯器以進行開發\n先決條件\n在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。\n簡介\n程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。\n開始使用 VSCode dev\nVSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。\n載入後，畫面應該看起來類似於以下圖片：\n主要有三個區域，從最左邊到右邊依次為：\n活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。\n展開的活動欄，預設為 檔案總管，稱為 側邊欄。\n最右邊是程式碼區域。\n點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。\n當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。\n開啟 GitHub 儲存庫\n首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。\n1使用編輯器\n使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕：\n你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。\n當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中：\nhttps://githubcom/microsoft/Web-Dev-For-Beginners\n✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。\n2使用 URL\n你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1245,
    "chunk_index": 6,
    "total_chunks": 21
  },
  {
    "id": "3b92b24d4ed691495403b5c6e9b7b674",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "dev（一個基於網頁的程式碼編輯器）的基礎知識，讓你可以在不需要在電腦上安裝任何軟件的情況下修改程式碼並為專案作出貢獻。 學習目標 在本課程中，你將學會： 在程式碼專案中使用程式碼編輯器 使用版本控制追蹤變更 自訂編輯器以進行開發 先決條件 在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。 開始使用 VSCode dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1254,
    "chunk_index": 7,
    "total_chunks": 21
  },
  {
    "id": "349b2f38dd1aa2ea89661dc37ddc78c5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "在程式碼專案中使用程式碼編輯器 使用版本控制追蹤變更 自訂編輯器以進行開發 先決條件 在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。 開始使用 VSCode dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。\n編輯檔案\n當你在瀏覽器或 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1184,
    "chunk_index": 8,
    "total_chunks": 21
  },
  {
    "id": "9b9566131868ca4a49a87d4e4af6f78f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "先決條件 在開始之前，你需要先建立一個 GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。 開始使用 VSCode dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1167,
    "chunk_index": 9,
    "total_chunks": 21
  },
  {
    "id": "8e7bb28b30ac3a1bc1ce96fabbce63db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "GitHub 帳戶。如果你還沒有帳戶，請前往 GitHub 註冊。 簡介 程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。 開始使用 VSCode dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案\n你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1249,
    "chunk_index": 10,
    "total_chunks": 21
  },
  {
    "id": "2831602e0cbe6d68f6d46a53f22f3db7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "註冊。 簡介 程式碼編輯器是撰寫程式和與現有程式專案協作的重要工具。一旦你了解了編輯器的基礎知識以及如何利用其功能，你就可以在撰寫程式碼時應用這些技能。 開始使用 VSCode dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1243,
    "chunk_index": 11,
    "total_chunks": 21
  },
  {
    "id": "d9c15bcff22e2f3bfa636a769982f06d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "開始使用 VSCode dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案\n使用 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1168,
    "chunk_index": 12,
    "total_chunks": 21
  },
  {
    "id": "bd4fa9177f9c3fa40c6a5acadec291fb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "dev VSCode dev 是一個基於網頁的程式碼編輯器。你不需要安裝任何東西，就像打開其他網站一樣簡單。要開始使用編輯器，請打開以下連結：https://vscodedev。如果你尚未登入 GitHub，請按照提示登入或建立新帳戶後再登入。 載入後，畫面應該看起來類似於以下圖片： 主要有三個區域，從最左邊到右邊依次為： 活動欄，包含一些圖示，例如放大鏡 🔎、齒輪 ⚙️ 等。 展開的活動欄，預設為 檔案總管，稱為 側邊欄。 最右邊是程式碼區域。 點擊每個圖示以顯示不同的選單。完成後，點擊 檔案總管，回到初始畫面。 當你開始撰寫程式碼或修改現有程式碼時，這些操作將在右側最大的區域進行。你也會在這裡查看現有程式碼，接下來我們將進一步探討。 開啟 GitHub 儲存庫 首先，你需要開啟一個 GitHub 儲存庫。有多種方式可以開啟儲存庫。在本節中，我們將介紹兩種不同的方法，讓你可以開始進行修改。 1使用編輯器 使用編輯器本身來開啟遠端儲存庫。如果你訪問 VSCodedev，你會看到一個 \"Open Remote Repository\" 按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 是一個方便的方式，當你想快速更新專案而不需要在本地載入任何軟件時。\n要更新程式碼，點擊活動欄上的 檔案總管 圖示，查看儲存庫中的檔案和資料夾。選擇一個檔案以在程式碼區域中打開，進行修改並儲存。\n完成專案更新後，選擇 原始碼控制 圖示，這裡包含了你對儲存庫所做的所有新變更。\n要查看你對專案所做的變更，選擇展開的活動欄中 Changes 資料夾中的檔案。這將打開一個 '工作樹'，讓你直觀地查看檔案的變更。紅色表示刪除的部分，而綠色表示新增的部分。\n如果你對所做的變更感到滿意，將滑鼠移到 Changes 資料夾上，然後點擊 + 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。\n如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。\n接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。\n完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1673,
    "chunk_index": 13,
    "total_chunks": 21
  },
  {
    "id": "96fa3a5159669e2418c60712886e262b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "按鈕： 你也可以使用命令面板。命令面板是一個輸入框，你可以在其中輸入任何與命令或操作相關的字詞來找到正確的命令。使用左上角的選單，然後選擇 檢視，接著選擇 命令面板，或者使用以下鍵盤快捷鍵：Ctrl-Shift-P（在 MacOS 上為 Command-Shift-P）。 當選單打開後，輸入 open remote repository，然後選擇第一個選項。你參與的或最近開啟的多個儲存庫將顯示出來。你也可以使用完整的 GitHub URL 來選擇一個儲存庫。將以下 URL 貼入輸入框中： https://githubcom/microsoft/Web-Dev-For-Beginners ✅ 如果成功，你將看到該儲存庫的所有檔案載入到文字編輯器中。 2使用 URL 你也可以直接使用 URL 來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 是一個方便的方式，當你想快速更新專案而不需要在本地載入任何軟件時。 要更新程式碼，點擊活動欄上的 檔案總管 圖示，查看儲存庫中的檔案和資料夾。選擇一個檔案以在程式碼區域中打開，進行修改並儲存。 完成專案更新後，選擇 原始碼控制 圖示，這裡包含了你對儲存庫所做的所有新變更。 要查看你對專案所做的變更，選擇展開的活動欄中 Changes 資料夾中的檔案。這將打開一個 '工作樹'，讓你直觀地查看檔案的變更。紅色表示刪除的部分，而綠色表示新增的部分。 如果你對所做的變更感到滿意，將滑鼠移到 Changes 資料夾上，然後點擊 + 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。 如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。\n使用擴展功能\n在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。\n要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。\n你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1525,
    "chunk_index": 14,
    "total_chunks": 21
  },
  {
    "id": "dc0f759a5ce9d95d49f3f65228d2ecec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "來載入儲存庫。例如，目前儲存庫的完整 URL 是 https://githubcom/microsoft/Web-Dev-For-Beginners，但你可以將 GitHub 網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 是一個方便的方式，當你想快速更新專案而不需要在本地載入任何軟件時。 要更新程式碼，點擊活動欄上的 檔案總管 圖示，查看儲存庫中的檔案和資料夾。選擇一個檔案以在程式碼區域中打開，進行修改並儲存。 完成專案更新後，選擇 原始碼控制 圖示，這裡包含了你對儲存庫所做的所有新變更。 要查看你對專案所做的變更，選擇展開的活動欄中 Changes 資料夾中的檔案。這將打開一個 '工作樹'，讓你直觀地查看檔案的變更。紅色表示刪除的部分，而綠色表示新增的部分。 如果你對所做的變更感到滿意，將滑鼠移到 Changes 資料夾上，然後點擊 + 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。 如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。 使用擴展功能 在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。 要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。 你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。 1安裝擴展功能\n要安裝擴展功能，在搜尋框中輸入擴展名稱，然後點擊它以在程式碼區域中查看該擴展的更多資訊（當它出現在展開的活動欄中時）。\n你可以點擊展開活動欄上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1388,
    "chunk_index": 15,
    "total_chunks": 21
  },
  {
    "id": "fd39221f7e998c32751a0f160d9455b9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "網域替換為 VSCodedev/github，直接載入儲存庫。結果 URL 將是 https://vscodedev/github/microsoft/Web-Dev-For-Beginners。 編輯檔案 當你在瀏覽器或 vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 是一個方便的方式，當你想快速更新專案而不需要在本地載入任何軟件時。 要更新程式碼，點擊活動欄上的 檔案總管 圖示，查看儲存庫中的檔案和資料夾。選擇一個檔案以在程式碼區域中打開，進行修改並儲存。 完成專案更新後，選擇 原始碼控制 圖示，這裡包含了你對儲存庫所做的所有新變更。 要查看你對專案所做的變更，選擇展開的活動欄中 Changes 資料夾中的檔案。這將打開一個 '工作樹'，讓你直觀地查看檔案的變更。紅色表示刪除的部分，而綠色表示新增的部分。 如果你對所做的變更感到滿意，將滑鼠移到 Changes 資料夾上，然後點擊 + 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。 如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。 使用擴展功能 在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。 要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。 你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。 1安裝擴展功能 要安裝擴展功能，在搜尋框中輸入擴展名稱，然後點擊它以在程式碼區域中查看該擴展的更多資訊（當它出現在展開的活動欄中時）。 你可以點擊展開活動欄上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。 2自訂擴展功能\n安裝擴展後，你可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴展圖示，這次你的擴展將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航到 擴展設定。\n3",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1467,
    "chunk_index": 16,
    "total_chunks": 21
  },
  {
    "id": "16a67b520499b8d8204031ab4409357a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "vscodedev 上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 是一個方便的方式，當你想快速更新專案而不需要在本地載入任何軟件時。 要更新程式碼，點擊活動欄上的 檔案總管 圖示，查看儲存庫中的檔案和資料夾。選擇一個檔案以在程式碼區域中打開，進行修改並儲存。 完成專案更新後，選擇 原始碼控制 圖示，這裡包含了你對儲存庫所做的所有新變更。 要查看你對專案所做的變更，選擇展開的活動欄中 Changes 資料夾中的檔案。這將打開一個 '工作樹'，讓你直觀地查看檔案的變更。紅色表示刪除的部分，而綠色表示新增的部分。 如果你對所做的變更感到滿意，將滑鼠移到 Changes 資料夾上，然後點擊 + 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。 如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。 使用擴展功能 在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。 要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。 你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。 1安裝擴展功能 要安裝擴展功能，在搜尋框中輸入擴展名稱，然後點擊它以在程式碼區域中查看該擴展的更多資訊（當它出現在展開的活動欄中時）。 你可以點擊展開活動欄上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。 2自訂擴展功能 安裝擴展後，你可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴展圖示，這次你的擴展將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航到 擴展設定。 3管理擴展功能\n安裝並使用擴展後，vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1412,
    "chunk_index": 17,
    "total_chunks": 21
  },
  {
    "id": "74c23dc89a7d1c858a74983e389c9f63",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "上開啟儲存庫後，下一步就是對專案進行更新或修改。 1建立新檔案 你可以在現有的資料夾中建立檔案，或者在根目錄/資料夾中建立檔案。要建立新檔案，打開你希望儲存檔案的位置/目錄，然後選擇活動欄（左側）上的 'New file' 圖示，為檔案命名並按下 Enter。 2編輯並儲存儲存庫中的檔案 使用 vscodedev 是一個方便的方式，當你想快速更新專案而不需要在本地載入任何軟件時。 要更新程式碼，點擊活動欄上的 檔案總管 圖示，查看儲存庫中的檔案和資料夾。選擇一個檔案以在程式碼區域中打開，進行修改並儲存。 完成專案更新後，選擇 原始碼控制 圖示，這裡包含了你對儲存庫所做的所有新變更。 要查看你對專案所做的變更，選擇展開的活動欄中 Changes 資料夾中的檔案。這將打開一個 '工作樹'，讓你直觀地查看檔案的變更。紅色表示刪除的部分，而綠色表示新增的部分。 如果你對所做的變更感到滿意，將滑鼠移到 Changes 資料夾上，然後點擊 + 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。 如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。 使用擴展功能 在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。 要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。 你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。 1安裝擴展功能 要安裝擴展功能，在搜尋框中輸入擴展名稱，然後點擊它以在程式碼區域中查看該擴展的更多資訊（當它出現在展開的活動欄中時）。 你可以點擊展開活動欄上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。 2自訂擴展功能 安裝擴展後，你可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴展圖示，這次你的擴展將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航到 擴展設定。 3管理擴展功能 安裝並使用擴展後，vscodedev 提供了基於不同需求管理擴展的選項。例如，你可以選擇：\n停用：（當你暫時不需要某個擴展但又不想完全卸載它時，可以選擇停用）\n選擇展開活動欄中的已安裝擴展 > 點擊齒輪圖示 > 選擇 '停用' 或 '停用（工作區）' 或 在程式碼區域中打開擴展並點擊藍色停用按鈕。\n卸載： 選擇展開活動欄中的已安裝擴展 > 點擊齒輪圖示 > 選擇 '卸載' 或 在程式碼區域中打開擴展並點擊藍色卸載按鈕。\n作業\n使用 vscode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1681,
    "chunk_index": 18,
    "total_chunks": 21
  },
  {
    "id": "dbb559f75ed8870992d478335c183387",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "+ 按鈕以暫存變更。暫存的意思是準備好將變更提交到 GitHub。 如果你對某些變更不滿意並希望捨棄它們，將滑鼠移到 Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。 使用擴展功能 在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。 要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。 你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。 1安裝擴展功能 要安裝擴展功能，在搜尋框中輸入擴展名稱，然後點擊它以在程式碼區域中查看該擴展的更多資訊（當它出現在展開的活動欄中時）。 你可以點擊展開活動欄上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。 2自訂擴展功能 安裝擴展後，你可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴展圖示，這次你的擴展將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航到 擴展設定。 3管理擴展功能 安裝並使用擴展後，vscodedev 提供了基於不同需求管理擴展的選項。例如，你可以選擇： 停用：（當你暫時不需要某個擴展但又不想完全卸載它時，可以選擇停用） 選擇展開活動欄中的已安裝擴展 > 點擊齒輪圖示 > 選擇 '停用' 或 '停用（工作區）' 或 在程式碼區域中打開擴展並點擊藍色停用按鈕。 卸載： 選擇展開活動欄中的已安裝擴展 > 點擊齒輪圖示 > 選擇 '卸載' 或 在程式碼區域中打開擴展並點擊藍色卸載按鈕。 作業 使用 vscodedev 建立一個履歷網站\n複習與自學\n閱讀更多關於 VSCode",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1217,
    "chunk_index": 19,
    "total_chunks": 21
  },
  {
    "id": "9c29e0a0dbf888440ad0eb10048cd380",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
    "source_type": "git_repo",
    "title": "使用程式碼編輯器",
    "content": "Changes 資料夾上，然後選擇 撤銷 圖示。 接著，輸入一個 提交訊息（對你所做變更的描述），點擊 勾選圖示 提交並推送你的變更。 完成專案工作後，選擇左上角的 漢堡選單圖示 返回到 githubcom 上的儲存庫。 使用擴展功能 在 VSCode 上安裝擴展功能可以為你的編輯器新增功能並自訂開發環境選項，從而改善你的開發工作流程。這些擴展功能還可以幫助你支援多種程式語言，通常分為通用擴展或基於語言的擴展。 要瀏覽所有可用的擴展功能列表，點擊活動欄上的 擴展圖示，然後在標有 'Search Extensions in Marketplace' 的文字框中開始輸入擴展名稱。你將看到一個擴展列表，每個擴展都包含 擴展名稱、發佈者名稱、一句話描述、下載次數 和 星級評分。 你還可以通過展開 已安裝資料夾 查看所有已安裝的擴展功能，通過 熱門資料夾 查看大多數開發者使用的熱門擴展，或者通過 推薦資料夾 查看基於相同工作區用戶或你最近打開的檔案推薦的擴展。 1安裝擴展功能 要安裝擴展功能，在搜尋框中輸入擴展名稱，然後點擊它以在程式碼區域中查看該擴展的更多資訊（當它出現在展開的活動欄中時）。 你可以點擊展開活動欄上的 藍色安裝按鈕 進行安裝，或者在選擇擴展以載入更多資訊後，使用程式碼區域中出現的安裝按鈕。 2自訂擴展功能 安裝擴展後，你可能需要根據自己的偏好修改其行為並進行自訂。要執行此操作，選擇擴展圖示，這次你的擴展將出現在 已安裝資料夾 中，點擊 齒輪圖示 並導航到 擴展設定。 3管理擴展功能 安裝並使用擴展後，vscodedev 提供了基於不同需求管理擴展的選項。例如，你可以選擇： 停用：（當你暫時不需要某個擴展但又不想完全卸載它時，可以選擇停用） 選擇展開活動欄中的已安裝擴展 > 點擊齒輪圖示 > 選擇 '停用' 或 '停用（工作區）' 或 在程式碼區域中打開擴展並點擊藍色停用按鈕。 卸載： 選擇展開活動欄中的已安裝擴展 > 點擊齒輪圖示 > 選擇 '卸載' 或 在程式碼區域中打開擴展並點擊藍色卸載按鈕。 作業 使用 vscodedev 建立一個履歷網站 複習與自學 閱讀更多關於 VSCodedev 及其其他功能的資訊。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。雖然我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始文件的母語版本應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 9218,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\8-code-editor\\1-using-a-code-editor\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1337,
    "chunk_index": 20,
    "total_chunks": 21
  },
  {
    "id": "45acfcedf5e7bbf74a2a817856fd31a8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "重構及添加註解到你的程式碼",
    "content": "重構及添加註解到你的程式碼\n指引\n隨著你的代碼庫不斷增長，定期重構程式碼對於保持其可讀性和可維護性至關重要。請添加註解並重構你的 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2495,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 90,
    "chunk_index": 0,
    "total_chunks": 2
  },
  {
    "id": "547e84400724c3eec4f79bd82099740e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\assignment.md",
    "source_type": "git_repo",
    "title": "重構及添加註解到你的程式碼",
    "content": "重構及添加註解到你的程式碼\n指引\n隨著你的代碼庫不斷增長，定期重構程式碼對於保持其可讀性和可維護性至關重要。請添加註解並重構你的 appjs，以提升代碼質量：\n抽取常數，例如伺服器 API 的基礎 URL\n將相似的代碼進行統一處理：例如，你可以創建一個 sendRequest() 函數，將 createAccount() 和 getAccount() 中使用的代碼整合起來\n重新組織代碼，使其更易於閱讀，並添加註解\n評分標準\n| 評分標準 | 優秀                                                                                                                                                          | 合格                                                                                             | 有待改進                                                                             |\n| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\n|          | 程式碼有註解，分為不同部分且易於閱讀。常數已被抽取，並創建了一個統一的 sendRequest() 函數。                                                                  | 程式碼乾淨，但仍可通過添加更多註解、抽取常數或進行統一處理來進一步改進。                                                               | 程式碼混亂，沒有註解，常數未被抽取，且代碼未進行統一處理。                                                               |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2495,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 612,
    "chunk_index": 1,
    "total_chunks": 2
  },
  {
    "id": "1f860f8afd9f4313ac4a955b92b98008",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完全功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接使用 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 392,
    "chunk_index": 0,
    "total_chunks": 49
  },
  {
    "id": "9a24fbb145525509a35ca029bbe5a5e9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完全功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接使用 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在您的專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。\n準備工作\n在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 1,
    "total_chunks": 49
  },
  {
    "id": "b091248617743cb811a0332ca7a294be",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完全功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接使用 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在您的專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。\n準備工作\n在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 indexhtml 的檔案。我們將從這個 HTML 樣板開始：\n```html\nBank App\n```\nHTML 模板\n如果您想為網頁建立多個畫面，一種解決方案是為每個您想顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處：\n切換畫面時需要重新載入整個 HTML，可能會很慢。\n在不同畫面之間共享資料會變得困難。\n另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須使用 JavaScript 在執行時實例化。\n任務\n我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後我們將用它來實例化應用程式的不同畫面：\n```html\nLoading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 869,
    "chunk_index": 2,
    "total_chunks": 49
  },
  {
    "id": "0e9afe6f3fb18000e22ffd3b2480fce4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "建立銀行應用程式第一部分：網頁應用程式中的 HTML 模板與路由\n課前測驗\n課前測驗\n簡介\n自從 JavaScript 在瀏覽器中出現以來，網站變得比以往更加互動且複雜。網頁技術現在常被用來直接在瀏覽器中建立完全功能的應用程式，我們稱之為網頁應用程式。由於網頁應用程式高度互動，使用者不希望每次執行操作時都需要等待整個頁面重新載入。因此，JavaScript 被用來直接使用 DOM 更新 HTML，以提供更流暢的使用者體驗。\n在本課程中，我們將建立銀行網頁應用程式的基礎，使用 HTML 模板來建立多個畫面，這些畫面可以顯示並更新，而無需重新載入整個 HTML 頁面。\n先決條件\n您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在您的專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。\n準備工作\n在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 indexhtml 的檔案。我們將從這個 HTML 樣板開始：\n```html\nBank App\n```\nHTML 模板\n如果您想為網頁建立多個畫面，一種解決方案是為每個您想顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處：\n切換畫面時需要重新載入整個 HTML，可能會很慢。\n在不同畫面之間共享資料會變得困難。\n另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須使用 JavaScript 在執行時實例化。\n任務\n我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後我們將用它來實例化應用程式的不同畫面：\n```html\nLoading```\n我們給它一個 id，以便稍後使用 JavaScript 更容易定位它。\n提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。\n接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只會在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。\n```html\nLogin\n```\n然後我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段：\n一個包含標題和登出連結的標頭\n銀行帳戶的當前餘額\n一個以表格顯示的交易列表\n```html\nBalance: 100$\nTransactions\nDate\nObject\nAmount\n```\n提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1194,
    "chunk_index": 3,
    "total_chunks": 49
  },
  {
    "id": "54b05a6e61842c4cfa0fc1a38726c222",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "頁面。 先決條件 您需要一個本地網頁伺服器來測試我們在本課程中建立的網頁應用程式。如果您沒有，可以安裝 Nodejs，並在您的專案資料夾中使用指令 npx lite-server。它將建立一個本地網頁伺服器並在瀏覽器中開啟您的應用程式。 準備工作 在您的電腦上建立一個名為 bank 的資料夾，並在其中建立一個名為 indexhtml 的檔案。我們將從這個 HTML 樣板開始： ```html Bank App ``` HTML 模板 如果您想為網頁建立多個畫面，一種解決方案是為每個您想顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處： 切換畫面時需要重新載入整個 HTML，可能會很慢。 在不同畫面之間共享資料會變得困難。 另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須使用 JavaScript 在執行時實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後我們將用它來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易定位它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只會在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。\n✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？\n使用 JavaScript 顯示模板\n如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 969,
    "chunk_index": 4,
    "total_chunks": 49
  },
  {
    "id": "54466b098a2a1909eac60bcc21217fd4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "樣板開始： ```html Bank App ``` HTML 模板 如果您想為網頁建立多個畫面，一種解決方案是為每個您想顯示的畫面建立一個 HTML 檔案。然而，這種解決方案有一些不便之處： 切換畫面時需要重新載入整個 HTML，可能會很慢。 在不同畫面之間共享資料會變得困難。 另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須使用 JavaScript 在執行時實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後我們將用它來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易定位它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只會在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。\n實例化模板通常分為三個步驟：\n在 DOM 中檢索模板元素，例如使用 document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 836,
    "chunk_index": 5,
    "total_chunks": 49
  },
  {
    "id": "9fb797fa6e960bdb41f3e6c42ce3e6f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "檔案。然而，這種解決方案有一些不便之處： 切換畫面時需要重新載入整個 HTML，可能會很慢。 在不同畫面之間共享資料會變得困難。 另一種方法是僅使用一個 HTML 檔案，並使用 <template> 元素定義多個 HTML 模板。模板是一個可重複使用的 HTML 區塊，瀏覽器不會顯示它，必須使用 JavaScript 在執行時實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後我們將用它來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易定位它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只會在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。\n使用 cloneNode 複製模板元素。\n將其附加到 DOM 中的可見元素，例如使用 appendChild。\n✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？\n任務\n在您的專案資料夾中建立一個名為 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 881,
    "chunk_index": 6,
    "total_chunks": 49
  },
  {
    "id": "5d7a7da208fe8de39ff6b13f505b8917",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "在執行時實例化。 任務 我們將建立一個具有兩個畫面的銀行應用程式：登入頁面和儀表板。首先，讓我們在 HTML 主體中新增一個佔位元素，稍後我們將用它來實例化應用程式的不同畫面： ```html Loading``` 我們給它一個 id，以便稍後使用 JavaScript 更容易定位它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只會在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案：\n```html\n```\n現在在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 765,
    "chunk_index": 7,
    "total_chunks": 49
  },
  {
    "id": "d3fa3ae260b93ea8cbcd9c72e9cd8e7a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "JavaScript 更容易定位它。 提示：由於此元素的內容將被替換，我們可以放置一個載入訊息或指示器，當應用程式載入時會顯示。 接下來，讓我們在 HTML 中新增登入頁面的模板。目前我們只會在其中放置一個標題和一個包含連結的區段，該連結將用於執行導航。 ```html Login ``` 然後我們將新增另一個儀表板頁面的 HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute：\njs\nfunction updateRoute(templateId) {\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 663,
    "chunk_index": 8,
    "total_chunks": 49
  },
  {
    "id": "2afc3d7114d975904ebc1474941d5917",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML 模板。此頁面將包含不同的區段： 一個包含標題和登出連結的標頭 銀行帳戶的當前餘額 一個以表格顯示的交易列表 ```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId);\nconst view = template content",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 9,
    "total_chunks": 49
  },
  {
    "id": "03b22880e45aa5b3646acf2036bf9d5e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "```html Balance: 100$ Transactions Date Object Amount ``` 提示：在建立 HTML 模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true);\nconst app = document getElementById('app');\napp innerHTML = '';\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 10,
    "total_chunks": 49
  },
  {
    "id": "994d97b6b07854335bb5619b32c944f6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "模板時，如果您想查看它的外觀，可以將 <template> 和 </template> 行用 <-- --> 註解掉。 ✅ 您認為我們為什麼使用 id 屬性來標識模板？我們是否可以使用其他方法，例如類別？ 使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view);\n}\n我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。\n現在使用其中一個模板呼叫此函數並查看結果。\njs\nupdateRoute('login');\n✅ 這段程式碼 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 568,
    "chunk_index": 11,
    "total_chunks": 49
  },
  {
    "id": "91e63b96c8f60d5aa5482a5e9a744db9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "使用 JavaScript 顯示模板 如果您在瀏覽器中嘗試目前的 HTML 檔案，您會看到它停留在顯示 Loading。這是因為我們需要新增一些 JavaScript 程式碼來實例化並顯示 HTML 模板。 實例化模板通常分為三個步驟： 在 DOM 中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？\n建立路由\n在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案：\nmywebsite/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 641,
    "chunk_index": 12,
    "total_chunks": 49
  },
  {
    "id": "29313b6adbe61ab13bcf1c6bdc99863a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "中檢索模板元素，例如使用 documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml\nmywebsite/login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 541,
    "chunk_index": 13,
    "total_chunks": 49
  },
  {
    "id": "7d199860105ed3083a34b63992a66274",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "documentgetElementById。 使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml\nmywebsite/admin/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 534,
    "chunk_index": 14,
    "total_chunks": 49
  },
  {
    "id": "d6107f5d884a5caae209e4d971ddaee7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "使用 cloneNode 複製模板元素。 將其附加到 DOM 中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml\n如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是：\nhttps://site",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 569,
    "chunk_index": 15,
    "total_chunks": 49
  },
  {
    "id": "7e82aa736612b2ff2dee8598cc9ffac7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "中的可見元素，例如使用 appendChild。 ✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom            --> mywebsite/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 553,
    "chunk_index": 16,
    "total_chunks": 49
  },
  {
    "id": "c31b3722f7b9d5d2b39b39002829b1c6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "✅ 為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml\nhttps://site",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 545,
    "chunk_index": 17,
    "total_chunks": 49
  },
  {
    "id": "a5fcffbfeb1ed00e156e4f289ea685ec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 18,
    "total_chunks": 49
  },
  {
    "id": "1e1c5c1033b8717612a34644b1c6b273",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "為什麼我們需要在附加到 DOM 之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/login",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 549,
    "chunk_index": 19,
    "total_chunks": 49
  },
  {
    "id": "00f2aa8feb74d275d20e450bf13628fd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "之前複製模板？如果跳過這一步會發生什麼？ 任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml\nhttps://site",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 535,
    "chunk_index": 20,
    "total_chunks": 49
  },
  {
    "id": "b4292a74c6dcd756a45c279293f4b7a3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "任務 在您的專案資料夾中建立一個名為 appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/     --> mywebsite/admin/index",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 512,
    "chunk_index": 21,
    "total_chunks": 49
  },
  {
    "id": "8d84686b2cbe90b7cd0194085faa82d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "appjs 的新檔案，並在 HTML 的 <head> 區段中匯入該檔案： ```html ``` 現在在 appjs 中，我們將建立一個新函數 updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml\n然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。\n任務\n我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 643,
    "chunk_index": 22,
    "total_chunks": 49
  },
  {
    "id": "5de40e4ce413c55080959680182ed704",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "updateRoute： js function updateRoute(templateId) { const template = documentgetElementById(templateId); const view = template contentcloneNode(true); const app = document getElementById('app'); app innerHTML = ''; appappendChild(view); } 我們在這裡執行的正是上述的三個步驟。我們使用 templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard' },\n};\n現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 724,
    "chunk_index": 23,
    "total_chunks": 49
  },
  {
    "id": "bd43966c59b230f1d278043d5d686f57",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 648,
    "chunk_index": 24,
    "total_chunks": 49
  },
  {
    "id": "0da086d1e9d39c3890588e4ca13d20df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templateId 實例化模板，並將其複製的內容放入應用程式的佔位元素中。注意，我們需要使用 cloneNode(true) 來複製模板的整個子樹。 現在使用其中一個模板呼叫此函數並查看結果。 js updateRoute('login'); ✅ 這段程式碼 appinnerHTML = ''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。\n```js\nfunction updateRoute() {\nconst path = window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 678,
    "chunk_index": 25,
    "total_chunks": 49
  },
  {
    "id": "9590cdb9a1433f6b2c09ba38336ed499",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 563,
    "chunk_index": 26,
    "total_chunks": 49
  },
  {
    "id": "e2c8a4a017d5741e3eeea62940f02732",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "''; 的目的是什麼？如果沒有它會發生什麼？ 建立路由 在談論網頁應用程式時，我們稱 路由 為將 URL 映射到應顯示的特定畫面的意圖。在具有多個 HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname;\nconst route = routes[path];\nconst template = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 575,
    "chunk_index": 27,
    "total_chunks": 49
  },
  {
    "id": "618baa100b3a18ff645797f6bd5bdcf2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML 檔案的網站中，這是自動完成的，因為檔案路徑會反映在 URL 上。例如，您的專案資料夾中有以下檔案： mywebsite/indexhtml mywebsite/loginhtml mywebsite/admin/indexhtml 如果您建立一個以 mywebsite 為根的網頁伺服器，URL 映射將是： https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId);\nconst view = template content cloneNode(true);\nconst app = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 28,
    "total_chunks": 49
  },
  {
    "id": "fa23ea6b48d71ce36433214740371ba6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "https://sitecom --> mywebsite/indexhtml https://sitecom/loginhtml --> mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app');\napp innerHTML = '';\napp",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 399,
    "chunk_index": 29,
    "total_chunks": 49
  },
  {
    "id": "29b015299d49d2b1986a2cfa280d7386",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "mywebsite/loginhtml https://sitecom/admin/ --> mywebsite/admin/indexhtml 然而，對於我們的網頁應用程式，我們使用的是包含所有畫面的單一 HTML 檔案，因此這種預設行為對我們沒有幫助。我們必須手動建立這個映射，並使用 JavaScript 更新顯示的模板。 任務 我們將使用一個簡單的物件來實現 映射 URL 路徑與模板之間的關係。在 appjs 檔案的頂部新增此物件。 js const routes = { '/login': { templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view);\n}\n```\n在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。\n✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？\n新增導航功能\n我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事：\n更新當前 URL\n根據新 URL 更新顯示的模板\n我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。\n我們需要使用 JavaScript，特別是 history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 628,
    "chunk_index": 30,
    "total_chunks": 49
  },
  {
    "id": "b0c465e13ef76d82eabe687b7412c02b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "templateId: 'login' }, '/dashboard': { templateId: 'dashboard' }, }; 現在讓我們稍微修改 updateRoute 函數。我們不再直接將 templateId 作為參數傳遞，而是希望先查看當前 URL，然後使用我們的映射來獲取對應的模板 ID 值。我們可以使用 windowlocationpathname 來僅獲取 URL 的路徑部分。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。\n注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。\n任務\n讓我們建立一個新函數，用於在應用程式中導航：\njs\nfunction navigate(path) {\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 613,
    "chunk_index": 31,
    "total_chunks": 49
  },
  {
    "id": "746a6bd4ba0fe16547b649eabea26ff1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistory",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 477,
    "chunk_index": 32,
    "total_chunks": 49
  },
  {
    "id": "97369546639b029e818164be6cc5f171",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "updateRoute() { const path = windowlocationpathname; const route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path);\nupdateRoute();\n}\n此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 520,
    "chunk_index": 33,
    "total_chunks": 49
  },
  {
    "id": "db709cdd682c14630627e9c493db5c6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 510,
    "chunk_index": 34,
    "total_chunks": 49
  },
  {
    "id": "fe1d588ed1836af79d6dd64e7c7d639a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "route = routes[path]; const template = documentgetElementById(route templateId); const view = template content cloneNode(true); const app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。\n現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。\n```js\nfunction updateRoute() {\nconst path = window",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 626,
    "chunk_index": 35,
    "total_chunks": 49
  },
  {
    "id": "84ebe8f3d96858f659f30b7bedd5c057",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocation",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 602,
    "chunk_index": 36,
    "total_chunks": 49
  },
  {
    "id": "0b7993e9454f5cafad96b87c9cf39752",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "app = documentgetElementById('app'); app innerHTML = ''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname;\nconst route = routes[path];\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 612,
    "chunk_index": 37,
    "total_chunks": 49
  },
  {
    "id": "9ccf1716a071aee110e7ff2a7211a008",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "''; appappendChild(view); } ``` 在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) {\nreturn navigate('/login');\n}",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 610,
    "chunk_index": 38,
    "total_chunks": 49
  },
  {
    "id": "6d86c1b5313d5cbc8931a0c222d49b0a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "在這裡，我們將宣告的路由映射到對應的模板。您可以嘗試手動更改瀏覽器中的 URL，檢查它是否正確運作。 ✅ 如果您在 URL 中輸入未知的路徑會發生什麼？我們如何解決這個問題？ 新增導航功能 我們應用程式的下一步是新增在頁面之間導航的功能，而不需要手動更改 URL。這涉及兩件事： 更新當前 URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }```\n如果找不到路由，我們現在會重定向到 login 頁面。\n現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為：\njs\nfunction onLinkClick(event) {\nevent",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 699,
    "chunk_index": 39,
    "total_chunks": 49
  },
  {
    "id": "5adb56490d2060a70c73100f7656420d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "URL 根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault();\nnavigate(event",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 534,
    "chunk_index": 40,
    "total_chunks": 49
  },
  {
    "id": "31317d64c6b784a77561b09e424a788c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtarget",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 534,
    "chunk_index": 41,
    "total_chunks": 49
  },
  {
    "id": "012abc856dd4ab41ac56a58f754930ef",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "根據新 URL 更新顯示的模板 我們已經使用 updateRoute 函數處理了第二部分，因此我們需要弄清楚如何更新當前 URL。 我們需要使用 JavaScript，特別是 historypushState，它允許更新 URL 並在瀏覽歷史中建立新條目，而不重新載入 HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref);\n}\n讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。\nhtml\n<a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a>",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 590,
    "chunk_index": 42,
    "total_chunks": 49
  },
  {
    "id": "de9a11f16a8956ee0d5c779e0ab1c270",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "HTML。 注意：雖然 HTML 錨點元素 <a href> 本身可以用來建立指向不同 URL 的超連結，但它預設會使瀏覽器重新載入 HTML。在使用自訂 JavaScript 處理路由時，必須使用 preventDefault() 函數來防止此行為。 任務 讓我們建立一個新函數，用於在應用程式中導航： js function navigate(path) { windowhistorypushState({}, path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a>\n上述的 event 物件捕捉 click 事件並將其傳遞給我們的 onLinkClick 函數。\n使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。\n嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間導航。\n✅ history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 625,
    "chunk_index": 43,
    "total_chunks": 49
  },
  {
    "id": "2b42a502107807d8168daa76857289fe",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "path, path); updateRoute(); } 此方法首先根據給定的路徑更新當前 URL，然後更新模板。屬性 windowlocationorigin 返回 URL 根目錄，允許我們從給定的路徑重建完整的 URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容且不重新載入頁面的路由，因為它的目的是在頁面內建立內部連結。\n處理瀏覽器的返回與前進按鈕\n使用 history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 658,
    "chunk_index": 44,
    "total_chunks": 49
  },
  {
    "id": "f663d9003935625979765a36cecaebab",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "URL。 現在我們有了這個函數，可以解決當路徑不符合任何定義的路由時的問題。我們將通過新增回退到現有路由之一來修改 updateRoute 函數。 ```js function updateRoute() { const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容且不重新載入頁面的路由，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以通過按住瀏覽器的返回按鈕檢查，它應顯示如下內容：\n如果您嘗試多次點擊返回按鈕，您會看到當前 URL 發生變化，歷史被更新，但顯示的模板保持不變。\n這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 history",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 752,
    "chunk_index": 45,
    "total_chunks": 49
  },
  {
    "id": "cedd5487a74d772e5c1392b204f7de9f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "{ const path = windowlocationpathname; const route = routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容且不重新載入頁面的路由，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以通過按住瀏覽器的返回按鈕檢查，它應顯示如下內容： 如果您嘗試多次點擊返回按鈕，您會看到當前 URL 發生變化，歷史被更新，但顯示的模板保持不變。 這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 historypushState 的文件，您會看到當狀態變更時（即我們移動到不同的 URL），popstate 事件會被觸發。我們將使用它來修正此問題。\n任務\n為了確保當瀏覽器歷史變更時顯示的模板被更新，我們將附加一個新函數來呼叫 updateRoute()。我們會在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 807,
    "chunk_index": 46,
    "total_chunks": 49
  },
  {
    "id": "ecf15161452418f16ab8e4b7f139ab6f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "= routes[path]; if (route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容且不重新載入頁面的路由，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以通過按住瀏覽器的返回按鈕檢查，它應顯示如下內容： 如果您嘗試多次點擊返回按鈕，您會看到當前 URL 發生變化，歷史被更新，但顯示的模板保持不變。 這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 historypushState 的文件，您會看到當狀態變更時（即我們移動到不同的 URL），popstate 事件會被觸發。我們將使用它來修正此問題。 任務 為了確保當瀏覽器歷史變更時顯示的模板被更新，我們將附加一個新函數來呼叫 updateRoute()。我們會在 appjs 檔案的底部完成此操作：\njs\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 813,
    "chunk_index": 47,
    "total_chunks": 49
  },
  {
    "id": "0c6e186de3777ae19341c0968669726b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
    "source_type": "git_repo",
    "title": "Bank App",
    "content": "(route) { return navigate('/login'); }``` 如果找不到路由，我們現在會重定向到 login 頁面。 現在讓我們建立一個函數，用於在點擊連結時獲取 URL，並防止瀏覽器的預設連結行為： js function onLinkClick(event) { eventpreventDefault(); navigate(eventtargethref); } 讓我們通過在 HTML 中的 Login 和 Logout 連結新增綁定來完成導航系統。 html <a href=\"/dashboard\" onclick=\"onLinkClick(event)\">Login</a><a href=\"/login\" onclick=\"onLinkClick(event)\">Logout</a> 上述的 event 物件捕捉 click 事件並將其傳遞給我們的 onLinkClick 函數。 使用 onclick 屬性將 click 事件綁定到 JavaScript 程式碼，這裡是呼叫 navigate() 函數。 嘗試點擊這些連結，您現在應該能夠在應用程式的不同畫面之間導航。 ✅ historypushState 方法是 HTML5 標準的一部分，並在所有現代瀏覽器中實現。如果您正在為舊版瀏覽器建立網頁應用程式，可以使用一個技巧來替代此 API：使用 hash (#) 作為路徑，您可以實現與常規錨點導航相容且不重新載入頁面的路由，因為它的目的是在頁面內建立內部連結。 處理瀏覽器的返回與前進按鈕 使用 historypushState 會在瀏覽器的導航歷史中建立新條目。您可以通過按住瀏覽器的返回按鈕檢查，它應顯示如下內容： 如果您嘗試多次點擊返回按鈕，您會看到當前 URL 發生變化，歷史被更新，但顯示的模板保持不變。 這是因為應用程式不知道每次歷史變更時需要呼叫 updateRoute()。如果您查看 historypushState 的文件，您會看到當狀態變更時（即我們移動到不同的 URL），popstate 事件會被觸發。我們將使用它來修正此問題。 任務 為了確保當瀏覽器歷史變更時顯示的模板被更新，我們將附加一個新函數來呼叫 updateRoute()。我們會在 appjs 檔案的底部完成此操作： js windowonpopstate = () => updateRoute();\nupdateRoute();\n注意：我們在這裡使用了一個箭頭函數來宣告 popstate 事件處理器以簡化程式碼，但普通函數也可以正常運作。\n這裡有一段關於箭頭函數的回顧影片：\n🎥 點擊上方圖片觀看有關箭頭函數的影片。\n現在嘗試使用瀏覽器的返回與前進按鈕，檢查顯示的路由是否正確更新。\n🚀 挑戰\n新增一個新的模板和路由，用於顯示此應用程式的製作人員名單的第三個頁面。\n課後測驗\n課後測驗\n回顧與自學\n路由是網頁開發中一個出乎意料的棘手部分，特別是當網頁從頁面刷新行為轉向單頁應用程式的頁面刷新時。閱讀一些關於 Azure 靜態網頁應用程式服務如何處理路由的資料。您能否解釋為什麼文件中描述的一些決策是必要的？\n作業\n改善路由\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為具權威性的來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14018,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\1-template-route\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1392,
    "chunk_index": 48,
    "total_chunks": 49
  },
  {
    "id": "f971b445aca7d8e9f8cdac865e1c465a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\assignment.md",
    "source_type": "git_repo",
    "title": "實現「新增交易」對話框",
    "content": "實現「新增交易」對話框\n指引\n我們的銀行應用程式仍然缺少一個重要功能：輸入新交易的可能性。\n運用你在前四節課中學到的所有知識，實現一個「新增交易」對話框：\n在儀表板頁面新增一個「新增交易」按鈕\n可以選擇建立一個帶有 HTML 模板的新頁面，或者使用 JavaScript 來顯示/隱藏對話框的 HTML，而不離開儀表板頁面（你可以使用 hidden 屬性，或者 CSS 類別來實現）\n確保你處理了鍵盤和螢幕閱讀器的無障礙性\n實現一個 HTML 表單來接收輸入數據\n從表單數據創建 JSON 數據並發送到 API\n使用新數據更新儀表板頁面\n查看 伺服器 API 規範 以了解需要調用的 API 以及預期的 JSON 格式。\n以下是完成作業後的範例結果：\n評分標準\n| 評分標準 | 優秀                                                                                              | 合格                                                                                                                    | 需要改進                                     |\n| -------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- | --------------------------------------------|\n|          | 完全按照課堂中學到的最佳實踐實現了新增交易功能。                                                  | 實現了新增交易功能，但未完全按照課堂中學到的最佳實踐，或者僅部分功能正常運作。                                           | 新增交易功能完全無法運作。                   |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。儘管我們致力於提供準確的翻譯，請注意自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為權威來源。對於重要資訊，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2817,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 692,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "c67dbe4ee96c96baffde9521468086a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "建立銀行應用程式第 4 部分：狀態管理的概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。\n在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。\n先決條件\n在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 442,
    "chunk_index": 0,
    "total_chunks": 29
  },
  {
    "id": "59de61cea006380093d4efe751b606e2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "建立銀行應用程式第 4 部分：狀態管理的概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。\n在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。\n先決條件\n在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Nodejs 並本地運行伺服器 API，以便管理帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 1,
    "total_chunks": 29
  },
  {
    "id": "7e87cda768d7ce63b9814106f90009ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "建立銀行應用程式第 4 部分：狀態管理的概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。\n在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。\n先決條件\n在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Nodejs 並本地運行伺服器 API，以便管理帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 2,
    "total_chunks": 29
  },
  {
    "id": "ceae040cc32a300de17647ce0d5da7d1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "建立銀行應用程式第 4 部分：狀態管理的概念\n課前測驗\n課前測驗\n簡介\n隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。\n在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。\n先決條件\n在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Nodejs 並本地運行伺服器 API，以便管理帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n重新思考狀態管理\n在上一課中，我們在應用程式中引入了一個基本的狀態概念，使用全域變數 account 來存儲當前登錄用戶的銀行數據。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新頁面，會發生什麼？\n目前程式碼有三個問題：\n狀態未被持久化，刷新瀏覽器會將您帶回登錄頁面。\n有多個函數修改狀態。隨著應用程式的增長，這會使得追蹤更改變得困難，並且容易忘記更新某些部分。\n狀態未被清理，因此當您點擊 登出 時，帳戶數據仍然存在，即使您已經回到登錄頁面。\n我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複，並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘，重新思考我們的策略。\n我們真正想解決的問題是什麼？\n狀態管理 的核心在於找到一個好的方法來解決以下兩個特定問題：\n如何讓應用程式中的數據流保持清晰易懂？\n如何確保狀態數據始終與用戶界面同步（反之亦然）？\n一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示：\n我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。\n✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。\n任務\n我們將從一些重構開始。將 account 的宣告替換為：\njs\nlet account = null;\n改為：\njs\nlet state = {\naccount: null\n};\n這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。\n我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1550,
    "chunk_index": 3,
    "total_chunks": 29
  },
  {
    "id": "7163d34212c6458087f4666d47b07806",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "4 部分：狀態管理的概念 課前測驗 課前測驗 簡介 隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。 在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。 先決條件 在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Nodejs 並本地運行伺服器 API，以便管理帳戶數據。 您可以通過在終端執行以下命令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了一個基本的狀態概念，使用全域變數 account 來存儲當前登錄用戶的銀行數據。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新頁面，會發生什麼？ 目前程式碼有三個問題： 狀態未被持久化，刷新瀏覽器會將您帶回登錄頁面。 有多個函數修改狀態。隨著應用程式的增長，這會使得追蹤更改變得困難，並且容易忘記更新某些部分。 狀態未被清理，因此當您點擊 登出 時，帳戶數據仍然存在，即使您已經回到登錄頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複，並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘，重新思考我們的策略。 我們真正想解決的問題是什麼？ 狀態管理 的核心在於找到一個好的方法來解決以下兩個特定問題： 如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1547,
    "chunk_index": 4,
    "total_chunks": 29
  },
  {
    "id": "1e52328508663e0823e5044ce5b507a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "部分：狀態管理的概念 課前測驗 課前測驗 簡介 隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。 在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。 先決條件 在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Nodejs 並本地運行伺服器 API，以便管理帳戶數據。 您可以通過在終端執行以下命令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了一個基本的狀態概念，使用全域變數 account 來存儲當前登錄用戶的銀行數據。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新頁面，會發生什麼？ 目前程式碼有三個問題： 狀態未被持久化，刷新瀏覽器會將您帶回登錄頁面。 有多個函數修改狀態。隨著應用程式的增長，這會使得追蹤更改變得困難，並且容易忘記更新某些部分。 狀態未被清理，因此當您點擊 登出 時，帳戶數據仍然存在，即使您已經回到登錄頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複，並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘，重新思考我們的策略。 我們真正想解決的問題是什麼？ 狀態管理 的核心在於找到一個好的方法來解決以下兩個特定問題： 如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1546,
    "chunk_index": 5,
    "total_chunks": 29
  },
  {
    "id": "32d17db177b6407e9159ae580c71e0ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "課前測驗 課前測驗 簡介 隨著網頁應用程式的規模增大，追蹤所有數據流變得越來越困難。哪些程式碼獲取數據，哪些頁面使用數據，數據需要在何時何地更新……很容易導致程式碼混亂且難以維護。這在需要在應用程式的不同頁面之間共享數據時（例如用戶數據）尤其明顯。狀態管理 的概念一直存在於各類程式中，但隨著網頁應用程式的複雜性不斷增加，現在在開發過程中考慮這一點變得至關重要。 在這最後一部分，我們將重新檢視我們建立的應用程式，重新思考如何管理狀態，從而支持隨時刷新瀏覽器，並在用戶會話之間持續保存數據。 先決條件 在學習本課之前，您需要完成網頁應用程式的數據獲取部分。此外，您需要安裝 Nodejs 並本地運行伺服器 API，以便管理帳戶數據。 您可以通過在終端執行以下命令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了一個基本的狀態概念，使用全域變數 account 來存儲當前登錄用戶的銀行數據。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新頁面，會發生什麼？ 目前程式碼有三個問題： 狀態未被持久化，刷新瀏覽器會將您帶回登錄頁面。 有多個函數修改狀態。隨著應用程式的增長，這會使得追蹤更改變得困難，並且容易忘記更新某些部分。 狀態未被清理，因此當您點擊 登出 時，帳戶數據仍然存在，即使您已經回到登錄頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複，並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘，重新思考我們的策略。 我們真正想解決的問題是什麼？ 狀態管理 的核心在於找到一個好的方法來解決以下兩個特定問題： 如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =;\n在 updateDashboard() 函數的開頭，添加以下程式碼：\njs\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1557,
    "chunk_index": 6,
    "total_chunks": 29
  },
  {
    "id": "23572d56c291b99c5814083476bb64f2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "Nodejs 並本地運行伺服器 API，以便管理帳戶數據。 您可以通過在終端執行以下命令來測試伺服器是否正常運行： ```sh curl http://localhost:5000/api -> should return \"Bank API v100\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了一個基本的狀態概念，使用全域變數 account 來存儲當前登錄用戶的銀行數據。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新頁面，會發生什麼？ 目前程式碼有三個問題： 狀態未被持久化，刷新瀏覽器會將您帶回登錄頁面。 有多個函數修改狀態。隨著應用程式的增長，這會使得追蹤更改變得困難，並且容易忘記更新某些部分。 狀態未被清理，因此當您點擊 登出 時，帳戶數據仍然存在，即使您已經回到登錄頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複，並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘，重新思考我們的策略。 我們真正想解決的問題是什麼？ 狀態管理 的核心在於找到一個好的方法來解決以下兩個特定問題： 如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount;\n這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。\n追蹤數據變更\n現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。\n為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。\n在 JavaScript 中，您可以使用 Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1508,
    "chunk_index": 7,
    "total_chunks": 29
  },
  {
    "id": "e74e59a1470f370e174e1c0c242fe471",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "v100\" as a result ``` 重新思考狀態管理 在上一課中，我們在應用程式中引入了一個基本的狀態概念，使用全域變數 account 來存儲當前登錄用戶的銀行數據。然而，我們目前的實現存在一些缺陷。嘗試在儀表板頁面刷新頁面，會發生什麼？ 目前程式碼有三個問題： 狀態未被持久化，刷新瀏覽器會將您帶回登錄頁面。 有多個函數修改狀態。隨著應用程式的增長，這會使得追蹤更改變得困難，並且容易忘記更新某些部分。 狀態未被清理，因此當您點擊 登出 時，帳戶數據仍然存在，即使您已經回到登錄頁面。 我們可以逐一更新程式碼來解決這些問題，但這會導致程式碼重複，並使應用程式更加複雜且難以維護。或者，我們可以暫停幾分鐘，重新思考我們的策略。 我們真正想解決的問題是什麼？ 狀態管理 的核心在於找到一個好的方法來解決以下兩個特定問題： 如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。\n✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。\n任務\n讓我們創建一個新的 updateState() 函數：\njs\nfunction updateState(property, newData) {\nstate = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1560,
    "chunk_index": 8,
    "total_chunks": 29
  },
  {
    "id": "bdcdbc51caa086820d1537ee712254cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1080,
    "chunk_index": 9,
    "total_chunks": 29
  },
  {
    "id": "64513a2b1a337d771ea8c693c294ef3a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "如何讓應用程式中的數據流保持清晰易懂？ 如何確保狀態數據始終與用戶界面同步（反之亦然）？ 一旦解決了這些問題，您可能面臨的其他問題要麼已經被解決，要麼變得更容易解決。有許多方法可以解決這些問題，但我們將採用一種常見的解決方案，即 集中化數據及其更改方式。數據流將如下圖所示： 我們不會在此討論數據自動觸發視圖更新的部分，因為這涉及到更高級的反應式編程概念。如果您有興趣深入研究，這是一個不錯的後續主題。 ✅ 市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state,\n[property]: newData\n});\n}\n在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1130,
    "chunk_index": 10,
    "total_chunks": 29
  },
  {
    "id": "dc08c8c064decc765624f7342a4d70ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "市面上有許多不同方法的狀態管理庫，Redux 是一個受歡迎的選擇。了解其概念和模式通常是學習如何解決大型網頁應用程式中潛在問題的好方法。 任務 我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製數據。然後，我們使用方括號表示法 [property] 覆蓋狀態物件的特定屬性，並使用 Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 910,
    "chunk_index": 11,
    "total_chunks": 29
  },
  {
    "id": "349b628c1b48c6e4db5ec1e8f5f5a0f0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "我們將從一些重構開始。將 account 的宣告替換為： js let account = null; 改為： js let state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製數據。然後，我們使用方括號表示法 [property] 覆蓋狀態物件的特定屬性，並使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲了 account 屬性，但通過這種方法，您可以在狀態中添加任意多的屬性。\n我們還需要更新 state 的初始化，以確保初始狀態也是不可變的：\njs\nlet state = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 919,
    "chunk_index": 12,
    "total_chunks": 29
  },
  {
    "id": "0b5ba1841ebb847e892317a15d32629a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "state = { account: null }; 這個想法是將我們應用程式的所有數據集中在一個單一的狀態物件中。目前狀態中只有 account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製數據。然後，我們使用方括號表示法 [property] 覆蓋狀態物件的特定屬性，並使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲了 account 屬性，但通過這種方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({\naccount: null\n});\n接下來，更新 register 函數，將 state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 896,
    "chunk_index": 13,
    "total_chunks": 29
  },
  {
    "id": "7b95c22514807698bcfa9dad1f2feaf3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "account，因此變化不大，但這為未來的擴展鋪平了道路。 我們還需要更新使用它的函數。在 register() 和 login() 函數中，將 account =替換為 stateaccount =; 在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製數據。然後，我們使用方括號表示法 [property] 覆蓋狀態物件的特定屬性，並使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲了 account 屬性，但通過這種方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({ account: null }); 接下來，更新 register 函數，將 stateaccount = result; 替換為：\njs\nupdateState('account', result);\n對 login 函數執行相同操作，將 state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 869,
    "chunk_index": 14,
    "total_chunks": 29
  },
  {
    "id": "07b872944eb16019871d3d4b3e7c0d61",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "在 updateDashboard() 函數的開頭，添加以下程式碼： js const account = stateaccount; 這次重構本身並未帶來太多改進，但其目的是為接下來的更改奠定基礎。 追蹤數據變更 現在我們已經設置了 state 物件來存儲數據，下一步是集中更新。目標是更容易追蹤任何變更及其發生的時間。 為了避免對 state 物件進行直接更改，考慮將其視為不可變是一個好習慣，這意味著它不能被修改。如果需要更改其中的任何內容，您必須創建一個新的狀態物件。通過這樣做，您可以防止潛在的副作用，並為應用程式的新功能（例如實現撤銷/重做）打開可能性，同時也更容易進行除錯。例如，您可以記錄對狀態所做的每次更改，並保留更改的歷史記錄，以便了解錯誤的來源。 在 JavaScript 中，您可以使用 Objectfreeze() 創建物件的不可變版本。如果嘗試更改不可變物件，將會引發異常。 ✅ 您知道 淺層 和 深層 不可變物件之間的區別嗎？您可以在這裡閱讀相關內容。 任務 讓我們創建一個新的 updateState() 函數： js function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製數據。然後，我們使用方括號表示法 [property] 覆蓋狀態物件的特定屬性，並使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲了 account 屬性，但通過這種方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({ account: null }); 接下來，更新 register 函數，將 stateaccount = result; 替換為： js updateState('account', result); 對 login 函數執行相同操作，將 stateaccount = data; 替換為：\njs\nupdateState('account', data);\n現在，我們可以順便解決用戶點擊 登出 時帳戶數據未被清除的問題。\n創建一個新函數 logout()：\njs\nfunction logout() {\nupdateState('account', null);\nnavigate('/login');\n}\n在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();;\n嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。\n提示：您可以在 updateState() 的底部添加 console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 976,
    "chunk_index": 15,
    "total_chunks": 29
  },
  {
    "id": "47263ffde266d0275721b8db6ab0ebf6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "function updateState(property, newData) { state = Objectfreeze({state, [property]: newData }); } 在這個函數中，我們創建了一個新的狀態物件，並使用展開運算符 ()從先前的狀態中複製數據。然後，我們使用方括號表示法 [property] 覆蓋狀態物件的特定屬性，並使用 Objectfreeze() 鎖定物件以防止修改。目前狀態中僅存儲了 account 屬性，但通過這種方法，您可以在狀態中添加任意多的屬性。 我們還需要更新 state 的初始化，以確保初始狀態也是不可變的： js let state = Objectfreeze({ account: null }); 接下來，更新 register 函數，將 stateaccount = result; 替換為： js updateState('account', result); 對 login 函數執行相同操作，將 stateaccount = data; 替換為： js updateState('account', data); 現在，我們可以順便解決用戶點擊 登出 時帳戶數據未被清除的問題。 創建一個新函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。\n持久化狀態\n大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。\n當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮：\n數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。\n需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？\n根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。\n另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣：\nlocalStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。\nsessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。\n請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1139,
    "chunk_index": 16,
    "total_chunks": 29
  },
  {
    "id": "b1a71f36d2099c79c2d98fbef3bd22be",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "= Objectfreeze({ account: null }); 接下來，更新 register 函數，將 stateaccount = result; 替換為： js updateState('account', result); 對 login 函數執行相同操作，將 stateaccount = data; 替換為： js updateState('account', data); 現在，我們可以順便解決用戶點擊 登出 時帳戶數據未被清除的問題。 創建一個新函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。\n✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。\n任務\n我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。\njs\nconst storageKey = 'savedAccount';\n然後在 updateState() 函數的末尾添加以下程式碼：\njs\nlocalStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1168,
    "chunk_index": 17,
    "total_chunks": 29
  },
  {
    "id": "5632ec2c3a3768036ab6f89937da5745",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "data); 現在，我們可以順便解決用戶點擊 登出 時帳戶數據未被清除的問題。 創建一個新函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1099,
    "chunk_index": 18,
    "total_chunks": 29
  },
  {
    "id": "7e36064148210fc1ba2d21bf079632fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "現在，我們可以順便解決用戶點擊 登出 時帳戶數據未被清除的問題。 創建一個新函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSONstringify(state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1099,
    "chunk_index": 19,
    "total_chunks": 29
  },
  {
    "id": "0ff70e30762de37c23d3bdc4d9f4495e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "現在，我們可以順便解決用戶點擊 登出 時帳戶數據未被清除的問題。 創建一個新函數 logout()： js function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSONstringify(stateaccount));\n通過這樣做，用戶帳戶數據將被持久化，並且由於我們之前集中化了所有狀態更新，因此數據始終是最新的。這正是我們之前重構的好處 🙂。\n由於數據已保存，我們還需要在應用程式加載時恢復數據。由於我們將開始有更多的初始化程式碼，因此可以考慮創建一個新的 init 函數，將之前在 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1278,
    "chunk_index": 20,
    "total_chunks": 29
  },
  {
    "id": "63b4e1ca44c3d7c0dcc41cfe738385b2",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "function logout() { updateState('account', null); navigate('/login'); } 在 updateDashboard() 中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 通過這樣做，用戶帳戶數據將被持久化，並且由於我們之前集中化了所有狀態更新，因此數據始終是最新的。這正是我們之前重構的好處 🙂。 由於數據已保存，我們還需要在應用程式加載時恢復數據。由於我們將開始有更多的初始化程式碼，因此可以考慮創建一個新的 init 函數，將之前在 appjs 底部的程式碼也包含進來：\n```js\nfunction init() {\nconst savedAccount = localStorage",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1247,
    "chunk_index": 21,
    "total_chunks": 29
  },
  {
    "id": "7cb89fea323c5969f40a1e87b368f957",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "中，將重定向 return navigate('/login'); 替換為 return logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 通過這樣做，用戶帳戶數據將被持久化，並且由於我們之前集中化了所有狀態更新，因此數據始終是最新的。這正是我們之前重構的好處 🙂。 由於數據已保存，我們還需要在應用程式加載時恢復數據。由於我們將開始有更多的初始化程式碼，因此可以考慮創建一個新的 init 函數，將之前在 appjs 底部的程式碼也包含進來： ```js function init() { const savedAccount = localStoragegetItem(storageKey);\nif (savedAccount) {\nupdateState('account', JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1242,
    "chunk_index": 22,
    "total_chunks": 29
  },
  {
    "id": "6978e8d6e036cafb5ff4a12849333c6a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "logout();; 嘗試註冊一個新帳戶，登出並重新登錄，檢查一切是否仍然正常運作。 提示：您可以在 updateState() 的底部添加 consolelog(state)，然後打開瀏覽器開發工具中的控制台，查看所有狀態變更。 持久化狀態 大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 通過這樣做，用戶帳戶數據將被持久化，並且由於我們之前集中化了所有狀態更新，因此數據始終是最新的。這正是我們之前重構的好處 🙂。 由於數據已保存，我們還需要在應用程式加載時恢復數據。由於我們將開始有更多的初始化程式碼，因此可以考慮創建一個新的 init 函數，將之前在 appjs 底部的程式碼也包含進來： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount));\n}\n// Our previous initialization code\nwindow",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1234,
    "chunk_index": 23,
    "total_chunks": 29
  },
  {
    "id": "ca8e258c4a605666544084197380ba91",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "大多數網頁應用程式需要持久化數據才能正常運作。所有關鍵數據通常存儲在數據庫中，並通過伺服器 API 訪問，例如我們的用戶帳戶數據。但有時，將某些數據持久化到運行在瀏覽器中的客戶端應用程式中也是有意義的，這樣可以提升用戶體驗或改善加載性能。 當您想在瀏覽器中持久化數據時，有幾個重要問題需要考慮： 數據是否敏感？ 您應避免在客戶端存儲任何敏感數據，例如用戶密碼。 需要保存數據多久？ 您是只打算在當前會話中訪問數據，還是希望永久保存？ 根據您的需求，有多種方法可以在網頁應用程式中存儲信息。例如，您可以使用 URL 存儲搜索查詢，並使其可在用戶之間共享。如果需要與伺服器共享數據（例如身份驗證信息），可以使用 HTTP cookies。 另一個選項是使用多種瀏覽器 API 之一來存儲數據。其中兩個特別有趣： localStorage：一個鍵值存儲，允許在不同會話中持久化特定於當前網站的數據。存儲在其中的數據永不過期。 sessionStorage：其工作方式與 localStorage 相同，但存儲在其中的數據會在會話結束時（瀏覽器關閉時）被清除。 請注意，這兩個 API 僅允許存儲字串。如果您想存儲複雜物件，則需要使用 JSONstringify() 將其序列化為 JSON 格式。 ✅ 如果您想創建一個不依賴伺服器的網頁應用程式，也可以使用 IndexedDB API 在客戶端創建數據庫。這適用於高級用例或需要存儲大量數據的情況，因為它的使用更為複雜。 任務 我們希望用戶在明確點擊 登出 按鈕之前保持登錄狀態，因此我們將使用 localStorage 存儲帳戶數據。首先，定義一個用於存儲數據的鍵。 js const storageKey = 'savedAccount'; 然後在 updateState() 函數的末尾添加以下程式碼： js localStoragesetItem(storageKey, JSONstringify(stateaccount)); 通過這樣做，用戶帳戶數據將被持久化，並且由於我們之前集中化了所有狀態更新，因此數據始終是最新的。這正是我們之前重構的好處 🙂。 由於數據已保存，我們還需要在應用程式加載時恢復數據。由於我們將開始有更多的初始化程式碼，因此可以考慮創建一個新的 init 函數，將之前在 appjs 底部的程式碼也包含進來： ```js function init() { const savedAccount = localStoragegetItem(storageKey); if (savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute();\nupdateRoute();\n}\ninit();\n```\n在這裡，我們檢索保存的數據，如果有數據，則相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。\n我們還可以將 儀表板 頁設為應用程式的默認頁面，因為我們現在已經持久化了帳戶數據。如果未找到數據，儀表板會負責重定向到 登錄 頁。在 updateRoute() 中，將回退的 return navigate('/login'); 替換為 return navigate('/dashboard');。\n現在登錄應用程式並嘗試刷新頁面。您應該仍然停留在儀表板頁面。通過這次更新，我們解決了所有初始問題……\n刷新數據\n……但我們可能也創造了一個新問題。糟糕！\n使用 test 帳戶進入儀表板，然後在終端運行以下命令創建一個新交易：\nsh\ncurl --request POST \\\n--header \"Content-Type: application/json\" \\\n--data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\\nhttp://localhost:5000/api/accounts/test/transactions\n現在嘗試在瀏覽器中刷新儀表板頁面。會發生什麼？您是否看到新交易？\n由於 localStorage 的狀態被無限期持久化，這也意味著在您登出應用程式並重新登錄之前，它永遠不會更新！\n解決此問題的一種策略是每次加載儀表板時重新加載帳戶數據，以避免數據陳舊。\n任務\n創建一個新函數 updateAccountData：\n```js\nasync function updateAccountData() {\nconst account = state",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1753,
    "chunk_index": 24,
    "total_chunks": 29
  },
  {
    "id": "0ee6278e766d46684b155723653af97f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "(savedAccount) { updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的數據，如果有數據，則相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將 儀表板 頁設為應用程式的默認頁面，因為我們現在已經持久化了帳戶數據。如果未找到數據，儀表板會負責重定向到 登錄 頁。在 updateRoute() 中，將回退的 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登錄應用程式並嘗試刷新頁面。您應該仍然停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新數據 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端運行以下命令創建一個新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試在瀏覽器中刷新儀表板頁面。會發生什麼？您是否看到新交易？ 由於 localStorage 的狀態被無限期持久化，這也意味著在您登出應用程式並重新登錄之前，它永遠不會更新！ 解決此問題的一種策略是每次加載儀表板時重新加載帳戶數據，以避免數據陳舊。 任務 創建一個新函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount;\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 656,
    "chunk_index": 25,
    "total_chunks": 29
  },
  {
    "id": "fb485eaf7b2e25d6d19e80be69f8ac2d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "updateState('account', JSONparse(savedAccount)); } // Our previous initialization code windowonpopstate = () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的數據，如果有數據，則相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將 儀表板 頁設為應用程式的默認頁面，因為我們現在已經持久化了帳戶數據。如果未找到數據，儀表板會負責重定向到 登錄 頁。在 updateRoute() 中，將回退的 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登錄應用程式並嘗試刷新頁面。您應該仍然停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新數據 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端運行以下命令創建一個新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試在瀏覽器中刷新儀表板頁面。會發生什麼？您是否看到新交易？ 由於 localStorage 的狀態被無限期持久化，這也意味著在您登出應用程式並重新登錄之前，它永遠不會更新！ 解決此問題的一種策略是每次加載儀表板時重新加載帳戶數據，以避免數據陳舊。 任務 創建一個新函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount; if (account) {\nreturn logout();\n}\nconst data = await getAccount(account",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 666,
    "chunk_index": 26,
    "total_chunks": 29
  },
  {
    "id": "fe9286c3496439e75e50affea479412a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "= () => updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的數據，如果有數據，則相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將 儀表板 頁設為應用程式的默認頁面，因為我們現在已經持久化了帳戶數據。如果未找到數據，儀表板會負責重定向到 登錄 頁。在 updateRoute() 中，將回退的 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登錄應用程式並嘗試刷新頁面。您應該仍然停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新數據 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端運行以下命令創建一個新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試在瀏覽器中刷新儀表板頁面。會發生什麼？您是否看到新交易？ 由於 localStorage 的狀態被無限期持久化，這也意味著在您登出應用程式並重新登錄之前，它永遠不會更新！ 解決此問題的一種策略是每次加載儀表板時重新加載帳戶數據，以避免數據陳舊。 任務 創建一個新函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount; if (account) { return logout(); } const data = await getAccount(accountuser);\nif (data",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 651,
    "chunk_index": 27,
    "total_chunks": 29
  },
  {
    "id": "8b6bf46bf03a3c6f0da7308d56ff2af0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第 4 部分：狀態管理的概念",
    "content": "=> updateRoute(); updateRoute(); } init(); ``` 在這裡，我們檢索保存的數據，如果有數據，則相應地更新狀態。重要的是要在更新路由之前執行此操作，因為在頁面更新期間可能有程式碼依賴於狀態。 我們還可以將 儀表板 頁設為應用程式的默認頁面，因為我們現在已經持久化了帳戶數據。如果未找到數據，儀表板會負責重定向到 登錄 頁。在 updateRoute() 中，將回退的 return navigate('/login'); 替換為 return navigate('/dashboard');。 現在登錄應用程式並嘗試刷新頁面。您應該仍然停留在儀表板頁面。通過這次更新，我們解決了所有初始問題…… 刷新數據 ……但我們可能也創造了一個新問題。糟糕！ 使用 test 帳戶進入儀表板，然後在終端運行以下命令創建一個新交易： sh curl --request POST \\ --header \"Content-Type: application/json\" \\ --data \"{ \\\"date\\\": \\\"2020-07-24\\\", \\\"object\\\": \\\"Bought book\\\", \\\"amount\\\": -20 }\" \\ http://localhost:5000/api/accounts/test/transactions 現在嘗試在瀏覽器中刷新儀表板頁面。會發生什麼？您是否看到新交易？ 由於 localStorage 的狀態被無限期持久化，這也意味著在您登出應用程式並重新登錄之前，它永遠不會更新！ 解決此問題的一種策略是每次加載儀表板時重新加載帳戶數據，以避免數據陳舊。 任務 創建一個新函數 updateAccountData： ```js async function updateAccountData() { const account = stateaccount; if (account) { return logout(); } const data = await getAccount(accountuser); if (dataerror) {\nreturn logout();\n}\nupdateState('account', data);\n}\n```\n此方法檢查當前是否已登錄，然後從伺服器重新加載帳戶數據。\n再創建一個名為 refresh 的函數：\njs\nasync function refresh() {\nawait updateAccountData();\nupdateDashboard();\n}\n此函數更新帳戶數據，然後負責更新儀表板頁面的 HTML。這是我們需要在加載儀表板路由時調用的函數。使用以下程式碼更新路由定義：\njs\nconst routes = {\n'/login': { templateId: 'login' },\n'/dashboard': { templateId: 'dashboard', init: refresh }\n};\n現在嘗試重新加載儀表板，它應該顯示更新的帳戶數據。\n🚀 挑戰\n現在我們每次加載儀表板時都會重新加載帳戶數據，您認為我們是否仍然需要持久化 所有帳戶 數據？\n嘗試與團隊合作，修改從 localStorage 保存和加載的內容，使其僅包括應用程式運行所需的最少數據。\n課後測驗\n課後測驗\n作業\n實現「新增交易」對話框\n以下是完成作業後的示例結果：\n免責聲明：\n本文件使用 AI 翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 14448,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\4-state-management\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1242,
    "chunk_index": 28,
    "total_chunks": 29
  },
  {
    "id": "a4aa7fe85bcc37112327ffd507d72cd4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "建立銀行應用程式第二部分：建立登入及註冊表單\n課前測驗\n課前測驗\n簡介\n幾乎所有現代網頁應用程式都允許用戶創建帳戶以擁有自己的私人空間。由於多個用戶可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個用戶的個人資料並選擇要顯示的資訊。我們不會深入探討如何安全地管理用戶身份，因為這是一個非常廣泛的主題，但我們會確保每個用戶能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式添加登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義用戶輸入的基本驗證規則。\n先決條件\n你需要完成網頁應用程式的HTML 模板和路由部分。此外，你需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n你需要同時運行兩個終端，如下所列：\n1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 482,
    "chunk_index": 0,
    "total_chunks": 71
  },
  {
    "id": "0c3c567ed2dccf207dfa77fab6252c46",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "建立銀行應用程式第二部分：建立登入及註冊表單\n課前測驗\n課前測驗\n簡介\n幾乎所有現代網頁應用程式都允許用戶創建帳戶以擁有自己的私人空間。由於多個用戶可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個用戶的個人資料並選擇要顯示的資訊。我們不會深入探討如何安全地管理用戶身份，因為這是一個非常廣泛的主題，但我們會確保每個用戶能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式添加登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義用戶輸入的基本驗證規則。\n先決條件\n你需要完成網頁應用程式的HTML 模板和路由部分。此外，你需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n你需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 517,
    "chunk_index": 1,
    "total_chunks": 71
  },
  {
    "id": "c7428f0b84b77f46219bd2cb0a1f42a5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "建立銀行應用程式第二部分：建立登入及註冊表單\n課前測驗\n課前測驗\n簡介\n幾乎所有現代網頁應用程式都允許用戶創建帳戶以擁有自己的私人空間。由於多個用戶可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個用戶的個人資料並選擇要顯示的資訊。我們不會深入探討如何安全地管理用戶身份，因為這是一個非常廣泛的主題，但我們會確保每個用戶能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式添加登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義用戶輸入的基本驗證規則。\n先決條件\n你需要完成網頁應用程式的HTML 模板和路由部分。此外，你需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n你需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2用於我們剛剛設置的銀行應用程式伺服器 API\n你需要確保這兩個伺服器都在運行，以便完成接下來的課程。它們分別監聽不同的端口（端口 3000 和端口 5000），因此應該可以正常運作。\n你可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 2,
    "total_chunks": 71
  },
  {
    "id": "be8a2500577abd3f155acc72b0698715",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "建立銀行應用程式第二部分：建立登入及註冊表單\n課前測驗\n課前測驗\n簡介\n幾乎所有現代網頁應用程式都允許用戶創建帳戶以擁有自己的私人空間。由於多個用戶可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個用戶的個人資料並選擇要顯示的資訊。我們不會深入探討如何安全地管理用戶身份，因為這是一個非常廣泛的主題，但我們會確保每個用戶能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式添加登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義用戶輸入的基本驗證規則。\n先決條件\n你需要完成網頁應用程式的HTML 模板和路由部分。此外，你需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n你需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2用於我們剛剛設置的銀行應用程式伺服器 API\n你需要確保這兩個伺服器都在運行，以便完成接下來的課程。它們分別監聽不同的端口（端口 3000 和端口 5000），因此應該可以正常運作。\n你可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v10",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 677,
    "chunk_index": 3,
    "total_chunks": 71
  },
  {
    "id": "f0261a1df114e907bc7e4fcc5956a8de",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "建立銀行應用程式第二部分：建立登入及註冊表單\n課前測驗\n課前測驗\n簡介\n幾乎所有現代網頁應用程式都允許用戶創建帳戶以擁有自己的私人空間。由於多個用戶可以同時訪問網頁應用程式，因此需要一種機制來分別存儲每個用戶的個人資料並選擇要顯示的資訊。我們不會深入探討如何安全地管理用戶身份，因為這是一個非常廣泛的主題，但我們會確保每個用戶能夠在我們的應用程式中創建一個（或多個）銀行帳戶。\n在這部分，我們將使用 HTML 表單為我們的網頁應用程式添加登入和註冊功能。我們將學習如何以程式化方式將資料發送到伺服器 API，並最終定義用戶輸入的基本驗證規則。\n先決條件\n你需要完成網頁應用程式的HTML 模板和路由部分。此外，你需要安裝 Node js 並在本地運行伺服器 API，以便能夠發送資料來創建帳戶。\n注意事項\n你需要同時運行兩個終端，如下所列：\n1用於我們在HTML 模板和路由課程中建立的主要銀行應用程式\n2用於我們剛剛設置的銀行應用程式伺服器 API\n你需要確保這兩個伺服器都在運行，以便完成接下來的課程。它們分別監聽不同的端口（端口 3000 和端口 5000），因此應該可以正常運作。\n你可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v100\" as a result\n```\n表單及控制項\n<form> 元素封裝了 HTML 文件的一部分，用戶可以通過互動式控制項輸入並提交資料。表單中可以使用各種用戶界面（UI）控制項，其中最常見的是 <input> 和 <button> 元素。\n<input> 有許多不同的類型，例如要創建一個用戶名輸入欄位，你可以使用：\nhtml\n<input id=\"username\" name=\"username\" type=\"text\">\nname 屬性將在表單資料發送時用作屬性名稱，而 id 屬性則用於將 <label> 與表單控制項關聯。\n查看 <input> 類型 和其他表單控制項的完整列表，了解你可以在建立 UI 時使用的所有原生 UI 元素。\n✅ 注意 <input> 是一個空元素，不應添加匹配的閉合標籤。不過，你可以使用自閉合的 <input/> 標記，但這不是必須的。\n表單中的 <button> 元素有些特殊。如果未指定其 type 屬性，按下時會自動提交表單資料到伺服器。以下是可能的 type 值：\nsubmit：表單中的預設值，按鈕觸發表單提交操作。\nreset：按鈕將所有表單控制項重置為初始值。\nbutton：按鈕按下時不分配預設行為。你可以使用 JavaScript 為其分配自定義操作。\n任務\n讓我們從在 login 模板中添加表單開始。我們需要一個用戶名欄位和一個登入按鈕。\n```html\nLogin\nUsername\nLogin\n```\n仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處：\n通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。\n你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。\n網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。\n現在我們將在前一個表單下方添加第二個註冊表單：\n```html\nRegister\nUsername\nCurrency\nDescription\nCurrent balance\nRegister\n```\n使用 value 屬性，我們可以為某個輸入欄位定義預設值。\n注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。\n✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？\n向伺服器提交資料\n現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？\n你是否注意到瀏覽器的 URL 區域發生了變化？\n<form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點：\n發送的資料大小有限（約 2000 字元）\n資料直接顯示在 URL 中（對於密碼來說不太安全）\n不支持文件上傳\n因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。\n雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。\n任務\n為註冊表單添加 action 和 method 屬性：\n```html\n```\n現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 2139,
    "chunk_index": 4,
    "total_chunks": 71
  },
  {
    "id": "eac37648be09825c1e1ef24422286caf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "讓我們從在 login 模板中添加表單開始。我們需要一個用戶名欄位和一個登入按鈕。 ```html Login Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1027,
    "chunk_index": 5,
    "total_chunks": 71
  },
  {
    "id": "0d347c8ce58d5535f6c7e9b1ba7c9405",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html Login Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 983,
    "chunk_index": 6,
    "total_chunks": 71
  },
  {
    "id": "4677ee6061043d5807ebbc12f3213919",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html Login Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 983,
    "chunk_index": 7,
    "total_chunks": 71
  },
  {
    "id": "0ea0c0020b53264c4fe8c0b8e9e5cb24",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html Login Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 983,
    "chunk_index": 8,
    "total_chunks": 71
  },
  {
    "id": "ee50660d67637cb78231910fe23fb862",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html Login Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-post",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 994,
    "chunk_index": 9,
    "total_chunks": 71
  },
  {
    "id": "493327071d73965e1f27b5093ac5b79c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html Login Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng)\n如果一切正常，伺服器應該會以 [JSON](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1021,
    "chunk_index": 10,
    "total_chunks": 71
  },
  {
    "id": "4e6b1809d579166ee5c99233ddd75d5e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjson",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1019,
    "chunk_index": 11,
    "total_chunks": 71
  },
  {
    "id": "f2e83cb8c694f6c7ea5a8a2f3df28257",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1022,
    "chunk_index": 12,
    "total_chunks": 71
  },
  {
    "id": "66916787c630ccc9b5ca8281e0e28f13",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "Username Login ``` 仔細觀察，你會注意到我們還添加了一個 <label> 元素。<label> 元素用於為 UI 控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。\n✅ 再次使用相同的名字註冊。會發生什麼？\n## 無需重新加載頁面提交資料\n你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1211,
    "chunk_index": 13,
    "total_chunks": 71
  },
  {
    "id": "98fe47e3fdaac82ae3ebc82725980840",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1167,
    "chunk_index": 14,
    "total_chunks": 71
  },
  {
    "id": "246e89ef75bb15a95166a4725dedf05d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "控制項添加名稱，例如我們的用戶名欄位。標籤對於表單的可讀性非常重要，還有以下額外好處： 通過將標籤與表單控制項關聯，幫助使用輔助技術（如螢幕閱讀器）的用戶理解需要提供哪些資料。 你可以點擊標籤直接將焦點放在相關的輸入欄位上，方便在觸控屏設備上操作。 網頁的可訪問性是一個非常重要但常被忽視的主題。得益於語義化 HTML 元素，如果正確使用它們，創建可訪問的內容並不困難。你可以閱讀更多關於可訪問性，避免常見錯誤，成為一名負責任的開發者。 現在我們將在前一個表單下方添加第二個註冊表單： ```html Register Username Currency Description Current balance Register ``` 使用 value 屬性，我們可以為某個輸入欄位定義預設值。 注意 balance 的輸入類型是 number。它看起來是否與其他輸入欄位不同？試著與它互動看看。 ✅ 你能僅使用鍵盤導航並與表單互動嗎？你會如何操作？ 向伺服器提交資料 現在我們有了一個功能性的 UI，下一步是將資料發送到伺服器。讓我們使用目前的程式碼進行快速測試：點擊登入或註冊按鈕會發生什麼？ 你是否注意到瀏覽器的 URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。\n要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務：\n- 獲取表單資料\n- 將表單資料轉換並編碼為合適的格式\n- 創建 HTTP 請求並將其發送到伺服器\n### 任務\n將註冊表單的 `action` 替換為：\n```html\n```\n打開 `app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1416,
    "chunk_index": 15,
    "total_chunks": 71
  },
  {
    "id": "91b233aaa2ea0a403ee6123903e44470",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "URL 區域發生了變化？ <form> 的預設行為是使用 GET 方法將表單提交到當前伺服器 URL，並將表單資料直接附加到 URL。這種方法有一些缺點： 發送的資料大小有限（約 2000 字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數：\n```js\nfunction register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 877,
    "chunk_index": 16,
    "total_chunks": 71
  },
  {
    "id": "df0a1fe506b39e80b01b403eb96e4353",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "字元） 資料直接顯示在 URL 中（對於密碼來說不太安全） 不支持文件上傳 因此，你可以將其更改為使用 POST 方法，該方法將表單資料發送到 HTTP 請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst data = Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 802,
    "chunk_index": 17,
    "total_chunks": 71
  },
  {
    "id": "b10ad22b6efbf874b55bda3e81b99712",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "請求的主體中，避免了上述限制。 雖然 POST 是最常用的資料發送方法，但在某些特定情況下，例如實現搜索欄位時，使用 GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData);\nconst jsonData = JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 735,
    "chunk_index": 18,
    "total_chunks": 71
  },
  {
    "id": "adc3c48047db3a9ac3aeeecd435f4e3d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "GET 方法更為合適。 任務 為註冊表單添加 action 和 method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data);\n}\n```\n在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 712,
    "chunk_index": 19,
    "total_chunks": 71
  },
  {
    "id": "c6dbad7412eb0db868f62ac0c4d56bf5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 686,
    "chunk_index": 20,
    "total_chunks": 71
  },
  {
    "id": "14f63a97814f0c67dcfa2aca4d56eded",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "method 屬性： ```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`Object",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 732,
    "chunk_index": 21,
    "total_chunks": 71
  },
  {
    "id": "a1511426449160e2091b6169a547d4b1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 734,
    "chunk_index": 22,
    "total_chunks": 71
  },
  {
    "id": "f362c3daf51cb8cc79f25d825eb7109a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 736,
    "chunk_index": 23,
    "total_chunks": 71
  },
  {
    "id": "1abbe1e51432efc35093e2e236692b7f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "```html ``` 現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://www",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 788,
    "chunk_index": 24,
    "total_chunks": 71
  },
  {
    "id": "4181049951964cc3281a7f835f0e1530",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjson",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 785,
    "chunk_index": 25,
    "total_chunks": 71
  },
  {
    "id": "994fab5652400c2975e9902cb3084a95",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-en",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 788,
    "chunk_index": 26,
    "total_chunks": 71
  },
  {
    "id": "b0202d60a49a6969488f7df0ca22e90c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "現在嘗試使用你的名字註冊新帳戶。點擊*註冊*按鈕後，你應該會看到類似以下的內容：[瀏覽器窗口顯示 localhost:5000/api/accounts，並顯示包含用戶資料的 JSON 字串](////7-bank-project/2-forms/images/form-postpng) 如果一切正常，伺服器應該會以 [JSON](https://wwwjsonorg/json-enhtml) 回應你的請求，並包含已創建的帳戶資料。 ✅ 再次使用相同的名字註冊。會發生什麼？ ## 無需重新加載頁面提交資料 你可能注意到我們剛剛使用的方法有一個小問題：提交表單時，我們離開了應用程式，瀏覽器重定向到伺服器 URL。我們正在嘗試避免所有頁面重新加載，因為我們正在建立一個[單頁應用程式 (SPA)](https://enwikipediaorg/wiki/Single-page_application)。 要在不強制重新加載頁面的情況下將表單資料發送到伺服器，我們需要使用 JavaScript 程式碼。與其在 `` 元素的 `action` 屬性中放置 URL，你可以使用任何以 `javascript:` 字串開頭的 JavaScript 程式碼來執行自定義操作。使用這種方法意味著你需要自己實現一些瀏覽器之前自動完成的任務： - 獲取表單資料 - 將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。\n資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數：\n```js\nasync function createAccount(account) {\ntry {\nconst response = await fetch('//localhost:5000/api/accounts', {\nmethod: 'POST',\nheaders: { 'Content-Type': 'application/json' },\nbody: account\n});\nreturn await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 908,
    "chunk_index": 27,
    "total_chunks": 71
  },
  {
    "id": "42f844b6fd467490bae385dfc3ecfc60",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "將表單資料轉換並編碼為合適的格式 - 創建 HTTP 請求並將其發送到伺服器 ### 任務 將註冊表單的 `action` 替換為： ```html ``` 打開 `appjs`，添加一個名為 `register` 的新函數： ```js function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson();\n} catch (error) {\nreturn { error: error message || 'Unknown error' };\n}\n}\n```\n這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 500,
    "chunk_index": 28,
    "total_chunks": 71
  },
  {
    "id": "1c792a4183166d8519d3ebe28edda06a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "{ const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。\n這裡有一段關於 `async/await` 使用的快速影片：\n[",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 29,
    "total_chunks": 71
  },
  {
    "id": "b211de553b37a07e05d1163be00f21e6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "= new FormData(registerForm); const data = ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 使用的快速影片： [[管理 Promise 的 Async 和 Await](https://img youtube",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 497,
    "chunk_index": 30,
    "total_chunks": 71
  },
  {
    "id": "275d3269fc285ddda701a41b97caa5db",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 使用的快速影片： [[管理 Promise 的 Async 和 Await](https://img youtubecom/vi/YwmlRkrxvkk/0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 503,
    "chunk_index": 31,
    "total_chunks": 71
  },
  {
    "id": "0392be48af43a43c49ed91f3927fa3f7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 使用的快速影片： [[管理 Promise 的 Async 和 Await](https://img youtubecom/vi/YwmlRkrxvkk/0jpg)](https://youtube",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 509,
    "chunk_index": 32,
    "total_chunks": 71
  },
  {
    "id": "e0a3c74fb8f2d262dbef6b72affa8c77",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 使用的快速影片： [[管理 Promise 的 Async 和 Await](https://img youtubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watch",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 513,
    "chunk_index": 33,
    "total_chunks": 71
  },
  {
    "id": "35d9821c7318c98ca3b42c8c2f48a3cb",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "ObjectfromEntries(formData); const jsonData = JSONstringify(data); } ``` 在這裡，我們使用 `getElementById()` 獲取表單元素，並使用 [`FormData`](https://developermozillaorg/docs/Web/API/FormData) 幫助提取表單控制項的值作為鍵/值對集合。然後，我們使用 [`ObjectfromEntries()`](https://developermozillaorg/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) 將資料轉換為常規物件，最後將資料序列化為 [JSON](https://wwwjsonorg/json-enhtml)，這是一種常用於網頁資料交換的格式。 資料現在已準備好發送到伺服器。創建一個名為 `createAccount` 的新函數： ```js async function createAccount(account) { try { const response = await fetch('//localhost:5000/api/accounts', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 使用的快速影片： [[管理 Promise 的 Async 和 Await](https://img youtubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"管理 Promise 的 Async 和 Await\")\n> 🎥 點擊上方圖片觀看關於 async/await 的影片。\n我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數：\n- 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。\n- 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們正在向伺服器發送 JSON 資料，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。\n由於伺服器會以 JSON 回應請求，我們可以使用 `await response",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 765,
    "chunk_index": 34,
    "total_chunks": 71
  },
  {
    "id": "f82ce05e19c990928b4158fa0c6017ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "'Content-Type': 'application/json' }, body: account }); return await responsejson(); } catch (error) { return { error: error message || 'Unknown error' }; } } ``` 這個函數在做什麼？首先，注意這裡的 `async` 關鍵字。這意味著函數包含將以[**非同步**](https://developermozilla org/docs/Web/JavaScript/Reference/Statements/async_function)方式執行的程式碼。當與 `await` 關鍵字一起使用時，它允許等待非同步程式碼執行（例如等待伺服器回應）後再繼續。 這裡有一段關於 `async/await` 使用的快速影片： [[管理 Promise 的 Async 和 Await](https://img youtubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"管理 Promise 的 Async 和 Await\") > 🎥 點擊上方圖片觀看關於 async/await 的影片。 我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們正在向伺服器發送 JSON 資料，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器會以 JSON 回應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。注意此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保解析過程中的任何錯誤都能被捕獲。\n現在在 `register` 函數中添加一些程式碼以調用 `createAccount()`：\n```js\nconst result = await createAccount(jsonData);\n```\n由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字：\n```js\nasync function register() {\n```\n最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示：\n```js\nasync function register() {\nconst registerForm = document",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 727,
    "chunk_index": 35,
    "total_chunks": 71
  },
  {
    "id": "6bbfd1522b866a714fb1749b6b1b6306",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "Await](https://img youtubecom/vi/YwmlRkrxvkk/0jpg)](https://youtubecom/watchv=YwmlRkrxvkk \"管理 Promise 的 Async 和 Await\") > 🎥 點擊上方圖片觀看關於 async/await 的影片。 我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們正在向伺服器發送 JSON 資料，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器會以 JSON 回應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。注意此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保解析過程中的任何錯誤都能被捕獲。 現在在 `register` 函數中添加一些程式碼以調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm');\nconst formData = new FormData(registerForm);\nconst jsonData = JSON",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 524,
    "chunk_index": 36,
    "total_chunks": 71
  },
  {
    "id": "1653c8bdc33363100b8a72ebf7774b6d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "🎥 點擊上方圖片觀看關於 async/await 的影片。 我們使用 `fetch()` API 將 JSON 資料發送到伺服器。此方法需要兩個參數： - 伺服器的 URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們正在向伺服器發送 JSON 資料，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器會以 JSON 回應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。注意此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保解析過程中的任何錯誤都能被捕獲。 現在在 `register` 函數中添加一些程式碼以調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData));\nconst result = await createAccount(jsonData);\nif (result error) {\nreturn console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 499,
    "chunk_index": 37,
    "total_chunks": 71
  },
  {
    "id": "efa4850ef3f514f5046fa3ae5c6ab9d5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "URL，因此我們在這裡放回 `//localhost:5000/api/accounts`。 - 請求的設置。在這裡，我們將方法設置為 `POST`，並提供請求的 `body`。由於我們正在向伺服器發送 JSON 資料，因此還需要將 `Content-Type` 標頭設置為 `application/json`，以便伺服器知道如何解釋內容。 由於伺服器會以 JSON 回應請求，我們可以使用 `await responsejson()` 解析 JSON 內容並返回結果物件。注意此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保解析過程中的任何錯誤都能被捕獲。 現在在 `register` 函數中添加一些程式碼以調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error);\n}\nconsole log('Account created ', result);\n}\n```\n雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 38,
    "total_chunks": 71
  },
  {
    "id": "6e1a3a3505aab01adb0645e7368bdd40",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "`await responsejson()` 解析 JSON 內容並返回結果物件。注意此方法是非同步的，因此我們在返回之前使用 `await` 關鍵字以確保解析過程中的任何錯誤都能被捕獲。 現在在 `register` 函數中添加一些程式碼以調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-console",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 446,
    "chunk_index": 39,
    "total_chunks": 71
  },
  {
    "id": "fbc55cf5b6ae475635e61932291643c3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "`await` 關鍵字以確保解析過程中的任何錯誤都能被捕獲。 現在在 `register` 函數中添加一些程式碼以調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng)\n✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipedia",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 474,
    "chunk_index": 40,
    "total_chunks": 71
  },
  {
    "id": "a8fa7928b81e6cf09ac810c172d07cc6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "`register` 函數中添加一些程式碼以調用 `createAccount()`： ```js const result = await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。\n## 資料驗證\n如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 534,
    "chunk_index": 41,
    "total_chunks": 71
  },
  {
    "id": "6835248aed247c57a0e018300c8437ad",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "= await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 507,
    "chunk_index": 42,
    "total_chunks": 71
  },
  {
    "id": "47e4e77fd33e9ef76555331917f3a488",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "= await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 552,
    "chunk_index": 43,
    "total_chunks": 71
  },
  {
    "id": "dab3c418d447a9145460bfe5cbbe9412",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "= await createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。\n在將資料發送到伺服器之前，最好先[驗證表單資料](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 44,
    "total_chunks": 71
  },
  {
    "id": "d778e3a2bb56a19a30c4d687f40567df",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 593,
    "chunk_index": 45,
    "total_chunks": 71
  },
  {
    "id": "342b3d2bee0e9fd52d5cd07193e17fc3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "createAccount(jsonData); ``` 由於我們在這裡使用了 `await` 關鍵字，因此需要在 register 函數前添加 `async` 關鍵字： ```js async function register() { ``` 最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性：\n- `required`：欄位必須填寫，否則表單無法提交。\n- `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。\n- `min` 和 `max`：定義數字欄位的最小和最大值。\n- `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 774,
    "chunk_index": 46,
    "total_chunks": 71
  },
  {
    "id": "20c0060ce2b5b883a8aeb007cad0e68b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 715,
    "chunk_index": 47,
    "total_chunks": 71
  },
  {
    "id": "ad8367ffd476604aba3a4ac756b317dc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "最後，讓我們添加一些日誌來檢查結果。最終的函數應如下所示： ```js async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。\n- `pattern`：允許定義一個[正則表達式](https://developer",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 780,
    "chunk_index": 48,
    "total_chunks": 71
  },
  {
    "id": "c8b79f73a372694aa42fe39bfde95bd9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozilla",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 740,
    "chunk_index": 49,
    "total_chunks": 71
  },
  {
    "id": "5e625b8f9ea001cd0ecb655d19eb085b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "async function register() { const registerForm = documentgetElementById('registerForm'); const formData = new FormData(registerForm); const jsonData = JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。\n提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。\n### 任務\n要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明：\n```html\nUsername (required)",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 917,
    "chunk_index": 50,
    "total_chunks": 71
  },
  {
    "id": "2a4ad029e8acf359d457e7d77b5d56fa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "= JSONstringify(Object fromEntries(formData)); const result = await createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required)\n```\n雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。\n為文字欄位添加 `maxlength` 屬性：\n```html",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 995,
    "chunk_index": 51,
    "total_chunks": 71
  },
  {
    "id": "54914bc6dc4183bb54793c82497fa43b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "createAccount(jsonData); if (result error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html```\n現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1053,
    "chunk_index": 52,
    "total_chunks": 71
  },
  {
    "id": "8ccb6c80c56153ae9dae8844bba86cf0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1073,
    "chunk_index": 53,
    "total_chunks": 71
  },
  {
    "id": "57842da8e648eac2e0a6b962eabdc2ba",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1074,
    "chunk_index": 54,
    "total_chunks": 71
  },
  {
    "id": "e7e9dd3a334ba24fa3caef33f66d1e47",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1074,
    "chunk_index": 55,
    "total_chunks": 71
  },
  {
    "id": "08fcf04153e6fd64b4bb994b6ea5dd13",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1074,
    "chunk_index": 56,
    "total_chunks": 71
  },
  {
    "id": "8dfef9534c2593cb94f5826e288a1913",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-error",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1085,
    "chunk_index": 57,
    "total_chunks": 71
  },
  {
    "id": "1e4bdd7cd0322818556e257b5d9a26ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "error) { return consolelog('An error occurred:', result error); } console log('Account created ', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng)\n這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。\n通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。\n---\n## 🚀 挑戰\n如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。\n以下是一個經過一些樣式設計後的最終登錄頁面的示例：",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1425,
    "chunk_index": 58,
    "total_chunks": 71
  },
  {
    "id": "8ba3148c6b8fb8e187563d30ff5d6285",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "', result); } ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1427,
    "chunk_index": 59,
    "total_chunks": 71
  },
  {
    "id": "a4c3db85419ffd2bd30adaf7c744538d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "} ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](/",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1425,
    "chunk_index": 60,
    "total_chunks": 71
  },
  {
    "id": "3ac74413f16dac0f79353a0c3e35cd0d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "} ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](//",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1425,
    "chunk_index": 61,
    "total_chunks": 71
  },
  {
    "id": "9fcaf11699218b19a93bb08188e18bc1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "} ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](///",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1425,
    "chunk_index": 62,
    "total_chunks": 71
  },
  {
    "id": "7ebeef929185d4eb4fa3862325f81627",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "} ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/result",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1435,
    "chunk_index": 63,
    "total_chunks": 71
  },
  {
    "id": "8f6c7b0c361c2aa5bc87b81edb5ef0b0",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "} ``` 雖然過程有點長，但我們完成了！如果你打開[瀏覽器開發者工具](https://developer mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng)\n## 課後測驗\n[課後測驗](https://ashy-river-0debb7803",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1468,
    "chunk_index": 64,
    "total_chunks": 71
  },
  {
    "id": "1aa13aff46002eecd98e3596ec72b4d8",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1424,
    "chunk_index": 65,
    "total_chunks": 71
  },
  {
    "id": "1d4b4a4c6a5bd3afb933fbceeb2a5e4b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticapps",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1427,
    "chunk_index": 66,
    "total_chunks": 71
  },
  {
    "id": "f111f162849515ac4b774fed072f97cd",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "mozillaorg/docs/Learn/Common_questions/What_are_browser_developer_tools)，並嘗試註冊新帳戶，你應該不會看到網頁有任何變化，但控制台中會出現一條消息，確認一切正常。 [瀏覽器控制台中的日誌消息截圖]( / / / /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44)\n## 回顧與自學\n開發者在構建表單方面變得非常有創意，特別是在驗證策略方面。通過瀏覽 [CodePen](https://codepen",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1500,
    "chunk_index": 67,
    "total_chunks": 71
  },
  {
    "id": "f424470de8ab8fa4154b7aec008a6b00",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "/ /7-bank-project/2-forms/images/browser-consolepng) ✅ 你認為資料是安全地發送到伺服器的嗎？如果有人能攔截請求會怎麼樣？你可以閱讀[HTTPS](https://en wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 回顧與自學 開發者在構建表單方面變得非常有創意，特別是在驗證策略方面。通過瀏覽 [CodePen](https://codepencom) 來了解不同的表單流程；你能找到一些有趣且具有啟發性的表單嗎？\n## 作業\n[為你的銀行應用程式設計樣式](assignment",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1468,
    "chunk_index": 68,
    "total_chunks": 71
  },
  {
    "id": "240370ab80e5ed63e901efbbf714840b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "wikipediaorg/wiki/HTTPS)以了解更多關於安全資料通信的內容。 ## 資料驗證 如果你嘗試在未設置用戶名的情況下註冊新帳戶，你會看到伺服器返回了一個狀態碼為 [400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 回顧與自學 開發者在構建表單方面變得非常有創意，特別是在驗證策略方面。通過瀏覽 [CodePen](https://codepencom) 來了解不同的表單流程；你能找到一些有趣且具有啟發性的表單嗎？ ## 作業 [為你的銀行應用程式設計樣式](assignmentmd)\n**免責聲明**：\n本文件已使用人工智能翻譯服務 [Co-op Translator](https://github",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1426,
    "chunk_index": 69,
    "total_chunks": 71
  },
  {
    "id": "60c6d5ce10d60b8f0035e22019e17bb1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第二部分：建立登入及註冊表單",
    "content": "[400 (Bad Request)](https://developermozillaorg/docs/Web/HTTP/Status/400#:~:text=The%20HyperText%20Transfer%20Protocol%20(HTTP,%2C%20or%20deceptive%20request%20routing)) 的錯誤。 在將資料發送到伺服器之前，最好先[驗證表單資料](https://developermozillaorg/docs/Learn/Forms/Form_validation)，以確保發送的是有效請求。HTML5 表單控制項提供了內建的驗證功能，使用各種屬性： - `required`：欄位必須填寫，否則表單無法提交。 - `minlength` 和 `maxlength`：定義文本欄位的最小和最大字元數。 - `min` 和 `max`：定義數字欄位的最小和最大值。 - `type`：定義預期的資料類型，例如 `number`、`email`、`file` 或[其他內建類型](https://developermozillaorg/docs/Web/HTML/Element/input)。此屬性還可能改變表單控制項的視覺呈現。 - `pattern`：允許定義一個[正則表達式](https://developermozillaorg/docs/Web/JavaScript/Guide/Regular_Expressions)模式，以測試輸入的資料是否有效。 提示：您可以使用 `:valid` 和 `:invalid` CSS 偽類來根據表單控件是否有效來自定義其外觀。 ### 任務 要創建一個有效的新帳戶，需要填寫兩個必填欄位：用戶名和貨幣，其餘欄位為可選。更新表單的 HTML，使用 `required` 屬性以及在欄位標籤中添加文字來說明： ```html Username (required)Currency (required) ``` 雖然這個特定的伺服器實現並未對欄位的最大長度設置具體限制，但為任何用戶輸入的文字定義合理的限制始終是一個良好的做法。 為文字欄位添加 `maxlength` 屬性： ```html``` 現在，如果你按下 *註冊* 按鈕，而某個欄位未遵守我們定義的驗證規則，你應該會看到如下所示的內容：[截圖顯示嘗試提交表單時的驗證錯誤](////7-bank-project/2-forms/images/validation-errorpng) 這種在將任何數據發送到伺服器之前進行的驗證稱為 **客戶端驗證**。但需要注意的是，並非所有檢查都能在不發送數據的情況下完成。例如，我們無法在這裡檢查是否已經存在相同用戶名的帳戶，除非向伺服器發送請求。在伺服器上執行的額外驗證稱為 **伺服器端驗證**。 通常需要同時實現這兩種驗證。客戶端驗證通過向用戶提供即時反饋來改善用戶體驗，而伺服器端驗證則至關重要，確保你處理的用戶數據是可靠且安全的。 --- ## 🚀 挑戰 如果用戶已存在，請在 HTML 中顯示一條錯誤訊息。 以下是一個經過一些樣式設計後的最終登錄頁面的示例：[添加 CSS 樣式後的登錄頁面截圖](////7-bank-project/2-forms/images/resultpng) ## 課後測驗 [課後測驗](https://ashy-river-0debb78031azurestaticappsnet/quiz/44) ## 回顧與自學 開發者在構建表單方面變得非常有創意，特別是在驗證策略方面。通過瀏覽 [CodePen](https://codepencom) 來了解不同的表單流程；你能找到一些有趣且具有啟發性的表單嗎？ ## 作業 [為你的銀行應用程式設計樣式](assignmentmd) **免責聲明**： 本文件已使用人工智能翻譯服務 [Co-op Translator](https://githubcom/Azure/co-op-translator) 進行翻譯。儘管我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。原始語言的文件應被視為權威來源。對於重要信息，建議使用專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16987,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\2-forms\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1495,
    "chunk_index": 70,
    "total_chunks": 71
  },
  {
    "id": "da8fde0481934b4307cdef14bfea2608",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\solution\\README.md",
    "source_type": "git_repo",
    "title": "銀行應用程式",
    "content": "銀行應用程式\n銀行應用程式專案的範例解決方案，使用原生 HTML5、CSS 和 JavaScript 建構（未使用任何框架或函式庫）。\n運行應用程式\n首先，請確保 API 伺服器 已經在運行。\n任何網頁伺服器都可以用來運行此應用程式，但由於你應該已經安裝了 Node.js 來運行 API，因此你可以：\nGit clone 此存儲庫。\n打開終端機，導航到此目錄，然後執行 npx lite-server .。它將在埠 3000 啟動一個開發網頁伺服器。\n在瀏覽器中打開 http://localhost:3000 以運行應用程式。\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1322,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\solution\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 437,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "2cde4be21e9a9bce9b9461442f1662b3",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行 API",
    "content": "銀行 API\n使用 Node js + Express 建構的銀行 API。\n這個 API 已經為你建構完成，並不是練習的一部分。\n不過，如果你有興趣學習如何建構這樣的 API，可以參考這系列影片：https://aka ms/NodeBeginner（第 17 到 21 集涵蓋了這個 API 的詳細內容）。\n你也可以查看這個互動式教學：https://aka ms/learn/express-api\n啟動伺服器\n請確保你已安裝 Node",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2644,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 188,
    "chunk_index": 0,
    "total_chunks": 3
  },
  {
    "id": "473679a38d70a8efda5f3531777d9493",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行 API",
    "content": "銀行 API\n使用 Node js + Express 建構的銀行 API。\n這個 API 已經為你建構完成，並不是練習的一部分。\n不過，如果你有興趣學習如何建構這樣的 API，可以參考這系列影片：https://aka ms/NodeBeginner（第 17 到 21 集涵蓋了這個 API 的詳細內容）。\n你也可以查看這個互動式教學：https://aka ms/learn/express-api\n啟動伺服器\n請確保你已安裝 Nodejs。\nGit clone 這個倉庫 The Web-Dev-For-Beginners。\n打開終端機，進入 Web-Dev-For-Beginners/7-bank-project/api 資料夾。\n執行 npm install，並等待套件安裝完成（根據你的網路連線品質，可能需要一些時間）。\n安裝完成後，執行 npm start，即可啟動伺服器。\n伺服器應該會開始在埠號 5000 上監聽。\n這個伺服器會與主要的銀行應用程式伺服器（監聽埠號 3000）同時運行，請不要關閉它。\n注意：所有的資料都儲存在記憶體中，並不會被持久化，因此當伺服器停止時，所有資料都會丟失。\nAPI 詳細資訊\n路由                                        | 描述\n---------------------------------------------|------------------------------------\nGET    /api/                                 | 獲取伺服器資訊\nPOST   /api/accounts/                        | 建立一個帳戶，例如：{ user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 }\nGET    /api/accounts/:user                   | 獲取指定帳戶的所有資料\nDELETE /api/accounts/:user                   | 刪除指定帳戶\nPOST   /api/accounts/:user/transactions      | 新增一筆交易，例如：{ date: '2020-07-23T18:25:43",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2644,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 621,
    "chunk_index": 1,
    "total_chunks": 3
  },
  {
    "id": "68ad9d030afb69234197e2dcdece9f07",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\api\\README.md",
    "source_type": "git_repo",
    "title": "銀行 API",
    "content": "API。 這個 API 已經為你建構完成，並不是練習的一部分。 不過，如果你有興趣學習如何建構這樣的 API，可以參考這系列影片：https://aka ms/NodeBeginner（第 17 到 21 集涵蓋了這個 API 的詳細內容）。 你也可以查看這個互動式教學：https://aka ms/learn/express-api 啟動伺服器 請確保你已安裝 Nodejs。 Git clone 這個倉庫 The Web-Dev-For-Beginners。 打開終端機，進入 Web-Dev-For-Beginners/7-bank-project/api 資料夾。 執行 npm install，並等待套件安裝完成（根據你的網路連線品質，可能需要一些時間）。 安裝完成後，執行 npm start，即可啟動伺服器。 伺服器應該會開始在埠號 5000 上監聽。 這個伺服器會與主要的銀行應用程式伺服器（監聽埠號 3000）同時運行，請不要關閉它。 注意：所有的資料都儲存在記憶體中，並不會被持久化，因此當伺服器停止時，所有資料都會丟失。 API 詳細資訊 路由 | 描述 ---------------------------------------------|------------------------------------ GET /api/ | 獲取伺服器資訊 POST /api/accounts/ | 建立一個帳戶，例如：{ user: 'Yohan', description: 'My budget', currency: 'EUR', balance: 100 } GET /api/accounts/:user | 獲取指定帳戶的所有資料 DELETE /api/accounts/:user | 刪除指定帳戶 POST /api/accounts/:user/transactions | 新增一筆交易，例如：{ date: '2020-07-23T18:25:43511Z', object: 'Bought a book', amount: -20 }\nDELETE  /api/accounts/:user/transactions/:id | 刪除指定的交易\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 2644,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\api\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 802,
    "chunk_index": 2,
    "total_chunks": 3
  },
  {
    "id": "bd540be5b5c9bd4c3aa941494649792a",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\assignment.md",
    "source_type": "git_repo",
    "title": "模擬一個遊戲",
    "content": "模擬一個遊戲\n指引\n利用課堂中的代碼範例，寫一個你喜歡的遊戲的簡單表示形式。這需要是一個簡單的遊戲，但目標是使用類別或組合模式以及發布/訂閱模式來展示遊戲如何啟動。發揮創意吧！\n評分標準\n| 評分標準 | 優異                                                   | 合格                                                 | 需要改進                                           |\n| -------- | ------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------- |\n|          | 在螢幕上放置並操作三個元素                              | 在螢幕上放置並操作兩個元素                           | 在螢幕上放置並操作一個元素                         |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1546,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 419,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "1af7f1ac706988ee5b89fbf881d443ce",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\assignment.md",
    "source_type": "git_repo",
    "title": "使用 Canvas API 玩創意",
    "content": "使用 Canvas API 玩創意\n指引\n選擇 Canvas API 的其中一個元素，並圍繞它創作一些有趣的內容。你能否創造一個由重複星星組成的小型星系？或者創造一個由彩色線條組成的有趣紋理？你可以參考 CodePen 的作品尋找靈感（但不要直接複製）。\n評分標準\n| 評分準則 | 卓越表現                                             | 合格表現                        | 有待改善             |\n| -------- | --------------------------------------------------- | ------------------------------- | --------------------- |\n|          | 提交的程式碼展示了有趣的紋理或形狀                 | 提交的程式碼，但無法正常運行    | 未提交程式碼          |\n免責聲明：\n本文件使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1439,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 420,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "2bb803c5c8670140f5d709e5d4343f61",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas\n課前測驗\n課前測驗\nCanvas\nCanvas 是一個 HTML 元素，預設是沒有內容的；它是一個空白的畫布。你需要透過在上面繪製來添加內容。\n✅ 在 MDN 上閱讀 更多關於 Canvas API 的資訊。\n以下是它通常在頁面中宣告的方式：\n```html\n```\n上面我們設定了 id、width 和 height。\nid：設定這個值以便在需要與它互動時獲取引用。\nwidth：這是元素的寬度。\nheight：這是元素的高度。\n繪製簡單幾何圖形\nCanvas 使用笛卡爾座標系統來繪製物件。因此，它使用 x 軸和 y 軸來表示物件的位置。位置 0,0 是左上角，而右下角則是你設定的 Canvas 的寬度和高度。\n圖片來源：MDN\n要在 Canvas 元素上繪製，你需要完成以下步驟：\n獲取 Canvas 元素的引用。\n獲取 Canvas 元素上的 Context 元素的引用。\n使用 Context 元素執行繪製操作。\n上述步驟的程式碼通常如下所示：\n```javascript\n// draws a red rectangle\n//1 get the canvas reference\ncanvas = document getElementById(\"myCanvas\");\n//2 set the context to 2D to draw basic shapes\nctx = canvas getContext(\"2d\");\n//3 fill it with the color red\nctx fillStyle = 'red';\n//4 and draw a rectangle with these parameters, setting location and size\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 490,
    "chunk_index": 0,
    "total_chunks": 16
  },
  {
    "id": "0050a3d8b2c363430ede78203d869a68",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "軸和 y 軸來表示物件的位置。位置 0,0 是左上角，而右下角則是你設定的 Canvas 的寬度和高度。 圖片來源：MDN 要在 Canvas 元素上繪製，你需要完成以下步驟： 獲取 Canvas 元素的引用。 獲取 Canvas 元素上的 Context 元素的引用。 使用 Context 元素執行繪製操作。 上述步驟的程式碼通常如下所示： ```javascript // draws a red rectangle //1 get the canvas reference canvas = document getElementById(\"myCanvas\"); //2 set the context to 2D to draw basic shapes ctx = canvas getContext(\"2d\"); //3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height\n```\n✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。\n使用 Canvas API 你可以繪製各種內容，例如：\n幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。\n文字，你可以使用任何字型和顏色繪製文字。\n圖片，你可以基於圖片資源（例如 jpg 或",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 389,
    "chunk_index": 1,
    "total_chunks": 16
  },
  {
    "id": "b55b682b325e141003ee41df38ece32d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "draws a red rectangle //1 get the canvas reference canvas = document getElementById(\"myCanvas\"); //2 set the context to 2D to draw basic shapes ctx = canvas getContext(\"2d\"); //3 fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API 你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字型和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。\n✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。\n加載並繪製圖片資源\n你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後監聽 load 事件以確保圖片已準備好使用。程式碼如下：\n加載資源\njavascript\nconst img = new Image();\nimg src = 'path/to/my/image png';\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 467,
    "chunk_index": 2,
    "total_chunks": 16
  },
  {
    "id": "ae74680d3e46356f2a58ea6ab29ebd54",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "fill it with the color red ctx fillStyle = 'red'; //4 and draw a rectangle with these parameters, setting location and size ctxfillRect(0,0, 200, 200) // x,y,width, height ``` ✅ Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API 你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字型和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。 ✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。 加載並繪製圖片資源 你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後監聽 load 事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => {\n// image loaded and ready to be used\n}\n加載資源模式\n建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在資源完全加載後才嘗試操作它：\n```javascript\nfunction loadAsset(path) {\nreturn new Promise((resolve) => {\nconst img = new Image();\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 534,
    "chunk_index": 3,
    "total_chunks": 16
  },
  {
    "id": "dcdd556745767965cf7caea6dbc9c359",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "Canvas API 主要專注於 2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API 你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字型和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。 ✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。 加載並繪製圖片資源 你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後監聽 load 事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } 加載資源模式 建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在資源完全加載後才嘗試操作它： ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path;\nimg",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 4,
    "total_chunks": 16
  },
  {
    "id": "bdd959debc298dedd82f86e914fa17f4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "2D 圖形，但你也可以在網站上繪製 3D 元素；為此，你可以使用 WebGL API。 使用 Canvas API 你可以繪製各種內容，例如： 幾何圖形，我們已展示如何繪製矩形，但還有更多可以繪製的內容。 文字，你可以使用任何字型和顏色繪製文字。 圖片，你可以基於圖片資源（例如 jpg 或png）繪製圖片。 ✅ 試試看！你已經知道如何繪製矩形，能否嘗試在頁面上繪製一個圓形？看看 CodePen 上一些有趣的 Canvas 繪圖。這裡有一個 特別令人印象深刻的例子。 加載並繪製圖片資源 你可以透過建立一個 Image 物件並設定其 src 屬性來加載圖片資源。然後監聽 load 事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } 加載資源模式 建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在資源完全加載後才嘗試操作它： ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path; imgonload = () => {\n// image loaded and ready to be used\nresolve(img);\n}\n})\n}\n// use like so\nasync function run() {\nconst heroImg = await loadAsset('hero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 518,
    "chunk_index": 5,
    "total_chunks": 16
  },
  {
    "id": "048446481f5b1f63094cdbb4100ee068",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "事件以確保圖片已準備好使用。程式碼如下： 加載資源 javascript const img = new Image(); img src = 'path/to/my/image png'; imgonload = () => { // image loaded and ready to be used } 加載資源模式 建議將上述程式碼包裝在如下結構中，這樣更容易使用，並且只有在資源完全加載後才嘗試操作它： ```javascript function loadAsset(path) { return new Promise((resolve) => { const img = new Image(); imgsrc = path; imgonload = () => { // image loaded and ready to be used resolve(img); } }) } // use like so async function run() { const heroImg = await loadAsset('heropng')\nconst monsterImg = await loadAsset('monster png')\n}\n```\n要將遊戲資源繪製到螢幕上，程式碼如下：\n```javascript\nasync function run() {\nconst heroImg = await loadAsset('hero png')\nconst monsterImg = await loadAsset('monster png')\ncanvas = document getElementById(\"myCanvas\");\nctx = canvas getContext(\"2d\");\nctx drawImage(heroImg, canvas width/2,canvas height/2);\nctx drawImage(monsterImg, 0,0);\n}\n```\n現在是時候開始建立你的遊戲了\n要建立什麼\n你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片：\n英雄飛船\n5*5 怪物\n建議的開發步驟\n找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容：\nbash\n-| assets\n-| enemyShip",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 496,
    "chunk_index": 6,
    "total_chunks": 16
  },
  {
    "id": "8e3e731eb0169905e8a6d0fe960e41a9",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "} // use like so async function run() { const heroImg = await loadAsset('heropng') const monsterImg = await loadAsset('monster png') } ``` 要將遊戲資源繪製到螢幕上，程式碼如下： ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是時候開始建立你的遊戲了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng\n-| player png\n-| index html\n-| app js\n-| package",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 334,
    "chunk_index": 7,
    "total_chunks": 16
  },
  {
    "id": "0b346edec71a9648ee252cb6f30c5178",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "= await loadAsset('heropng') const monsterImg = await loadAsset('monster png') } ``` 要將遊戲資源繪製到螢幕上，程式碼如下： ```javascript async function run() { const heroImg = await loadAsset('hero png') const monsterImg = await loadAsset('monster png') canvas = document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是時候開始建立你的遊戲了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson\n在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code 並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡有相關指南。\n通過導航到 your_work 資料夾開始你的專案：\nbash\ncd your-work\nnpm start\n上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。\n注意：要在螢幕上看到變更，請刷新瀏覽器。\n添加程式碼\n在 your-work/app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 544,
    "chunk_index": 8,
    "total_chunks": 16
  },
  {
    "id": "ec67a96f3471ce21a049022a39603e26",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "= document getElementById(\"myCanvas\"); ctx = canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是時候開始建立你的遊戲了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code 並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡有相關指南。 通過導航到 your_work 資料夾開始你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到變更，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下任務：\n繪製一個黑色背景的 Canvas\n提示：在 /app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 9,
    "total_chunks": 16
  },
  {
    "id": "7871e2813f911ed32156bc7adeb63d75",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "canvas getContext(\"2d\"); ctx drawImage(heroImg, canvas width/2,canvas height/2); ctx drawImage(monsterImg, 0,0); } ``` 現在是時候開始建立你的遊戲了 要建立什麼 你將建立一個包含 Canvas 元素的網頁。它應該渲染一個黑色螢幕，大小為 1024*768。我們已提供兩張圖片： 英雄飛船 5*5 怪物 建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code 並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡有相關指南。 通過導航到 your_work 資料夾開始你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到變更，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下任務： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將頂部/左側座標設置為 0,0，高度和寬度等於 Canvas 的大小。\n加載材質\n提示：使用 await loadTexture 並傳入圖片路徑來加載玩家和敵人的圖片。你暫時還看不到它們出現在螢幕上！\n繪製英雄到螢幕底部中央\n提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 683,
    "chunk_index": 10,
    "total_chunks": 16
  },
  {
    "id": "92f3acc3fc75052919081095d6640029",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "建議的開發步驟 找到在 your-work 子資料夾中為你建立的檔案。它應包含以下內容： bash -| assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code 並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡有相關指南。 通過導航到 your_work 資料夾開始你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到變更，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下任務： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將頂部/左側座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來加載玩家和敵人的圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕底部中央 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 541,
    "chunk_index": 11,
    "total_chunks": 16
  },
  {
    "id": "2acb4e08cb1fe88b0fb79a0cdc3de741",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "assets -| enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code 並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡有相關指南。 通過導航到 your_work 資料夾開始你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到變更，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下任務： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將頂部/左側座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來加載玩家和敵人的圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕底部中央 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 493,
    "chunk_index": 12,
    "total_chunks": 16
  },
  {
    "id": "f86aed2df2bc84d4d3afc006c9019c3f",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "enemyShippng -| player png -| index html -| app js -| packagejson 在 Visual Studio Code 中打開這個資料夾的副本。你需要設置本地開發環境，最好使用 Visual Studio Code 並安裝 NPM 和 Node。如果你的電腦尚未設置 npm，這裡有相關指南。 通過導航到 your_work 資料夾開始你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到變更，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下任務： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將頂部/左側座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來加載玩家和敵人的圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕底部中央 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvasheight / 4)。\n繪製 5*5 怪物\n提示：現在你可以取消註解程式碼以在螢幕上繪製敵人。接著，進入 createEnemies 函數並完成它。\n首先，設置一些常數：\n```javascript\nconst MONSTER_TOTAL = 5;\nconst MONSTER_WIDTH = MONSTER_TOTAL * 98;\nconst START_X = (canvas",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 602,
    "chunk_index": 13,
    "total_chunks": 16
  },
  {
    "id": "6611734c2cfcd8ef20848bc61738b3b5",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "npm，這裡有相關指南。 通過導航到 your_work 資料夾開始你的專案： bash cd your-work npm start 上述指令會在地址 http://localhost:5000 上啟動一個 HTTP 伺服器。打開瀏覽器並輸入該地址。現在是一個空白頁面，但很快就會改變。 注意：要在螢幕上看到變更，請刷新瀏覽器。 添加程式碼 在 your-work/appjs 中添加所需程式碼以完成以下任務： 繪製一個黑色背景的 Canvas 提示：在 /appjs 中適當的 TODO 下添加兩行程式碼，將 ctx 元素設置為黑色，並將頂部/左側座標設置為 0,0，高度和寬度等於 Canvas 的大小。 加載材質 提示：使用 await loadTexture 並傳入圖片路徑來加載玩家和敵人的圖片。你暫時還看不到它們出現在螢幕上！ 繪製英雄到螢幕底部中央 提示：使用 drawImage API 將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvasheight / 4)。 繪製 5*5 怪物 提示：現在你可以取消註解程式碼以在螢幕上繪製敵人。接著，進入 createEnemies 函數並完成它。 首先，設置一些常數： ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2;\nconst STOP_X = START_X + MONSTER_WIDTH;\n```\n然後，建立一個迴圈以將怪物陣列繪製到螢幕上：\n```javascript\nfor (let x = START_X; x < STOP_X; x += 98) {\nfor (let y = 0; y < 50 * 5; y += 50) {\nctx",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 617,
    "chunk_index": 14,
    "total_chunks": 16
  },
  {
    "id": "01a4aeacbb750a324946976d9ca97b9b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲第二部分：將英雄和怪物繪製到 Canvas",
    "content": "將 heroImg 繪製到螢幕上，座標設置為 canvaswidth / 2 - 45 和 canvasheight - canvasheight / 4)。 繪製 5*5 怪物 提示：現在你可以取消註解程式碼以在螢幕上繪製敵人。接著，進入 createEnemies 函數並完成它。 首先，設置一些常數： ```javascript const MONSTER_TOTAL = 5; const MONSTER_WIDTH = MONSTER_TOTAL * 98; const START_X = (canvaswidth - MONSTER_WIDTH) / 2; const STOP_X = START_X + MONSTER_WIDTH; ``` 然後，建立一個迴圈以將怪物陣列繪製到螢幕上： ```javascript for (let x = START_X; x < STOP_X; x += 98) { for (let y = 0; y < 50 * 5; y += 50) { ctxdrawImage(enemyImg, x, y);\n}\n}\n```\n結果\n完成的結果應如下所示：\n解決方案\n請先嘗試自己解決，但如果遇到困難，可以查看 解決方案。\n🚀 挑戰\n你已經學習了使用 2D 為主的 Canvas API；看看 WebGL API，並嘗試繪製一個 3D 物件。\n課後測驗\n課後測驗\n回顧與自學\n透過 閱讀相關內容 來深入了解 Canvas API。\n作業\n使用 Canvas API\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8048,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\2-drawing-to-canvas\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 623,
    "chunk_index": 15,
    "total_chunks": 16
  },
  {
    "id": "dcc1092f0dc625fdcd649f1bfe8b28fc",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "建立太空遊戲 第1部分：簡介\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於項目範圍較小，設計應用程式架構並不是一個需要特別關注的問題。然而，當你的應用程式規模和範圍逐漸擴大時，架構設計的決策就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩種方法各有優缺點，但我們將從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一與設計模式有關。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡兒座標系統中有一個位置，具體表現為 x 和 y 座標。在開發遊戲時，你會發現所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，主要包括以下幾個元素：\n基於位置 大多數（如果不是全部的話）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些是可以移動到新位置的物件。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在於一段時間內，然後會自動設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件中常見的屬性。一個典型的例子是文字或圖形效果（如爆炸），它們只應該顯示幾毫秒。\n✅ 想一想像吃豆人（Pac-Man）這樣的遊戲。你能在這個遊戲中識別出上述四種類型的物件嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼，我們如何編碼這些行為呢？我們可以將這些行為表達為與類別或物件相關聯的方法。\n類別\n我們可以使用 類別 結合 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的繼承文章 中了解更多。\n用程式碼表達時，一個遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1001,
    "chunk_index": 0,
    "total_chunks": 19
  },
  {
    "id": "2fc0cc4791d3af680a4f2ecffe7609b4",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "建立太空遊戲 第1部分：簡介\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於項目範圍較小，設計應用程式架構並不是一個需要特別關注的問題。然而，當你的應用程式規模和範圍逐漸擴大時，架構設計的決策就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩種方法各有優缺點，但我們將從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一與設計模式有關。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡兒座標系統中有一個位置，具體表現為 x 和 y 座標。在開發遊戲時，你會發現所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，主要包括以下幾個元素：\n基於位置 大多數（如果不是全部的話）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些是可以移動到新位置的物件。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在於一段時間內，然後會自動設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件中常見的屬性。一個典型的例子是文字或圖形效果（如爆炸），它們只應該顯示幾毫秒。\n✅ 想一想像吃豆人（Pac-Man）這樣的遊戲。你能在這個遊戲中識別出上述四種類型的物件嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼，我們如何編碼這些行為呢？我們可以將這些行為表達為與類別或物件相關聯的方法。\n類別\n我們可以使用 類別 結合 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的繼承文章 中了解更多。\n用程式碼表達時，一個遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1006,
    "chunk_index": 1,
    "total_chunks": 19
  },
  {
    "id": "04e0f846d4e9d704dc8efbe5af12a5ca",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "建立太空遊戲 第1部分：簡介\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於項目範圍較小，設計應用程式架構並不是一個需要特別關注的問題。然而，當你的應用程式規模和範圍逐漸擴大時，架構設計的決策就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩種方法各有優缺點，但我們將從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一與設計模式有關。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡兒座標系統中有一個位置，具體表現為 x 和 y 座標。在開發遊戲時，你會發現所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，主要包括以下幾個元素：\n基於位置 大多數（如果不是全部的話）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些是可以移動到新位置的物件。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在於一段時間內，然後會自動設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件中常見的屬性。一個典型的例子是文字或圖形效果（如爆炸），它們只應該顯示幾毫秒。\n✅ 想一想像吃豆人（Pac-Man）這樣的遊戲。你能在這個遊戲中識別出上述四種類型的物件嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼，我們如何編碼這些行為呢？我們可以將這些行為表達為與類別或物件相關聯的方法。\n類別\n我們可以使用 類別 結合 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的繼承文章 中了解更多。\n用程式碼表達時，一個遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthisy = y;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1011,
    "chunk_index": 2,
    "total_chunks": 19
  },
  {
    "id": "a5ceb50c2ba36a92e1d794d464ca03a1",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "建立太空遊戲 第1部分：簡介\n課前測驗\n課前測驗\n繼承與組合在遊戲開發中的應用\n在之前的課程中，由於項目範圍較小，設計應用程式架構並不是一個需要特別關注的問題。然而，當你的應用程式規模和範圍逐漸擴大時，架構設計的決策就變得更加重要。在 JavaScript 中，建立大型應用程式有兩種主要方法：組合 或 繼承。這兩種方法各有優缺點，但我們將從遊戲的角度來解釋它們。\n✅ 最著名的程式設計書籍之一與設計模式有關。\n在遊戲中，你會有 遊戲物件，這些物件存在於螢幕上。這意味著它們在笛卡兒座標系統中有一個位置，具體表現為 x 和 y 座標。在開發遊戲時，你會發現所有的遊戲物件都有一些標準屬性，這些屬性在每個遊戲中都很常見，主要包括以下幾個元素：\n基於位置 大多數（如果不是全部的話）遊戲元素都是基於位置的。這意味著它們有一個位置，即 x 和 y。\n可移動 這些是可以移動到新位置的物件。通常是英雄、怪物或 NPC（非玩家角色），但例如像樹這樣的靜態物件則不屬於此類。\n自我銷毀 這些物件只存在於一段時間內，然後會自動設置為刪除。通常這是通過一個 dead 或 destroyed 的布林值來表示，告訴遊戲引擎該物件不再需要渲染。\n冷卻時間 \"冷卻時間\" 是短暫存在的物件中常見的屬性。一個典型的例子是文字或圖形效果（如爆炸），它們只應該顯示幾毫秒。\n✅ 想一想像吃豆人（Pac-Man）這樣的遊戲。你能在這個遊戲中識別出上述四種類型的物件嗎？\n表達行為\n上述描述的都是遊戲物件可能具有的行為。那麼，我們如何編碼這些行為呢？我們可以將這些行為表達為與類別或物件相關聯的方法。\n類別\n我們可以使用 類別 結合 繼承 來為類別添加特定的行為。\n✅ 繼承是一個重要的概念。可以在 MDN 的繼承文章 中了解更多。\n用程式碼表達時，一個遊戲物件通常看起來像這樣：\n```javascript\n//set up the class GameObject\nclass GameObject {\nconstructor(x, y, type) {\nthisx = x;\nthisy = y;\nthistype = type;\n}\n}\n//this class will extend the GameObject's inherent class properties\nclass Movable extends GameObject {\nconstructor(x,y, type) {\nsuper(x,y, type)\n}\n//this movable object can be moved on the screen\nmoveTo(x, y) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1069,
    "chunk_index": 3,
    "total_chunks": 19
  },
  {
    "id": "0143099dae09fe803c8c1b175836a485",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "冷卻時間 \"冷卻時間\" 是短暫存在的物件中常見的屬性。一個典型的例子是文字或圖形效果（如爆炸），它們只應該顯示幾毫秒。 ✅ 想一想像吃豆人（Pac-Man）這樣的遊戲。你能在這個遊戲中識別出上述四種類型的物件嗎？ 表達行為 上述描述的都是遊戲物件可能具有的行為。那麼，我們如何編碼這些行為呢？我們可以將這些行為表達為與類別或物件相關聯的方法。 類別 我們可以使用 類別 結合 繼承 來為類別添加特定的行為。 ✅ 繼承是一個重要的概念。可以在 MDN 的繼承文章 中了解更多。 用程式碼表達時，一個遊戲物件通常看起來像這樣： ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x; thisy = y; thistype = type; } } //this class will extend the GameObject's inherent class properties class Movable extends GameObject { constructor(x,y, type) { super(x,y, type) } //this movable object can be moved on the screen moveTo(x, y) { thisx = x;\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 429,
    "chunk_index": 4,
    "total_chunks": 19
  },
  {
    "id": "7a93de72c6465ad21a9b6f9bd8dea7bf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "✅ 想一想像吃豆人（Pac-Man）這樣的遊戲。你能在這個遊戲中識別出上述四種類型的物件嗎？ 表達行為 上述描述的都是遊戲物件可能具有的行為。那麼，我們如何編碼這些行為呢？我們可以將這些行為表達為與類別或物件相關聯的方法。 類別 我們可以使用 類別 結合 繼承 來為類別添加特定的行為。 ✅ 繼承是一個重要的概念。可以在 MDN 的繼承文章 中了解更多。 用程式碼表達時，一個遊戲物件通常看起來像這樣： ```javascript //set up the class GameObject class GameObject { constructor(x, y, type) { thisx = x; thisy = y; thistype = type; } } //this class will extend the GameObject's inherent class properties class Movable extends GameObject { constructor(x,y, type) { super(x,y, type) } //this movable object can be moved on the screen moveTo(x, y) { thisx = x; thisy = y;\n}\n}\n//this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits\nclass Hero extends Movable {\nconstructor(x,y) {\nsuper(x,y, 'Hero')\n}\n}\n//this class, on the other hand, only inherits the GameObject properties\nclass Tree extends GameObject {\nconstructor(x,y) {\nsuper(x,y, 'Tree')\n}\n}\n//a hero can move const hero = new Hero();\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 453,
    "chunk_index": 5,
    "total_chunks": 19
  },
  {
    "id": "a554f61c7d43c093cada203c0fc49a0d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "moveTo(x, y) { thisx = x; thisy = y; } } //this is a specific class that extends the Movable class, so it can take advantage of all the properties that it inherits class Hero extends Movable { constructor(x,y) { super(x,y, 'Hero') } } //this class, on the other hand, only inherits the GameObject properties class Tree extends GameObject { constructor(x,y) { super(x,y, 'Tree') } } //a hero can move const hero = new Hero(); heromoveTo(5,5);\n//but a tree cannot\nconst tree = new Tree();\n```\n✅ 花幾分鐘重新構想一下吃豆人中的英雄（例如 Inky、Pinky 或 Blinky），並思考如何用 JavaScript 編寫它們。\n組合\n處理物件繼承的另一種方式是使用 組合。在這種情況下，物件的行為表達如下：\n```javascript\n//create a constant gameObject\nconst gameObject = {\nx: 0,\ny: 0,\ntype: ''\n};\n// and a constant movable\nconst movable = {\nmoveTo(x, y) {\nthis x = x;\nthis y = y;\n}\n}\n//then the constant movableObject is composed of the gameObject and movable constants\nconst movableObject = { gameObject, movable};\n//then create a function to create a new Hero who inherits the movableObject properties\nfunction createHero(x, y) {\nreturn { movableObject,\nx,\ny,\ntype: 'Hero'\n}\n}\n// and a static object that inherits only the gameObject properties\nfunction createStatic(x, y, type) {\nreturn { gameObject\nx,\ny,\ntype\n}\n}\n//create the hero and move it\nconst hero = createHero(10,10);\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 413,
    "chunk_index": 6,
    "total_chunks": 19
  },
  {
    "id": "b357acbdf74d3980cbaeadd535aba626",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "is composed of the gameObject and movable constants const movableObject = { gameObject, movable}; //then create a function to create a new Hero who inherits the movableObject properties function createHero(x, y) { return { movableObject, x, y, type: 'Hero' } } // and a static object that inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); heromoveTo(5,5);\n//and create a static tree which only stands around\nconst tree = createStatic(0,0, 'Tree');\n```\n應該使用哪種模式？\n選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。\n--\n在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。\nPub/Sub 模式\n✅ Pub/Sub 代表 \"發布-訂閱\"。\n這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現：\n訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。\n發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。\n訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。\n這種模式的實現規模很小，但它非常強大。以下是它的實現方式：\n```javascript\n//set up an EventEmitter class that contains listeners\nclass EventEmitter {\nconstructor() {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 612,
    "chunk_index": 7,
    "total_chunks": 19
  },
  {
    "id": "5a088245825405a513609bcadb1bbc7b",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "inherits only the gameObject properties function createStatic(x, y, type) { return { gameObject x, y, type } } //create the hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 應該使用哪種模式？ 選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {};\n}\n//when a message is received, let the listener to handle its payload\non(message, listener) {\nif (",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 576,
    "chunk_index": 8,
    "total_chunks": 19
  },
  {
    "id": "9e4a55427f1fc528dfdce21e650fc952",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 應該使用哪種模式？ 選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 548,
    "chunk_index": 9,
    "total_chunks": 19
  },
  {
    "id": "6ccb99cbfe419f8295ac127898c8b94d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "hero and move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 應該使用哪種模式？ 選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 554,
    "chunk_index": 10,
    "total_chunks": 19
  },
  {
    "id": "a185fe1bbbb67305893d83b9b0bfbcb7",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "move it const hero = createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 應該使用哪種模式？ 選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = [];\n}\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 560,
    "chunk_index": 11,
    "total_chunks": 19
  },
  {
    "id": "7eb97463368fee404711bcdb4696e1ac",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "= createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 應該使用哪種模式？ 選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 560,
    "chunk_index": 12,
    "total_chunks": 19
  },
  {
    "id": "9f93824f1c1e0d7e5f4ff537a56b7e34",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "= createHero(10,10); heromoveTo(5,5); //and create a static tree which only stands around const tree = createStatic(0,0, 'Tree'); ``` 應該使用哪種模式？ 選擇哪種模式完全取決於你。JavaScript 支援這兩種範式。 -- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener);\n}\n//when a message is sent, send it to a listener with some payload\nemit(message, payload = null) {\nif (this",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 591,
    "chunk_index": 13,
    "total_chunks": 19
  },
  {
    "id": "1de550cff6ea27a65c736212a63b6b38",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "-- 在遊戲開發中，另一種常見的模式是解決遊戲用戶體驗和效能問題。 Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) {\nthis",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 506,
    "chunk_index": 14,
    "total_chunks": 19
  },
  {
    "id": "a0bafd3940c6c739583eb21d53929e34",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { thislisteners[message]",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 466,
    "chunk_index": 15,
    "total_chunks": 19
  },
  {
    "id": "06fe91e316cc3da4fdf427df52f2f7aa",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "Pub/Sub 模式 ✅ Pub/Sub 代表 \"發布-訂閱\"。 這種模式解決了應用程式中不同部分不應該彼此了解的問題。為什麼這很重要？因為這樣可以更容易了解整體情況，並且如果需要改變行為，也會更加簡單。我們如何實現這一點？我們通過建立以下概念來實現： 訊息：訊息通常是一個文字字串，並可能附帶一個可選的有效負載（用於說明訊息的內容）。遊戲中的典型訊息可以是 KEY_PRESSED_ENTER。 發布者：這個元素發布一個訊息，並將其發送給所有訂閱者。 訂閱者：這個元素監聽特定的訊息，並在接收到該訊息後執行某些任務，例如發射雷射。 這種模式的實現規模很小，但它非常強大。以下是它的實現方式： ```javascript //set up an EventEmitter class that contains listeners class EventEmitter { constructor() { thislisteners = {}; } //when a message is received, let the listener to handle its payload on(message, listener) { if (thislisteners[message]) { thislisteners[message] = []; } thislisteners[message]push(listener); } //when a message is sent, send it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { thislisteners[message]forEach(l => l(message, payload))\n}\n}\n}\n```\n要使用上述程式碼，我們可以創建一個非常小的實現：\n```javascript\n//set up a message structure\nconst Messages = {\nHERO_MOVE_LEFT: 'HERO_MOVE_LEFT'\n};\n//invoke the eventEmitter you set up above\nconst eventEmitter = new EventEmitter();\n//set up a hero\nconst hero = createHero(0,0);\n//let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it\neventEmitter",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 590,
    "chunk_index": 16,
    "total_chunks": 19
  },
  {
    "id": "77a938ffb1ce771be5f98e19ba7285cf",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "it to a listener with some payload emit(message, payload = null) { if (thislisteners[message]) { thislisteners[message]forEach(l => l(message, payload)) } } } ``` 要使用上述程式碼，我們可以創建一個非常小的實現： ```javascript //set up a message structure const Messages = { HERO_MOVE_LEFT: 'HERO_MOVE_LEFT' }; //invoke the eventEmitter you set up above const eventEmitter = new EventEmitter(); //set up a hero const hero = createHero(0,0); //let the eventEmitter know to watch for messages pertaining to the hero moving left, and act on it eventEmitteron(Messages HERO_MOVE_LEFT, () => {\nhero move(5,0);\n});\n//set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left\nwindow addEventListener('keyup', (evt) => {\nif (evt key === 'ArrowLeft') {\neventEmitter emit(Messages HERO_MOVE_LEFT)\n}\n});\n```\n在上面的例子中，我們連接了一個鍵盤事件 ArrowLeft，並發送了 HERO_MOVE_LEFT 訊息。我們監聽該訊息，並因此移動 hero。這種模式的優勢在於事件監聽器和英雄彼此並不了解。你可以將 ArrowLeft 重新映射到 A 鍵。此外，通過對 eventEmitter 的 on 函數進行一些編輯，也可以在 ArrowLeft 上執行完全不同的操作：\njavascript\neventEmitter on(Messages HERO_MOVE_LEFT, () => {\nhero",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 397,
    "chunk_index": 17,
    "total_chunks": 19
  },
  {
    "id": "00cccbf9fbd6c4cbd4c8f3b1a20dfa4c",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
    "source_type": "git_repo",
    "title": "建立太空遊戲 第1部分：簡介",
    "content": "act on it eventEmitteron(Messages HERO_MOVE_LEFT, () => { hero move(5,0); }); //set up the window to listen for the keyup event, specifically if the left arrow is hit, emit a message to move the hero left window addEventListener('keyup', (evt) => { if (evt key === 'ArrowLeft') { eventEmitter emit(Messages HERO_MOVE_LEFT) } }); ``` 在上面的例子中，我們連接了一個鍵盤事件 ArrowLeft，並發送了 HERO_MOVE_LEFT 訊息。我們監聽該訊息，並因此移動 hero。這種模式的優勢在於事件監聽器和英雄彼此並不了解。你可以將 ArrowLeft 重新映射到 A 鍵。此外，通過對 eventEmitter 的 on 函數進行一些編輯，也可以在 ArrowLeft 上執行完全不同的操作： javascript eventEmitter on(Messages HERO_MOVE_LEFT, () => { heromove(5,0);\n});\n隨著遊戲規模的增大和複雜性的增加，這種模式的複雜性保持不變，並且你的程式碼保持整潔。非常推薦採用這種模式。\n🚀 挑戰\n思考 Pub/Sub 模式如何增強遊戲的功能。哪些部分應該發出事件，遊戲應該如何對它們作出反應？現在是發揮創意的時候，想像一個新遊戲及其各部分的行為。\n課後測驗\n課後測驗\n複習與自學\n通過閱讀相關內容來進一步了解 Pub/Sub。\n作業\n設計一個遊戲原型\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。如涉及關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 8943,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\1-introduction\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 688,
    "chunk_index": 18,
    "total_chunks": 19
  },
  {
    "id": "234bf54d3c14e59f26de6542e6de5dec",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\assignment.md",
    "source_type": "git_repo",
    "title": "為你的程式碼添加註解",
    "content": "為你的程式碼添加註解\n指引\n檢查你遊戲文件夾中的 /app.js 文件，找出可以添加註解和整理的地方。程式碼很容易變得混亂，現在是一個好機會添加註解，確保你的程式碼易於閱讀，方便日後使用。\n評分標準\n| 評分標準 | 優秀                                                          | 合格                              | 需要改進                                              |\n| -------- | ------------------------------------------------------------- | --------------------------------- | ---------------------------------------------------- |\n|          | app.js 程式碼完全有註解並且整理成邏輯區塊                   | app.js 程式碼有適當的註解       | app.js 程式碼有些混亂，缺乏良好的註解              |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或誤釋不承擔責任。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1527,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\3-moving-elements-around\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 421,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "6e7712d603724609fd7334bb1eb0612d",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\assignment.md",
    "source_type": "git_repo",
    "title": "探索碰撞",
    "content": "探索碰撞\n指引\n為了更好地了解碰撞的運作方式，嘗試建立一個非常小型的遊戲，包含一些會發生碰撞的物件。讓它們透過按鍵或滑鼠點擊移動，並在其中一個物件被撞擊時觸發某些事件。這可以是像隕石撞擊地球，或者碰碰車之類的情景。發揮你的創意！\n評分標準\n| 評分標準 | 卓越                                                                                                                | 合格                       | 需要改進         |\n| -------- | ------------------------------------------------------------------------------------------------------------------- | -------------------------- | ---------------- |\n|          | 提供完整可運行的程式碼範例，物件成功繪製到畫布上，基本碰撞發生，並有相應的反應產生                                   | 程式碼在某些方面不完整     | 程式碼無法正常運作 |\n免責聲明：\n本文件已使用人工智能翻譯服務 Co-op Translator 進行翻譯。我們致力於提供準確的翻譯，但請注意，自動翻譯可能包含錯誤或不準確之處。應以原文文件作為權威來源。對於關鍵資訊，建議尋求專業人工翻譯。我們對因使用此翻譯而引起的任何誤解或錯誤解釋概不負責。",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 1660,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\6-space-game\\4-collision-detection\\assignment.md",
      "source_type": "git_repo"
    },
    "token_count": 488,
    "chunk_index": 0,
    "total_chunks": 1
  },
  {
    "id": "0b5a3dae8cdfed56a4cf914d01c462d6",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "建立銀行應用程式第三部分：獲取及使用數據的方法\n課前測驗\n課前測驗\n簡介\n每個網頁應用程式的核心都是數據。數據可以有多種形式，但其主要目的是向用戶展示信息。隨著網頁應用程式越來越互動化和複雜，用戶如何訪問和操作信息已成為網頁開發的重要部分。\n在本課中，我們將學習如何從伺服器異步獲取數據，並使用這些數據在不重新加載 HTML 的情況下在網頁上顯示信息。\n先決條件\n您需要完成本課程的登錄和註冊表單部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便獲取帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 0",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 368,
    "chunk_index": 0,
    "total_chunks": 83
  },
  {
    "id": "a04a4ac377d94c726fa614f42f9a3687",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "建立銀行應用程式第三部分：獲取及使用數據的方法\n課前測驗\n課前測驗\n簡介\n每個網頁應用程式的核心都是數據。數據可以有多種形式，但其主要目的是向用戶展示信息。隨著網頁應用程式越來越互動化和複雜，用戶如何訪問和操作信息已成為網頁開發的重要部分。\n在本課中，我們將學習如何從伺服器異步獲取數據，並使用這些數據在不重新加載 HTML 的情況下在網頁上顯示信息。\n先決條件\n您需要完成本課程的登錄和註冊表單部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便獲取帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAX 和數據獲取\n傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。\n隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。\n在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。\n雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniuse",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 948,
    "chunk_index": 1,
    "total_chunks": 83
  },
  {
    "id": "63d3b4e8b95c0827818bf008f338a78e",
    "source_file": "corpus\\git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
    "source_type": "git_repo",
    "title": "建立銀行應用程式第三部分：獲取及使用數據的方法",
    "content": "建立銀行應用程式第三部分：獲取及使用數據的方法\n課前測驗\n課前測驗\n簡介\n每個網頁應用程式的核心都是數據。數據可以有多種形式，但其主要目的是向用戶展示信息。隨著網頁應用程式越來越互動化和複雜，用戶如何訪問和操作信息已成為網頁開發的重要部分。\n在本課中，我們將學習如何從伺服器異步獲取數據，並使用這些數據在不重新加載 HTML 的情況下在網頁上顯示信息。\n先決條件\n您需要完成本課程的登錄和註冊表單部分。此外，您需要安裝 Node js 並在本地運行伺服器 API，以便獲取帳戶數據。\n您可以通過在終端執行以下命令來測試伺服器是否正常運行：\n```sh\ncurl http://localhost:5000/api\n-> should return \"Bank API v1 00\" as a result\n```\nAJAX 和數據獲取\n傳統網站在用戶選擇鏈接或使用表單提交數據時，通過重新加載整個 HTML 頁面來更新顯示的內容。每次需要加載新數據時，網頁伺服器都會返回一個全新的 HTML 頁面，瀏覽器需要重新處理，這會中斷當前的用戶操作並限制加載期間的互動。這種工作流程也被稱為多頁應用程式（Multi-Page Application，MPA）。\n隨著網頁應用程式變得更加複雜和互動化，一種名為 AJAX（Asynchronous JavaScript and XML） 的新技術出現了。這種技術允許網頁應用程式使用 JavaScript 從伺服器異步發送和獲取數據，而無需重新加載 HTML 頁面，從而實現更快的更新和更流暢的用戶互動。當從伺服器接收到新數據時，可以使用 DOM API 通過 JavaScript 更新當前的 HTML 頁面。隨著時間的推移，這種方法演變成現在所謂的單頁應用程式（Single-Page Application，SPA）。\n在 AJAX 剛推出時，唯一可用的異步獲取數據的 API 是 XMLHttpRequest。但現代瀏覽器現在也實現了更方便且功能更強大的 Fetch API，它使用 Promise 並更適合處理 JSON 數據。\n雖然所有現代瀏覽器都支持 Fetch API，但如果您希望您的網頁應用程式在舊版或過時的瀏覽器上運行，最好先檢查 caniusecom 的兼容性表。\n任務\n在上一課中，我們實現了註冊表單以創建帳戶。現在，我們將添加代碼以使用現有帳戶登錄並獲取其數據。打開 app",
    "metadata": {
      "file_extension": ".md",
      "file_type": "markdown",
      "file_size": 16885,
      "relative_path": "git_repos\\web-dev-beginners\\translations\\hk\\7-bank-project\\3-data\\README.md",
      "source_type": "git_repo"
    },
    "token_count": 1032,
    "chunk_index": 2,
    "total_chunks": 83
  }
]