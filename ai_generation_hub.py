#!/usr/bin/env python3
"""
AI Generation Hub - Central de IA Generativa

Este sistema integra todas as ferramentas de IA generativa:
1. DALL-E 3 - Gera√ß√£o de imagens fotoreal√≠sticas
2. Leonardo AI - Arte e design profissional
3. Kling AI - V√≠deos e anima√ß√µes
4. Veo 3 - V√≠deos de alta qualidade
5. HeyGen - Avatares e apresenta√ß√µes
6. Midjourney - Arte conceitual
7. Stable Diffusion - Imagens customiz√°veis

Tudo integrado para criar a melhor Vibe Creation Platform!
"""

import asyncio
import aiohttp
import json
import os
import time
import base64
from datetime import datetime
from dataclasses import dataclass, asdict
from typing import List, Dict, Optional, Any, Union
from pathlib import Path
import uuid
from PIL import Image, ImageEnhance, ImageFilter
from io import BytesIO
import hashlib

@dataclass
class AIProvider:
    """Representa um provedor de IA generativa"""
    name: str
    category: str  # 'image', 'video', 'avatar', 'audio', 'text'
    api_endpoint: str
    auth_method: str  # 'api_key', 'oauth', 'bearer'
    capabilities: List[str]
    max_resolution: str
    supported_formats: List[str]
    rate_limits: Dict[str, int]
    pricing_tier: str  # 'free', 'premium', 'enterprise'
    quality_score: float  # 1-10
    speed_score: float  # 1-10
    ease_of_use: float  # 1-10

@dataclass
class GenerationRequest:
    """Solicita√ß√£o de gera√ß√£o de conte√∫do"""
    id: str
    provider: str
    type: str  # 'image', 'video', 'avatar', 'audio'
    prompt: str
    style: Optional[str] = None
    parameters: Dict[str, Any] = None
    user_id: str = None
    project_id: str = None
    created_at: str = None
    status: str = 'pending'  # 'pending', 'processing', 'completed', 'failed'
    result_url: Optional[str] = None
    error_message: Optional[str] = None
    processing_time: Optional[float] = None
    cost: Optional[float] = None

@dataclass
class GenerationResult:
    """Resultado da gera√ß√£o"""
    request_id: str
    provider: str
    type: str
    status: str
    result_urls: List[str]
    metadata: Dict[str, Any]
    quality_metrics: Dict[str, float]
    processing_time: float
    cost: float
    created_at: str

class AIGenerationHub:
    """Central de IA Generativa - O cora√ß√£o da Vibe Creation Platform"""
    
    def __init__(self, project_dir: str = "."):
        self.project_dir = Path(project_dir)
        self.ai_dir = self.project_dir / ".vibe" / "ai"
        self.ai_dir.mkdir(parents=True, exist_ok=True)
        
        # Cache e hist√≥rico
        self.generation_cache = {}
        self.generation_history = []
        self.active_requests = {}
        
        # Configura√ß√µes
        self.config = self._load_config()
        
        # Provedores de IA
        self.providers = self._initialize_providers()
        
        # M√©tricas e analytics
        self.usage_metrics = {
            'total_generations': 0,
            'successful_generations': 0,
            'failed_generations': 0,
            'total_cost': 0.0,
            'average_processing_time': 0.0,
            'provider_usage': {},
            'popular_styles': {},
            'user_satisfaction': 0.0
        }
        
        # Sistema de qualidade
        self.quality_enhancer = AIQualityEnhancer()
        
        # Estado de inicializa√ß√£o
        self.initialized = False
        
        print("ü§ñ AI Generation Hub inicializado!")
    
    async def initialize(self):
        """Inicializa o hub de IA generativa"""
        if self.initialized:
            return
        
        # Configurar sess√£o HTTP
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=60),
            headers={'User-Agent': 'VibeCreationPlatform/1.0'}
        )
        
        # Verificar conectividade com provedores
        await self._verify_providers()
        
        # Carregar cache existente
        await self._load_cache()
        
        self.initialized = True
        print(f"üöÄ AI Generation Hub inicializado com {len(self.providers)} provedores")
    
    async def cleanup(self):
        """Limpa recursos"""
        if hasattr(self, 'session') and self.session:
            await self.session.close()
        self.initialized = False
    
    async def _verify_providers(self):
        """Verifica conectividade com provedores de IA"""
        for provider_name, provider in self.providers.items():
            # Simula√ß√£o de verifica√ß√£o
            self.usage_metrics['provider_usage'][provider_name] = {
                'status': 'ready',
                'last_check': datetime.now().isoformat(),
                'requests_count': 0
            }
    
    async def _load_cache(self):
        """Carrega cache de gera√ß√µes anteriores"""
        cache_file = self.ai_dir / "generation_cache.json"
        if cache_file.exists():
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    self.generation_cache = json.load(f)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao carregar cache: {e}")
    
    def _initialize_providers(self) -> Dict[str, AIProvider]:
        """Inicializa todos os provedores de IA"""
        return {
            # === DALL-E 3 - O rei das imagens fotoreal√≠sticas ===
            'dalle3': AIProvider(
                name="DALL-E 3",
                category="image",
                api_endpoint="https://api.openai.com/v1/images/generations",
                auth_method="bearer",
                capabilities=[
                    'photorealistic_images',
                    'artistic_styles',
                    'text_integration',
                    'high_detail',
                    'creative_concepts',
                    'brand_consistency',
                    'multiple_variations'
                ],
                max_resolution="1024x1024",
                supported_formats=["png", "webp"],
                rate_limits={"requests_per_minute": 50, "requests_per_day": 1000},
                pricing_tier="premium",
                quality_score=9.5,
                speed_score=8.0,
                ease_of_use=9.0
            ),
            
            # === Leonardo AI - Arte e design profissional ===
            'leonardo': AIProvider(
                name="Leonardo AI",
                category="image",
                api_endpoint="https://cloud.leonardo.ai/api/rest/v1",
                auth_method="bearer",
                capabilities=[
                    'professional_art',
                    'character_design',
                    'concept_art',
                    'logo_design',
                    'illustration',
                    'fine_tuned_models',
                    'style_transfer',
                    'upscaling',
                    'background_removal'
                ],
                max_resolution="1536x1536",
                supported_formats=["png", "jpg", "webp"],
                rate_limits={"requests_per_minute": 30, "requests_per_day": 500},
                pricing_tier="premium",
                quality_score=9.0,
                speed_score=7.5,
                ease_of_use=8.5
            ),
            
            # === Kling AI - V√≠deos e anima√ß√µes revolucion√°rias ===
            'kling': AIProvider(
                name="Kling AI",
                category="video",
                api_endpoint="https://api.kling.ai/v1",
                auth_method="api_key",
                capabilities=[
                    'text_to_video',
                    'image_to_video',
                    'video_extension',
                    'motion_control',
                    'camera_movements',
                    'realistic_physics',
                    'character_animation',
                    'scene_transitions',
                    'high_fps_generation'
                ],
                max_resolution="1280x720",
                supported_formats=["mp4", "webm", "gif"],
                rate_limits={"requests_per_minute": 10, "requests_per_day": 100},
                pricing_tier="enterprise",
                quality_score=9.2,
                speed_score=6.5,
                ease_of_use=8.0
            ),
            
            # === Veo 3 - V√≠deos de qualidade cinematogr√°fica ===
            'veo3': AIProvider(
                name="Veo 3",
                category="video",
                api_endpoint="https://api.veo.google.com/v3",
                auth_method="oauth",
                capabilities=[
                    'cinematic_quality',
                    'long_form_video',
                    'realistic_humans',
                    'complex_scenes',
                    'temporal_consistency',
                    'advanced_lighting',
                    'professional_editing',
                    'multi_shot_sequences'
                ],
                max_resolution="1920x1080",
                supported_formats=["mp4", "mov", "webm"],
                rate_limits={"requests_per_minute": 5, "requests_per_day": 50},
                pricing_tier="enterprise",
                quality_score=9.8,
                speed_score=5.5,
                ease_of_use=7.5
            ),
            
            # === HeyGen - Avatares e apresenta√ß√µes ===
            'heygen': AIProvider(
                name="HeyGen",
                category="avatar",
                api_endpoint="https://api.heygen.com/v2",
                auth_method="api_key",
                capabilities=[
                    'ai_avatars',
                    'voice_cloning',
                    'lip_sync',
                    'multilingual_support',
                    'custom_avatars',
                    'presentation_mode',
                    'real_time_generation',
                    'emotion_control',
                    'gesture_animation'
                ],
                max_resolution="1920x1080",
                supported_formats=["mp4", "webm"],
                rate_limits={"requests_per_minute": 20, "requests_per_day": 200},
                pricing_tier="premium",
                quality_score=8.8,
                speed_score=8.5,
                ease_of_use=9.2
            ),
            
            # === Midjourney - Arte conceitual ===
            'midjourney': AIProvider(
                name="Midjourney",
                category="image",
                api_endpoint="https://api.midjourney.com/v1",
                auth_method="api_key",
                capabilities=[
                    'artistic_masterpieces',
                    'concept_art',
                    'fantasy_art',
                    'architectural_visualization',
                    'fashion_design',
                    'unique_styles',
                    'creative_interpretation',
                    'mood_boards'
                ],
                max_resolution="2048x2048",
                supported_formats=["png", "jpg"],
                rate_limits={"requests_per_minute": 25, "requests_per_day": 300},
                pricing_tier="premium",
                quality_score=9.3,
                speed_score=7.0,
                ease_of_use=8.0
            ),
            
            # === Stable Diffusion - Customiza√ß√£o total ===
            'stable_diffusion': AIProvider(
                name="Stable Diffusion XL",
                category="image",
                api_endpoint="https://api.stability.ai/v1",
                auth_method="api_key",
                capabilities=[
                    'open_source_flexibility',
                    'custom_models',
                    'fine_tuning',
                    'controlnet_integration',
                    'inpainting',
                    'outpainting',
                    'img2img_transformation',
                    'style_mixing',
                    'batch_processing'
                ],
                max_resolution="1536x1536",
                supported_formats=["png", "jpg", "webp"],
                rate_limits={"requests_per_minute": 100, "requests_per_day": 2000},
                pricing_tier="free",
                quality_score=8.5,
                speed_score=9.0,
                ease_of_use=7.0
            )
        }
    
    async def generate_content(self, provider: str, content_type: str, prompt: str, 
                             style: Optional[str] = None, parameters: Optional[Dict] = None,
                             user_id: Optional[str] = None, project_id: Optional[str] = None) -> GenerationRequest:
        """Gera conte√∫do usando IA - Fun√ß√£o principal da plataforma"""
        
        print(f"üé® Gerando {content_type} com {provider}: {prompt[:50]}...")
        
        # Criar solicita√ß√£o
        request = GenerationRequest(
            id=str(uuid.uuid4()),
            provider=provider,
            type=content_type,
            prompt=prompt,
            style=style,
            parameters=parameters or {},
            user_id=user_id,
            project_id=project_id,
            created_at=datetime.now().isoformat(),
            status='pending'
        )
        
        # Verificar cache primeiro
        cache_key = self._generate_cache_key(request)
        if cache_key in self.generation_cache:
            print("‚ö° Resultado encontrado no cache!")
            cached_result = self.generation_cache[cache_key]
            request.status = 'completed'
            request.result_url = cached_result['url']
            return request
        
        # Adicionar √† lista de solicita√ß√µes ativas
        self.active_requests[request.id] = request
        
        # Processar baseado no provedor
        try:
            request.status = 'processing'
            start_time = time.time()
            
            if provider == 'dalle3':
                result = await self._generate_with_dalle3(request)
            elif provider == 'leonardo':
                result = await self._generate_with_leonardo(request)
            elif provider == 'kling':
                result = await self._generate_with_kling(request)
            elif provider == 'veo3':
                result = await self._generate_with_veo3(request)
            elif provider == 'heygen':
                result = await self._generate_with_heygen(request)
            elif provider == 'midjourney':
                result = await self._generate_with_midjourney(request)
            elif provider == 'stable_diffusion':
                result = await self._generate_with_stable_diffusion(request)
            else:
                raise ValueError(f"Provedor '{provider}' n√£o suportado")
            
            # Calcular tempo de processamento
            processing_time = time.time() - start_time
            request.processing_time = processing_time
            
            # Aplicar melhorias de qualidade se necess√°rio
            if self.config.get('auto_enhance', True):
                result = await self.quality_enhancer.enhance_result(result, request)
            
            # Atualizar status
            request.status = 'completed'
            request.result_url = result.get('url')
            
            # Salvar no cache
            self.generation_cache[cache_key] = {
                'url': request.result_url,
                'metadata': result.get('metadata', {}),
                'created_at': datetime.now().isoformat()
            }
            
            # Atualizar m√©tricas
            await self._update_metrics(request, True)
            
            print(f"‚úÖ Gera√ß√£o conclu√≠da em {processing_time:.2f}s: {request.result_url}")
            
        except Exception as e:
            request.status = 'failed'
            request.error_message = str(e)
            await self._update_metrics(request, False)
            print(f"‚ùå Erro na gera√ß√£o: {str(e)}")
        
        finally:
            # Remover da lista ativa
            if request.id in self.active_requests:
                del self.active_requests[request.id]
            
            # Adicionar ao hist√≥rico
            self.generation_history.append(request)
            
            # Salvar estado
            await self._save_generation_state()
        
        return request
    
    async def generate_vibe_complete(self, vibe_description: str, project_id: str, 
                                   user_preferences: Optional[Dict] = None) -> Dict[str, Any]:
        """Gera uma 'vibe' completa - imagens, v√≠deos, avatares, tudo!"""
        
        print(f"üåü Gerando VIBE COMPLETA: {vibe_description}")
        
        vibe_id = str(uuid.uuid4())
        results = {
            'vibe_id': vibe_id,
            'description': vibe_description,
            'project_id': project_id,
            'assets': {},
            'timeline': [],
            'total_cost': 0.0,
            'processing_time': 0.0,
            'quality_score': 0.0
        }
        
        start_time = time.time()
        
        try:
            # 1. Gerar imagem principal com DALL-E 3
            print("üé® Gerando imagem principal...")
            main_image = await self.generate_content(
                provider='dalle3',
                content_type='image',
                prompt=f"Professional, high-quality image representing: {vibe_description}. Photorealistic, modern, engaging.",
                style='photorealistic',
                project_id=project_id
            )
            results['assets']['main_image'] = main_image
            results['timeline'].append({'step': 'main_image', 'status': main_image.status})
            
            # 2. Gerar arte conceitual com Leonardo AI
            print("üé≠ Gerando arte conceitual...")
            concept_art = await self.generate_content(
                provider='leonardo',
                content_type='image',
                prompt=f"Artistic interpretation, concept art style: {vibe_description}. Creative, inspiring, professional.",
                style='concept_art',
                project_id=project_id
            )
            results['assets']['concept_art'] = concept_art
            results['timeline'].append({'step': 'concept_art', 'status': concept_art.status})
            
            # 3. Gerar v√≠deo promocional com Kling AI
            print("üé¨ Gerando v√≠deo promocional...")
            promo_video = await self.generate_content(
                provider='kling',
                content_type='video',
                prompt=f"Dynamic promotional video showcasing: {vibe_description}. Engaging, modern, professional quality.",
                style='promotional',
                project_id=project_id
            )
            results['assets']['promo_video'] = promo_video
            results['timeline'].append({'step': 'promo_video', 'status': promo_video.status})
            
            # 4. Gerar avatar apresentador com HeyGen
            print("üë§ Gerando avatar apresentador...")
            avatar_presenter = await self.generate_content(
                provider='heygen',
                content_type='avatar',
                prompt=f"Professional presenter avatar explaining: {vibe_description}. Friendly, confident, engaging.",
                style='professional',
                parameters={'voice_style': 'friendly', 'language': 'en'},
                project_id=project_id
            )
            results['assets']['avatar_presenter'] = avatar_presenter
            results['timeline'].append({'step': 'avatar_presenter', 'status': avatar_presenter.status})
            
            # 5. Gerar varia√ß√µes art√≠sticas com Midjourney
            print("üé® Gerando varia√ß√µes art√≠sticas...")
            artistic_variations = await self.generate_content(
                provider='midjourney',
                content_type='image',
                prompt=f"Artistic masterpiece interpretation: {vibe_description}. Creative, unique, inspiring.",
                style='artistic',
                project_id=project_id
            )
            results['assets']['artistic_variations'] = artistic_variations
            results['timeline'].append({'step': 'artistic_variations', 'status': artistic_variations.status})
            
            # Calcular m√©tricas finais
            total_time = time.time() - start_time
            results['processing_time'] = total_time
            
            # Calcular custo total estimado
            total_cost = self._calculate_vibe_cost(results['assets'])
            results['total_cost'] = total_cost
            
            # Calcular score de qualidade m√©dio
            quality_scores = []
            for asset in results['assets'].values():
                if asset.status == 'completed':
                    provider_quality = self.providers[asset.provider].quality_score
                    quality_scores.append(provider_quality)
            
            results['quality_score'] = sum(quality_scores) / len(quality_scores) if quality_scores else 0.0
            
            print(f"üåü VIBE COMPLETA gerada em {total_time:.2f}s!")
            print(f"üí∞ Custo estimado: ${total_cost:.2f}")
            print(f"‚≠ê Score de qualidade: {results['quality_score']:.1f}/10")
            
            # Salvar vibe completa
            await self._save_complete_vibe(results)
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar vibe completa: {str(e)}")
            results['error'] = str(e)
        
        return results
    
    async def get_ai_recommendations(self, project_context: Dict, user_history: List[Dict]) -> List[Dict]:
        """Gera recomenda√ß√µes inteligentes de IA baseadas no contexto"""
        
        recommendations = []
        
        # Analisar contexto do projeto
        project_type = project_context.get('type', 'general')
        target_audience = project_context.get('audience', 'general')
        brand_style = project_context.get('brand_style', 'modern')
        
        # Recomenda√ß√µes baseadas no tipo de projeto
        if project_type == 'ecommerce':
            recommendations.extend([
                {
                    'provider': 'dalle3',
                    'type': 'image',
                    'suggestion': 'Gerar fotos de produtos profissionais',
                    'prompt_template': 'Professional product photography of {product}, white background, studio lighting',
                    'priority': 'high'
                },
                {
                    'provider': 'heygen',
                    'type': 'avatar',
                    'suggestion': 'Criar avatar vendedor para apresentar produtos',
                    'prompt_template': 'Professional sales avatar presenting {product} benefits',
                    'priority': 'medium'
                }
            ])
        
        elif project_type == 'landing_page':
            recommendations.extend([
                {
                    'provider': 'leonardo',
                    'type': 'image',
                    'suggestion': 'Criar hero image impactante',
                    'prompt_template': 'Modern hero image for {business_type}, professional, engaging',
                    'priority': 'high'
                },
                {
                    'provider': 'kling',
                    'type': 'video',
                    'suggestion': 'Gerar v√≠deo explicativo animado',
                    'prompt_template': 'Animated explainer video for {service}, clear, engaging',
                    'priority': 'medium'
                }
            ])
        
        # Recomenda√ß√µes baseadas no hist√≥rico do usu√°rio
        if user_history:
            popular_providers = self._analyze_user_preferences(user_history)
            for provider in popular_providers[:3]:
                recommendations.append({
                    'provider': provider,
                    'type': 'suggestion',
                    'suggestion': f'Voc√™ costuma ter √≥timos resultados com {self.providers[provider].name}',
                    'priority': 'low'
                })
        
        return recommendations
    
    # M√©todos espec√≠ficos para cada provedor
    async def _generate_with_dalle3(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com DALL-E 3"""
        api_key = os.getenv('OPENAI_API_KEY')
        if not api_key:
            raise ValueError("OPENAI_API_KEY n√£o configurada")
        
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        
        payload = {
            'model': 'dall-e-3',
            'prompt': request.prompt,
            'n': 1,
            'size': request.parameters.get('size', '1024x1024'),
            'quality': request.parameters.get('quality', 'hd'),
            'style': request.parameters.get('style', 'vivid')
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                'https://api.openai.com/v1/images/generations',
                headers=headers,
                json=payload
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    return {
                        'url': data['data'][0]['url'],
                        'metadata': {
                            'model': 'dall-e-3',
                            'size': payload['size'],
                            'quality': payload['quality'],
                            'revised_prompt': data['data'][0].get('revised_prompt')
                        }
                    }
                else:
                    error_data = await response.json()
                    raise Exception(f"DALL-E 3 API Error: {error_data}")
    
    async def _generate_with_leonardo(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com Leonardo AI"""
        api_key = os.getenv('LEONARDO_API_KEY')
        if not api_key:
            raise ValueError("LEONARDO_API_KEY n√£o configurada")
        
        # Implementar integra√ß√£o Leonardo AI
        # Por enquanto, retorna resultado simulado
        await asyncio.sleep(2)  # Simular processamento
        
        return {
            'url': 'https://example.com/leonardo-generated-image.png',
            'metadata': {
                'model': 'leonardo-diffusion-xl',
                'style': request.style or 'artistic',
                'resolution': '1536x1536'
            }
        }
    
    async def _generate_with_kling(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com Kling AI"""
        api_key = os.getenv('KLING_API_KEY')
        if not api_key:
            raise ValueError("KLING_API_KEY n√£o configurada")
        
        # Implementar integra√ß√£o Kling AI
        await asyncio.sleep(5)  # Simular processamento de v√≠deo
        
        return {
            'url': 'https://example.com/kling-generated-video.mp4',
            'metadata': {
                'duration': '10s',
                'resolution': '1280x720',
                'fps': 30,
                'format': 'mp4'
            }
        }
    
    async def _generate_with_veo3(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com Veo 3"""
        # Implementar integra√ß√£o Veo 3
        await asyncio.sleep(8)  # Simular processamento de v√≠deo de alta qualidade
        
        return {
            'url': 'https://example.com/veo3-generated-video.mp4',
            'metadata': {
                'duration': '30s',
                'resolution': '1920x1080',
                'fps': 60,
                'format': 'mp4',
                'quality': 'cinematic'
            }
        }
    
    async def _generate_with_heygen(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com HeyGen"""
        api_key = os.getenv('HEYGEN_API_KEY')
        if not api_key:
            raise ValueError("HEYGEN_API_KEY n√£o configurada")
        
        # Implementar integra√ß√£o HeyGen
        await asyncio.sleep(4)  # Simular processamento de avatar
        
        return {
            'url': 'https://example.com/heygen-avatar-video.mp4',
            'metadata': {
                'avatar_id': 'professional_presenter',
                'voice': request.parameters.get('voice_style', 'friendly'),
                'language': request.parameters.get('language', 'en'),
                'duration': '60s'
            }
        }
    
    async def _generate_with_midjourney(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com Midjourney"""
        # Implementar integra√ß√£o Midjourney
        await asyncio.sleep(3)  # Simular processamento art√≠stico
        
        return {
            'url': 'https://example.com/midjourney-artwork.png',
            'metadata': {
                'style': 'artistic_masterpiece',
                'resolution': '2048x2048',
                'aspect_ratio': '1:1',
                'artistic_score': 9.5
            }
        }
    
    async def _generate_with_stable_diffusion(self, request: GenerationRequest) -> Dict:
        """Gera conte√∫do com Stable Diffusion"""
        api_key = os.getenv('STABILITY_API_KEY')
        if not api_key:
            raise ValueError("STABILITY_API_KEY n√£o configurada")
        
        # Implementar integra√ß√£o Stability AI
        await asyncio.sleep(1.5)  # Simular processamento r√°pido
        
        return {
            'url': 'https://example.com/stable-diffusion-image.png',
            'metadata': {
                'model': 'stable-diffusion-xl',
                'steps': 30,
                'cfg_scale': 7.5,
                'resolution': '1536x1536'
            }
        }
    
    # M√©todos auxiliares
    def _generate_cache_key(self, request: GenerationRequest) -> str:
        """Gera chave de cache para a solicita√ß√£o"""
        content = f"{request.provider}_{request.type}_{request.prompt}_{request.style}_{json.dumps(request.parameters, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def _calculate_vibe_cost(self, assets: Dict) -> float:
        """Calcula custo estimado da vibe completa"""
        cost_map = {
            'dalle3': 0.04,  # por imagem
            'leonardo': 0.02,
            'kling': 0.50,   # por v√≠deo
            'veo3': 1.00,
            'heygen': 0.30,
            'midjourney': 0.03,
            'stable_diffusion': 0.01
        }
        
        total_cost = 0.0
        for asset in assets.values():
            if asset.status == 'completed':
                total_cost += cost_map.get(asset.provider, 0.05)
        
        return total_cost
    
    def _analyze_user_preferences(self, user_history: List[Dict]) -> List[str]:
        """Analisa prefer√™ncias do usu√°rio baseado no hist√≥rico"""
        provider_usage = {}
        
        for item in user_history:
            provider = item.get('provider')
            if provider:
                provider_usage[provider] = provider_usage.get(provider, 0) + 1
        
        return sorted(provider_usage.keys(), key=lambda x: provider_usage[x], reverse=True)
    
    async def _update_metrics(self, request: GenerationRequest, success: bool):
        """Atualiza m√©tricas de uso"""
        self.usage_metrics['total_generations'] += 1
        
        if success:
            self.usage_metrics['successful_generations'] += 1
        else:
            self.usage_metrics['failed_generations'] += 1
        
        # Atualizar uso por provedor
        provider = request.provider
        if provider not in self.usage_metrics['provider_usage']:
            self.usage_metrics['provider_usage'][provider] = 0
        self.usage_metrics['provider_usage'][provider] += 1
        
        # Atualizar tempo m√©dio
        if request.processing_time:
            current_avg = self.usage_metrics['average_processing_time']
            total = self.usage_metrics['total_generations']
            self.usage_metrics['average_processing_time'] = (
                (current_avg * (total - 1) + request.processing_time) / total
            )
    
    async def _save_generation_state(self):
        """Salva estado das gera√ß√µes"""
        state_file = self.ai_dir / "generation_state.json"
        
        state_data = {
            'usage_metrics': self.usage_metrics,
            'generation_history': [asdict(req) for req in self.generation_history[-100:]],  # √öltimas 100
            'cache_size': len(self.generation_cache),
            'active_requests': len(self.active_requests),
            'timestamp': datetime.now().isoformat()
        }
        
        with open(state_file, 'w', encoding='utf-8') as f:
            json.dump(state_data, f, indent=2, ensure_ascii=False, default=str)
    
    async def _save_complete_vibe(self, vibe_data: Dict):
        """Salva vibe completa gerada"""
        vibe_file = self.ai_dir / f"vibe_{vibe_data['vibe_id']}.json"
        
        with open(vibe_file, 'w', encoding='utf-8') as f:
            json.dump(vibe_data, f, indent=2, ensure_ascii=False, default=str)
    
    def _load_config(self) -> Dict:
        """Carrega configura√ß√µes"""
        config_file = self.ai_dir / "ai_config.json"
        
        default_config = {
            'auto_enhance': True,
            'cache_enabled': True,
            'max_cache_size': 1000,
            'default_quality': 'high',
            'parallel_processing': True,
            'cost_optimization': True
        }
        
        if config_file.exists():
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    return {**default_config, **config}
            except Exception:
                pass
        
        return default_config

class AIQualityEnhancer:
    """Sistema de melhoria de qualidade autom√°tica"""
    
    def __init__(self):
        self.enhancement_rules = {
            'image': {
                'upscale': True,
                'noise_reduction': True,
                'color_enhancement': True,
                'sharpening': True
            },
            'video': {
                'stabilization': True,
                'color_grading': True,
                'audio_enhancement': True
            }
        }
    
    async def enhance_result(self, result: Dict, request: GenerationRequest) -> Dict:
        """Aplica melhorias autom√°ticas no resultado"""
        
        if request.type == 'image':
            return await self._enhance_image(result, request)
        elif request.type == 'video':
            return await self._enhance_video(result, request)
        
        return result
    
    async def _enhance_image(self, result: Dict, request: GenerationRequest) -> Dict:
        """Melhora qualidade da imagem"""
        # Implementar melhorias de imagem
        # Por enquanto, apenas adiciona metadata de melhoria
        result['metadata']['enhanced'] = True
        result['metadata']['enhancements'] = ['upscaled', 'color_enhanced', 'sharpened']
        return result
    
    async def _enhance_video(self, result: Dict, request: GenerationRequest) -> Dict:
        """Melhora qualidade do v√≠deo"""
        # Implementar melhorias de v√≠deo
        result['metadata']['enhanced'] = True
        result['metadata']['enhancements'] = ['stabilized', 'color_graded']
        return result

# Fun√ß√£o principal
async def main():
    """Fun√ß√£o principal para testar o AI Generation Hub"""
    hub = AIGenerationHub()
    
    print("üöÄ Testando AI Generation Hub...\n")
    
    # Teste 1: Gerar imagem com DALL-E 3
    dalle_request = await hub.generate_content(
        provider='dalle3',
        content_type='image',
        prompt='A futuristic workspace with holographic displays and AI assistants',
        style='photorealistic',
        project_id='test-project'
    )
    
    # Teste 2: Gerar vibe completa
    complete_vibe = await hub.generate_vibe_complete(
        vibe_description='Modern tech startup with innovative AI solutions',
        project_id='test-project'
    )
    
    # Teste 3: Obter recomenda√ß√µes
    recommendations = await hub.get_ai_recommendations(
        project_context={'type': 'landing_page', 'audience': 'tech_professionals'},
        user_history=[]
    )
    
    print(f"\nüéâ Testes conclu√≠dos!")
    print(f"üìä M√©tricas: {hub.usage_metrics}")
    print(f"üí° Recomenda√ß√µes: {len(recommendations)}")
    print(f"üåü Vibe completa: {complete_vibe['quality_score']:.1f}/10")

if __name__ == "__main__":
    asyncio.run(main())